{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,C,E,C,E,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,G,C,C,E,C,O,C,C,E,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,O,C,K,E,E,S,C,K,E,E,S,C,K,E,E,C,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,A,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,Q,C,S,C,C,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GCEwB,EAAA,MAAA,CAAA,EAAA,UAAA,IAAA,GAFxB,IAAA,EAAA,EAAA,oBAEe,SAAS,EAAoB,EAAM,CAAC,CAAC,EAChD,OAAO,AAAC,IACJ,IAMI,EACA,EAPE,CAAE,OAAA,CAAM,CAAE,YAAA,CAAW,CAAE,CAAG,EAC1B,CAAE,cAAA,CAAa,CAAE,IAAA,CAAG,CAAE,CAAG,EAAY,KAAK,CAE1C,EAAS,EAAc,UACvB,EAAM,EAAO,UAAU,CAAC,MAK1B,EAAO,KACP,EAAc,KACd,EAAa,KACb,EAAa,KACb,EAAe,EAEb,EAAQ,CACV,QAAS,CAAA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M,C,E,a,I,I,G,M,C,E,qB,I,I,G,M,C,E,U,I,I,G,M,C,E,M,I,G,G,E,G,M,C,E,U,I,I,G,M,C,E,kB,I,I,G,M,C,E,kB,I,I,G,M,C,E,O,I,I,G,M,C,E,gB,I,I,G,M,C,E,kB,I,I,G,M,C,E,gB,I,I,G,M,C,E,kB,I,I,G,M,C,E,mB,I,I,G,M,C,E,sB,I,I,I,G,E,oB,G,G,c,C,I,G,E,yB,G,E,kB,G,E,c,G,O,c,C,G,A,I,M,U,E,E,G,C,E,E,I,K,E,G,E,E,C,W,C,E,a,C,E,S,C,E,M,C,G,C,C,E,C,E,G,C,E,E,I,G,E,A,U,O,E,E,G,E,G,G,C,E,E,I,E,G,C,I,G,U,G,G,C,E,E,I,C,G,E,E,2B,E,E,I,C,G,E,G,C,E,E,G,C,E,E,I,E,G,C,G,G,qD,a,Q,E,G,C,G,E,G,C,E,G,G,C,E,E,E,I,C,G,E,E,0B,E,E,I,C,E,G,E,G,C,E,G,C,E,G,C,E,E,I,C,G,E,E,yB,C,EEvTsB,eAAAqmE,GACpBH,CAAAA,CACAtyD,CAAAA,EAEM,IAAA0yD,EAAQL,AA7CA,SAAcC,CAAAA,CAAatyD,CAAAA,EACnC,IAAAuyD,EAVC,SAAS,aAAA,CAUK,MACjBA,CAAAA,EAAA,KAAA,CAAM,OAAA,CAAU,CAAA,WAAA,EAAcvyD,EAAO,sCAAA,CAAA,CACzCuyD,EAAI,WAAA,CAAcD,EACT,SAAA,IAAA,CAAK,WAAA,CAAYC,GAE1B,GAAM,CAAE,MAAAr+D,CAAAA,CAAO,OAAAC,CAAAA,CAAO,CAAIo+D,EAAI,qBAAA,EAE9BA,CAAAA,EAAI,MAAA,GACJA,EAAI,KAAA,CAAM,UAAA,CAAa,UAEjB,IAAA3nD,EAAM,IAAI,KAChBA,CAAAA,EAAI,KAAA,CAAQ1W,EACZ0W,EAAI,MAAA,CAASzW,EACb,IAAMq+D,EAAS;AAAA,mDAAA,EACoCt+D,EAAK,UAAA,EAAaC,EADtD;A;AAC4D,kDAAA,EAEzBo+D,EAAI,SAAS,CAFY;A;A;AAEZ,EAAA,CAAA,CAI5D,OAAA,CAAQ,MAAO,IACf,OAAA,CAAQ,KAAM,OAEb,OAAA3nD,EAAA,GAAA,CAAM,CAAA,iCAAA,EAAoC4nD,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B,GAGA,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,wBAAwB,CAAE,QACpE,EAAU,qBAAqB,CAAC,EAAU,uBAAuB,CAAG,QACpE,EAAU,qBAAqB,CAAC,EAAU,uBAAuB,CAAG,QACpE,EAAU,qBAAqB,CAAC,EAAU,uBAAuB,CAAG,QACpE,EAAU,qBAAqB,CAAC,EAAU,uBAAuB,CAAG,QACpE,EAAU,qBAAqB,CAAC,EAAU,uBAAuB,CAAG,QACpE,EAAU,qBAAqB,CAAC,EAAU,uBAAuB,CAAG,QACpE,EAAU,qBAAqB,CAAC,EAAU,uBAAuB,CAAG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MAAM,CAAC,WAAW,IAAI,CAAC,MAAM,CAChD,EAKA,IAAI,EAAS,CAAC,CAEd,CAAA,EAAO,UAAU,CAAG,SAAU,CAAa,CAAE,CAAO,EAGnD,IAAI,EAAO,IAAI,EAAQ,GAEvB,OADA,EAAK,eAAe,EAFA,CAAA,AAAkB,KAAA,IAAlB,GAA8B,CADlD,EAIO,CACR,EAGC,EAAQ,UAAU,CAAG,EAAO,UAAU,A,E,C,E,C,M,C,S,C,C,C,C,C,C,C,E,I,E,E,E,kD,E,iB,C,G,E,M,C,E,Y,I,G,E,M,C,E,M,I,G,E,M,C,E,iB,I,G,E,M,C,E,c,I,G,E,M,C,E,Y,I,G,E,M,C,E,c,I,G,I,E,E,oB,E,E,c,C,G,E,O,c,C,E,A,I,M,U,E,E,E,C,E,E,I,K,E,E,E,E,C,W,C,E,a,C,E,S,C,E,M,C,G,C,C,E,C,E,E,C,E,E,I,E,E,A,U,O,E,E,G,E,G,E,C,E,E,I,E,G,C,I,E,U,G,E,C,E,E,I,C,E,E,E,2B,E,E,I,C,G,E,G,C,E,E,E,C,E,E,I,E,G,C,G,E,qD,a,Q,E,G,C,G,E,G,C,E,EEh8QhC,OAAMp0D,EAAN,aAAyC,CAoC9Co9C,EAAA,IAAA,CAAA+X,EAAAA,IAAiB,KAKjB3X,EAAA,IAAA,CAAA,KAAK,CAAuBnkE,EAAY+7E,KACtC,IAAMC,EAAW9X,EAAA,IAAA,CAAK4X,GAAW,GAAA,CAAI97E,IAAI,IAAS,IAClD,OAAAg8E,EAAS,GAAA,CAAID,GAER7X,EAAA,IAAA,CAAK4X,GAAW,GAAA,CAAI97E,IAClBkkE,EAAA,IAAA,CAAA4X,GAAW,GAAA,CAAI97E,EAAMg8E,GAGrB,KACLA,EAAS,MAAA,CAAOD,GACZC,AAAkB,IAAlBA,EAAS,IAAA,EACN9X,EAAA,IAAA,CAAA4X,GAAW,MAAA,CAAO97E,EACzB,CACF,GAQFmkE,EAAA,IAAA,CAAA,OAAO,CACLnkE,EACA+7E,KAGA,IAAME,EAAM,IAAA,CAAK,EAAA,CAAGj8E,EAAM,CAAA,GAAIu2D,KACxB0lB,IACJF,KAAYxlB,EAAI,GAGX,OAAA0lB,CAAA,GAST9X,EAAA,IAAA,CAAA,OAAO,CACLnkE,EAAAA,GACG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AAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAGzC,OAFA,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CACzC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAG,EACf,CACT,CAKA,OAAQ,CACN,IAAK,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,IACtC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAG,CAAC,EAAG,EAAE,AAE7B,CACF,C,E,C,iD,O,E,C,M,C,S,C,C,C,C,C,C,C,E,I,E,E,E,E,E,E,E,E,E,E,E,E,E,kD,E,iB,C,G,E,M,C,E,M,I,G,E,M,C,E,O,I,G,E,M,C,E,W,I,G,E,M,C,E,U,I,G,E,M,C,E,Q,I,G,I,E,A,I,M,U,E,E,E,C,E,E,I,E,G,C,I,E,U,G,E,C,E,E,I,C,E,E,E,2B,E,E,I,C,G,E,G,C,E,E,E,C,E,E,I,E,G,C,G,E,qD,a,Q,E,G,C,G,E,G,C,E,G,E,C,E,E,E,I,C,E,E,E,0B,E,E,I,C,E,G,E,G,C,E,G,C,E,I,E,mnE,E,A,I,O,M,K,I,E,I,K,C,W,I,C,K,G,A,G,E,U,C,I,C,C,K,+B,G,S,E,C,E,I,E,G,C,G,C,C,E,G,A,C,K,G,E,K,S,A,E,e,C,E,E,K,G,I,E,I,O,E,C,K,A,M,E,K,E,E,I,A,G,O,E,gB,C,Q,K,A,C,K,G,E,K,S,A,E,e,C,E,G,C,C,K,C,O,I,O,+B,E,C,K,A,M,E,K,E,E,I,A,E,Q,C,G,A,C,K,G,E,K,S,A,E,e,C,E,C,CE5GsB,eAAAqC,EACpB3kB,CAAAA,CACAC,CAAAA,CACAC,CAAAA,EAEA,IAAM0kB,EAAUC,AAyClB,WAEM,GAAAC,EAAW,MAAA,CAAS,EAAG,CACzB,IAAME,EAAQ7sE,AAShB,WACQ,IAAA4nE,EAAS,IAAIkF,EAEfrlB,EAAO,EACPslB,EAAiE,CAAA,EAErE,OAAAnF,EAAO,SAAA,CAAY,CAAC,CAClB,KAAAztE,CADkB,CAClB,I,I,E,CASIA,AAAiB,CAAA,aAAjBA,EAAK,OAAA,CACP2xD,AAAA,MAAAA,CAAAA,EAAAihB,CAAAA,CAAM5yE,EAAK,IAAI,CAAA,AAAA,GAAf2xD,EAAkB,OAAA,CAAQ3xD,EAAK,SAAA,EACtBA,AAAiB,eAAjBA,EAAK,OAAA,EAAY,CAAA,AAC1B,MAAAoyD,CAAAA,EAAAwgB,CAAAA,CAAM5yE,EAAK,IAAI,CAAA,AAAA,GAAfoyD,EAAkB,MAAA,CAAO,MAAMpyD,EAAK,MAAM,EAAA,EAErC,OAAA4yE,CAAAA,CAAM5yE,EAAK,IAAI,CALlB,AAKkB,EAGjB,eACLqtD,CAAAA,CACAhG,CAAAA,CACAwrB,EAAwB,EAAA,EAEhBvlB,GAAA,EAER,IAAMwlB,EAAM,IAAI,QAAQ,CAACnnF,EAAS6hE,KAChColB,CAAAA,CAAMtlB,EAAI,CAAI,CAAE,QAAA3hE,EAAS,OAAA6hE,CAAO,CAAA,GAE3B,OAAAigB,EAAA,WAAA,CACL,CACE,KAAAngB,EACA,QAAAD,EACA,KAAAhG,CACF,EACAwrB,GAGKC,CAAA,CAEX,IArDE,OAAAN,EAAW,IAAA,CAAKE,GACTA,CAAA,CACF,CACC,IAAAA,EAAQF,CAAAA,CAAWC,EAAnB,CACU,OAAAA,EAAAA,AAAAA,CAAAA,EAAe,CAAA,EAAKD,EAAW,MAAA,CACxCE,CACT,CAgDF,IAlGE,OAAA,MAAMJ,EAAQ,WAAY,CAAE,OAAA5kB,EAAQ,SAAAC,EAAU,KAAAC,CAAAA,GACvC,CACL,KAAM,MAAO7jD,EAAQvC,IAClB,MAAM8qE,EAAQ,OAAQ,CACrB,OAAA5kB,EACA,OAAA3jD,EACA,KAAAvC,CAAA,GAEJ,MAAO,MAAOxH,EAAM6tD,IACjB,MAAMykB,EACL,QACA,CACE,OAAA5kB,EACA,KAAA1tD,EACA,KAAA6tD,CACF,EACA,CAAC,YAAY,MAAA,CAAO7tD,GAAQA,EAAK,MAAA,CAASA,EAD1C,EAGJ,MAAO,SACJ,MAAMsyE,EAAQ,QAAS,CACtB,OAAA5kB,CAAA,GAEJ,SAAU,MAAOM,GACd,MAAMskB,EAAQ,WAAY,CACzB,OAAA5kB,EACA,QAAAM,CAAA,GAEJ,QAAS,SACN,MAAMskB,EAAQ,UAAW,CACxB,OAAA5kB,CAAA,GAEJ,MAAO,SACJ,MAAM4kB,EAAQ,QAAS,CACtB,OAAA5kB,CAAA,EACD,CAEP,CAEA,IAAM8kB,EAA8B,EAApC,CACIC,EAAe,EC/CZ,SAASM,EAAUtkB,CAAAA,EACxB,GAAIA,AAAS,MAATA,EAAc,MAAO,CAAE,OAAQ,KAAM,KAAM,EAA/C,EAEM,IAAAukB,EAAUvkB,EAAK,KAAA,CAAM,KAAK,MAAA,CAAO,AAAClyD,GAAMA,EAAE,MAAA,CAAS,GACzD,GAAIy2E,AAAmB,IAAnBA,EAAQ,MAAA,CAAc,MAAM,MAAM,gBAM/B,MAAA,CAAE,KAJIA,CAAAA,CAAQA,EAAQ,MAAA,CAAS,EAAC,CAIxB,OAFA,IAAMA,EAAQ,KAAA,CAAM,EAAG,IAAI,IAAA,CAAK,IAExC,CACT,CAEsB,eAAAC,EAMpBxkB,CAAAA,CACAZ,CAAAA,EAKA,GAAM,CAAE,OAAAxhE,CAAAA,CAAQ,KAAAjB,CAAAA,CAAK,CAAI2nF,EAAUtkB,GAEnC,GAAIpiE,AAAU,MAAVA,EAAgB,OAAQ,MAAM,UAAU,OAAA,CAAQ,YAApD,GAEM,IAAA6mF,EAAW7mF,EAAO,KAAA,CAAM,KAAK,MAAA,CAAO,AAACkQ,GAAMA,EAAE,MAAA,CAAS,GAExD,GAAA,CACF,IAAI42E,EAAY,MAAM,UAAU,OAAA,CAAQ,YAAA,GACxC,IAAA,IAAWhrE,KAAK+qE,EACFC,EAAA,MAAMA,EAAU,kBAAA,CAAmBhrE,EAAG,CAChD,OAAQ0lD,EAAK,MADmC,AACnC,GAGjB,OAAIA,EAAK,MAAA,CACC,MAAMslB,EAAU,aAAA,CAAc/nF,EAAM,CAC1C,OAAQyiE,EAAK,MAD6B,AAC7B,GAGP,MAAMslB,EAAU,kBAAA,CAAmB/nF,EAAM,CAC/C,OAAQyiE,EAAK,MADkC,AAClC,EACd,CAAA,MAEItiE,EAAK,CACP,GAAAA,AAAuB,kBAAvBA,EAAc,IAAA,CACV,OAAA,IAEH,OAAAA,CACR,CACF,CAEA,eAAsBwS,EAAO0wD,CAAAA,EAC3B,GAAM,CAAE,OAAApiE,CAAAA,CAAQ,KAAAjB,CAAAA,CAAK,CAAI2nF,EAAUtkB,GACnC,GAAIpiE,AAAU,MAAVA,EAAgB,CAClB,IAAM+mF,EAAO,MAAM,UAAU,OAAA,CAAQ,YAAA,GACpB,UAAA,IAAA/7E,KAAM+7E,EAAK,IAAX,GACf,MAAMA,EAAK,WAAA,CAAY/7E,EAAI,CAAE,UAAW,CAAA,CAAA,GAE1C,MACF,CAEM,IAAA87E,EAAa,MAAMF,EAAY5mF,EAAQ,CAC3C,OAAQ,CADmC,EAE3C,OAAQ,CADA,CACA,GAEV,GAAI8mF,AAAa,MAAbA,EAEA,GAAA,CACF,MAAMA,EAAU,WAAA,CAAY/nF,EAAM,CAAE,UAAW,CAAA,CAAA,EAAM,CAAA,MAC9CG,EAAK,CACP,GAAAA,AAAuB,kBAAvBA,EAAc,IAAA,CAAd,MACC,OAAAA,CACR,CACF,CAEgB,SAAA8nF,EAASC,CAAAA,CAAYC,CAAAA,EACnC,MAAO,CAAA,EAAGD,EAAE,CAAA,EAAIC,EAAAA,CAAE,CAAG,OAAA,CAAQ,KAAM,IACrC,CChEO,SAASC,EAAIC,CAAAA,EACX,OAAA,IAAIC,EAAMD,EACnB,CAEO,IAAME,EAAN,MAAMA,EAqBX,YAAYF,CAAAA,CAAiB,CAJ7B5e,EAAA,IAAA,CAAA+e,GACA/e,EAAA,IAAA,CAAAgf,GACAhf,EAAA,IAAA,CAAAif,GAGE/d,EAAA,IAAA,CAAK6d,EAAQH,GACb,GAAM,CAAE,OAAApnF,CAAAA,CAAQ,KAAAjB,CAAAA,CAAK,CAAI2nF,EAAUU,EACnC1d,CAAAA,EAAA,IAAA,CAAK8d,EAAQzoF,GACb2qE,EAAA,IAAA,CAAK+d,EAAcznF,EACrB,CAzBA,IAAI,MAAc,CACT,MAAA,KACT,CAEA,IAAI,MAAO,CACT,OAAO2oE,EAAA,IAAA,CAAK6e,EACd,CAEA,IAAI,MAAO,CACT,OAAO7e,EAAA,IAAA,CAAK4e,EACd,CAEA,IAAI,QAAuB,CACzB,OAAO5e,AAAoB,MAApBA,EAAA,IAAA,CAAK8e,GAAsB,KAAON,EAAIxe,EAAA,IAAA,CAAK8e,GACpD,CAiBA,MAAM,QAAS,CACP,OAAA,MAAAb,EAAYje,EAAA,IAAA,CAAK4e,GAAO,CAC5B,OAAQ,CADoB,EAE5B,OAAQ,CADA,CACA,GAEHJ,EAAIxe,EAAA,IAAA,CAAK4e,GAClB,CAMA,MAAM,QAAS,CAEV,OAAA,MAAMX,EAAYje,EAAA,IAAA,CAAK4e,GAAO,CAC7B,OAAQ,CADqB,EAE7B,OAAQ,CADA,CAET,cAAc,yBAEnB,CAMA,MAAM,QAAS,CACb,IAAA,IAAWv8E,IAAM,CAAA,MAAM,IAAA,CAAK,QAAA,EAAA,EACtB,GAAA,CACF,MAAMA,EAAG,MAAT,EACO9L,CAAAA,MAAAA,EAAK,CACZ,QAAQ,IAAA,CAAKA,EACf,CAEE,GAAA,CACI,MAAAwS,EAAOi3D,EAAA,IAAA,CAAK4e,GAAK,CAAA,MAChBroF,EAAK,CACZ,QAAQ,IAAA,CAAKA,EACf,CACF,CAMA,MAAM,UAA2C,CAC/C,IAAMwoF,EAAU,MAAMd,EAAYje,EAAA,IAAA,CAAK4e,GAAO,CAC5C,OAAQ,CADoC,EAE5C,OAAQ,CADA,CACA,GAEN,GAAAG,AAAU,MAAVA,EAAgB,MAAO,EAAvB,CAEJ,IAAMxjB,EAAK,EAAX,CACiB,UAAA,IAAAl5D,KAAM08E,EAAO,MAAb,GACfxjB,EAAG,IAAA,CAAMl5D,AAAAA,CAAAA,AAAY,SAAZA,EAAG,IAAA,CAAkBma,EAAOgiE,CAAAA,EAAKH,EAASre,EAAA,IAAA,CAAK4e,GAAOv8E,EAAG,IAAI,IAEjE,OAAAk5D,CACT,CAQA,MAAM,OAAU9H,CAAAA,CAAS,CACvB,GAAI,CAAE,MAAM,IAAA,CAAK,MAAjB,GACE,MAAM,MAAM,CAAA,IAAA,EAAO,IAAA,CAAK,IAAI,CAAA,WAAA,CAAa,EAG3C,GAAIA,aAAgBkrB,EAAO,CACzB,IAAMK,EAAU,MAAMvrB,EAAK,MAAA,GACvB+qB,EAAIH,EAAS5qB,EAAK,IAAA,CAAM,IAAA,CAAK,IAAI,GACjCA,EACJ,OAAA,MAAMurB,EAAO,MAAA,GACb,MAAM,QAAQ,GAAA,CAAK,AAAA,CAAA,MAAM,IAAA,CAAK,QAAA,EAAA,EAAY,GAAA,CAAI,AAAC38E,GAAOA,EAAG,MAAA,CAAO28E,KACzDA,CAAA,CAAA,GACEvrB,aAAgB,0BACzB,OAAA,MAAM,QAAQ,GAAd,CAEI,AAAA,CAAA,MAAM,IAAA,CAAK,QAAA,EAAA,EACX,GAAA,CAAI,MAAOpxD,IACPA,AAAY,SAAZA,EAAG,IAAA,CACL,MAAMA,EAAG,MADP,CAEA,MAAMoxD,EAAK,aAAA,CAAcpxD,EAAG,IAAA,CAAM,CAAE,OAAQ,CAAA,CAAA,IAG9C,MAAMA,EAAG,MAH2C,CAIlD,MAAMoxD,EAAK,kBAAA,CAAmBpxD,EAAG,IAAA,CAAM,CAAE,OAAQ,CAAA,CAAA,GAErD,IAGG,IAET,OAAM,MAAM,sBACd,CAKA,MAAM,OAAOoxD,CAAAA,CAA6B,CACxC,IAAMurB,EAAS,MAAM,IAAA,CAAK,MAAA,CAAOvrB,GACjC,OAAA,MAAM,IAAA,CAAK,MAAA,GACJurB,CACT,CACF,CAxHEJ,CAAAA,EAAA,IAAA,QACAC,EAAA,IAAA,QACAC,EAAA,IAFAF,QAjBK,IAAMF,EAANC,ECzBDM,EAAAA,IAAgB,IAqBN,SAAAziE,EAAKm8C,CAAAA,CAAkBC,EAAsB,IAAA,EAC3D,GAAIA,AAAS,OAATA,EAAe,CACX,IAAAnlD,EAAIwrE,EAAU,GAAA,CAAItmB,IAAa,IAAIumB,EAAOvmB,EAAUC,GAChD,OAAAqmB,EAAA,GAAA,CAAItmB,EAAUllD,GACjBA,CACT,CACO,OAAA,IAAIyrE,EAAOvmB,EAAUC,EAC9B,CAYA,eAAsB7qD,EACpByvD,CAAAA,CACAmN,CAAAA,CACA9R,EAAO,CAAE,UAAW,CAAA,CAAA,CAAA,EAEpB,GAAI8R,aAAmBuU,EAAQ,YAC7B,MAAMnxE,EAAMyvD,EAAQ,MAAMmN,EAAQ,MAAA,GAAU9R,GAIxC,IAAAsmB,EAAS,MAAA,AAAO3hB,CAAAA,aAAkB0hB,EACpC1hB,EACAhhD,EAAKghD,EAAQ,KAAA,EACf,YAHI,GAIF,GAAA,CAEF,GADI3E,EAAK,SAAA,EAAiB,MAAAsmB,EAAO,QAAA,CAAS,GACtCxU,aAAmB,eAAgB,CAC/B,IAAAxL,EAASwL,EAAQ,SAAjB,GACN,OAAa,CACX,GAAM,CAAE,KAAAxmD,CAAAA,CAAM,MAAAhlB,CAAAA,CAAA,CAAU,MAAMggE,EAAO,IAAA,GACrC,GAAIh7C,EAAJ,KACM,OAAAg7D,EAAO,KAAA,CAAMhgF,EACrB,CAAA,MAEM,MAAAggF,EAAO,KAAA,CAAMxU,EAAO,CAAA,MAErBp0E,EAAK,CACN,MAAAA,CAAA,QACN,CACA,MAAM4oF,EAAO,KAAb,EACF,CACF,CAEA,IAAIC,EAAU,EACRC,EAAY,IAAM,EAAED,EAObE,EAAN,MAAMA,EAuBX,YAAY3mB,CAAAA,CAAkBC,CAAAA,CAAqB,KAkB7C+mB,EAxBN9f,EAAA,IAAA,CAAA+e,GACA/e,EAAA,IAAA,CAAAif,GACAjf,EAAA,IAAA,CAAAgf,GACAhf,EAAA,IAAA,CAAA0f,GAEA1f,EAAA,IAAA,CAAA2f,GAiBA3f,EAAA,IAAA,CAAA4f,EAAY,GACZ5f,EAAA,IAAA,CAAA6f,GACMC,EAEO,KAEJ,IACL5e,CAAAA,EAAA,IAAA,CAAK0e,EAALzf,EAAA,IAAA,CAAKyf,GAAa,GACdE,GAEIA,CAAAA,EAAa,IAAI,QAAQ,MAAOhpF,EAAS6hE,KAC3C,GAAA,CACF,IAAMonB,EAAY,MAAMvC,EACtBrd,EAAA,IAAA,CAAKwf,GACLxf,EAAA,IAAA,CAAK4e,GACL5e,EAAA,IAAA,CAAKuf,IAEC5oF,EAAA,CACNipF,EACA,UACE7e,EAAA,IAAA,CAAK0e,EAALzf,EAAA,IAAA,CAAKyf,GAAa,GACd,AAAAzf,EAAA,IAAA,CAAKyf,GAAY,GAERE,CAAAA,EAAA,KACb,MAAMC,EAAU,KAHZ,EAAA,CAIN,EACD,CAAA,CAAA,MACMrpF,EAAK,CACZiiE,EAAOjiE,EACT,CAAA,EAAA,CACD,IAILspE,EAAA,IAAA,CAAAggB,EAAW,CAAX,GAjDE9e,EAAA,IAAA,CAAKye,EAAMH,KACXte,EAAA,IAAA,CAAK6d,EAAQjmB,GACboI,EAAA,IAAA,CAAKwe,EACH,CACE,EAAG,YACH,GAAI,YACJ,YAAa,kBAAA,CAAA,CAEf3mB,EAFe,EAGjB,GAAM,CAAE,OAAAvhE,CAAAA,CAAQ,KAAAjB,CAAAA,CAAK,CAAI2nF,EAAUplB,GACnC,GAAIthE,AAAU,MAAVA,EAAsB,MAAA,MAAM,eAChC0pE,CAAAA,EAAA,IAAA,CAAK8d,EAAQzoF,GACb2qE,EAAA,IAAA,CAAK+d,EAAcznF,EACrB,CApCA,IAAI,MAAe,CACV,MAAA,MACT,CAEA,IAAI,MAAO,CACT,OAAO2oE,EAAA,IAAA,CAAK4e,EACd,CAEA,IAAI,MAAO,CACT,OAAO5e,EAAA,IAAA,CAAK6e,EACd,CAEA,IAAI,QAAwC,CAC1C,OAAO7e,AAAoB,MAApBA,EAAA,IAAA,CAAK8e,GAAsB,KAAON,EAAIxe,EAAA,IAAA,CAAK8e,GACpD,CA8DA,MAAM,cAAe,CACnB,GAAI9e,AAAe,cAAfA,EAAA,IAAA,CAAKuf,GAAuB,MAAM,MAAM,qBAC5C,GAAIvf,EAAA,IAAA,CAAK6f,GAAgB,MAAA,MAAM,qCAC/B9e,EAAA,IAAA,CAAK8e,EAAW,CAAhB,GAEM,IAAAC,EAAQ,IAAI,YAGZ,CAACF,EAAWG,EAAK,CAAI,MAAM/f,EAAA,IAAA,CAAK0f,GAAL,IAH3B,CAAA,IAAA,EAIFv2D,EAAM,MAAMy2D,EAAU,OAAA,GACtBI,EAAS,CADT,EAEG,MAAA,CACL,MAAO,MACLpZ,EACA/N,EAAwB,CAAA,CAAA,IAEpB,GAAAmnB,EAAc,MAAA,MAAM,oBACxB,IAAMrV,EAAU,AAAiB,UAAjB,OAAO/D,EAAqBkZ,EAAM,MAAA,CAAOlZ,GAASA,EAC5DlmE,EAAKm4D,EAAK,EAAA,EAAM1vC,EAEtB,OAAAA,EAAMzoB,EADciqE,EAAQ,UAF5B,CAIO,MAAMiV,EAAU,KAAA,CAAMjV,EAAS,CAAE,GAAAjqE,CAAI,EAC9C,EACA,SAAU,MAAO8R,IACX,GAAAwtE,EAAc,MAAA,MAAM,mBAClB,OAAAJ,EAAU,QAAA,CAASptE,GACrB2W,EAAM3W,GAAY2W,CAAAA,EAAA3W,CAAAA,CACxB,EACA,MAAO,UACD,GAAAwtE,EAAc,MAAA,MAAM,mBACxB,OAAMJ,EAAU,KAAhB,EACF,EACA,MAAO,UACD,GAAAI,EAAc,MAAA,MAAM,mBACfA,CAAAA,EAAA,CAAA,EACTjf,EAAA,IAAA,CAAK8e,EAAW,CAAA,GAChB,MAAME,GACR,CAAA,CAEJ,CAKA,MAAM,cAAe,CACnB,GAAM,CAACH,EAAWG,EAAK,CAAI,MAAM/f,EAAA,IAAA,CAAK0f,GAAL,IAAjC,CAAA,IAAA,EAEIM,EAAS,CAAA,EACT72D,EAAM,EACH,MAAA,CACL,KAAM,MAAO3W,EAAcqmD,EAAwB,CAAA,CAAA,IAC7C,GAAAmnB,EAAc,MAAA,MAAM,oBAClB,IAAAjrE,EAAS8jD,EAAK,EAAA,EAAM1vC,EACpBjtB,EAAM,MAAM0jF,EAAU,IAAA,CAAK7qE,EAAQvC,GACzC,OAAA2W,EAAMpU,EAAS7Y,EAAI,UAAA,CACZA,CACT,EACA,QAAS,UACH,GAAA8jF,EAAc,MAAA,MAAM,oBACjB,OAAA,MAAMJ,EAAU,OAAhB,EACT,EACA,MAAO,UACDI,GACKA,CAAAA,EAAA,CAAA,EACT,MAAMD,GAAAA,CACR,CAAA,CAEJ,CAEA,MAAM,MAAO,CACX,OAAO,IAAI,cAAc,MAAA,CAAO,MAAM,IAAA,CAAK,WAAA,GAC7C,CAEA,MAAM,aAAc,CACZ,IAAAG,EAAK,MAAMjC,EAAYje,EAAA,IAAA,CAAK4e,GAAO,CAAE,OAAQ,CAAA,EAAO,OAAQ,CAAA,CAAA,GAClE,OAAIsB,AAAM,MAANA,EAAmB,IAAI,YAAY,GAC/B,AAAA,CAAA,MAAMA,EAAG,OAAA,EAAA,EAAW,WAAA,EAC9B,CAEA,MAAM,QAAS,CACP,IAAAC,EAAQ,MAAM,IAAA,CAAK,aAAnB,GACN,OAAIA,AAAS,MAATA,EACK,IAAI,eAA2B,CACpC,KAAM,AAAChU,IACLA,EAAK,KAAA,EACP,CAAA,GAIGgU,EAAM,MAJT,EAKN,CAEA,MAAM,eAAgB,C,I,EAElB,OAAAxjB,AAAA,MAAAA,CAAAA,EAAA,MAAMshB,EAAYje,EAAA,IAAA,CAAK4e,GAAO,CAAE,OAAQ,CAAA,EAAO,OAAQ,CAAA,CAAA,EAAA,EAAvD,KAAA,EAAAjiB,EACC,OADD,EAEJ,CAEA,MAAM,SAAU,CACR,IAAAujB,EAAK,MAAMjC,EAAYje,EAAA,IAAA,CAAK4e,GAAO,CAAE,OAAQ,CAAA,EAAO,OAAQ,CAAA,CAAA,GAC9D,OAAAsB,AAAM,MAANA,EAAmB,EACf,AAAA,CAAA,MAAMA,EAAG,OAAA,EAAA,EAAW,IADxB,AAEN,CAEA,MAAM,QAAS,CAEV,OAAA,MAAMjC,EAAYje,EAAA,IAAA,CAAK4e,GAAO,CAC7B,OAAQ,CADqB,EAE7B,OAAQ,CADA,CAET,cAAc,oBAEnB,CAEA,MAAM,QAAS,CACb,GAAI5e,EAAA,IAAA,CAAKyf,GAAiB,MAAA,MAAM,gCAC1B,OAAA12E,EAAOi3D,EAAA,IAAA,CAAK4e,GAEpB,CAQA,MAAM,OAAUphB,CAAAA,CAAW,CACzB,GAAIA,aAAkB8hB,EACpB,OAAI9hB,EAAO,IAAA,GAAS,IAAA,CAAK,IAAA,CAAa,IAAA,CAEhC,CAAA,MAAAzvD,EAAMyvD,EAAO,IAAA,CAAM,IAAI,EACtBhhD,EAAKghD,EAAO,IAAI,CAAA,EACzB,GAAWA,aAAkBkhB,EAAO,CAClC,GAAI,CAAE,MAAM,IAAA,CAAK,MAAjB,GACE,MAAM,MAAM,CAAA,KAAA,EAAQ,IAAA,CAAK,IAAI,CAAA,WAAA,CAAa,EAErC,OAAA,MAAM,IAAA,CAAK,MAAA,CAAOliE,EAAK6hE,EAAS7gB,EAAO,IAAA,CAAM,IAAA,CAAK,IAAI,GAAE,CAAA,GACtDA,aAAkB,qBACpB,OAAA,MAAA,AAAA,CAAA,MAAM,IAAA,CAAK,MAAA,EAAA,EAAU,MAAA,CAAO,MAAMA,EAAO,cAAA,IACzC,IAET,OAAM,MAAM,sBACd,CAKA,MAAM,OAAOA,CAAAA,CAAyC,CACpD,IAAM4iB,EAAU,MAAM,IAAA,CAAK,MAAA,CAAO5iB,GAClC,OAAA,MAAM,IAAA,CAAK,MAAA,GACJ4iB,CACT,CACF,CAnNExB,CAAAA,EAAA,IAAA,QACAE,EAAA,IAAA,QACAD,EAAA,IAAA,QACAU,EAAA,IAAA,QAEAC,EAAA,IAAA,QAiBAC,EAAA,IAAA,QACAC,EAAA,IAAA,QAiCAG,EAAA,IAxDAjB,QAjBK,IAAMM,EAANI,ECtFDe,EAAU,wBAEhB,eAAeC,EAAWj+E,CAAAA,EACpB,GAAA,CACE,GAAAA,AAAY,SAAZA,EAAG,IAAA,CAAiB,CACtB,GAAI,CAAE,MAAMA,EAAG,MAAA,GAAkB,MAAA,CAAjC,EAEM,IAAA88E,EAAS,MAAM98E,EAAG,YAAlB,EACA,OAAA88E,EAAO,QAAA,CAAS,GACtB,MAAMA,EAAO,KAAA,GACb,MAAM98E,EAAG,MAFH,EAEU,MAEhB,MAAMA,EAAG,MAAT,GAEK,MAAA,CAAA,CAAA,CAAA,MACA,EAAG,CACV,OAAA,QAAQ,IAAA,CAAK,GACN,CADP,CAEF,CACF,CAgBA,IAAMm+E,EAAgC,EAAtC,CACIC,EAAkB,CAAtB,EAGA,eAAsBC,IAChB,GAAA,AAA2B,MAA3B,WAAW,YAAA,CAAX,OAEJ,IAAMC,EAAmB,8BAEpBF,CAAAA,GACeA,CAAAA,EAAA,CAAA,EACP,WAAA,gBAAA,CAAiB,SAAU,KAChCD,AAA+B,IAA/BA,EAAoB,MAAA,EACX,aAAA,OADT,CAEFG,EACA,CAAA,EACE,aAAa,OAAA,CAAQA,IAAqB,GAC5C,CAAA,EAAIH,EAAoB,IAAA,CAAK,KAAA,CAH7B,CAIF,EAAA,EAIJ,IAAII,EAAU,aAAa,OAAA,CAAQD,IAAqB,GACxD,IAAA,IAAWvqF,KAAQwqF,EAAQ,KAAA,CAAM,KAC3BxqF,AAAgB,IAAhBA,EAAK,MAAA,EACL,MAAMkqF,EAAW9jE,EAAK,CAAA,EAAG6jE,EAAO,CAAA,EAAIjqF,EAAAA,CAAM,IAClCwqF,CAAAA,EAAAA,EAAQ,OAAA,CAAQxqF,EAAM,GAAA,EAGpC,aAAa,OAAA,CAAQuqF,EAAkBC,EAAQ,OAAA,CAAQ,SAAU,KACnE,CAwBO,SAASvvE,IACd,IAAMjb,EAAO,CAAA,EAAG,KAAK,MAAA,GAAS,QAAA,GAAW,KAAA,CAAM,GAAE,CAAA,EAAI,KAAK,GAAA,GAAA,CAA1D,CACA,OAAAoqF,EAAoB,IAAA,CAAKpqF,GAClBomB,EAAK,CAAA,EAAG6jE,EAAO,CAAA,EAAIjqF,EAAAA,CAAM,CAClC,CC9FgB,SAAAyqF,EAASloB,CAAAA,CAAkBmoB,CAAAA,EACrC,IAAArtE,EAAI+I,EAAKm8C,GAETnmD,EAAO,EACPuuE,EAAmDttE,EAAE,YAAA,GACrDutE,EAAgBvtE,EAAE,YAJlB,GAMEuhD,EAAQ,MAAOmqB,IAEnB,IAAMn0E,EAAO,MAAA,AADE,CAAA,MAAMg2E,CAAAA,EACK,IAAA,CAAKxuE,EAAM,CAAE,GAAI,KAAK,KAAA,CAAMA,AAAO,GAAPA,EAAa,EACnEA,CAAAA,EAAO,MAAM2sE,EAAO,KAAA,CAAMn0E,EAAM,CAAE,GAAI,CAAA,GAChC,MAAAm0E,EAAO,QAAA,CAAS3sE,EAAI,EAGrB,MAAA,CACL,OAAQ,MAAOm4D,IACb,IAAMwU,EAAS,MAAM4B,CACbvuE,CAAAA,CAAAA,GAAA,MAAM2sE,EAAO,KAAA,CAAMxU,EAAAA,GACfmW,GAAe,MAAA9rB,EAAMmqB,EACnC,EACA,KAAM1rE,EAAE,IAAA,CAAK,IAAA,CAAKA,GAClB,OAAQ,UACC,MAAA,AAAA,CAAA,MAAMutE,CAAAA,EAAe,KAAA,GACrB,MAAA,AAAA,CAAA,MAAMD,CAAAA,EAAe,KAAA,GAC5B,MAAMttE,EAAE,MAFD,EAGT,EACA,QAAS,SAAYjB,CAAA,CAEzB,EDwCC,AAAA,iB,I,CACK,AAA2C,EAAA,IAA3C,WAAW,2BAAA,EACf,CAAA,WAAW,2BAAA,CAA8B,CAAA,EAIvC,AAAwC,MAAxC,WAAW,yBAAA,EACX,AAAmC,MAAnC,WAAW,oBAAA,EAAwB,AAAA,CAAA,AACnC,MAAAmqD,CAAAA,EAAA,WAAW,SAAA,AAAA,EAAX,KAAA,EAAAA,EAAsB,OAAA,CAAQ,YAAA,AAAA,GAAgB,MAMlC4jB,CAAAA,AA1Dd,YAAY,UAEV,IAAA,IAAWl+E,IAAM,CAAA,MAAMm8E,EAAI6B,GAAS,QAAA,EAAA,EAAY,CAC9C,IAAMrlE,EAAQ,cAAc,IAAA,CAAK3Y,EAAG,IAAI,CACpC2Y,CAAAA,CAAAA,AAAS,MAATA,GAAiB,KAAK,GAAA,GAAQ,OAAOA,CAAAA,CAAM,EAAE,EAAI,MAAA,GAEnD,MAAMslE,EAAWj+E,EAErB,CAAA,EACC,KAkDH,MAAMq+E,GAAAA,CAAa,CACrB,G,E,C,iD,O,E,E,C,Q,C,Q,oB,C,G,G,C,Q,C,C,C,kB,gB,K,O","sources":["<anon>","packages/artplayer-proxy-webav/src/index.js","node_modules/@webav/av-cliper/dist/av-cliper.js","node_modules/@webav/av-cliper/src/dom-utils.ts","node_modules/@webav/av-cliper/src/av-utils.ts","node_modules/@webav/av-cliper/src/clips/iclip.ts","node_modules/@webav/av-cliper/src/mp4-utils/mp4box-utils.ts","node_modules/@webav/av-cliper/src/clips/mp4-clip.ts","node_modules/@webav/av-cliper/src/clips/img-clip.ts","node_modules/@webav/av-cliper/src/clips/audio-clip.ts","node_modules/@webav/av-cliper/src/clips/media-stream-clip.ts","node_modules/@webav/av-cliper/src/clips/embed-subtitles-clip.ts","node_modules/@webav/av-cliper/src/mp4-utils/sample-transform.ts","node_modules/@webav/av-cliper/src/mp4-utils/index.ts","node_modules/@webav/av-cliper/src/chromakey.ts","node_modules/@webav/av-cliper/src/sprite/rect.ts","node_modules/@webav/av-cliper/src/sprite/base-sprite.ts","node_modules/@webav/av-cliper/src/sprite/offscreen-sprite.ts","node_modules/@webav/av-cliper/src/sprite/visible-sprite.ts","node_modules/@webav/av-cliper/src/combinator.ts","node_modules/@webav/mp4box.js/dist/mp4box.all.js","node_modules/@webav/internal-utils/dist/internal-utils.js","node_modules/@webav/internal-utils/src/event-tool.ts","node_modules/@webav/internal-utils/src/worker-timer.ts","node_modules/@webav/internal-utils/src/stream-utils.ts","node_modules/@webav/internal-utils/src/meta-box.ts","node_modules/@webav/internal-utils/src/log.ts","node_modules/@webav/internal-utils/src/recodemux.ts","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","node_modules/wave-resampler/index.js","node_modules/wave-resampler/lib/interpolator.js","node_modules/wave-resampler/lib/fir-lpf.js","node_modules/wave-resampler/lib/butterworth-lpf.js","node_modules/opfs-tools/dist/opfs-tools.js","node_modules/opfs-tools/src/access-worker.ts","node_modules/opfs-tools/src/common.ts","node_modules/opfs-tools/src/directory.ts","node_modules/opfs-tools/src/file.ts","node_modules/opfs-tools/src/tmpfile.ts","node_modules/opfs-tools/src/rollfile.ts"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (\n  modules,\n  entry,\n  mainEntry,\n  parcelRequireName,\n  externals,\n  distDir,\n  publicUrl,\n  devServer\n) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var importMap = previousRequire.i || {};\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        if (externals[name]) {\n          return externals[name];\n        }\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        globalObject\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.require = nodeRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.distDir = distDir;\n  newRequire.publicUrl = publicUrl;\n  newRequire.devServer = devServer;\n  newRequire.i = importMap;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  // Only insert newRequire.load when it is actually used.\n  // The code in this file is linted against ES5, so dynamic import is not allowed.\n  // INSERT_LOAD_HERE\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n    }\n  }\n})({\"3MqzM\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"default\", ()=>artplayerProxyWebAV);\nvar _avCliper = require(\"@webav/av-cliper\");\nfunction artplayerProxyWebAV(opt = {}) {\n    return (art)=>{\n        const { option, constructor } = art;\n        const { createElement, def } = constructor.utils;\n        const canvas = createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        let audioCtx;\n        let gainNode;\n        let clip = null;\n        let audioSource = null;\n        let intervalId = null;\n        let seekTarget = null;\n        let lastSeekTime = 0;\n        const state = {\n            playing: false,\n            duration: 0,\n            videoWidth: 0,\n            videoHeight: 0,\n            currentTime: 0,\n            playbackRate: 1,\n            paused: true,\n            ended: false,\n            readyState: 0,\n            buffered: 0,\n            muted: option.muted,\n            volume: option.volume,\n            autoplay: option.autoplay\n        };\n        function reset() {\n            Object.assign(state, {\n                playing: false,\n                duration: 0,\n                videoWidth: 0,\n                videoHeight: 0,\n                currentTime: 0,\n                playbackRate: 1,\n                paused: true,\n                ended: false,\n                readyState: 0,\n                buffered: 0,\n                muted: option.muted,\n                volume: option.volume,\n                autoplay: option.autoplay\n            });\n        }\n        function stop() {\n            if (intervalId) {\n                clearInterval(intervalId);\n                intervalId = null;\n            }\n            if (audioSource) {\n                audioSource.stop();\n                audioSource = null;\n            }\n        }\n        function updateVolume() {\n            if (gainNode) {\n                const effectiveVolume = state.muted ? 0 : state.volume;\n                gainNode.gain.setValueAtTime(effectiveVolume, audioCtx.currentTime);\n            }\n        }\n        async function play() {\n            if (!audioCtx) {\n                audioCtx = new AudioContext();\n                gainNode = audioCtx.createGain();\n                gainNode.connect(audioCtx.destination);\n            }\n            let curTime = state.currentTime * 1e6;\n            let startAt = 0;\n            let first = true;\n            let lastFrameTime = performance.now();\n            stop();\n            updateVolume();\n            async function frameHandler() {\n                if (!state.playing) return;\n                const currentFrameTime = performance.now();\n                const deltaTime = currentFrameTime - lastFrameTime;\n                lastFrameTime = currentFrameTime;\n                if (seekTarget !== null) {\n                    curTime = seekTarget * 1e6;\n                    seekTarget = null;\n                    first = true;\n                } else curTime += deltaTime * 1000 * state.playbackRate;\n                state.currentTime = curTime / 1e6;\n                const { state: clipState, video, audio } = await clip.tick(Math.round(curTime));\n                art.emit('video:timeupdate', {\n                    type: 'timeupdate'\n                });\n                if (clipState === 'done') {\n                    stop();\n                    state.ended = true;\n                    state.playing = false;\n                    state.paused = true;\n                    art.emit('video:ended', {\n                        type: 'ended'\n                    });\n                    return;\n                }\n                if (video && clipState === 'success') {\n                    ctx.clearRect(0, 0, state.videoWidth, state.videoHeight);\n                    ctx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);\n                    video.close();\n                }\n                if (first) first = false;\n                else if (audio?.[0]?.length) {\n                    const buf = audioCtx.createBuffer(2, audio[0].length, 48000);\n                    buf.copyToChannel(audio[0], 0);\n                    buf.copyToChannel(audio[1], 1);\n                    audioSource = audioCtx.createBufferSource();\n                    audioSource.buffer = buf;\n                    audioSource.connect(gainNode);\n                    audioSource.playbackRate.setValueAtTime(state.playbackRate, audioCtx.currentTime);\n                    startAt = Math.max(audioCtx.currentTime, startAt);\n                    audioSource.start(startAt);\n                    startAt += buf.duration / state.playbackRate;\n                }\n            }\n            state.playing = true;\n            state.paused = false;\n            intervalId = setInterval(frameHandler, 1000 / 60); // 约60fps\n        }\n        async function preview(time) {\n            const { video } = await clip.tick(time * 1e6);\n            if (video) {\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n                video.close();\n            }\n        }\n        function resize() {\n            const player = art.template?.$player;\n            if (!player || option.autoSize) return;\n            const aspectRatio = canvas.videoWidth / canvas.videoHeight;\n            const containerWidth = player.clientWidth;\n            const containerHeight = player.clientHeight;\n            const containerRatio = containerWidth / containerHeight;\n            let paddingLeft = 0;\n            let paddingTop = 0;\n            if (containerRatio > aspectRatio) {\n                const canvasWidth = containerHeight * aspectRatio;\n                paddingLeft = (containerWidth - canvasWidth) / 2;\n            } else {\n                const canvasHeight = containerWidth / aspectRatio;\n                paddingTop = (containerHeight - canvasHeight) / 2;\n            }\n            Object.assign(canvas.style, {\n                padding: `${paddingTop}px ${paddingLeft}px`\n            });\n        }\n        async function init() {\n            const isSupported = await (0, _avCliper.Combinator).isSupported();\n            if (!isSupported) {\n                art.notice.show = 'WebAV is not supported';\n                throw new Error('WebAV is not supported');\n            }\n            stop();\n            reset();\n            if (clip) {\n                clip.destroy();\n                art.emit('video:abort', {\n                    type: 'abort'\n                });\n                art.emit('video:emptied', {\n                    type: 'emptied'\n                });\n            }\n            try {\n                await Promise.resolve();\n                state.readyState = 1;\n                art.emit('video:loadstart', {\n                    type: 'loadstart'\n                });\n                const response = await fetch(option.url);\n                if (!response.body) throw new Error('No response body');\n                clip = new (0, _avCliper.MP4Clip)(response.body, opt);\n            } catch (error) {\n                state.readyState = 0;\n                art.emit('video:error', error);\n                throw error;\n            }\n            const info = await clip.ready;\n            Object.assign(state, {\n                readyState: 4,\n                duration: Math.round(info.duration / 1e6),\n                videoWidth: info.width,\n                videoHeight: info.height\n            });\n            canvas.width = state.videoWidth;\n            canvas.height = state.videoHeight;\n            await preview(0.1);\n            resize();\n            art.emit('video:loadedmetadata', {\n                type: 'loadedmetadata'\n            });\n            art.emit('video:durationchange', {\n                type: 'durationchange'\n            });\n            art.emit('video:loadeddata', {\n                type: 'loadeddata'\n            });\n            art.emit('video:canplay', {\n                type: 'canplay'\n            });\n            art.emit('video:canplaythrough', {\n                type: 'canplaythrough'\n            });\n        }\n        def(canvas, 'duration', {\n            get: ()=>state.duration\n        });\n        def(canvas, 'videoWidth', {\n            get: ()=>state.videoWidth\n        });\n        def(canvas, 'videoHeight', {\n            get: ()=>state.videoHeight\n        });\n        def(canvas, 'volume', {\n            get: ()=>state.volume,\n            set: (val)=>{\n                state.volume = Math.max(0, Math.min(1, val));\n                updateVolume();\n                art.emit('video:volumechange', {\n                    type: 'volumechange'\n                });\n            }\n        });\n        def(canvas, 'currentTime', {\n            get: ()=>state.currentTime,\n            set: (val)=>{\n                if (state.readyState < 4) return;\n                const newTime = Math.max(0, Math.min(val, state.duration));\n                const now = performance.now();\n                if (now - lastSeekTime > 16) {\n                    lastSeekTime = now;\n                    seekTarget = newTime;\n                    state.currentTime = newTime;\n                    if (!state.playing) preview(newTime);\n                    art.emit('video:timeupdate', {\n                        type: 'timeupdate'\n                    });\n                }\n            }\n        });\n        def(canvas, 'autoplay', {\n            get: ()=>state.autoplay,\n            set: (val)=>{\n                state.autoplay = val;\n                if (val && state.readyState >= 4) canvas.play();\n            }\n        });\n        def(canvas, 'src', {\n            get: ()=>option.url,\n            set: (val)=>{\n                option.url = val;\n                init().then(()=>{\n                    if (option.autoplay) canvas.play();\n                });\n            }\n        });\n        def(canvas, 'playbackRate', {\n            get: ()=>state.playbackRate,\n            set: (val)=>{\n                state.playbackRate = Math.max(0.25, Math.min(2, val));\n                if (audioSource) audioSource.playbackRate.setValueAtTime(state.playbackRate, audioCtx.currentTime);\n                art.emit('video:ratechange', {\n                    type: 'ratechange'\n                });\n            }\n        });\n        def(canvas, 'playing', {\n            get: ()=>state.playing\n        });\n        def(canvas, 'paused', {\n            get: ()=>state.paused\n        });\n        def(canvas, 'ended', {\n            get: ()=>state.ended\n        });\n        def(canvas, 'readyState', {\n            get: ()=>state.readyState\n        });\n        def(canvas, 'muted', {\n            get: ()=>state.muted,\n            set: (val)=>{\n                state.muted = val;\n                updateVolume();\n                art.emit('video:volumechange', {\n                    type: 'volumechange'\n                });\n            }\n        });\n        def(canvas, 'buffered', {\n            get: ()=>({\n                    start: ()=>0,\n                    end: ()=>state.buffered,\n                    length: 1\n                })\n        });\n        def(canvas, 'play', {\n            value: async ()=>{\n                if (state.readyState < 4) return false;\n                await play();\n                art.emit('video:play', {\n                    type: 'play'\n                });\n                art.emit('video:playing', {\n                    type: 'playing'\n                });\n                return true;\n            }\n        });\n        def(canvas, 'pause', {\n            value: ()=>{\n                stop();\n                state.playing = false;\n                state.paused = true;\n                art.emit('video:pause', {\n                    type: 'pause'\n                });\n            }\n        });\n        art.on('destroy', ()=>{\n            stop();\n            if (clip) clip.destroy();\n        });\n        art.on('resize', resize);\n        return canvas;\n    };\n}\nif (typeof window !== 'undefined') window['artplayerProxyWebAV'] = artplayerProxyWebAV;\n\n},{\"@webav/av-cliper\":\"dS1kg\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"dS1kg\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"AudioClip\", ()=>ti);\nparcelHelpers.export(exports, \"Combinator\", ()=>En);\nparcelHelpers.export(exports, \"EmbedSubtitlesClip\", ()=>ii);\nparcelHelpers.export(exports, \"ImgClip\", ()=>Ze);\nparcelHelpers.export(exports, \"Log\", ()=>(0, _internalUtils.Log));\nparcelHelpers.export(exports, \"MP4Clip\", ()=>Qe);\nparcelHelpers.export(exports, \"MediaStreamClip\", ()=>ei);\nparcelHelpers.export(exports, \"OffscreenSprite\", ()=>ri);\nparcelHelpers.export(exports, \"Rect\", ()=>Oe);\nparcelHelpers.export(exports, \"VisibleSprite\", ()=>ai);\nparcelHelpers.export(exports, \"createChromakey\", ()=>Rn);\nparcelHelpers.export(exports, \"fastConcatMP4\", ()=>tn);\nparcelHelpers.export(exports, \"fixFMP4Duration\", ()=>In);\nparcelHelpers.export(exports, \"mixinMP4AndAudio\", ()=>Fn);\nparcelHelpers.export(exports, \"renderTxt2ImgBitmap\", ()=>kn);\nvar _mp4BoxJs = require(\"@webav/mp4box.js\");\nvar _mp4BoxJsDefault = parcelHelpers.interopDefault(_mp4BoxJs);\nvar _internalUtils = require(\"@webav/internal-utils\");\nvar _waveResampler = require(\"wave-resampler\");\nvar _opfsTools = require(\"opfs-tools\");\nvar vi = Object.defineProperty;\nvar Je = (s)=>{\n    throw TypeError(s);\n};\nvar Si = (s, t, e)=>t in s ? vi(s, t, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value: e\n    }) : s[t] = e;\nvar S = (s, t, e)=>Si(s, typeof t != \"symbol\" ? t + \"\" : t, e), Fe = (s, t, e)=>t.has(s) || Je(\"Cannot \" + e);\nvar n = (s, t, e)=>(Fe(s, t, \"read from private field\"), e ? e.call(s) : t.get(s)), d = (s, t, e)=>t.has(s) ? Je(\"Cannot add the same private member more than once\") : t instanceof WeakSet ? t.add(s) : t.set(s, e), h = (s, t, e, i)=>(Fe(s, t, \"write to private field\"), i ? i.call(s, e) : t.set(s, e), e), B = (s, t, e)=>(Fe(s, t, \"access private method\"), e);\nfunction Ii(s) {\n    return document.createElement(s);\n}\nfunction Fi(s, t) {\n    const e = Ii(\"pre\");\n    e.style.cssText = `margin: 0; ${t}; visibility: hidden; position: fixed;`, e.textContent = s, document.body.appendChild(e);\n    const { width: i, height: r } = e.getBoundingClientRect();\n    e.remove(), e.style.visibility = \"visible\";\n    const a = new Image();\n    a.width = i, a.height = r;\n    const o = `\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${i}\" height=\"${r}\">\n    <foreignObject width=\"100%\" height=\"100%\">\n        <div xmlns=\"http://www.w3.org/1999/xhtml\">${e.outerHTML}</div>\n    </foreignObject>\n    </svg>\n  `.replace(/\\t/g, \"\").replace(/#/g, \"%23\");\n    return a.src = `data:image/svg+xml;charset=utf-8,${o}`, a;\n}\nasync function kn(s, t) {\n    const e = Fi(s, t);\n    await new Promise((a)=>{\n        e.onload = a;\n    });\n    const i = new OffscreenCanvas(e.width, e.height), r = i.getContext(\"2d\");\n    return r == null || r.drawImage(e, 0, 0, e.width, e.height), await createImageBitmap(i);\n}\nfunction Ri(s) {\n    const t = new Float32Array(s.map((i)=>i.length).reduce((i, r)=>i + r));\n    let e = 0;\n    for (const i of s)t.set(i, e), e += i.length;\n    return t;\n}\nfunction Ei(s) {\n    const t = [];\n    for(let e = 0; e < s.length; e += 1)for(let i = 0; i < s[e].length; i += 1)t[i] == null && (t[i] = []), t[i].push(s[e][i]);\n    return t.map(Ri);\n}\nfunction ci(s) {\n    if (s.format === \"f32-planar\") {\n        const t = [];\n        for(let e = 0; e < s.numberOfChannels; e += 1){\n            const i = s.allocationSize({\n                planeIndex: e\n            }), r = new ArrayBuffer(i);\n            s.copyTo(r, {\n                planeIndex: e\n            }), t.push(new Float32Array(r));\n        }\n        return t;\n    } else if (s.format === \"f32\") {\n        const t = new ArrayBuffer(s.allocationSize({\n            planeIndex: 0\n        }));\n        return s.copyTo(t, {\n            planeIndex: 0\n        }), Di(new Float32Array(t), s.numberOfChannels);\n    } else if (s.format === \"s16\") {\n        const t = new ArrayBuffer(s.allocationSize({\n            planeIndex: 0\n        }));\n        return s.copyTo(t, {\n            planeIndex: 0\n        }), Pi(new Int16Array(t), s.numberOfChannels);\n    }\n    throw Error(\"Unsupported audio data format\");\n}\nfunction Pi(s, t) {\n    const e = s.length / t, i = Array.from({\n        length: t\n    }, ()=>new Float32Array(e));\n    for(let r = 0; r < e; r++)for(let a = 0; a < t; a++){\n        const o = s[r * t + a];\n        i[a][r] = o / 32768;\n    }\n    return i;\n}\nfunction Di(s, t) {\n    const e = s.length / t, i = Array.from({\n        length: t\n    }, ()=>new Float32Array(e));\n    for(let r = 0; r < e; r++)for(let a = 0; a < t; a++)i[a][r] = s[r * t + a];\n    return i;\n}\nfunction Le(s) {\n    return Array(s.numberOfChannels).fill(0).map((t, e)=>s.getChannelData(e));\n}\nasync function Bi(s, t) {\n    var o;\n    const e = {\n        type: t,\n        data: s\n    }, i = new ImageDecoder(e);\n    await Promise.all([\n        i.completed,\n        i.tracks.ready\n    ]);\n    let r = ((o = i.tracks.selectedTrack) == null ? void 0 : o.frameCount) ?? 1;\n    const a = [];\n    for(let c = 0; c < r; c += 1)a.push((await i.decode({\n        frameIndex: c\n    })).image);\n    return a;\n}\nfunction Ye(s) {\n    var i, r;\n    const t = Math.max(...s.map((a)=>{\n        var o;\n        return ((o = a[0]) == null ? void 0 : o.length) ?? 0;\n    })), e = new Float32Array(t * 2);\n    for(let a = 0; a < t; a++){\n        let o = 0, c = 0;\n        for(let l = 0; l < s.length; l++){\n            const m = ((i = s[l][0]) == null ? void 0 : i[a]) ?? 0, u = ((r = s[l][1]) == null ? void 0 : r[a]) ?? m;\n            o += m, c += u;\n        }\n        e[a] = o, e[a + t] = c;\n    }\n    return e;\n}\nasync function _i(s, t, e) {\n    const i = s.length, r = Array(e.chanCount).fill(0).map(()=>new Float32Array(0));\n    if (i === 0) return r;\n    const a = Math.max(...s.map((m)=>m.length));\n    if (a === 0) return r;\n    if (globalThis.OfflineAudioContext == null) return s.map((m)=>new Float32Array(_waveResampler.resample(m, t, e.rate, {\n            method: \"sinc\",\n            LPF: !1\n        })));\n    const o = new globalThis.OfflineAudioContext(e.chanCount, a * e.rate / t, e.rate), c = o.createBufferSource(), l = o.createBuffer(i, a, t);\n    return s.forEach((m, u)=>l.copyToChannel(m, u)), c.buffer = l, c.connect(o.destination), c.start(), Le(await o.startRendering());\n}\nfunction Ue(s) {\n    return new Promise((t)=>{\n        const e = (0, _internalUtils.workerTimer)(()=>{\n            e(), t();\n        }, s);\n    });\n}\nfunction De(s, t, e) {\n    const i = e - t, r = new Float32Array(i);\n    let a = 0;\n    for(; a < i;)r[a] = s[(t + a) % s.length], a += 1;\n    return r;\n}\nfunction li(s, t) {\n    const e = Math.floor(s.length / t), i = new Float32Array(e);\n    for(let r = 0; r < e; r++){\n        const a = r * t, o = Math.floor(a), c = a - o;\n        o + 1 < s.length ? i[r] = s[o] * (1 - c) + s[o + 1] * c : i[r] = s[o];\n    }\n    return i;\n}\nconst T = {\n    sampleRate: 48e3,\n    channelCount: 2,\n    codec: \"mp4a.40.2\"\n};\nfunction Ne(s, t) {\n    const e = t.videoTracks[0], i = {};\n    if (e != null) {\n        const a = Oi(s.getTrackById(e.id)).buffer, { descKey: o, type: c } = e.codec.startsWith(\"avc1\") ? {\n            descKey: \"avcDecoderConfigRecord\",\n            type: \"avc1\"\n        } : e.codec.startsWith(\"hvc1\") ? {\n            descKey: \"hevcDecoderConfigRecord\",\n            type: \"hvc1\"\n        } : {\n            descKey: \"\",\n            type: \"\"\n        };\n        o !== \"\" && (i.videoTrackConf = {\n            timescale: e.timescale,\n            duration: e.duration,\n            width: e.video.width,\n            height: e.video.height,\n            brands: t.brands,\n            type: c,\n            [o]: a\n        }), i.videoDecoderConf = {\n            codec: e.codec,\n            codedHeight: e.video.height,\n            codedWidth: e.video.width,\n            description: a\n        };\n    }\n    const r = t.audioTracks[0];\n    if (r != null) {\n        const a = je(s);\n        i.audioTrackConf = {\n            timescale: r.timescale,\n            samplerate: r.audio.sample_rate,\n            channel_count: r.audio.channel_count,\n            hdlr: \"soun\",\n            type: r.codec.startsWith(\"mp4a\") ? \"mp4a\" : r.codec,\n            description: je(s)\n        }, i.audioDecoderConf = {\n            codec: r.codec.startsWith(\"mp4a\") ? T.codec : r.codec,\n            numberOfChannels: r.audio.channel_count,\n            sampleRate: r.audio.sample_rate,\n            ...a == null ? {} : Mi(a)\n        };\n    }\n    return i;\n}\nfunction Oi(s) {\n    for (const t of s.mdia.minf.stbl.stsd.entries){\n        const e = t.avcC ?? t.hvcC ?? t.av1C ?? t.vpcC;\n        if (e != null) {\n            const i = new (0, _mp4BoxJsDefault.default).DataStream(void 0, 0, (0, _mp4BoxJsDefault.default).DataStream.BIG_ENDIAN);\n            return e.write(i), new Uint8Array(i.buffer.slice(8));\n        }\n    }\n    throw Error(\"avcC, hvcC, av1C or VPX not found\");\n}\nfunction je(s, t = \"mp4a\") {\n    var i;\n    const e = (i = s.moov) == null ? void 0 : i.traks.map((r)=>r.mdia.minf.stbl.stsd.entries).flat().find(({ type: r })=>r === t);\n    return e == null ? void 0 : e.esds;\n}\nfunction Mi(s) {\n    var c;\n    const t = (c = s.esd.descs[0]) == null ? void 0 : c.descs[0];\n    if (t == null) return {};\n    const [e, i] = t.data, r = ((e & 7) << 1) + (i >> 7), a = (i & 127) >> 3;\n    return {\n        sampleRate: [\n            96e3,\n            88200,\n            64e3,\n            48e3,\n            44100,\n            32e3,\n            24e3,\n            22050,\n            16e3,\n            12e3,\n            11025,\n            8e3,\n            7350\n        ][r],\n        numberOfChannels: a\n    };\n}\nasync function zi(s, t, e) {\n    const i = (0, _mp4BoxJsDefault.default).createFile(!1);\n    i.onReady = (a)=>{\n        var l, m;\n        t({\n            mp4boxFile: i,\n            info: a\n        });\n        const o = (l = a.videoTracks[0]) == null ? void 0 : l.id;\n        o != null && i.setExtractionOptions(o, \"video\", {\n            nbSamples: 100\n        });\n        const c = (m = a.audioTracks[0]) == null ? void 0 : m.id;\n        c != null && i.setExtractionOptions(c, \"audio\", {\n            nbSamples: 100\n        }), i.start();\n    }, i.onSamples = e, await r();\n    async function r() {\n        let a = 0;\n        const o = 31457280;\n        for(;;){\n            const c = await s.read(o, {\n                at: a\n            });\n            if (c.byteLength === 0) break;\n            c.fileStart = a;\n            const l = i.appendBuffer(c);\n            if (l == null) break;\n            a = l;\n        }\n        i.stop();\n    }\n}\nlet He = 0;\nfunction Re(s) {\n    return s.kind === \"file\" && s.createReader instanceof Function;\n}\nvar Ce, Jt, Yt, V, R, $, jt, L, rt, _t, bt, W, D, Ot;\nconst yt = class yt {\n    constructor(t, e = {}){\n        d(this, Ce, He++);\n        d(this, Jt, (0, _internalUtils.Log).create(`MP4Clip id:${n(this, Ce)},`));\n        S(this, \"ready\");\n        d(this, Yt, !1);\n        d(this, V, {\n            // 微秒\n            duration: 0,\n            width: 0,\n            height: 0,\n            audioSampleRate: 0,\n            audioChanCount: 0\n        });\n        d(this, R);\n        d(this, $, []);\n        d(this, jt, 1);\n        d(this, L, []);\n        d(this, rt, []);\n        d(this, _t, null);\n        d(this, bt, null);\n        d(this, W, {\n            video: null,\n            audio: null\n        });\n        d(this, D, {\n            audio: !0\n        });\n        /**\n     * 拦截 {@link MP4Clip.tick} 方法返回的数据，用于对图像、音频数据二次处理\n     * @param time 调用 tick 的时间\n     * @param tickRet tick 返回的数据\n     *\n     * @see [移除视频绿幕背景](https://webav-tech.github.io/WebAV/demo/3_2-chromakey-video)\n     */ S(this, \"tickInterceptor\", async (t, e)=>e);\n        d(this, Ot, new AbortController());\n        if (!(t instanceof ReadableStream) && !Re(t) && !Array.isArray(t.videoSamples)) throw Error(\"Illegal argument\");\n        h(this, D, {\n            audio: !0,\n            ...e\n        }), h(this, jt, typeof e.audio == \"object\" && \"volume\" in e.audio ? e.audio.volume : 1);\n        const i = async (r)=>(await (0, _opfsTools.write)(n(this, R), r), n(this, R));\n        h(this, R, Re(t) ? t : \"localFile\" in t ? t.localFile : (0, _opfsTools.tmpfile)()), this.ready = (t instanceof ReadableStream ? i(t).then((r)=>Ke(r, n(this, D))) : Re(t) ? Ke(t, n(this, D)) : Promise.resolve(t)).then(async ({ videoSamples: r, audioSamples: a, decoderConf: o, headerBoxPos: c })=>{\n            h(this, L, r), h(this, rt, a), h(this, W, o), h(this, $, c);\n            const { videoFrameFinder: l, audioFrameFinder: m } = Li({\n                video: o.video == null ? null : {\n                    ...o.video,\n                    hardwareAcceleration: n(this, D).__unsafe_hardwareAcceleration__\n                },\n                audio: o.audio\n            }, await n(this, R).createReader(), r, a, n(this, D).audio !== !1 ? n(this, jt) : 0);\n            return h(this, _t, l), h(this, bt, m), h(this, V, Vi(o, r, a)), n(this, Jt).info(\"MP4Clip meta:\", n(this, V)), {\n                ...n(this, V)\n            };\n        });\n    }\n    get meta() {\n        return {\n            ...n(this, V)\n        };\n    }\n    /**\n   * 提供视频头（box: ftyp, moov）的二进制数据\n   * 使用任意 mp4 demxer 解析即可获得详细的视频信息\n   * 单元测试包含使用 mp4box.js 解析示例代码\n   */ async getFileHeaderBinData() {\n        await this.ready;\n        const t = await n(this, R).getOriginFile();\n        if (t == null) throw Error(\"MP4Clip localFile is not origin file\");\n        return await new Blob(n(this, $).map(({ start: e, size: i })=>t.slice(e, e + i))).arrayBuffer();\n    }\n    /**\n   * 获取素材指定时刻的图像帧、音频数据\n   * @param time 微秒\n   */ async tick(t) {\n        var r, a, o;\n        if (t >= n(this, V).duration) return await this.tickInterceptor(t, {\n            audio: await ((r = n(this, bt)) == null ? void 0 : r.find(t)) ?? [],\n            state: \"done\"\n        });\n        const [e, i] = await Promise.all([\n            ((a = n(this, bt)) == null ? void 0 : a.find(t)) ?? [],\n            (o = n(this, _t)) == null ? void 0 : o.find(t)\n        ]);\n        return i == null ? await this.tickInterceptor(t, {\n            audio: e,\n            state: \"success\"\n        }) : await this.tickInterceptor(t, {\n            video: i,\n            audio: e,\n            state: \"success\"\n        });\n    }\n    /**\n   * 生成缩略图，默认每个关键帧生成一个 100px 宽度的缩略图。\n   *\n   * @param imgWidth 缩略图宽度，默认 100\n   * @param opts Partial<ThumbnailOpts>\n   * @returns Promise<Array<{ ts: number; img: Blob }>>\n   */ async thumbnails(t = 100, e) {\n        n(this, Ot).abort(), h(this, Ot, new AbortController());\n        const i = n(this, Ot).signal;\n        await this.ready;\n        const r = \"generate thumbnails aborted\";\n        if (i.aborted) throw Error(r);\n        const { width: a, height: o } = n(this, V), c = Wi(t, Math.round(o * (t / a)), {\n            quality: 0.1,\n            type: \"image/png\"\n        });\n        return new Promise(async (l, m)=>{\n            let u = [];\n            const w = n(this, W).video;\n            if (w == null || n(this, L).length === 0) {\n                p();\n                return;\n            }\n            i.addEventListener(\"abort\", ()=>{\n                m(Error(r));\n            });\n            async function p() {\n                i.aborted || l(await Promise.all(u.map(async (b)=>({\n                        ts: b.ts,\n                        img: await b.img\n                    }))));\n            }\n            function x(b) {\n                u.push({\n                    ts: b.timestamp,\n                    img: c(b)\n                });\n            }\n            const { start: f = 0, end: y = n(this, V).duration, step: g } = e ?? {};\n            if (g) {\n                let b = f;\n                const C = new hi(await n(this, R).createReader(), n(this, L), {\n                    ...w,\n                    hardwareAcceleration: n(this, D).__unsafe_hardwareAcceleration__\n                });\n                for(; b <= y && !i.aborted;){\n                    const v = await C.find(b);\n                    v && x(v), b += g;\n                }\n                C.destroy(), p();\n            } else await Yi(n(this, L), n(this, R), w, i, {\n                start: f,\n                end: y\n            }, (b, C)=>{\n                b != null && x(b), C && p();\n            });\n        });\n    }\n    async split(t) {\n        if (await this.ready, t <= 0 || t >= n(this, V).duration) throw Error('\"time\" out of bounds');\n        const [e, i] = Xi(n(this, L), t), [r, a] = Gi(n(this, rt), t), o = new yt({\n            localFile: n(this, R),\n            videoSamples: e ?? [],\n            audioSamples: r ?? [],\n            decoderConf: n(this, W),\n            headerBoxPos: n(this, $)\n        }, n(this, D)), c = new yt({\n            localFile: n(this, R),\n            videoSamples: i ?? [],\n            audioSamples: a ?? [],\n            decoderConf: n(this, W),\n            headerBoxPos: n(this, $)\n        }, n(this, D));\n        return await Promise.all([\n            o.ready,\n            c.ready\n        ]), [\n            o,\n            c\n        ];\n    }\n    async clone() {\n        await this.ready;\n        const t = new yt({\n            localFile: n(this, R),\n            videoSamples: [\n                ...n(this, L)\n            ],\n            audioSamples: [\n                ...n(this, rt)\n            ],\n            decoderConf: n(this, W),\n            headerBoxPos: n(this, $)\n        }, n(this, D));\n        return await t.ready, t.tickInterceptor = this.tickInterceptor, t;\n    }\n    /**\n   * 拆分 MP4Clip 为仅包含视频轨道和音频轨道的 MP4Clip\n   * @returns Mp4CLip[]\n   */ async splitTrack() {\n        await this.ready;\n        const t = [];\n        if (n(this, L).length > 0) {\n            const e = new yt({\n                localFile: n(this, R),\n                videoSamples: [\n                    ...n(this, L)\n                ],\n                audioSamples: [],\n                decoderConf: {\n                    video: n(this, W).video,\n                    audio: null\n                },\n                headerBoxPos: n(this, $)\n            }, n(this, D));\n            await e.ready, e.tickInterceptor = this.tickInterceptor, t.push(e);\n        }\n        if (n(this, rt).length > 0) {\n            const e = new yt({\n                localFile: n(this, R),\n                videoSamples: [],\n                audioSamples: [\n                    ...n(this, rt)\n                ],\n                decoderConf: {\n                    audio: n(this, W).audio,\n                    video: null\n                },\n                headerBoxPos: n(this, $)\n            }, n(this, D));\n            await e.ready, e.tickInterceptor = this.tickInterceptor, t.push(e);\n        }\n        return t;\n    }\n    destroy() {\n        var t, e;\n        n(this, Yt) || (n(this, Jt).info(\"MP4Clip destroy\"), h(this, Yt, !0), (t = n(this, _t)) == null || t.destroy(), (e = n(this, bt)) == null || e.destroy());\n    }\n};\nCe = new WeakMap(), Jt = new WeakMap(), Yt = new WeakMap(), V = new WeakMap(), R = new WeakMap(), $ = new WeakMap(), jt = new WeakMap(), L = new WeakMap(), rt = new WeakMap(), _t = new WeakMap(), bt = new WeakMap(), W = new WeakMap(), D = new WeakMap(), Ot = new WeakMap();\nlet Qe = yt;\nfunction Vi(s, t, e) {\n    const i = {\n        duration: 0,\n        width: 0,\n        height: 0,\n        audioSampleRate: 0,\n        audioChanCount: 0\n    };\n    s.video != null && t.length > 0 && (i.width = s.video.codedWidth ?? 0, i.height = s.video.codedHeight ?? 0), s.audio != null && e.length > 0 && (i.audioSampleRate = T.sampleRate, i.audioChanCount = T.channelCount);\n    let r = 0, a = 0;\n    if (t.length > 0) for(let o = t.length - 1; o >= 0; o--){\n        const c = t[o];\n        if (!c.deleted) {\n            r = c.cts + c.duration;\n            break;\n        }\n    }\n    if (e.length > 0) {\n        const o = e.at(-1);\n        a = o.cts + o.duration;\n    }\n    return i.duration = Math.max(r, a), i;\n}\nfunction Li(s, t, e, i, r) {\n    return {\n        audioFrameFinder: r === 0 || s.audio == null || i.length === 0 ? null : new Ni(t, i, s.audio, {\n            volume: r,\n            targetSampleRate: T.sampleRate\n        }),\n        videoFrameFinder: s.video == null || e.length === 0 ? null : new hi(t, e, s.video)\n    };\n}\nasync function Ke(s, t = {}) {\n    let e = null;\n    const i = {\n        video: null,\n        audio: null\n    };\n    let r = [], a = [], o = [], c = -1, l = -1;\n    const m = await s.createReader();\n    await zi(m, (p)=>{\n        e = p.info;\n        const x = p.mp4boxFile.ftyp;\n        o.push({\n            start: x.start,\n            size: x.size\n        });\n        const f = p.mp4boxFile.moov;\n        o.push({\n            start: f.start,\n            size: f.size\n        });\n        let { videoDecoderConf: y, audioDecoderConf: g } = Ne(p.mp4boxFile, p.info);\n        i.video = y ?? null, i.audio = g ?? null, y == null && g == null && (0, _internalUtils.Log).error(\"MP4Clip no video and audio track\"), (0, _internalUtils.Log).info(\"mp4BoxFile moov ready\", {\n            ...p.info,\n            tracks: null,\n            videoTracks: null,\n            audioTracks: null\n        }, i);\n    }, (p, x, f)=>{\n        if (x === \"video\") {\n            c === -1 && (c = f[0].dts);\n            for (const y of f)r.push(w(y, c, \"video\"));\n        } else if (x === \"audio\" && t.audio) {\n            l === -1 && (l = f[0].dts);\n            for (const y of f)a.push(w(y, l, \"audio\"));\n        }\n    }), await m.close();\n    const u = r.at(-1) ?? a.at(-1);\n    if (e == null) throw Error(\"MP4Clip stream is done, but not emit ready\");\n    if (u == null) throw Error(\"MP4Clip stream not contain any sample\");\n    return _e(r), (0, _internalUtils.Log).info(\"mp4 stream parsed\"), {\n        videoSamples: r,\n        audioSamples: a,\n        decoderConf: i,\n        headerBoxPos: o\n    };\n    function w(p, x = 0, f) {\n        const y = f === \"video\" && p.is_sync ? Ji(p.data, p.description.type) : -1;\n        let g = p.offset, b = p.size;\n        return y >= 0 && (g += y, b -= y), {\n            ...p,\n            is_idr: y >= 0,\n            offset: g,\n            size: b,\n            cts: (p.cts - x) / p.timescale * 1e6,\n            dts: (p.dts - x) / p.timescale * 1e6,\n            duration: p.duration / p.timescale * 1e6,\n            timescale: 1e6,\n            // 音频数据量可控，直接保存在内存中\n            data: f === \"video\" ? null : p.data\n        };\n    }\n}\nvar F, xt, Ct, Qt, vt, X, _, at, St, Mt, Kt, zt, ot, qt, Tt, Zt;\nclass hi {\n    constructor(t, e, i){\n        d(this, F, null);\n        d(this, xt, 0);\n        d(this, Ct, {\n            abort: !1,\n            st: performance.now()\n        });\n        S(this, \"find\", async (t)=>{\n            (n(this, F) == null || n(this, F).state === \"closed\" || t <= n(this, xt) || t - n(this, xt) > 3e6) && n(this, Tt).call(this, t), n(this, Ct).abort = !0, h(this, xt, t), h(this, Ct, {\n                abort: !1,\n                st: performance.now()\n            });\n            const e = await n(this, zt).call(this, t, n(this, F), n(this, Ct));\n            return h(this, Mt, 0), e;\n        });\n        // fix VideoFrame duration is null\n        d(this, Qt, 0);\n        d(this, vt, !1);\n        d(this, X, 0);\n        d(this, _, []);\n        d(this, at, 0);\n        d(this, St, 0);\n        d(this, Mt, 0);\n        d(this, Kt, !1);\n        d(this, zt, async (t, e, i)=>{\n            if (e == null || e.state === \"closed\" || i.abort) return null;\n            if (n(this, _).length > 0) {\n                const r = n(this, _)[0];\n                return t < r.timestamp ? null : (n(this, _).shift(), t > r.timestamp + (r.duration ?? 0) ? (r.close(), await n(this, zt).call(this, t, e, i)) : (!n(this, Kt) && n(this, _).length < 10 && n(this, qt).call(this, e).catch((a)=>{\n                    throw h(this, Kt, !0), n(this, Tt).call(this, t), a;\n                }), r));\n            }\n            if (n(this, ot) || n(this, at) < n(this, St) && e.decodeQueueSize > 0) {\n                if (performance.now() - i.st > 6e3) throw Error(`MP4Clip.tick video timeout, ${JSON.stringify(n(this, Zt).call(this))}`);\n                h(this, Mt, n(this, Mt) + 1), await Ue(15);\n            } else {\n                if (n(this, X) >= this.samples.length) return null;\n                try {\n                    await n(this, qt).call(this, e);\n                } catch (r) {\n                    throw n(this, Tt).call(this, t), r;\n                }\n            }\n            return await n(this, zt).call(this, t, e, i);\n        });\n        d(this, ot, !1);\n        d(this, qt, async (t)=>{\n            var r, a;\n            if (n(this, ot) || t.decodeQueueSize > 600) return;\n            let e = n(this, X) + 1;\n            if (e > this.samples.length) return;\n            h(this, ot, !0);\n            let i = !1;\n            for(; e < this.samples.length; e++){\n                const o = this.samples[e];\n                if (!i && !o.deleted && (i = !0), o.is_idr) break;\n            }\n            if (i) {\n                const o = this.samples.slice(n(this, X), e);\n                if (((r = o[0]) == null ? void 0 : r.is_idr) !== !0) (0, _internalUtils.Log).warn(\"First sample not idr frame\");\n                else {\n                    const c = performance.now(), l = await di(o, this.localFileReader), m = performance.now() - c;\n                    if (m > 1e3) {\n                        const u = o[0], w = o.at(-1), p = w.offset + w.size - u.offset;\n                        (0, _internalUtils.Log).warn(`Read video samples time cost: ${Math.round(m)}ms, file chunk size: ${p}`);\n                    }\n                    if (t.state === \"closed\") return;\n                    h(this, Qt, ((a = l[0]) == null ? void 0 : a.duration) ?? 0), Be(t, l, {\n                        onDecodingError: (u)=>{\n                            if (n(this, vt)) throw u;\n                            n(this, at) === 0 && (h(this, vt, !0), (0, _internalUtils.Log).warn(\"Downgrade to software decode\"), n(this, Tt).call(this));\n                        }\n                    }), h(this, St, n(this, St) + l.length);\n                }\n            }\n            h(this, X, e), h(this, ot, !1);\n        });\n        d(this, Tt, (t)=>{\n            var i, r;\n            if (h(this, ot, !1), n(this, _).forEach((a)=>a.close()), h(this, _, []), t == null || t === 0) h(this, X, 0);\n            else {\n                let a = 0;\n                for(let o = 0; o < this.samples.length; o++){\n                    const c = this.samples[o];\n                    if (c.is_idr && (a = o), !(c.cts < t)) {\n                        h(this, X, a);\n                        break;\n                    }\n                }\n            }\n            h(this, St, 0), h(this, at, 0), ((i = n(this, F)) == null ? void 0 : i.state) !== \"closed\" && ((r = n(this, F)) == null || r.close());\n            const e = {\n                ...this.conf,\n                ...n(this, vt) ? {\n                    hardwareAcceleration: \"prefer-software\"\n                } : {}\n            };\n            h(this, F, new VideoDecoder({\n                output: (a)=>{\n                    if (h(this, at, n(this, at) + 1), a.timestamp === -1) {\n                        a.close();\n                        return;\n                    }\n                    let o = a;\n                    a.duration == null && (o = new VideoFrame(a, {\n                        duration: n(this, Qt)\n                    }), a.close()), n(this, _).push(o);\n                },\n                error: (a)=>{\n                    if (a.message.includes(\"Codec reclaimed due to inactivity\")) {\n                        h(this, F, null), (0, _internalUtils.Log).warn(a.message);\n                        return;\n                    }\n                    const o = `VideoFinder VideoDecoder err: ${a.message}, config: ${JSON.stringify(e)}, state: ${JSON.stringify(n(this, Zt).call(this))}`;\n                    throw (0, _internalUtils.Log).error(o), Error(o);\n                }\n            })), n(this, F).configure(e);\n        });\n        d(this, Zt, ()=>{\n            var t, e;\n            return {\n                time: n(this, xt),\n                decState: (t = n(this, F)) == null ? void 0 : t.state,\n                decQSize: (e = n(this, F)) == null ? void 0 : e.decodeQueueSize,\n                decCusorIdx: n(this, X),\n                sampleLen: this.samples.length,\n                inputCnt: n(this, St),\n                outputCnt: n(this, at),\n                cacheFrameLen: n(this, _).length,\n                softDeocde: n(this, vt),\n                clipIdCnt: He,\n                sleepCnt: n(this, Mt),\n                memInfo: ui()\n            };\n        });\n        S(this, \"destroy\", ()=>{\n            var t, e;\n            ((t = n(this, F)) == null ? void 0 : t.state) !== \"closed\" && ((e = n(this, F)) == null || e.close()), h(this, F, null), n(this, Ct).abort = !0, n(this, _).forEach((i)=>i.close()), h(this, _, []), this.localFileReader.close();\n        });\n        this.localFileReader = t, this.samples = e, this.conf = i;\n    }\n}\nF = new WeakMap(), xt = new WeakMap(), Ct = new WeakMap(), Qt = new WeakMap(), vt = new WeakMap(), X = new WeakMap(), _ = new WeakMap(), at = new WeakMap(), St = new WeakMap(), Mt = new WeakMap(), Kt = new WeakMap(), zt = new WeakMap(), ot = new WeakMap(), qt = new WeakMap(), Tt = new WeakMap(), Zt = new WeakMap();\nfunction Ui(s, t) {\n    for(let e = 0; e < t.length; e++){\n        const i = t[e];\n        if (s >= i.cts && s < i.cts + i.duration) return e;\n        if (i.cts > s) break;\n    }\n    return 0;\n}\nvar te, ee, U, At, G, et, M, Vt, ie, ne, ve, Se;\nclass Ni {\n    constructor(t, e, i, r){\n        d(this, te, 1);\n        d(this, ee);\n        d(this, U, null);\n        d(this, At, {\n            abort: !1,\n            st: performance.now()\n        });\n        S(this, \"find\", async (t)=>{\n            const e = t <= n(this, G) || t - n(this, G) > 1e5;\n            (n(this, U) == null || n(this, U).state === \"closed\" || e) && n(this, ve).call(this), e && (h(this, G, t), h(this, et, Ui(t, this.samples))), n(this, At).abort = !0;\n            const i = t - n(this, G);\n            h(this, G, t), h(this, At, {\n                abort: !1,\n                st: performance.now()\n            });\n            const r = await n(this, ie).call(this, Math.ceil(i * (n(this, ee) / 1e6)), n(this, U), n(this, At));\n            return h(this, Vt, 0), r;\n        });\n        d(this, G, 0);\n        d(this, et, 0);\n        d(this, M, {\n            frameCnt: 0,\n            data: []\n        });\n        d(this, Vt, 0);\n        d(this, ie, async (t, e = null, i)=>{\n            if (e == null || i.abort || e.state === \"closed\" || t === 0) return [];\n            const r = n(this, M).frameCnt - t;\n            if (r > 0) return r < T.sampleRate / 10 && n(this, ne).call(this, e), qe(n(this, M), t);\n            if (e.decoding) {\n                if (performance.now() - i.st > 3e3) throw i.abort = !0, Error(`MP4Clip.tick audio timeout, ${JSON.stringify(n(this, Se).call(this))}`);\n                h(this, Vt, n(this, Vt) + 1), await Ue(15);\n            } else {\n                if (n(this, et) >= this.samples.length - 1) return qe(n(this, M), n(this, M).frameCnt);\n                n(this, ne).call(this, e);\n            }\n            return n(this, ie).call(this, t, e, i);\n        });\n        d(this, ne, (t)=>{\n            if (t.decodeQueueSize > 10) return;\n            const i = [];\n            let r = n(this, et);\n            for(; r < this.samples.length;){\n                const a = this.samples[r];\n                if (r += 1, !a.deleted && (i.push(a), i.length >= 10)) break;\n            }\n            h(this, et, r), t.decode(i.map((a)=>new EncodedAudioChunk({\n                    type: \"key\",\n                    timestamp: a.cts,\n                    duration: a.duration,\n                    data: a.data\n                })));\n        });\n        d(this, ve, ()=>{\n            var t;\n            h(this, G, 0), h(this, et, 0), h(this, M, {\n                frameCnt: 0,\n                data: []\n            }), (t = n(this, U)) == null || t.close(), h(this, U, Hi(this.conf, {\n                resampleRate: T.sampleRate,\n                volume: n(this, te)\n            }, (e)=>{\n                n(this, M).data.push(e), n(this, M).frameCnt += e[0].length;\n            }));\n        });\n        d(this, Se, ()=>{\n            var t, e;\n            return {\n                time: n(this, G),\n                decState: (t = n(this, U)) == null ? void 0 : t.state,\n                decQSize: (e = n(this, U)) == null ? void 0 : e.decodeQueueSize,\n                decCusorIdx: n(this, et),\n                sampleLen: this.samples.length,\n                pcmLen: n(this, M).frameCnt,\n                clipIdCnt: He,\n                sleepCnt: n(this, Vt),\n                memInfo: ui()\n            };\n        });\n        S(this, \"destroy\", ()=>{\n            h(this, U, null), n(this, At).abort = !0, h(this, M, {\n                frameCnt: 0,\n                data: []\n            }), this.localFileReader.close();\n        });\n        this.localFileReader = t, this.samples = e, this.conf = i, h(this, te, r.volume), h(this, ee, r.targetSampleRate);\n    }\n}\nte = new WeakMap(), ee = new WeakMap(), U = new WeakMap(), At = new WeakMap(), G = new WeakMap(), et = new WeakMap(), M = new WeakMap(), Vt = new WeakMap(), ie = new WeakMap(), ne = new WeakMap(), ve = new WeakMap(), Se = new WeakMap();\nfunction Hi(s, t, e) {\n    let i = 0, r = 0;\n    const a = (u)=>{\n        if (r += 1, u.length !== 0) {\n            if (t.volume !== 1) for (const w of u)for(let p = 0; p < w.length; p++)w[p] *= t.volume;\n            u.length === 1 && (u = [\n                u[0],\n                u[0]\n            ]), e(u);\n        }\n    }, o = $i(a), c = t.resampleRate !== s.sampleRate;\n    let l = new AudioDecoder({\n        output: (u)=>{\n            const w = ci(u);\n            c ? o(()=>_i(w, u.sampleRate, {\n                    rate: t.resampleRate,\n                    chanCount: u.numberOfChannels\n                })) : a(w), u.close();\n        },\n        error: (u)=>{\n            u.message.includes(\"Codec reclaimed due to inactivity\") || m(\"MP4Clip AudioDecoder err\", u);\n        }\n    });\n    l.configure(s);\n    function m(u, w) {\n        const p = `${u}: ${w.message}, state: ${JSON.stringify({\n            qSize: l.decodeQueueSize,\n            state: l.state,\n            inputCnt: i,\n            outputCnt: r\n        })}`;\n        throw (0, _internalUtils.Log).error(p), Error(p);\n    }\n    return {\n        decode (u) {\n            i += u.length;\n            try {\n                for (const w of u)l.decode(w);\n            } catch (w) {\n                m(\"decode audio chunk error\", w);\n            }\n        },\n        close () {\n            l.state !== \"closed\" && l.close();\n        },\n        get decoding () {\n            return i > r && l.decodeQueueSize > 0;\n        },\n        get state () {\n            return l.state;\n        },\n        get decodeQueueSize () {\n            return l.decodeQueueSize;\n        }\n    };\n}\nfunction $i(s) {\n    const t = [];\n    let e = 0;\n    function i(o, c) {\n        t[c] = o, r();\n    }\n    function r() {\n        const o = t[e];\n        o != null && (s(o), e += 1, r());\n    }\n    let a = 0;\n    return (o)=>{\n        const c = a;\n        a += 1, o().then((l)=>i(l, c)).catch((l)=>i(l, c));\n    };\n}\nfunction qe(s, t) {\n    const e = [\n        new Float32Array(t),\n        new Float32Array(t)\n    ];\n    let i = 0, r = 0;\n    for(; r < s.data.length;){\n        const [a, o] = s.data[r];\n        if (i + a.length > t) {\n            const c = t - i;\n            e[0].set(a.subarray(0, c), i), e[1].set(o.subarray(0, c), i), s.data[r][0] = a.subarray(c, a.length), s.data[r][1] = o.subarray(c, o.length);\n            break;\n        } else e[0].set(a, i), e[1].set(o, i), i += a.length, r++;\n    }\n    return s.data = s.data.slice(r), s.frameCnt -= t, e;\n}\nasync function di(s, t) {\n    const e = s[0], i = s.at(-1);\n    if (i == null) return [];\n    const r = i.offset + i.size - e.offset;\n    if (r < 3e7) {\n        const a = new Uint8Array(await t.read(r, {\n            at: e.offset\n        }));\n        return s.map((o)=>{\n            const c = o.offset - e.offset;\n            return new EncodedVideoChunk({\n                type: o.is_sync ? \"key\" : \"delta\",\n                timestamp: o.cts,\n                duration: o.duration,\n                data: a.subarray(c, c + o.size)\n            });\n        });\n    }\n    return await Promise.all(s.map(async (a)=>new EncodedVideoChunk({\n            type: a.is_sync ? \"key\" : \"delta\",\n            timestamp: a.cts,\n            duration: a.duration,\n            data: await t.read(a.size, {\n                at: a.offset\n            })\n        })));\n}\nfunction Wi(s, t, e) {\n    const i = new OffscreenCanvas(s, t), r = i.getContext(\"2d\");\n    return async (a)=>(r.drawImage(a, 0, 0, s, t), a.close(), await i.convertToBlob(e));\n}\nfunction Xi(s, t) {\n    if (s.length === 0) return [];\n    let e = 0, i = 0, r = -1;\n    for(let l = 0; l < s.length; l++){\n        const m = s[l];\n        if (r === -1 && t < m.cts && (r = l - 1), m.is_idr) {\n            if (r === -1) e = l;\n            else {\n                i = l;\n                break;\n            }\n        }\n    }\n    const a = s[r];\n    if (a == null) throw Error(\"Not found video sample by time\");\n    const o = s.slice(0, i === 0 ? s.length : i).map((l)=>({\n            ...l\n        }));\n    for(let l = e; l < o.length; l++){\n        const m = o[l];\n        t < m.cts && (m.deleted = !0, m.cts = -1);\n    }\n    _e(o);\n    const c = s.slice(a.is_idr ? r : e).map((l)=>({\n            ...l,\n            cts: l.cts - t\n        }));\n    for (const l of c)l.cts < 0 && (l.deleted = !0, l.cts = -1);\n    return _e(c), [\n        o,\n        c\n    ];\n}\nfunction Gi(s, t) {\n    if (s.length === 0) return [];\n    let e = -1;\n    for(let a = 0; a < s.length; a++){\n        const o = s[a];\n        if (!(t > o.cts)) {\n            e = a;\n            break;\n        }\n    }\n    if (e === -1) throw Error(\"Not found audio sample by time\");\n    const i = s.slice(0, e).map((a)=>({\n            ...a\n        })), r = s.slice(e).map((a)=>({\n            ...a,\n            cts: a.cts - t\n        }));\n    return [\n        i,\n        r\n    ];\n}\nfunction Be(s, t, e) {\n    let i = 0;\n    if (s.state === \"configured\") {\n        for(; i < t.length; i++)s.decode(t[i]);\n        s.flush().catch((r)=>{\n            if (!(r instanceof Error)) throw r;\n            if (r.message.includes(\"Decoding error\") && e.onDecodingError != null) {\n                e.onDecodingError(r);\n                return;\n            }\n            if (!r.message.includes(\"Aborted due to close\")) throw r;\n        });\n    }\n}\nfunction Ji(s, t) {\n    if (t !== \"avc1\" && t !== \"hvc1\") return 0;\n    const e = new DataView(s.buffer);\n    let i = 0;\n    for(; i < s.byteLength - 4;){\n        if (t === \"avc1\" && (e.getUint8(i + 4) & 31) === 5) return i;\n        if (t === \"hvc1\") {\n            const r = e.getUint8(i + 4) >> 1 & 63;\n            if (r === 19 || r === 20) return i;\n        }\n        i += e.getUint32(i) + 4;\n    }\n    return -1;\n}\nasync function Yi(s, t, e, i, r, a) {\n    const o = await t.createReader(), c = await di(s.filter((u)=>!u.deleted && u.is_sync && u.cts >= r.start && u.cts <= r.end), o);\n    if (c.length === 0 || i.aborted) return;\n    let l = 0;\n    Be(m(), c, {\n        onDecodingError: (u)=>{\n            (0, _internalUtils.Log).warn(\"thumbnailsByKeyFrame\", u), l === 0 ? Be(m(!0), c, {\n                onDecodingError: (w)=>{\n                    o.close(), (0, _internalUtils.Log).error(\"thumbnailsByKeyFrame retry soft deocde\", w);\n                }\n            }) : (a(null, !0), o.close());\n        }\n    });\n    function m(u = !1) {\n        const w = {\n            ...e,\n            ...u ? {\n                hardwareAcceleration: \"prefer-software\"\n            } : {}\n        }, p = new VideoDecoder({\n            output: (x)=>{\n                l += 1;\n                const f = l === c.length;\n                a(x, f), f && (o.close(), p.state !== \"closed\" && p.close());\n            },\n            error: (x)=>{\n                const f = `thumbnails decoder error: ${x.message}, config: ${JSON.stringify(w)}, state: ${JSON.stringify({\n                    qSize: p.decodeQueueSize,\n                    state: p.state,\n                    outputCnt: l,\n                    inputCnt: c.length\n                })}`;\n                throw (0, _internalUtils.Log).error(f), Error(f);\n            }\n        });\n        return i.addEventListener(\"abort\", ()=>{\n            o.close(), p.state !== \"closed\" && p.close();\n        }), p.configure(w), p;\n    }\n}\nfunction _e(s) {\n    let t = 0, e = null;\n    for (const i of s)if (!i.deleted) {\n        if (i.is_sync && (t += 1), t >= 2) break;\n        (e == null || i.cts < e.cts) && (e = i);\n    }\n    e != null && e.cts < 2e5 && (e.duration += e.cts, e.cts = 0);\n}\nfunction ui() {\n    try {\n        const s = performance.memory;\n        return {\n            jsHeapSizeLimit: s.jsHeapSizeLimit,\n            totalJSHeapSize: s.totalJSHeapSize,\n            usedJSHeapSize: s.usedJSHeapSize,\n            percentUsed: (s.usedJSHeapSize / s.jsHeapSizeLimit).toFixed(3),\n            percentTotal: (s.totalJSHeapSize / s.jsHeapSizeLimit).toFixed(3)\n        };\n    } catch  {\n        return {};\n    }\n}\nvar E, z, I, Te, fi;\nconst gt = class gt {\n    /**\n   * 静态图片可使用流、ImageBitmap 初始化\n   *\n   * 动图需要使用 VideoFrame[] 或提供图片类型\n   */ constructor(t){\n        d(this, Te);\n        S(this, \"ready\");\n        d(this, E, {\n            // 微秒\n            duration: 0,\n            width: 0,\n            height: 0\n        });\n        d(this, z, null);\n        d(this, I, []);\n        S(this, \"tickInterceptor\", async (t, e)=>e);\n        const e = (i)=>(h(this, z, i), n(this, E).width = i.width, n(this, E).height = i.height, n(this, E).duration = 1 / 0, {\n                ...n(this, E)\n            });\n        if (t instanceof ReadableStream) this.ready = new Response(t).blob().then((i)=>createImageBitmap(i)).then(e);\n        else if (t instanceof ImageBitmap) this.ready = Promise.resolve(e(t));\n        else if (Array.isArray(t) && t.every((i)=>i instanceof VideoFrame)) {\n            h(this, I, t);\n            const i = n(this, I)[0];\n            if (i == null) throw Error(\"The frame count must be greater than 0\");\n            h(this, E, {\n                width: i.displayWidth,\n                height: i.displayHeight,\n                duration: n(this, I).reduce((r, a)=>r + (a.duration ?? 0), 0)\n            }), this.ready = Promise.resolve({\n                ...n(this, E),\n                duration: 1 / 0\n            });\n        } else if (\"type\" in t) this.ready = B(this, Te, fi).call(this, t.stream, t.type).then(()=>({\n                width: n(this, E).width,\n                height: n(this, E).height,\n                duration: 1 / 0\n            }));\n        else throw Error(\"Illegal arguments\");\n    }\n    /**\n   * ⚠️ 静态图片的 duration 为 Infinity\n   *\n   * 使用 Sprite 包装时需要将它的 duration 设置为有限数\n   *\n   */ get meta() {\n        return {\n            ...n(this, E)\n        };\n    }\n    async tick(t) {\n        if (n(this, z) != null) return await this.tickInterceptor(t, {\n            video: await createImageBitmap(n(this, z)),\n            state: \"success\"\n        });\n        const e = t % n(this, E).duration;\n        return await this.tickInterceptor(t, {\n            video: (n(this, I).find((i)=>e >= i.timestamp && e <= i.timestamp + (i.duration ?? 0)) ?? n(this, I)[0]).clone(),\n            state: \"success\"\n        });\n    }\n    async split(t) {\n        if (await this.ready, n(this, z) != null) return [\n            new gt(await createImageBitmap(n(this, z))),\n            new gt(await createImageBitmap(n(this, z)))\n        ];\n        let e = -1;\n        for(let a = 0; a < n(this, I).length; a++){\n            const o = n(this, I)[a];\n            if (!(t > o.timestamp)) {\n                e = a;\n                break;\n            }\n        }\n        if (e === -1) throw Error(\"Not found frame by time\");\n        const i = n(this, I).slice(0, e).map((a)=>new VideoFrame(a)), r = n(this, I).slice(e).map((a)=>new VideoFrame(a, {\n                timestamp: a.timestamp - t\n            }));\n        return [\n            new gt(i),\n            new gt(r)\n        ];\n    }\n    async clone() {\n        await this.ready;\n        const t = n(this, z) == null ? n(this, I).map((e)=>e.clone()) : await createImageBitmap(n(this, z));\n        return new gt(t);\n    }\n    destroy() {\n        var t;\n        (0, _internalUtils.Log).info(\"ImgClip destroy\"), (t = n(this, z)) == null || t.close(), n(this, I).forEach((e)=>e.close());\n    }\n};\nE = new WeakMap(), z = new WeakMap(), I = new WeakMap(), Te = new WeakSet(), fi = async function(t, e) {\n    h(this, I, await Bi(t, e));\n    const i = n(this, I)[0];\n    if (i == null) throw Error(\"No frame available in gif\");\n    h(this, E, {\n        duration: n(this, I).reduce((r, a)=>r + (a.duration ?? 0), 0),\n        width: i.codedWidth,\n        height: i.codedHeight\n    }), (0, _internalUtils.Log).info(\"ImgClip ready:\", n(this, E));\n};\nlet Ze = gt;\nvar kt, it, ct, J, Ae, mi, lt, Y;\nconst tt = class tt {\n    /**\n   *\n   * @param dataSource 音频文件流\n   * @param opts 音频配置，控制音量、是否循环\n   */ constructor(t, e = {}){\n        d(this, Ae);\n        S(this, \"ready\");\n        d(this, kt, {\n            // 微秒\n            duration: 0,\n            width: 0,\n            height: 0\n        });\n        d(this, it, new Float32Array());\n        d(this, ct, new Float32Array());\n        d(this, J);\n        /**\n     * 拦截 {@link AudioClip.tick} 方法返回的数据，用于对音频数据二次处理\n     * @param time 调用 tick 的时间\n     * @param tickRet tick 返回的数据\n     *\n     * @see [移除视频绿幕背景](https://webav-tech.github.io/WebAV/demo/3_2-chromakey-video)\n     */ S(this, \"tickInterceptor\", async (t, e)=>e);\n        // 微秒\n        d(this, lt, 0);\n        d(this, Y, 0);\n        h(this, J, {\n            loop: !1,\n            volume: 1,\n            ...e\n        }), this.ready = B(this, Ae, mi).call(this, t).then(()=>({\n                // audio 没有宽高，无需绘制\n                width: 0,\n                height: 0,\n                duration: e.loop ? 1 / 0 : n(this, kt).duration\n            }));\n    }\n    /**\n   * 音频元信息\n   *\n   * ⚠️ 注意，这里是转换后（标准化）的元信息，非原始音频元信息\n   */ get meta() {\n        return {\n            ...n(this, kt),\n            sampleRate: T.sampleRate,\n            chanCount: 2\n        };\n    }\n    /**\n   * 获取音频素材完整的 PCM 数据\n   */ getPCMData() {\n        return [\n            n(this, it),\n            n(this, ct)\n        ];\n    }\n    /**\n   * 返回上次与当前时刻差对应的音频 PCM 数据；\n   *\n   * 若差值超过 3s 或当前时间小于上次时间，则重置状态\n   * @example\n   * tick(0) // => []\n   * tick(1e6) // => [leftChanPCM(1s), rightChanPCM(1s)]\n   *\n   */ async tick(t) {\n        if (!n(this, J).loop && t >= n(this, kt).duration) return await this.tickInterceptor(t, {\n            audio: [],\n            state: \"done\"\n        });\n        const e = t - n(this, lt);\n        if (t < n(this, lt) || e > 3e6) return h(this, lt, t), h(this, Y, Math.ceil(n(this, lt) / 1e6 * T.sampleRate)), await this.tickInterceptor(t, {\n            audio: [\n                new Float32Array(0),\n                new Float32Array(0)\n            ],\n            state: \"success\"\n        });\n        h(this, lt, t);\n        const i = Math.ceil(e / 1e6 * T.sampleRate), r = n(this, Y) + i, a = n(this, J).loop ? [\n            De(n(this, it), n(this, Y), r),\n            De(n(this, ct), n(this, Y), r)\n        ] : [\n            n(this, it).slice(n(this, Y), r),\n            n(this, ct).slice(n(this, Y), r)\n        ];\n        return h(this, Y, r), await this.tickInterceptor(t, {\n            audio: a,\n            state: \"success\"\n        });\n    }\n    /**\n   * 按指定时间切割，返回前后两个音频素材\n   * @param time 时间，单位微秒\n   */ async split(t) {\n        await this.ready;\n        const e = Math.ceil(t / 1e6 * T.sampleRate), i = new tt(this.getPCMData().map((a)=>a.slice(0, e)), n(this, J)), r = new tt(this.getPCMData().map((a)=>a.slice(e)), n(this, J));\n        return [\n            i,\n            r\n        ];\n    }\n    async clone() {\n        await this.ready;\n        const t = new tt(this.getPCMData(), n(this, J));\n        return await t.ready, t;\n    }\n    /**\n   * 销毁实例，释放资源\n   */ destroy() {\n        h(this, it, new Float32Array(0)), h(this, ct, new Float32Array(0)), (0, _internalUtils.Log).info(\"---- audioclip destroy ----\");\n    }\n};\nkt = new WeakMap(), it = new WeakMap(), ct = new WeakMap(), J = new WeakMap(), Ae = new WeakSet(), mi = async function(t) {\n    tt.ctx == null && (tt.ctx = new AudioContext({\n        sampleRate: T.sampleRate\n    }));\n    const e = performance.now(), i = t instanceof ReadableStream ? await ji(t, tt.ctx) : t;\n    (0, _internalUtils.Log).info(\"Audio clip decoded complete:\", performance.now() - e);\n    const r = n(this, J).volume;\n    if (r !== 1) for (const a of i)for(let o = 0; o < a.length; o += 1)a[o] *= r;\n    n(this, kt).duration = i[0].length / T.sampleRate * 1e6, h(this, it, i[0]), h(this, ct, i[1] ?? n(this, it)), (0, _internalUtils.Log).info(\"Audio clip convert to AudioData, time:\", performance.now() - e);\n}, lt = new WeakMap(), Y = new WeakMap(), S(tt, \"ctx\", null);\nlet ti = tt;\nasync function ji(s, t) {\n    const e = await new Response(s).arrayBuffer();\n    return Le(await t.decodeAudioData(e));\n}\nvar It, se, Lt, Ut;\nconst ke = class ke {\n    constructor(t){\n        S(this, \"ready\");\n        d(this, It, {\n            // 微秒\n            duration: 0,\n            width: 0,\n            height: 0\n        });\n        d(this, se, ()=>{});\n        /**\n     * 实时流的音轨\n     */ S(this, \"audioTrack\");\n        d(this, Lt, null);\n        d(this, Ut);\n        h(this, Ut, t), this.audioTrack = t.getAudioTracks()[0] ?? null, n(this, It).duration = 1 / 0;\n        const e = t.getVideoTracks()[0];\n        e != null ? (e.contentHint = \"motion\", this.ready = new Promise((i)=>{\n            h(this, se, Qi(e, (r)=>{\n                n(this, It).width = r.width, n(this, It).height = r.height, h(this, Lt, r), i(this.meta);\n            }));\n        })) : this.ready = Promise.resolve(this.meta);\n    }\n    get meta() {\n        return {\n            ...n(this, It)\n        };\n    }\n    async tick() {\n        return {\n            video: n(this, Lt) == null ? null : await createImageBitmap(n(this, Lt)),\n            audio: [],\n            state: \"success\"\n        };\n    }\n    async split() {\n        return [\n            await this.clone(),\n            await this.clone()\n        ];\n    }\n    async clone() {\n        return new ke(n(this, Ut).clone());\n    }\n    destroy() {\n        n(this, Ut).getTracks().forEach((t)=>t.stop()), n(this, se).call(this);\n    }\n};\nIt = new WeakMap(), se = new WeakMap(), Lt = new WeakMap(), Ut = new WeakMap(), S(ke, \"ctx\", null);\nlet ei = ke;\nfunction Qi(s, t) {\n    let e = !1, i;\n    return (0, _internalUtils.autoReadStream)(new MediaStreamTrackProcessor({\n        track: s\n    }).readable, {\n        onChunk: async (r)=>{\n            if (!e) {\n                const { displayHeight: a, displayWidth: o } = r, c = o ?? 0, l = a ?? 0, m = new OffscreenCanvas(c, l);\n                i = m.getContext(\"2d\"), t(m), e = !0;\n            }\n            i.drawImage(r, 0, 0), r.close();\n        },\n        onDone: async ()=>{}\n    });\n}\nvar P, re, j, Q, K, O, nt, st, Ie, pi;\nconst Gt = class Gt {\n    constructor(t, e){\n        d(this, Ie);\n        S(this, \"ready\");\n        d(this, P, []);\n        d(this, re, {\n            width: 0,\n            height: 0,\n            duration: 0\n        });\n        d(this, j, {\n            color: \"#FFF\",\n            textBgColor: null,\n            type: \"srt\",\n            fontSize: 30,\n            letterSpacing: null,\n            bottomOffset: 30,\n            fontFamily: \"Noto Sans SC\",\n            strokeStyle: \"#000\",\n            lineWidth: null,\n            lineCap: null,\n            lineJoin: null,\n            textShadow: {\n                offsetX: 2,\n                offsetY: 2,\n                blur: 4,\n                color: \"#000\"\n            },\n            videoWidth: 1280,\n            videoHeight: 720\n        });\n        d(this, Q);\n        d(this, K);\n        d(this, O, null);\n        d(this, nt, 0);\n        d(this, st, 0);\n        var l;\n        if (h(this, P, Array.isArray(t) ? t : Ki(t).map(({ start: m, end: u, text: w })=>({\n                start: m * 1e6,\n                end: u * 1e6,\n                text: w\n            }))), n(this, P).length === 0) throw Error(\"No subtitles content\");\n        h(this, j, Object.assign(n(this, j), e)), h(this, st, e.textBgColor == null ? 0 : (e.fontSize ?? 50) * 0.2);\n        const { fontSize: i, fontFamily: r, videoWidth: a, videoHeight: o, letterSpacing: c } = n(this, j);\n        h(this, nt, i + n(this, st) * 2), h(this, Q, new OffscreenCanvas(a, o)), h(this, K, n(this, Q).getContext(\"2d\")), n(this, K).font = `${i}px ${r}`, n(this, K).textAlign = \"center\", n(this, K).textBaseline = \"top\", n(this, K).letterSpacing = c ?? \"0px\", h(this, re, {\n            width: a,\n            height: o,\n            duration: ((l = n(this, P).at(-1)) == null ? void 0 : l.end) ?? 0\n        }), this.ready = Promise.resolve(this.meta);\n    }\n    get meta() {\n        return {\n            ...n(this, re)\n        };\n    }\n    /**\n   * @see {@link IClip.tick}\n   */ async tick(t) {\n        var a, o;\n        if (n(this, O) != null && t >= n(this, O).timestamp && t <= n(this, O).timestamp + (n(this, O).duration ?? 0)) return {\n            video: n(this, O).clone(),\n            state: \"success\"\n        };\n        let e = 0;\n        for(; e < n(this, P).length && !(t <= n(this, P)[e].end); e += 1);\n        const i = n(this, P)[e] ?? n(this, P).at(-1);\n        if (t > i.end) return {\n            state: \"done\"\n        };\n        if (t < i.start) {\n            n(this, K).clearRect(0, 0, n(this, Q).width, n(this, Q).height);\n            const c = new VideoFrame(n(this, Q), {\n                timestamp: t,\n                // 直到下个字幕出现的时机\n                duration: i.start - t\n            });\n            return (a = n(this, O)) == null || a.close(), h(this, O, c), {\n                video: c.clone(),\n                state: \"success\"\n            };\n        }\n        B(this, Ie, pi).call(this, i.text);\n        const r = new VideoFrame(n(this, Q), {\n            timestamp: t,\n            duration: i.end - t\n        });\n        return (o = n(this, O)) == null || o.close(), h(this, O, r), {\n            video: r.clone(),\n            state: \"success\"\n        };\n    }\n    /**\n   * @see {@link IClip.split}\n   */ async split(t) {\n        await this.ready;\n        let e = -1;\n        for(let c = 0; c < n(this, P).length; c++){\n            const l = n(this, P)[c];\n            if (!(t > l.start)) {\n                e = c;\n                break;\n            }\n        }\n        if (e === -1) throw Error(\"Not found subtitle by time\");\n        const i = n(this, P).slice(0, e).map((c)=>({\n                ...c\n            }));\n        let r = i.at(-1), a = null;\n        r != null && r.end > t && (a = {\n            start: 0,\n            end: r.end - t,\n            text: r.text\n        }, r.end = t);\n        const o = n(this, P).slice(e).map((c)=>({\n                ...c,\n                start: c.start - t,\n                end: c.end - t\n            }));\n        return a != null && o.unshift(a), [\n            new Gt(i, n(this, j)),\n            new Gt(o, n(this, j))\n        ];\n    }\n    /**\n   * @see {@link IClip.clone}\n   */ async clone() {\n        return new Gt(n(this, P).slice(0), n(this, j));\n    }\n    /**\n   * @see {@link IClip.destroy}\n   */ destroy() {\n        var t;\n        (t = n(this, O)) == null || t.close();\n    }\n};\nP = new WeakMap(), re = new WeakMap(), j = new WeakMap(), Q = new WeakMap(), K = new WeakMap(), O = new WeakMap(), nt = new WeakMap(), st = new WeakMap(), Ie = new WeakSet(), pi = function(t) {\n    const e = t.split(`\n`).reverse().map((g)=>g.trim()), { width: i, height: r } = n(this, Q), { color: a, fontSize: o, textBgColor: c, textShadow: l, strokeStyle: m, lineWidth: u, lineCap: w, lineJoin: p, bottomOffset: x } = n(this, j), f = n(this, K);\n    f.clearRect(0, 0, i, r), f.globalAlpha = 0.6;\n    let y = x;\n    for (const g of e){\n        const b = f.measureText(g), C = i / 2;\n        c != null && (f.shadowOffsetX = 0, f.shadowOffsetY = 0, f.shadowBlur = 0, f.fillStyle = c, f.globalAlpha = 0.5, f.fillRect(C - b.actualBoundingBoxLeft - n(this, st), r - y - n(this, nt), b.width + n(this, st) * 2, n(this, nt))), f.shadowColor = l.color, f.shadowOffsetX = l.offsetX, f.shadowOffsetY = l.offsetY, f.shadowBlur = l.blur, f.globalAlpha = 1, m != null && (f.lineWidth = u ?? o / 6, w != null && (f.lineCap = w), p != null && (f.lineJoin = p), f.strokeStyle = m, f.strokeText(g, C, r - y - n(this, nt) + n(this, st))), f.fillStyle = a, f.fillText(g, C, r - y - n(this, nt) + n(this, st)), y += n(this, nt) + o * 0.2;\n    }\n};\nlet ii = Gt;\nfunction ni(s) {\n    const t = s.match(/(\\d{2}):(\\d{2}):(\\d{2}),(\\d{3})/);\n    if (t == null) throw Error(`time format error: ${s}`);\n    const e = Number(t[1]), i = Number(t[2]), r = Number(t[3]), a = Number(t[4]);\n    return e * 3600 + i * 60 + r + a / 1e3;\n}\nfunction Ki(s) {\n    return s.split(/\\r|\\n/).map((t)=>t.trim()).filter((t)=>t.length > 0).map((t)=>({\n            lineStr: t,\n            match: t.match(/(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})/)\n        })).filter(({ lineStr: t }, e, i)=>{\n        var r;\n        return !(/^\\d+$/.test(t) && ((r = i[e + 1]) == null ? void 0 : r.match) != null);\n    }).reduce((t, { lineStr: e, match: i })=>{\n        if (i == null) {\n            const r = t.at(-1);\n            if (r == null) return t;\n            r.text += r.text.length === 0 ? e : `\n${e}`;\n        } else t.push({\n            start: ni(i[1]),\n            end: ni(i[2]),\n            text: \"\"\n        });\n        return t;\n    }, []);\n}\nvar ae;\nclass wi {\n    constructor(){\n        S(this, \"readable\");\n        S(this, \"writable\");\n        d(this, ae, 0);\n        const t = (0, _mp4BoxJsDefault.default).createFile();\n        let e = !1;\n        this.readable = new ReadableStream({\n            start: (i)=>{\n                t.onReady = (a)=>{\n                    var l, m;\n                    const o = (l = a.videoTracks[0]) == null ? void 0 : l.id;\n                    o != null && t.setExtractionOptions(o, \"video\", {\n                        nbSamples: 100\n                    });\n                    const c = (m = a.audioTracks[0]) == null ? void 0 : m.id;\n                    c != null && t.setExtractionOptions(c, \"audio\", {\n                        nbSamples: 100\n                    }), i.enqueue({\n                        chunkType: \"ready\",\n                        data: {\n                            info: a,\n                            file: t\n                        }\n                    }), t.start();\n                };\n                const r = {};\n                t.onSamples = (a, o, c)=>{\n                    i.enqueue({\n                        chunkType: \"samples\",\n                        data: {\n                            id: a,\n                            type: o,\n                            samples: c.map((l)=>({\n                                    ...l\n                                }))\n                        }\n                    }), r[a] = (r[a] ?? 0) + c.length, t.releaseUsedSamples(a, r[a]);\n                }, t.onFlush = ()=>{\n                    i.close();\n                };\n            },\n            cancel: ()=>{\n                t.stop(), e = !0;\n            }\n        }, {\n            // 每条消息 100 个 samples\n            highWaterMark: 50\n        }), this.writable = new WritableStream({\n            write: async (i)=>{\n                if (e) {\n                    this.writable.abort();\n                    return;\n                }\n                const r = i.buffer;\n                r.fileStart = n(this, ae), h(this, ae, n(this, ae) + r.byteLength), t.appendBuffer(r);\n            },\n            close: ()=>{\n                var i;\n                t.flush(), t.stop(), (i = t.onFlush) == null || i.call(t);\n            }\n        });\n    }\n}\nae = new WeakMap();\nfunction qi(s) {\n    let t = 0;\n    const e = s.boxes, i = [];\n    let r = 0;\n    async function a() {\n        const f = x(e, t);\n        t = e.length, i.forEach(({ track: y, id: g })=>{\n            const b = y.samples.at(-1);\n            b != null && (r = Math.max(r, b.cts + b.duration)), s.releaseUsedSamples(g, y.samples.length), y.samples = [];\n        }), s.mdats = [], s.moofs = [], f != null && await (u == null ? void 0 : u.write(f));\n    }\n    let o = [];\n    function c() {\n        if (o.length > 0) return !0;\n        const f = e.findIndex((y)=>y.type === \"moov\");\n        if (f === -1) return !1;\n        if (o = e.slice(0, f + 1), t = f + 1, i.length === 0) for(let y = 1;; y += 1){\n            const g = s.getTrackById(y);\n            if (g == null) break;\n            i.push({\n                track: g,\n                id: y\n            });\n        }\n        return !0;\n    }\n    let l = 0;\n    const m = (0, _opfsTools.tmpfile)();\n    let u = null;\n    const w = (async ()=>{\n        u = await m.createWriter(), l = self.setInterval(()=>{\n            c() && a();\n        }, 100);\n    })();\n    let p = !1;\n    return async ()=>{\n        if (p) throw Error(\"File exported\");\n        if (p = !0, await w, clearInterval(l), !c() || u == null) return null;\n        s.flush(), await a(), await (u == null ? void 0 : u.close());\n        const f = o.find((b)=>b.type === \"moov\");\n        if (f == null) return null;\n        f.mvhd.duration = r;\n        const y = (0, _opfsTools.tmpfile)(), g = x(o, 0);\n        return await (0, _opfsTools.write)(y, g), await (0, _opfsTools.write)(y, m, {\n            overwrite: !1\n        }), await y.stream();\n    };\n    function x(f, y) {\n        if (y >= f.length) return null;\n        const g = new (0, _mp4BoxJsDefault.default).DataStream();\n        g.endianness = (0, _mp4BoxJsDefault.default).DataStream.BIG_ENDIAN;\n        for(let b = y; b < f.length; b++)f[b] !== null && (f[b].write(g), delete f[b]);\n        return new Uint8Array(g.buffer);\n    }\n}\nfunction Zi(s) {\n    const t = new ArrayBuffer(s.byteLength);\n    s.copyTo(t);\n    const e = s.timestamp;\n    return {\n        duration: s.duration ?? 0,\n        dts: e,\n        cts: e,\n        is_sync: s.type === \"key\",\n        data: t\n    };\n}\nasync function tn(s) {\n    const t = (0, _mp4BoxJsDefault.default).createFile(), e = qi(t);\n    await en(s, t);\n    const i = await e();\n    if (i == null) throw Error(\"Can not generate file from streams\");\n    return i;\n}\nasync function en(s, t) {\n    let e = 0, i = 0, r = 0, a = 0, o = 0, c = 0, l = null, m = null;\n    for (const u of s)await new Promise(async (w)=>{\n        (0, _internalUtils.autoReadStream)(u.pipeThrough(new wi()), {\n            onDone: w,\n            onChunk: async ({ chunkType: p, data: x })=>{\n                if (p === \"ready\") {\n                    const { videoTrackConf: f, audioTrackConf: y } = Ne(x.file, x.info);\n                    e === 0 && f != null && (e = t.addTrack(f)), a === 0 && y != null && (a = t.addTrack(y));\n                } else if (p === \"samples\") {\n                    const { type: f, samples: y } = x, g = f === \"video\" ? e : a, b = f === \"video\" ? i : o, C = f === \"video\" ? r : c;\n                    y.forEach((k)=>{\n                        t.addSample(g, k.data, {\n                            duration: k.duration,\n                            dts: k.dts + b,\n                            cts: k.cts + C,\n                            is_sync: k.is_sync\n                        });\n                    });\n                    const v = y.at(-1);\n                    if (v == null) return;\n                    f === \"video\" ? l = v : f === \"audio\" && (m = v);\n                }\n            }\n        });\n    }), l != null && (i += l.dts, r += l.cts), m != null && (o += m.dts, c += m.cts);\n}\nasync function In(s) {\n    return await tn([\n        s\n    ]);\n}\nfunction nn(s) {\n    let t = [];\n    const e = new AudioDecoder({\n        output: (i)=>{\n            t.push(i);\n        },\n        error: (0, _internalUtils.Log).error\n    });\n    return e.configure(s), {\n        decode: async (i)=>{\n            i.forEach((a)=>{\n                e.decode(new EncodedAudioChunk({\n                    type: a.is_sync ? \"key\" : \"delta\",\n                    timestamp: 1e6 * a.cts / a.timescale,\n                    duration: 1e6 * a.duration / a.timescale,\n                    data: a.data\n                }));\n            }), await e.flush();\n            const r = t;\n            return t = [], r;\n        },\n        close: ()=>{\n            e.close();\n        }\n    };\n}\nfunction sn(s, t) {\n    const e = {\n        codec: s.codec,\n        sampleRate: s.sampleRate,\n        numberOfChannels: s.numberOfChannels\n    }, i = new AudioEncoder({\n        output: (o)=>{\n            t(Zi(o));\n        },\n        error: (o)=>{\n            (0, _internalUtils.Log).error(\"AudioEncoder error:\", o, \", config:\", e);\n        }\n    });\n    i.configure(e);\n    let r = null;\n    function a(o, c) {\n        return new AudioData({\n            timestamp: c,\n            numberOfChannels: s.numberOfChannels,\n            numberOfFrames: o.length / s.numberOfChannels,\n            sampleRate: s.sampleRate,\n            format: \"f32-planar\",\n            data: o\n        });\n    }\n    return {\n        encode: async (o, c)=>{\n            r != null && i.encode(a(r.data, r.ts)), r = {\n                data: o,\n                ts: c\n            };\n        },\n        stop: async ()=>{\n            r != null && (rn(r.data, s.numberOfChannels, s.sampleRate), i.encode(a(r.data, r.ts)), r = null), await i.flush(), i.close();\n        }\n    };\n}\nfunction rn(s, t, e) {\n    const i = s.length - 1, r = Math.min(e / 2, i);\n    for(let a = 0; a < r; a++)for(let o = 1; o <= t; o++)s[Math.floor(i / o) - a] *= a / r;\n}\nfunction Fn(s, t) {\n    (0, _internalUtils.Log).info(\"mixinMP4AndAudio, opts:\", {\n        volume: t.volume,\n        loop: t.loop\n    });\n    const e = (0, _mp4BoxJsDefault.default).createFile(), { stream: i, stop: r } = (0, _internalUtils.file2stream)(e, 500);\n    let a = null, o = null, c = [], l = 0, m = 0, u = 0, w = !0, p = T.sampleRate;\n    (0, _internalUtils.autoReadStream)(s.pipeThrough(new wi()), {\n        onDone: async ()=>{\n            await (o == null ? void 0 : o.stop()), a == null || a.close(), r();\n        },\n        onChunk: async ({ chunkType: g, data: b })=>{\n            if (g === \"ready\") {\n                const { videoTrackConf: C, audioTrackConf: v, audioDecoderConf: k } = Ne(b.file, b.info);\n                l === 0 && C != null && (l = e.addTrack(C));\n                const H = v ?? {\n                    timescale: 1e6,\n                    samplerate: p,\n                    channel_count: T.channelCount,\n                    hdlr: \"soun\",\n                    name: \"SoundHandler\",\n                    type: \"mp4a\"\n                };\n                m === 0 && (m = e.addTrack(H), p = (v == null ? void 0 : v.samplerate) ?? p, w = v != null);\n                const Ci = new AudioContext({\n                    sampleRate: p\n                });\n                c = Le(await Ci.decodeAudioData(await new Response(t.stream).arrayBuffer())), k != null && (a = nn(k)), o = sn(k ?? {\n                    codec: H.type === \"mp4a\" ? T.codec : H.type,\n                    numberOfChannels: H.channel_count,\n                    sampleRate: H.samplerate\n                }, (Ge)=>e.addSample(m, Ge.data, Ge));\n            } else if (g === \"samples\") {\n                const { id: C, type: v, samples: k } = b;\n                if (v === \"video\") {\n                    k.forEach((H)=>e.addSample(C, H.data, H)), w || await f(k);\n                    return;\n                }\n                v === \"audio\" && await y(k);\n            }\n        }\n    });\n    function x(g) {\n        const b = c.map((C)=>t.loop ? De(C, u, u + g) : C.slice(u, u + g));\n        if (u += g, t.volume !== 1) for (const C of b)for(let v = 0; v < C.length; v++)C[v] *= t.volume;\n        return b;\n    }\n    async function f(g) {\n        const b = g[0], C = g[g.length - 1], v = Math.floor((C.cts + C.duration - b.cts) / C.timescale * p), k = Ye([\n            x(v)\n        ]);\n        k.length !== 0 && (o == null || o.encode(k, b.cts / b.timescale * 1e6));\n    }\n    async function y(g) {\n        if (a == null) return;\n        const b = (await a.decode(g)).map(ci), C = Ei(b), v = x(C[0].length), k = g[0];\n        o == null || o.encode(// 2. 混合输入的音频\n        Ye([\n            C,\n            v\n        ]), k.cts / k.timescale * 1e6);\n    }\n    return i;\n}\nconst an = `#version 300 es\n  layout (location = 0) in vec4 a_position;\n  layout (location = 1) in vec2 a_texCoord;\n  out vec2 v_texCoord;\n  void main () {\n    gl_Position = a_position;\n    v_texCoord = a_texCoord;\n  }\n`, on = `#version 300 es\nprecision mediump float;\nout vec4 FragColor;\nin vec2 v_texCoord;\n\nuniform sampler2D frameTexture;\nuniform vec3 keyColor;\n\n// \\u{8272}\\u{5EA6}\\u{7684}\\u{76F8}\\u{4F3C}\\u{5EA6}\\u{8BA1}\\u{7B97}\nuniform float similarity;\n// \\u{900F}\\u{660E}\\u{5EA6}\\u{7684}\\u{5E73}\\u{6ED1}\\u{5EA6}\\u{8BA1}\\u{7B97}\nuniform float smoothness;\n// \\u{964D}\\u{4F4E}\\u{7EFF}\\u{5E55}\\u{9971}\\u{548C}\\u{5EA6}\\u{FF0C}\\u{63D0}\\u{9AD8}\\u{62A0}\\u{56FE}\\u{51C6}\\u{786E}\\u{5EA6}\nuniform float spill;\n\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\n\nvoid main() {\n  // \\u{83B7}\\u{53D6}\\u{5F53}\\u{524D}\\u{50CF}\\u{7D20}\\u{7684}rgba\\u{503C}\n  vec4 rgba = texture(frameTexture, v_texCoord);\n  // \\u{8BA1}\\u{7B97}\\u{5F53}\\u{524D}\\u{50CF}\\u{7D20}\\u{4E0E}\\u{7EFF}\\u{5E55}\\u{50CF}\\u{7D20}\\u{7684}\\u{8272}\\u{5EA6}\\u{5DEE}\\u{503C}\n  vec2 chromaVec = RGBtoUV(rgba.rgb) - RGBtoUV(keyColor);\n  // \\u{8BA1}\\u{7B97}\\u{5F53}\\u{524D}\\u{50CF}\\u{7D20}\\u{4E0E}\\u{7EFF}\\u{5E55}\\u{50CF}\\u{7D20}\\u{7684}\\u{8272}\\u{5EA6}\\u{8DDD}\\u{79BB}\\u{FF08}\\u{5411}\\u{91CF}\\u{957F}\\u{5EA6}\\u{FF09}, \\u{8D8A}\\u{76F8}\\u{50CF}\\u{5219}\\u{8272}\\u{5EA6}\\u{8DDD}\\u{79BB}\\u{8D8A}\\u{5C0F}\n  float chromaDist = sqrt(dot(chromaVec, chromaVec));\n  // \\u{8BBE}\\u{7F6E}\\u{4E86}\\u{4E00}\\u{4E2A}\\u{76F8}\\u{4F3C}\\u{5EA6}\\u{9608}\\u{503C}\\u{FF0C}baseMask\\u{4E3A}\\u{8D1F}\\u{FF0C}\\u{5219}\\u{8868}\\u{660E}\\u{662F}\\u{7EFF}\\u{5E55}\\u{FF0C}\\u{4E3A}\\u{6B63}\\u{5219}\\u{8868}\\u{660E}\\u{4E0D}\\u{662F}\\u{7EFF}\\u{5E55}\n  float baseMask = chromaDist - similarity;\n  // \\u{5982}\\u{679C}baseMask\\u{4E3A}\\u{8D1F}\\u{6570}\\u{FF0C}fullMask\\u{7B49}\\u{4E8E}0\\u{FF1B}baseMask\\u{4E3A}\\u{6B63}\\u{6570}\\u{FF0C}\\u{8D8A}\\u{5927}\\u{FF0C}\\u{5219}\\u{900F}\\u{660E}\\u{5EA6}\\u{8D8A}\\u{4F4E}\n  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);\n  rgba.a = fullMask; // \\u{8BBE}\\u{7F6E}\\u{900F}\\u{660E}\\u{5EA6}\n  // \\u{5982}\\u{679C}baseMask\\u{4E3A}\\u{8D1F}\\u{6570}\\u{FF0C}spillVal\\u{7B49}\\u{4E8E}0\\u{FF1B}baseMask\\u{4E3A}\\u{6574}\\u{6570}\\u{FF0C}\\u{8D8A}\\u{5C0F}\\u{FF0C}\\u{9971}\\u{548C}\\u{5EA6}\\u{8D8A}\\u{4F4E}\n  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);\n  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.); // \\u{8BA1}\\u{7B97}\\u{5F53}\\u{524D}\\u{50CF}\\u{7D20}\\u{7684}\\u{7070}\\u{5EA6}\\u{503C}\n  rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);\n  FragColor = rgba;\n}\n`, cn = [\n    -1,\n    1,\n    -1,\n    -1,\n    1,\n    -1,\n    1,\n    -1,\n    1,\n    1,\n    -1,\n    1\n], ln = [\n    0,\n    1,\n    0,\n    0,\n    1,\n    0,\n    1,\n    0,\n    1,\n    1,\n    0,\n    1\n];\nfunction hn(s, t, e) {\n    const i = si(s, s.VERTEX_SHADER, t), r = si(s, s.FRAGMENT_SHADER, e), a = s.createProgram();\n    if (s.attachShader(a, i), s.attachShader(a, r), s.linkProgram(a), !s.getProgramParameter(a, s.LINK_STATUS)) throw Error(s.getProgramInfoLog(a) ?? \"Unable to initialize the shader program\");\n    return a;\n}\nfunction si(s, t, e) {\n    const i = s.createShader(t);\n    if (s.shaderSource(i, e), s.compileShader(i), !s.getShaderParameter(i, s.COMPILE_STATUS)) {\n        const r = s.getShaderInfoLog(i);\n        throw s.deleteShader(i), Error(r ?? \"An error occurred compiling the shaders\");\n    }\n    return i;\n}\nfunction dn(s, t, e) {\n    s.bindTexture(s.TEXTURE_2D, e), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, t), s.drawArrays(s.TRIANGLES, 0, 6);\n}\nfunction un(s) {\n    const t = s.createTexture();\n    if (t == null) throw Error(\"Create WebGL texture error\");\n    s.bindTexture(s.TEXTURE_2D, t);\n    const e = 0, i = s.RGBA, r = 1, a = 1, o = 0, c = s.RGBA, l = s.UNSIGNED_BYTE, m = new Uint8Array([\n        0,\n        0,\n        255,\n        255\n    ]);\n    return s.texImage2D(s.TEXTURE_2D, e, i, r, a, o, c, l, m), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), t;\n}\nfunction fn(s) {\n    const t = \"document\" in globalThis ? globalThis.document.createElement(\"canvas\") : new OffscreenCanvas(s.width, s.height);\n    t.width = s.width, t.height = s.height;\n    const e = t.getContext(\"webgl2\", {\n        premultipliedAlpha: !1,\n        alpha: !0\n    });\n    if (e == null) throw Error(\"Cant create gl context\");\n    const i = hn(e, an, on);\n    e.useProgram(i), e.uniform3fv(e.getUniformLocation(i, \"keyColor\"), s.keyColor.map((l)=>l / 255)), e.uniform1f(e.getUniformLocation(i, \"similarity\"), s.similarity), e.uniform1f(e.getUniformLocation(i, \"smoothness\"), s.smoothness), e.uniform1f(e.getUniformLocation(i, \"spill\"), s.spill);\n    const r = e.createBuffer();\n    e.bindBuffer(e.ARRAY_BUFFER, r), e.bufferData(e.ARRAY_BUFFER, new Float32Array(cn), e.STATIC_DRAW);\n    const a = e.getAttribLocation(i, \"a_position\");\n    e.vertexAttribPointer(a, 2, e.FLOAT, !1, Float32Array.BYTES_PER_ELEMENT * 2, 0), e.enableVertexAttribArray(a);\n    const o = e.createBuffer();\n    e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(e.ARRAY_BUFFER, new Float32Array(ln), e.STATIC_DRAW);\n    const c = e.getAttribLocation(i, \"a_texCoord\");\n    return e.vertexAttribPointer(c, 2, e.FLOAT, !1, Float32Array.BYTES_PER_ELEMENT * 2, 0), e.enableVertexAttribArray(c), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, 1), {\n        cvs: t,\n        gl: e\n    };\n}\nfunction mn(s) {\n    return s instanceof VideoFrame ? {\n        width: s.codedWidth,\n        height: s.codedHeight\n    } : {\n        width: s.width,\n        height: s.height\n    };\n}\nfunction pn(s) {\n    const e = new OffscreenCanvas(1, 1).getContext(\"2d\");\n    e.drawImage(s, 0, 0);\n    const { data: [i, r, a] } = e.getImageData(0, 0, 1, 1);\n    return [\n        i,\n        r,\n        a\n    ];\n}\nconst Rn = (s)=>{\n    let t = null, e = null, i = s.keyColor, r = null;\n    return async (a)=>{\n        if ((t == null || e == null || r == null) && (i == null && (i = pn(a)), { cvs: t, gl: e } = fn({\n            ...mn(a),\n            keyColor: i,\n            ...s\n        }), r = un(e)), dn(e, a, r), globalThis.VideoFrame != null && a instanceof globalThis.VideoFrame) {\n            const o = new VideoFrame(t, {\n                alpha: \"keep\",\n                timestamp: a.timestamp,\n                duration: a.duration ?? void 0\n            });\n            return a.close(), o;\n        }\n        return createImageBitmap(t, {\n            imageOrientation: a instanceof ImageBitmap ? \"flipY\" : \"none\"\n        });\n    };\n};\nvar oe, ce, le, he, de, ue, ht, Bt, dt;\nconst $e = class $e {\n    constructor(t, e, i, r, a){\n        d(this, ht);\n        d(this, oe, new (0, _internalUtils.EventTool)());\n        /**\n     * 监听属性变更事件\n     * @example\n     * rect.on('propsChange', (changedProps) => {})\n     */ S(this, \"on\", n(this, oe).on);\n        d(this, ce, 0);\n        d(this, le, 0);\n        d(this, he, 0);\n        d(this, de, 0);\n        d(this, ue, 0);\n        /**\n     * 如果当前实例是 Rect 控制点之一，`master` 将指向该 Rect\n     *\n     * 控制点的坐标是相对于它的 `master` 定位\n     */ d(this, dt, null);\n        /**\n     * 是否保持固定宽高比例，禁止变形缩放\n     *\n     * 值为 true 时，将缺少上下左右四个控制点\n     */ S(this, \"fixedAspectRatio\", !1);\n        /**\n     * 是否固定中心点进行缩放\n     * 值为 true 时，固定中心点不变进行缩放\n     * 值为 false 时，固定对角点不变进行缩放\n     */ S(this, \"fixedScaleCenter\", !1);\n        this.x = t ?? 0, this.y = e ?? 0, this.w = i ?? 0, this.h = r ?? 0, h(this, dt, a ?? null);\n    }\n    /**\n   * x 坐标\n   */ get x() {\n        return n(this, ce);\n    }\n    set x(t) {\n        B(this, ht, Bt).call(this, \"x\", t);\n    }\n    get y() {\n        return n(this, le);\n    }\n    /**\n   * y 坐标\n   */ set y(t) {\n        B(this, ht, Bt).call(this, \"y\", t);\n    }\n    /**\n   * 宽\n   */ get w() {\n        return n(this, he);\n    }\n    set w(t) {\n        B(this, ht, Bt).call(this, \"w\", t);\n    }\n    /**\n   * 高\n   */ get h() {\n        return n(this, de);\n    }\n    set h(t) {\n        B(this, ht, Bt).call(this, \"h\", t);\n    }\n    /**\n   * 旋转角度\n   * @see [MDN Canvas rotate](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/rotate)\n   */ get angle() {\n        return n(this, ue);\n    }\n    set angle(t) {\n        B(this, ht, Bt).call(this, \"angle\", t);\n    }\n    /**\n   * 根据坐标、宽高计算出来的矩形中心点\n   */ get center() {\n        const { x: t, y: e, w: i, h: r } = this;\n        return {\n            x: t + i / 2,\n            y: e + r / 2\n        };\n    }\n    clone() {\n        const { x: t, y: e, w: i, h: r } = this, a = new $e(t, e, i, r, n(this, dt));\n        return a.angle = this.angle, a.fixedAspectRatio = this.fixedAspectRatio, a.fixedScaleCenter = this.fixedScaleCenter, a;\n    }\n    /**\n   * 检测目标坐标是否命中当前实例\n   * @param tx 目标点 x 坐标\n   * @param ty 目标点 y 坐标\n   */ checkHit(t, e) {\n        var y, g;\n        let { angle: i, center: r, x: a, y: o, w: c, h: l } = this;\n        const m = ((y = n(this, dt)) == null ? void 0 : y.center) ?? r, u = ((g = n(this, dt)) == null ? void 0 : g.angle) ?? i;\n        n(this, dt) == null && (a = a - m.x, o = o - m.y);\n        const w = t - m.x, p = e - m.y;\n        let x = w, f = p;\n        return u !== 0 && (x = w * Math.cos(u) + p * Math.sin(u), f = p * Math.cos(u) - w * Math.sin(u)), !(x < a || x > a + c || f < o || f > o + l);\n    }\n};\noe = new WeakMap(), ce = new WeakMap(), le = new WeakMap(), he = new WeakMap(), de = new WeakMap(), ue = new WeakMap(), ht = new WeakSet(), Bt = function(t, e) {\n    const i = this[t] !== e;\n    switch(t){\n        case \"x\":\n            h(this, ce, e);\n            break;\n        case \"y\":\n            h(this, le, e);\n            break;\n        case \"w\":\n            h(this, he, e);\n            break;\n        case \"h\":\n            h(this, de, e);\n            break;\n        case \"angle\":\n            h(this, ue, e);\n            break;\n    }\n    i && n(this, oe).emit(\"propsChange\", {\n        [t]: e\n    });\n}, dt = new WeakMap();\nlet Oe = $e;\nvar fe, Ft, Nt, ut, q;\nclass yi {\n    constructor(){\n        /**\n     * 控制素材在视频中的空间属性（坐标、旋转、缩放）\n     */ S(this, \"rect\", new Oe());\n        /**\n     * 控制素材在的时间偏移、时长、播放速率，常用于剪辑场景时间轴（轨道）模块\n     * duration 不能大于引用 {@link IClip} 的时长，单位 微秒\n     *\n     * playbackRate 控制当前素材的播放速率，1 表示正常播放；\n     * **注意**\n     *    1. 设置 playbackRate 时需要主动修正 duration\n     *    2. 音频使用最简单的插值算法来改变速率，所以改变速率后音调会产生变化，自定义算法请使用 {@link MP4Clip.tickInterceptor} 配合实现\n     *\n     */ d(this, fe, {\n            offset: 0,\n            duration: 0,\n            playbackRate: 1\n        });\n        d(this, Ft, new (0, _internalUtils.EventTool)());\n        /**\n     * 监听属性变更事件\n     * @example\n     * sprite.on('propsChange', (changedProps) => {})\n     */ S(this, \"on\", n(this, Ft).on);\n        d(this, Nt, 0);\n        /**\n     * 不透明度\n     */ S(this, \"opacity\", 1);\n        /**\n     * 水平或垂直方向翻转素材\n     */ S(this, \"flip\", null);\n        d(this, ut, null);\n        d(this, q, null);\n        /**\n     * @see {@link IClip.ready}\n     */ S(this, \"ready\", Promise.resolve());\n        this.rect.on(\"propsChange\", (t)=>{\n            n(this, Ft).emit(\"propsChange\", {\n                rect: t\n            });\n        });\n    }\n    get time() {\n        return n(this, fe);\n    }\n    set time(t) {\n        Object.assign(n(this, fe), t);\n    }\n    get zIndex() {\n        return n(this, Nt);\n    }\n    /**\n   * 控制素材间的层级关系，zIndex 值较小的素材会被遮挡\n   */ set zIndex(t) {\n        const e = n(this, Nt) !== t;\n        h(this, Nt, t), e && n(this, Ft).emit(\"propsChange\", {\n            zIndex: t\n        });\n    }\n    _render(t) {\n        const { rect: { center: e, angle: i } } = this;\n        t.setTransform(// 水平 缩放、倾斜\n        this.flip === \"horizontal\" ? -1 : 1, 0, // 垂直 倾斜、缩放\n        0, this.flip === \"vertical\" ? -1 : 1, // 坐标原点偏移 x y\n        e.x, e.y), t.rotate((this.flip == null ? 1 : -1) * i), t.globalAlpha = this.opacity;\n    }\n    /**\n   * 给素材添加动画，使用方法参考 css animation\n   *\n   * @example\n   * sprite.setAnimation(\n   *   {\n   *     '0%': { x: 0, y: 0 },\n   *     '25%': { x: 1200, y: 680 },\n   *     '50%': { x: 1200, y: 0 },\n   *     '75%': { x: 0, y: 680 },\n   *     '100%': { x: 0, y: 0 },\n   *   },\n   *   { duration: 4e6, iterCount: 1 },\n   * );\n   *\n   * @see [视频水印动画](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n   */ setAnimation(t, e) {\n        h(this, ut, Object.entries(t).map(([i, r])=>{\n            const a = {\n                from: 0,\n                to: 100\n            }[i] ?? Number(i.slice(0, -1));\n            if (isNaN(a) || a > 100 || a < 0) throw Error(\"keyFrame must between 0~100\");\n            return [\n                a / 100,\n                r\n            ];\n        })), h(this, q, Object.assign({}, n(this, q), {\n            duration: e.duration,\n            delay: e.delay ?? 0,\n            iterCount: e.iterCount ?? 1 / 0\n        }));\n    }\n    /**\n   * 如果当前 sprite 已被设置动画，将 sprite 的动画属性设定到指定时间的状态\n   */ animate(t) {\n        if (n(this, ut) == null || n(this, q) == null || t < n(this, q).delay) return;\n        const e = wn(t, n(this, ut), n(this, q));\n        for(const i in e)switch(i){\n            case \"opacity\":\n                this.opacity = e[i];\n                break;\n            case \"x\":\n            case \"y\":\n            case \"w\":\n            case \"h\":\n            case \"angle\":\n                this.rect[i] = e[i];\n                break;\n        }\n    }\n    /**\n   * 将当前 sprite 的属性赋值到目标\n   *\n   * 用于 clone，或 {@link VisibleSprite} 与 {@link OffscreenSprite} 实例间的类型转换\n   */ copyStateTo(t) {\n        h(t, ut, n(this, ut)), h(t, q, n(this, q)), t.zIndex = this.zIndex, t.opacity = this.opacity, t.flip = this.flip, t.rect = this.rect.clone(), t.time = {\n            ...this.time\n        };\n    }\n    destroy() {\n        n(this, Ft).destroy();\n    }\n}\nfe = new WeakMap(), Ft = new WeakMap(), Nt = new WeakMap(), ut = new WeakMap(), q = new WeakMap();\nfunction wn(s, t, e) {\n    const i = s - e.delay;\n    if (i / e.duration >= e.iterCount) return {};\n    const r = i % e.duration, a = i === e.duration ? 1 : r / e.duration, o = t.findIndex((x)=>x[0] >= a);\n    if (o === -1) return {};\n    const c = t[o - 1], l = t[o], m = l[1];\n    if (c == null) return m;\n    const u = c[1], w = {}, p = (a - c[0]) / (l[0] - c[0]);\n    for(const x in m){\n        const f = x;\n        u[f] != null && (w[f] = (m[f] - u[f]) * p + u[f]);\n    }\n    return w;\n}\nvar Rt, ft, me;\nconst We = class We extends yi {\n    constructor(e){\n        super();\n        d(this, Rt);\n        // 保持最近一帧，若 clip 在当前帧无数据，则绘制最近一帧\n        d(this, ft, null);\n        d(this, me, !1);\n        h(this, Rt, e), this.ready = e.ready.then(({ width: i, height: r, duration: a })=>{\n            this.rect.w = this.rect.w === 0 ? i : this.rect.w, this.rect.h = this.rect.h === 0 ? r : this.rect.h, this.time.duration = this.time.duration === 0 ? a : this.time.duration;\n        });\n    }\n    /**\n   * 绘制素材指定时刻的图像到 canvas 上下文，并返回对应的音频数据\n   * @param time 指定时刻，微秒\n   */ async offscreenRender(e, i) {\n        var p;\n        const r = i * this.time.playbackRate;\n        this.animate(r), super._render(e);\n        const { w: a, h: o } = this.rect, { video: c, audio: l, state: m } = await n(this, Rt).tick(r);\n        let u = l ?? [];\n        if (l != null && this.time.playbackRate !== 1 && (u = l.map((x)=>li(x, this.time.playbackRate))), m === \"done\") return {\n            audio: u,\n            done: !0\n        };\n        const w = c ?? n(this, ft);\n        return w != null && e.drawImage(w, -a / 2, -o / 2, a, o), c != null && ((p = n(this, ft)) == null || p.close(), h(this, ft, c)), {\n            audio: u,\n            done: !1\n        };\n    }\n    async clone() {\n        const e = new We(await n(this, Rt).clone());\n        return await e.ready, this.copyStateTo(e), e;\n    }\n    destroy() {\n        var e;\n        n(this, me) || (h(this, me, !0), (0, _internalUtils.Log).info(\"OffscreenSprite destroy\"), super.destroy(), (e = n(this, ft)) == null || e.close(), h(this, ft, null), n(this, Rt).destroy());\n    }\n};\nRt = new WeakMap(), ft = new WeakMap(), me = new WeakMap();\nlet ri = We;\nvar Et, mt, Pt, Ht, pe, Me, we, ye;\nconst Xe = class Xe extends yi {\n    constructor(e){\n        super();\n        d(this, pe);\n        d(this, Et);\n        /**\n     * 元素是否可见，用于不想删除，期望临时隐藏 Sprite 的场景\n     */ S(this, \"visible\", !0);\n        // 保持最近一帧，若 clip 在当前帧无数据，则绘制最近一帧\n        d(this, mt, null);\n        d(this, Pt, []);\n        d(this, Ht, !1);\n        d(this, we, -1);\n        d(this, ye, !1);\n        h(this, Et, e), this.ready = e.ready.then(({ width: i, height: r, duration: a })=>{\n            this.rect.w = this.rect.w === 0 ? i : this.rect.w, this.rect.h = this.rect.h === 0 ? r : this.rect.h, this.time.duration = this.time.duration === 0 ? a : this.time.duration;\n        });\n    }\n    getClip() {\n        return n(this, Et);\n    }\n    /**\n   * 提前准备指定 time 的帧\n   */ preFrame(e) {\n        B(this, pe, Me).call(this, e);\n    }\n    /**\n   * 绘制素材指定时刻的图像到 canvas 上下文，并返回对应的音频数据\n   * @param time 指定时刻，微秒\n   */ render(e, i) {\n        this.animate(i), super._render(e);\n        const { w: r, h: a } = this.rect;\n        n(this, we) !== i && B(this, pe, Me).call(this, i), h(this, we, i);\n        const o = n(this, Pt);\n        h(this, Pt, []);\n        const c = n(this, mt);\n        return c != null && e.drawImage(c, -r / 2, -a / 2, r, a), {\n            audio: o\n        };\n    }\n    copyStateTo(e) {\n        super.copyStateTo(e), e instanceof Xe && (e.visible = this.visible);\n    }\n    destroy() {\n        var e;\n        n(this, ye) || (h(this, ye, !0), (0, _internalUtils.Log).info(\"VisibleSprite destroy\"), super.destroy(), (e = n(this, mt)) == null || e.close(), h(this, mt, null), n(this, Et).destroy());\n    }\n};\nEt = new WeakMap(), mt = new WeakMap(), Pt = new WeakMap(), Ht = new WeakMap(), pe = new WeakSet(), Me = function(e) {\n    n(this, Ht) || (h(this, Ht, !0), n(this, Et).tick(e * this.time.playbackRate).then(({ video: i, audio: r })=>{\n        var a;\n        i != null && ((a = n(this, mt)) == null || a.close(), h(this, mt, i ?? null)), h(this, Pt, r ?? []), r != null && this.time.playbackRate !== 1 && h(this, Pt, r.map((o)=>li(o, this.time.playbackRate)));\n    }).finally(()=>{\n        h(this, Ht, !1);\n    }));\n}, we = new WeakMap(), ye = new WeakMap();\nlet ai = Xe, yn = 0;\nasync function gi(s) {\n    s() > 50 && (await Ue(15), await gi(s));\n}\nvar Z, ge, N, $t, be, xe, Dt, Wt, pt, Xt, bi, xi;\nclass En {\n    /**\n   * 根据配置创建合成器实例\n   * @param opts ICombinatorOpts\n   */ constructor(t = {}){\n        d(this, Xt);\n        d(this, Z, (0, _internalUtils.Log).create(`id:${yn++},`));\n        d(this, ge, !1);\n        d(this, N, []);\n        d(this, $t);\n        d(this, be);\n        // 中断输出\n        d(this, xe, null);\n        d(this, Dt);\n        d(this, Wt);\n        d(this, pt, new (0, _internalUtils.EventTool)());\n        S(this, \"on\", n(this, pt).on);\n        const { width: e = 0, height: i = 0 } = t;\n        h(this, $t, new OffscreenCanvas(e, i));\n        const r = n(this, $t).getContext(\"2d\", {\n            alpha: !1\n        });\n        if (r == null) throw Error(\"Can not create 2d offscreen context\");\n        h(this, be, r), h(this, Dt, Object.assign({\n            bgColor: \"#000\",\n            width: 0,\n            height: 0,\n            videoCodec: \"avc1.42E032\",\n            audio: !0,\n            bitrate: 5e6,\n            fps: 30,\n            metaDataTags: null\n        }, t)), h(this, Wt, e * i > 0);\n    }\n    /**\n   * 检测当前环境的兼容性\n   * @param args.videoCodec 指定视频编码格式，默认 avc1.42E032\n   * @param args.width 指定视频宽度，默认 1920\n   * @param args.height 指定视频高度，默认 1080\n   * @param args.bitrate 指定视频比特率，默认 5e6\n   */ static async isSupported(t = {}) {\n        return (self.OffscreenCanvas != null && self.VideoEncoder != null && self.VideoDecoder != null && self.VideoFrame != null && self.AudioEncoder != null && self.AudioDecoder != null && self.AudioData != null && ((await self.VideoEncoder.isConfigSupported({\n            codec: t.videoCodec ?? \"avc1.42E032\",\n            width: t.width ?? 1920,\n            height: t.height ?? 1080,\n            bitrate: t.bitrate ?? 7e6\n        })).supported ?? !1) && (await self.AudioEncoder.isConfigSupported({\n            codec: T.codec,\n            sampleRate: T.sampleRate,\n            numberOfChannels: T.channelCount\n        })).supported) ?? !1;\n    }\n    /**\n   * 添加用于合成视频的 Sprite，视频时长默认取所有素材 duration 字段的最大值\n   * @param os Sprite\n   * @param opts.main 如果 main 为 true，视频时长为该素材的 duration 值\n   */ async addSprite(t, e = {}) {\n        const i = {\n            rect: Cn([\n                \"x\",\n                \"y\",\n                \"w\",\n                \"h\"\n            ], t.rect),\n            time: {\n                ...t.time\n            },\n            zIndex: t.zIndex\n        };\n        n(this, Z).info(\"Combinator add sprite\", i);\n        const r = await t.clone();\n        n(this, Z).info(\"Combinator add sprite ready\"), n(this, N).push(Object.assign(r, {\n            main: e.main ?? !1,\n            expired: !1\n        })), n(this, N).sort((a, o)=>a.zIndex - o.zIndex);\n    }\n    /**\n   * 输出视频文件二进制流\n   */ output() {\n        if (n(this, N).length === 0) throw Error(\"No sprite added\");\n        const t = n(this, N).find((l)=>l.main), e = t != null ? t.time.offset + t.time.duration : Math.max(...n(this, N).map((l)=>l.time.offset + l.time.duration));\n        if (e === 1 / 0) throw Error(\"Unable to determine the end time, please specify a main sprite, or limit the duration of ImgClip, AudioCli\");\n        e === -1 && n(this, Z).warn(\"Unable to determine the end time, process value don't update\"), n(this, Z).info(`start combinate video, maxTime:${e}`);\n        const i = B(this, Xt, bi).call(this, e);\n        let r = performance.now();\n        const a = B(this, Xt, xi).call(this, i, e, {\n            onProgress: (l)=>{\n                n(this, Z).debug(\"OutputProgress:\", l), n(this, pt).emit(\"OutputProgress\", l);\n            },\n            onEnded: async ()=>{\n                await i.flush(), n(this, Z).info(\"===== output ended =====, cost:\", performance.now() - r), n(this, pt).emit(\"OutputProgress\", 1), this.destroy();\n            },\n            onError: (l)=>{\n                n(this, pt).emit(\"error\", l), c(l), this.destroy();\n            }\n        });\n        h(this, xe, ()=>{\n            a(), i.close(), c();\n        });\n        const { stream: o, stop: c } = (0, _internalUtils.file2stream)(i.mp4file, 500, this.destroy);\n        return o;\n    }\n    /**\n   * 销毁实例，释放资源\n   */ destroy() {\n        var t;\n        n(this, ge) || (h(this, ge, !0), (t = n(this, xe)) == null || t.call(this), n(this, pt).destroy());\n    }\n}\nZ = new WeakMap(), ge = new WeakMap(), N = new WeakMap(), $t = new WeakMap(), be = new WeakMap(), xe = new WeakMap(), Dt = new WeakMap(), Wt = new WeakMap(), pt = new WeakMap(), Xt = new WeakSet(), bi = function(t) {\n    const { fps: e, width: i, height: r, videoCodec: a, bitrate: o, audio: c, metaDataTags: l } = n(this, Dt);\n    return (0, _internalUtils.recodemux)({\n        video: n(this, Wt) ? {\n            width: i,\n            height: r,\n            expectFPS: e,\n            codec: a,\n            bitrate: o,\n            __unsafe_hardwareAcceleration__: n(this, Dt).__unsafe_hardwareAcceleration__\n        } : null,\n        audio: c === !1 ? null : {\n            codec: \"aac\",\n            sampleRate: T.sampleRate,\n            channelCount: T.channelCount\n        },\n        duration: t,\n        metaDataTags: l\n    });\n}, xi = function(t, e, { onProgress: i, onEnded: r, onError: a }) {\n    let o = 0;\n    const c = {\n        aborted: !1\n    };\n    let l = null;\n    (async ()=>{\n        const { fps: p, bgColor: x, audio: f } = n(this, Dt), y = Math.round(1e6 / p), g = n(this, be), b = gn({\n            ctx: g,\n            bgColor: x,\n            sprites: n(this, N),\n            aborter: c\n        }), C = bn({\n            remux: t,\n            ctx: g,\n            cvs: n(this, $t),\n            outputAudio: f,\n            hasVideoTrack: n(this, Wt),\n            timeSlice: y,\n            fps: p\n        });\n        let v = 0;\n        for(;;){\n            if (l != null) return;\n            if (c.aborted || e !== -1 && v > e || n(this, N).length === 0) {\n                w(), await r();\n                return;\n            }\n            o = v / e;\n            const { audios: k, mainSprDone: H } = await b(v);\n            if (H) {\n                w(), await r();\n                return;\n            }\n            if (c.aborted) return;\n            C(v, k), v += y, await gi(t.getEncodeQueueSize);\n        }\n    })().catch((p)=>{\n        l = p, n(this, Z).error(p), w(), a(p);\n    });\n    const u = setInterval(()=>{\n        i(o);\n    }, 500), w = ()=>{\n        c.aborted || (c.aborted = !0, clearInterval(u), n(this, N).forEach((p)=>p.destroy()));\n    };\n    return w;\n};\nfunction gn(s) {\n    const { ctx: t, bgColor: e, sprites: i, aborter: r } = s, { width: a, height: o } = t.canvas;\n    return async (c)=>{\n        t.fillStyle = e, t.fillRect(0, 0, a, o);\n        const l = [];\n        let m = !1;\n        for (const u of i){\n            if (r.aborted) break;\n            if (c < u.time.offset || u.expired) continue;\n            t.save();\n            const { audio: w, done: p } = await u.offscreenRender(t, c - u.time.offset);\n            l.push(w), t.restore(), (u.time.duration > 0 && c > u.time.offset + u.time.duration || p) && (u.main && (m = !0), u.destroy(), u.expired = !0);\n        }\n        return {\n            audios: l,\n            mainSprDone: m\n        };\n    };\n}\nfunction bn(s) {\n    const { ctx: t, cvs: e, outputAudio: i, remux: r, hasVideoTrack: a, timeSlice: o } = s, { width: c, height: l } = e;\n    let m = 0;\n    const u = Math.floor(3 * s.fps), w = xn(1024);\n    return (p, x)=>{\n        if (i !== !1) for (const f of w(p, x))r.encodeAudio(f);\n        if (a) {\n            const f = new VideoFrame(e, {\n                duration: o,\n                timestamp: p\n            });\n            r.encodeVideo(f, {\n                keyFrame: m % u === 0\n            }), t.resetTransform(), t.clearRect(0, 0, c, l), m += 1;\n        }\n    };\n}\nfunction xn(s) {\n    const t = s * T.channelCount, e = new Float32Array(t * 3);\n    let i = 0, r = 0;\n    const a = s / T.sampleRate * 1e6, o = new Float32Array(t), c = (l)=>{\n        let m = 0;\n        const u = Math.floor(i / t), w = [];\n        for(let p = 0; p < u; p++)w.push(new AudioData({\n            timestamp: r,\n            numberOfChannels: T.channelCount,\n            numberOfFrames: s,\n            sampleRate: T.sampleRate,\n            format: \"f32\",\n            data: e.subarray(m, m + t)\n        })), m += t, r += a;\n        for(e.set(e.subarray(m, i), 0), i -= m; l - r > a;)w.push(new AudioData({\n            timestamp: r,\n            numberOfChannels: T.channelCount,\n            numberOfFrames: s,\n            sampleRate: T.sampleRate,\n            format: \"f32\",\n            data: o\n        })), r += a;\n        return w;\n    };\n    return (l, m)=>{\n        var w, p;\n        const u = Math.max(...m.map((x)=>{\n            var f;\n            return ((f = x[0]) == null ? void 0 : f.length) ?? 0;\n        }));\n        for(let x = 0; x < u; x++){\n            let f = 0, y = 0;\n            for(let g = 0; g < m.length; g++){\n                const b = ((w = m[g][0]) == null ? void 0 : w[x]) ?? 0, C = ((p = m[g][1]) == null ? void 0 : p[x]) ?? b;\n                f += b, y += C;\n            }\n            e[i] = f, e[i + 1] = y, i += 2;\n        }\n        return c(l);\n    };\n}\nfunction Cn(s, t) {\n    return s.reduce((e, i)=>(e[i] = t[i], e), {});\n}\n\n},{\"@webav/mp4box.js\":\"g0QYf\",\"@webav/internal-utils\":\"d6vtv\",\"wave-resampler\":\"511Cz\",\"opfs-tools\":\"ga02n\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"g0QYf\":[function(require,module,exports,__globalThis) {\n// file:src/log.js\n/* \n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ var Log = function() {\n    var start = new Date();\n    var LOG_LEVEL_ERROR = 4;\n    var LOG_LEVEL_WARNING = 3;\n    var LOG_LEVEL_INFO = 2;\n    var LOG_LEVEL_DEBUG = 1;\n    var log_level = LOG_LEVEL_ERROR;\n    var logObject = {\n        setLogLevel: function(level) {\n            if (level == this.debug) log_level = LOG_LEVEL_DEBUG;\n            else if (level == this.info) log_level = LOG_LEVEL_INFO;\n            else if (level == this.warn) log_level = LOG_LEVEL_WARNING;\n            else if (level == this.error) log_level = LOG_LEVEL_ERROR;\n            else log_level = LOG_LEVEL_ERROR;\n        },\n        debug: function(module, msg) {\n            if (console.debug === undefined) console.debug = console.log;\n            if (LOG_LEVEL_DEBUG >= log_level) console.debug(\"[\" + Log.getDurationString(new Date() - start, 1000) + \"]\", \"[\" + module + \"]\", msg);\n        },\n        log: function(module, msg) {\n            this.debug(module.msg);\n        },\n        info: function(module, msg) {\n            if (LOG_LEVEL_INFO >= log_level) console.info(\"[\" + Log.getDurationString(new Date() - start, 1000) + \"]\", \"[\" + module + \"]\", msg);\n        },\n        warn: function(module, msg) {\n            if (LOG_LEVEL_WARNING >= log_level) console.warn(\"[\" + Log.getDurationString(new Date() - start, 1000) + \"]\", \"[\" + module + \"]\", msg);\n        },\n        error: function(module, msg) {\n            if (LOG_LEVEL_ERROR >= log_level) console.error(\"[\" + Log.getDurationString(new Date() - start, 1000) + \"]\", \"[\" + module + \"]\", msg);\n        }\n    };\n    return logObject;\n}();\n/* Helper function to print a duration value in the form H:MM:SS.MS */ Log.getDurationString = function(duration, _timescale) {\n    var neg;\n    /* Helper function to print a number on a fixed number of digits */ function pad(number, length) {\n        var str = '' + number;\n        var a = str.split('.');\n        while(a[0].length < length)a[0] = '0' + a[0];\n        return a.join('.');\n    }\n    if (duration < 0) {\n        neg = true;\n        duration = -duration;\n    } else neg = false;\n    var timescale = _timescale || 1;\n    var duration_sec = duration / timescale;\n    var hours = Math.floor(duration_sec / 3600);\n    duration_sec -= hours * 3600;\n    var minutes = Math.floor(duration_sec / 60);\n    duration_sec -= minutes * 60;\n    var msec = duration_sec * 1000;\n    duration_sec = Math.floor(duration_sec);\n    msec -= duration_sec * 1000;\n    msec = Math.floor(msec);\n    return (neg ? \"-\" : \"\") + hours + \":\" + pad(minutes, 2) + \":\" + pad(duration_sec, 2) + \".\" + pad(msec, 3);\n};\n/* Helper function to stringify HTML5 TimeRanges objects */ Log.printRanges = function(ranges) {\n    var length = ranges.length;\n    if (length > 0) {\n        var str = \"\";\n        for(var i1 = 0; i1 < length; i1++){\n            if (i1 > 0) str += \",\";\n            str += \"[\" + Log.getDurationString(ranges.start(i1)) + \",\" + Log.getDurationString(ranges.end(i1)) + \"]\";\n        }\n        return str;\n    } else return \"(empty)\";\n};\nexports.Log = Log;\n// file:src/stream.js\nvar MP4BoxStream = function(arrayBuffer) {\n    if (arrayBuffer instanceof ArrayBuffer) {\n        this.buffer = arrayBuffer;\n        this.dataview = new DataView(arrayBuffer);\n    } else throw \"Needs an array buffer\";\n    this.position = 0;\n};\n/*************************************************************************\n  Common API between MultiBufferStream and SimpleStream\n *************************************************************************/ MP4BoxStream.prototype.getPosition = function() {\n    return this.position;\n};\nMP4BoxStream.prototype.getEndPosition = function() {\n    return this.buffer.byteLength;\n};\nMP4BoxStream.prototype.getLength = function() {\n    return this.buffer.byteLength;\n};\nMP4BoxStream.prototype.seek = function(pos) {\n    var npos = Math.max(0, Math.min(this.buffer.byteLength, pos));\n    this.position = isNaN(npos) || !isFinite(npos) ? 0 : npos;\n    return true;\n};\nMP4BoxStream.prototype.isEos = function() {\n    return this.getPosition() >= this.getEndPosition();\n};\n/*************************************************************************\n  Read methods, simimar to DataStream but simpler\n *************************************************************************/ MP4BoxStream.prototype.readAnyInt = function(size, signed) {\n    var res = 0;\n    if (this.position + size <= this.buffer.byteLength) {\n        switch(size){\n            case 1:\n                if (signed) res = this.dataview.getInt8(this.position);\n                else res = this.dataview.getUint8(this.position);\n                break;\n            case 2:\n                if (signed) res = this.dataview.getInt16(this.position);\n                else res = this.dataview.getUint16(this.position);\n                break;\n            case 3:\n                if (signed) throw \"No method for reading signed 24 bits values\";\n                else {\n                    res = this.dataview.getUint8(this.position) << 16;\n                    res |= this.dataview.getUint8(this.position + 1) << 8;\n                    res |= this.dataview.getUint8(this.position + 2);\n                }\n                break;\n            case 4:\n                if (signed) res = this.dataview.getInt32(this.position);\n                else res = this.dataview.getUint32(this.position);\n                break;\n            case 8:\n                if (signed) throw \"No method for reading signed 64 bits values\";\n                else {\n                    res = this.dataview.getUint32(this.position) << 32;\n                    res |= this.dataview.getUint32(this.position + 4);\n                }\n                break;\n            default:\n                throw \"readInt method not implemented for size: \" + size;\n        }\n        this.position += size;\n        return res;\n    } else throw \"Not enough bytes in buffer\";\n};\nMP4BoxStream.prototype.readUint8 = function() {\n    return this.readAnyInt(1, false);\n};\nMP4BoxStream.prototype.readUint16 = function() {\n    return this.readAnyInt(2, false);\n};\nMP4BoxStream.prototype.readUint24 = function() {\n    return this.readAnyInt(3, false);\n};\nMP4BoxStream.prototype.readUint32 = function() {\n    return this.readAnyInt(4, false);\n};\nMP4BoxStream.prototype.readUint64 = function() {\n    return this.readAnyInt(8, false);\n};\nMP4BoxStream.prototype.readString = function(length) {\n    if (this.position + length <= this.buffer.byteLength) {\n        var s = \"\";\n        for(var i1 = 0; i1 < length; i1++)s += String.fromCharCode(this.readUint8());\n        return s;\n    } else throw \"Not enough bytes in buffer\";\n};\nMP4BoxStream.prototype.readCString = function() {\n    var arr = [];\n    while(true){\n        var b = this.readUint8();\n        if (b !== 0) arr.push(b);\n        else break;\n    }\n    return String.fromCharCode.apply(null, arr);\n};\nMP4BoxStream.prototype.readInt8 = function() {\n    return this.readAnyInt(1, true);\n};\nMP4BoxStream.prototype.readInt16 = function() {\n    return this.readAnyInt(2, true);\n};\nMP4BoxStream.prototype.readInt32 = function() {\n    return this.readAnyInt(4, true);\n};\nMP4BoxStream.prototype.readInt64 = function() {\n    return this.readAnyInt(8, false);\n};\nMP4BoxStream.prototype.readUint8Array = function(length) {\n    var arr = new Uint8Array(length);\n    for(var i1 = 0; i1 < length; i1++)arr[i1] = this.readUint8();\n    return arr;\n};\nMP4BoxStream.prototype.readInt16Array = function(length) {\n    var arr = new Int16Array(length);\n    for(var i1 = 0; i1 < length; i1++)arr[i1] = this.readInt16();\n    return arr;\n};\nMP4BoxStream.prototype.readUint16Array = function(length) {\n    var arr = new Int16Array(length);\n    for(var i1 = 0; i1 < length; i1++)arr[i1] = this.readUint16();\n    return arr;\n};\nMP4BoxStream.prototype.readUint32Array = function(length) {\n    var arr = new Uint32Array(length);\n    for(var i1 = 0; i1 < length; i1++)arr[i1] = this.readUint32();\n    return arr;\n};\nMP4BoxStream.prototype.readInt32Array = function(length) {\n    var arr = new Int32Array(length);\n    for(var i1 = 0; i1 < length; i1++)arr[i1] = this.readInt32();\n    return arr;\n};\nexports.MP4BoxStream = MP4BoxStream;\n/**\n  DataStream reads scalars, arrays and structs of data from an ArrayBuffer.\n  It's like a file-like DataView on steroids.\n\n  @param {ArrayBuffer} arrayBuffer ArrayBuffer to read from.\n  @param {?Number} byteOffset Offset from arrayBuffer beginning for the DataStream.\n  @param {?Boolean} endianness DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN (the default).\n  */ var DataStream = function(arrayBuffer, byteOffset, endianness) {\n    this._byteOffset = byteOffset || 0;\n    if (arrayBuffer instanceof ArrayBuffer) this.buffer = arrayBuffer;\n    else if (typeof arrayBuffer == \"object\") {\n        this.dataView = arrayBuffer;\n        if (byteOffset) this._byteOffset += byteOffset;\n    } else this.buffer = new ArrayBuffer(arrayBuffer || 0);\n    this.position = 0;\n    this.endianness = endianness == null ? DataStream.LITTLE_ENDIAN : endianness;\n};\nDataStream.prototype = {};\nDataStream.prototype.getPosition = function() {\n    return this.position;\n};\n/**\n  Internal function to resize the DataStream buffer when required.\n  @param {number} extra Number of bytes to add to the buffer allocation.\n  @return {null}\n  */ DataStream.prototype._realloc = function(extra) {\n    if (!this._dynamicSize) return;\n    var req = this._byteOffset + this.position + extra;\n    var blen = this._buffer.byteLength;\n    if (req <= blen) {\n        if (req > this._byteLength) this._byteLength = req;\n        return;\n    }\n    if (blen < 1) blen = 1;\n    while(req > blen)blen *= 2;\n    var buf = new ArrayBuffer(blen);\n    var src = new Uint8Array(this._buffer);\n    var dst = new Uint8Array(buf, 0, src.length);\n    dst.set(src);\n    this.buffer = buf;\n    this._byteLength = req;\n};\n/**\n  Internal function to trim the DataStream buffer when required.\n  Used for stripping out the extra bytes from the backing buffer when\n  the virtual byteLength is smaller than the buffer byteLength (happens after\n  growing the buffer with writes and not filling the extra space completely).\n\n  @return {null}\n  */ DataStream.prototype._trimAlloc = function() {\n    if (this._byteLength == this._buffer.byteLength) return;\n    var buf = new ArrayBuffer(this._byteLength);\n    var dst = new Uint8Array(buf);\n    var src = new Uint8Array(this._buffer, 0, dst.length);\n    dst.set(src);\n    this.buffer = buf;\n};\n/**\n  Big-endian const to use as default endianness.\n  @type {boolean}\n  */ DataStream.BIG_ENDIAN = false;\n/**\n  Little-endian const to use as default endianness.\n  @type {boolean}\n  */ DataStream.LITTLE_ENDIAN = true;\n/**\n  Virtual byte length of the DataStream backing buffer.\n  Updated to be max of original buffer size and last written size.\n  If dynamicSize is false is set to buffer size.\n  @type {number}\n  */ DataStream.prototype._byteLength = 0;\n/**\n  Returns the byte length of the DataStream object.\n  @type {number}\n  */ Object.defineProperty(DataStream.prototype, 'byteLength', {\n    get: function() {\n        return this._byteLength - this._byteOffset;\n    }\n});\n/**\n  Set/get the backing ArrayBuffer of the DataStream object.\n  The setter updates the DataView to point to the new buffer.\n  @type {Object}\n  */ Object.defineProperty(DataStream.prototype, 'buffer', {\n    get: function() {\n        this._trimAlloc();\n        return this._buffer;\n    },\n    set: function(v) {\n        this._buffer = v;\n        this._dataView = new DataView(this._buffer, this._byteOffset);\n        this._byteLength = this._buffer.byteLength;\n    }\n});\n/**\n  Set/get the byteOffset of the DataStream object.\n  The setter updates the DataView to point to the new byteOffset.\n  @type {number}\n  */ Object.defineProperty(DataStream.prototype, 'byteOffset', {\n    get: function() {\n        return this._byteOffset;\n    },\n    set: function(v) {\n        this._byteOffset = v;\n        this._dataView = new DataView(this._buffer, this._byteOffset);\n        this._byteLength = this._buffer.byteLength;\n    }\n});\n/**\n  Set/get the backing DataView of the DataStream object.\n  The setter updates the buffer and byteOffset to point to the DataView values.\n  @type {Object}\n  */ Object.defineProperty(DataStream.prototype, 'dataView', {\n    get: function() {\n        return this._dataView;\n    },\n    set: function(v) {\n        this._byteOffset = v.byteOffset;\n        this._buffer = v.buffer;\n        this._dataView = new DataView(this._buffer, this._byteOffset);\n        this._byteLength = this._byteOffset + v.byteLength;\n    }\n});\n/**\n  Sets the DataStream read/write position to given position.\n  Clamps between 0 and DataStream length.\n\n  @param {number} pos Position to seek to.\n  @return {null}\n  */ DataStream.prototype.seek = function(pos) {\n    var npos = Math.max(0, Math.min(this.byteLength, pos));\n    this.position = isNaN(npos) || !isFinite(npos) ? 0 : npos;\n};\n/**\n  Returns true if the DataStream seek pointer is at the end of buffer and\n  there's no more data to read.\n\n  @return {boolean} True if the seek pointer is at the end of the buffer.\n  */ DataStream.prototype.isEof = function() {\n    return this.position >= this._byteLength;\n};\n/**\n  Maps a Uint8Array into the DataStream buffer.\n\n  Nice for quickly reading in data.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint8Array to the DataStream backing buffer.\n  */ DataStream.prototype.mapUint8Array = function(length) {\n    this._realloc(length * 1);\n    var arr = new Uint8Array(this._buffer, this.byteOffset + this.position, length);\n    this.position += length * 1;\n    return arr;\n};\n/**\n  Reads an Int32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int32Array.\n */ DataStream.prototype.readInt32Array = function(length, e) {\n    length = length == null ? this.byteLength - this.position / 4 : length;\n    var arr = new Int32Array(length);\n    DataStream.memcpy(arr.buffer, 0, this.buffer, this.byteOffset + this.position, length * arr.BYTES_PER_ELEMENT);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += arr.byteLength;\n    return arr;\n};\n/**\n  Reads an Int16Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int16Array.\n */ DataStream.prototype.readInt16Array = function(length, e) {\n    length = length == null ? this.byteLength - this.position / 2 : length;\n    var arr = new Int16Array(length);\n    DataStream.memcpy(arr.buffer, 0, this.buffer, this.byteOffset + this.position, length * arr.BYTES_PER_ELEMENT);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += arr.byteLength;\n    return arr;\n};\n/**\n  Reads an Int8Array of desired length from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int8Array.\n */ DataStream.prototype.readInt8Array = function(length) {\n    length = length == null ? this.byteLength - this.position : length;\n    var arr = new Int8Array(length);\n    DataStream.memcpy(arr.buffer, 0, this.buffer, this.byteOffset + this.position, length * arr.BYTES_PER_ELEMENT);\n    this.position += arr.byteLength;\n    return arr;\n};\n/**\n  Reads a Uint32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint32Array.\n */ DataStream.prototype.readUint32Array = function(length, e) {\n    length = length == null ? this.byteLength - this.position / 4 : length;\n    var arr = new Uint32Array(length);\n    DataStream.memcpy(arr.buffer, 0, this.buffer, this.byteOffset + this.position, length * arr.BYTES_PER_ELEMENT);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += arr.byteLength;\n    return arr;\n};\n/**\n  Reads a Uint16Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint16Array.\n */ DataStream.prototype.readUint16Array = function(length, e) {\n    length = length == null ? this.byteLength - this.position / 2 : length;\n    var arr = new Uint16Array(length);\n    DataStream.memcpy(arr.buffer, 0, this.buffer, this.byteOffset + this.position, length * arr.BYTES_PER_ELEMENT);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += arr.byteLength;\n    return arr;\n};\n/**\n  Reads a Uint8Array of desired length from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint8Array.\n */ DataStream.prototype.readUint8Array = function(length) {\n    length = length == null ? this.byteLength - this.position : length;\n    var arr = new Uint8Array(length);\n    DataStream.memcpy(arr.buffer, 0, this.buffer, this.byteOffset + this.position, length * arr.BYTES_PER_ELEMENT);\n    this.position += arr.byteLength;\n    return arr;\n};\n/**\n  Reads a Float64Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Float64Array.\n */ DataStream.prototype.readFloat64Array = function(length, e) {\n    length = length == null ? this.byteLength - this.position / 8 : length;\n    var arr = new Float64Array(length);\n    DataStream.memcpy(arr.buffer, 0, this.buffer, this.byteOffset + this.position, length * arr.BYTES_PER_ELEMENT);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += arr.byteLength;\n    return arr;\n};\n/**\n  Reads a Float32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Float32Array.\n */ DataStream.prototype.readFloat32Array = function(length, e) {\n    length = length == null ? this.byteLength - this.position / 4 : length;\n    var arr = new Float32Array(length);\n    DataStream.memcpy(arr.buffer, 0, this.buffer, this.byteOffset + this.position, length * arr.BYTES_PER_ELEMENT);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += arr.byteLength;\n    return arr;\n};\n/**\n  Reads a 32-bit int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */ DataStream.prototype.readInt32 = function(e) {\n    var v = this._dataView.getInt32(this.position, e == null ? this.endianness : e);\n    this.position += 4;\n    return v;\n};\n/**\n  Reads a 16-bit int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */ DataStream.prototype.readInt16 = function(e) {\n    var v = this._dataView.getInt16(this.position, e == null ? this.endianness : e);\n    this.position += 2;\n    return v;\n};\n/**\n  Reads an 8-bit int from the DataStream.\n\n  @return {number} The read number.\n */ DataStream.prototype.readInt8 = function() {\n    var v = this._dataView.getInt8(this.position);\n    this.position += 1;\n    return v;\n};\n/**\n  Reads a 32-bit unsigned int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */ DataStream.prototype.readUint32 = function(e) {\n    var v = this._dataView.getUint32(this.position, e == null ? this.endianness : e);\n    this.position += 4;\n    return v;\n};\n/**\n  Reads a 16-bit unsigned int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */ DataStream.prototype.readUint16 = function(e) {\n    var v = this._dataView.getUint16(this.position, e == null ? this.endianness : e);\n    this.position += 2;\n    return v;\n};\n/**\n  Reads an 8-bit unsigned int from the DataStream.\n\n  @return {number} The read number.\n */ DataStream.prototype.readUint8 = function() {\n    var v = this._dataView.getUint8(this.position);\n    this.position += 1;\n    return v;\n};\n/**\n  Reads a 32-bit float from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */ DataStream.prototype.readFloat32 = function(e) {\n    var v = this._dataView.getFloat32(this.position, e == null ? this.endianness : e);\n    this.position += 4;\n    return v;\n};\n/**\n  Reads a 64-bit float from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */ DataStream.prototype.readFloat64 = function(e) {\n    var v = this._dataView.getFloat64(this.position, e == null ? this.endianness : e);\n    this.position += 8;\n    return v;\n};\n/**\n  Native endianness. Either DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN\n  depending on the platform endianness.\n\n  @type {boolean}\n */ DataStream.endianness = new Int8Array(new Int16Array([\n    1\n]).buffer)[0] > 0;\n/**\n  Copies byteLength bytes from the src buffer at srcOffset to the\n  dst buffer at dstOffset.\n\n  @param {Object} dst Destination ArrayBuffer to write to.\n  @param {number} dstOffset Offset to the destination ArrayBuffer.\n  @param {Object} src Source ArrayBuffer to read from.\n  @param {number} srcOffset Offset to the source ArrayBuffer.\n  @param {number} byteLength Number of bytes to copy.\n */ DataStream.memcpy = function(dst, dstOffset, src, srcOffset, byteLength) {\n    var dstU8 = new Uint8Array(dst, dstOffset, byteLength);\n    var srcU8 = new Uint8Array(src, srcOffset, byteLength);\n    dstU8.set(srcU8);\n};\n/**\n  Converts array to native endianness in-place.\n\n  @param {Object} array Typed array to convert.\n  @param {boolean} arrayIsLittleEndian True if the data in the array is\n                                       little-endian. Set false for big-endian.\n  @return {Object} The converted typed array.\n */ DataStream.arrayToNative = function(array, arrayIsLittleEndian) {\n    if (arrayIsLittleEndian == this.endianness) return array;\n    else return this.flipArrayEndianness(array);\n};\n/**\n  Converts native endianness array to desired endianness in-place.\n\n  @param {Object} array Typed array to convert.\n  @param {boolean} littleEndian True if the converted array should be\n                                little-endian. Set false for big-endian.\n  @return {Object} The converted typed array.\n */ DataStream.nativeToEndian = function(array, littleEndian) {\n    if (this.endianness == littleEndian) return array;\n    else return this.flipArrayEndianness(array);\n};\n/**\n  Flips typed array endianness in-place.\n\n  @param {Object} array Typed array to flip.\n  @return {Object} The converted typed array.\n */ DataStream.flipArrayEndianness = function(array) {\n    var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n    for(var i1 = 0; i1 < array.byteLength; i1 += array.BYTES_PER_ELEMENT)for(var j = i1 + array.BYTES_PER_ELEMENT - 1, k = i1; j > k; j--, k++){\n        var tmp = u8[k];\n        u8[k] = u8[j];\n        u8[j] = tmp;\n    }\n    return array;\n};\n/**\n  Seek position where DataStream#readStruct ran into a problem.\n  Useful for debugging struct parsing.\n\n  @type {number}\n */ DataStream.prototype.failurePosition = 0;\nString.fromCharCodeUint8 = function(uint8arr) {\n    var arr = [];\n    for(var i1 = 0; i1 < uint8arr.length; i1++)arr[i1] = uint8arr[i1];\n    return String.fromCharCode.apply(null, arr);\n};\n/**\n  Read a string of desired length and encoding from the DataStream.\n\n  @param {number} length The length of the string to read in bytes.\n  @param {?string} encoding The encoding of the string data in the DataStream.\n                            Defaults to ASCII.\n  @return {string} The read string.\n */ DataStream.prototype.readString = function(length, encoding) {\n    if (encoding == null || encoding == \"ASCII\") return String.fromCharCodeUint8.apply(null, [\n        this.mapUint8Array(length == null ? this.byteLength - this.position : length)\n    ]);\n    else return new TextDecoder(encoding).decode(this.mapUint8Array(length));\n};\n/**\n  Read null-terminated string of desired length from the DataStream. Truncates\n  the returned string so that the null byte is not a part of it.\n\n  @param {?number} length The length of the string to read.\n  @return {string} The read string.\n */ DataStream.prototype.readCString = function(length) {\n    var blen = this.byteLength - this.position;\n    var u8 = new Uint8Array(this._buffer, this._byteOffset + this.position);\n    var len = blen;\n    if (length != null) len = Math.min(length, blen);\n    for(var i1 = 0; i1 < len && u8[i1] !== 0; i1++); // find first zero byte\n    var s = String.fromCharCodeUint8.apply(null, [\n        this.mapUint8Array(i1)\n    ]);\n    if (length != null) this.position += len - i1;\n    else if (i1 != blen) this.position += 1; // trailing zero if not at end of buffer\n    return s;\n};\n/* \n   TODO: fix endianness for 24/64-bit fields\n   TODO: check range/support for 64-bits numbers in JavaScript\n*/ var MAX_SIZE = Math.pow(2, 32);\nDataStream.prototype.readInt64 = function() {\n    return this.readInt32() * MAX_SIZE + this.readUint32();\n};\nDataStream.prototype.readUint64 = function() {\n    return this.readUint32() * MAX_SIZE + this.readUint32();\n};\nDataStream.prototype.readInt64 = function() {\n    return this.readUint32() * MAX_SIZE + this.readUint32();\n};\nDataStream.prototype.readUint24 = function() {\n    return (this.readUint8() << 16) + (this.readUint8() << 8) + this.readUint8();\n};\nexports.DataStream = DataStream;\n// file:src/DataStream-write.js\n/**\n  Saves the DataStream contents to the given filename.\n  Uses Chrome's anchor download property to initiate download.\n \n  @param {string} filename Filename to save as.\n  @return {null}\n  */ DataStream.prototype.save = function(filename) {\n    var blob = new Blob([\n        this.buffer\n    ]);\n    if (window.URL && URL.createObjectURL) {\n        var url = window.URL.createObjectURL(blob);\n        var a = document.createElement('a');\n        // Required in Firefox:\n        document.body.appendChild(a);\n        a.setAttribute('href', url);\n        a.setAttribute('download', filename);\n        // Required in Firefox:\n        a.setAttribute('target', '_self');\n        a.click();\n        window.URL.revokeObjectURL(url);\n    } else throw \"DataStream.save: Can't create object URL.\";\n};\n/**\n  Whether to extend DataStream buffer when trying to write beyond its size.\n  If set, the buffer is reallocated to twice its current size until the\n  requested write fits the buffer.\n  @type {boolean}\n  */ DataStream.prototype._dynamicSize = true;\nObject.defineProperty(DataStream.prototype, 'dynamicSize', {\n    get: function() {\n        return this._dynamicSize;\n    },\n    set: function(v) {\n        if (!v) this._trimAlloc();\n        this._dynamicSize = v;\n    }\n});\n/**\n  Internal function to trim the DataStream buffer when required.\n  Used for stripping out the first bytes when not needed anymore.\n\n  @return {null}\n  */ DataStream.prototype.shift = function(offset) {\n    var buf = new ArrayBuffer(this._byteLength - offset);\n    var dst = new Uint8Array(buf);\n    var src = new Uint8Array(this._buffer, offset, dst.length);\n    dst.set(src);\n    this.buffer = buf;\n    this.position -= offset;\n};\n/**\n  Writes an Int32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */ DataStream.prototype.writeInt32Array = function(arr, e) {\n    this._realloc(arr.length * 4);\n    if (arr instanceof Int32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT === 0) {\n        DataStream.memcpy(this._buffer, this.byteOffset + this.position, arr.buffer, 0, arr.byteLength);\n        this.mapInt32Array(arr.length, e);\n    } else for(var i1 = 0; i1 < arr.length; i1++)this.writeInt32(arr[i1], e);\n};\n/**\n  Writes an Int16Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */ DataStream.prototype.writeInt16Array = function(arr, e) {\n    this._realloc(arr.length * 2);\n    if (arr instanceof Int16Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT === 0) {\n        DataStream.memcpy(this._buffer, this.byteOffset + this.position, arr.buffer, 0, arr.byteLength);\n        this.mapInt16Array(arr.length, e);\n    } else for(var i1 = 0; i1 < arr.length; i1++)this.writeInt16(arr[i1], e);\n};\n/**\n  Writes an Int8Array to the DataStream.\n\n  @param {Object} arr The array to write.\n */ DataStream.prototype.writeInt8Array = function(arr) {\n    this._realloc(arr.length * 1);\n    if (arr instanceof Int8Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT === 0) {\n        DataStream.memcpy(this._buffer, this.byteOffset + this.position, arr.buffer, 0, arr.byteLength);\n        this.mapInt8Array(arr.length);\n    } else for(var i1 = 0; i1 < arr.length; i1++)this.writeInt8(arr[i1]);\n};\n/**\n  Writes a Uint32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */ DataStream.prototype.writeUint32Array = function(arr, e) {\n    this._realloc(arr.length * 4);\n    if (arr instanceof Uint32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT === 0) {\n        DataStream.memcpy(this._buffer, this.byteOffset + this.position, arr.buffer, 0, arr.byteLength);\n        this.mapUint32Array(arr.length, e);\n    } else for(var i1 = 0; i1 < arr.length; i1++)this.writeUint32(arr[i1], e);\n};\n/**\n  Writes a Uint16Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */ DataStream.prototype.writeUint16Array = function(arr, e) {\n    this._realloc(arr.length * 2);\n    if (arr instanceof Uint16Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT === 0) {\n        DataStream.memcpy(this._buffer, this.byteOffset + this.position, arr.buffer, 0, arr.byteLength);\n        this.mapUint16Array(arr.length, e);\n    } else for(var i1 = 0; i1 < arr.length; i1++)this.writeUint16(arr[i1], e);\n};\n/**\n  Writes a Uint8Array to the DataStream.\n\n  @param {Object} arr The array to write.\n */ DataStream.prototype.writeUint8Array = function(arr) {\n    this._realloc(arr.length * 1);\n    if (arr instanceof Uint8Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT === 0) {\n        DataStream.memcpy(this._buffer, this.byteOffset + this.position, arr.buffer, 0, arr.byteLength);\n        this.mapUint8Array(arr.length);\n    } else for(var i1 = 0; i1 < arr.length; i1++)this.writeUint8(arr[i1]);\n};\n/**\n  Writes a Float64Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */ DataStream.prototype.writeFloat64Array = function(arr, e) {\n    this._realloc(arr.length * 8);\n    if (arr instanceof Float64Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT === 0) {\n        DataStream.memcpy(this._buffer, this.byteOffset + this.position, arr.buffer, 0, arr.byteLength);\n        this.mapFloat64Array(arr.length, e);\n    } else for(var i1 = 0; i1 < arr.length; i1++)this.writeFloat64(arr[i1], e);\n};\n/**\n  Writes a Float32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */ DataStream.prototype.writeFloat32Array = function(arr, e) {\n    this._realloc(arr.length * 4);\n    if (arr instanceof Float32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT === 0) {\n        DataStream.memcpy(this._buffer, this.byteOffset + this.position, arr.buffer, 0, arr.byteLength);\n        this.mapFloat32Array(arr.length, e);\n    } else for(var i1 = 0; i1 < arr.length; i1++)this.writeFloat32(arr[i1], e);\n};\n/**\n  Writes a 32-bit int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */ DataStream.prototype.writeInt32 = function(v, e) {\n    this._realloc(4);\n    this._dataView.setInt32(this.position, v, e == null ? this.endianness : e);\n    this.position += 4;\n};\n/**\n  Writes a 16-bit int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */ DataStream.prototype.writeInt16 = function(v, e) {\n    this._realloc(2);\n    this._dataView.setInt16(this.position, v, e == null ? this.endianness : e);\n    this.position += 2;\n};\n/**\n  Writes an 8-bit int to the DataStream.\n\n  @param {number} v Number to write.\n */ DataStream.prototype.writeInt8 = function(v) {\n    this._realloc(1);\n    this._dataView.setInt8(this.position, v);\n    this.position += 1;\n};\n/**\n  Writes a 32-bit unsigned int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */ DataStream.prototype.writeUint32 = function(v, e) {\n    this._realloc(4);\n    this._dataView.setUint32(this.position, v, e == null ? this.endianness : e);\n    this.position += 4;\n};\n/**\n  Writes a 16-bit unsigned int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */ DataStream.prototype.writeUint16 = function(v, e) {\n    this._realloc(2);\n    this._dataView.setUint16(this.position, v, e == null ? this.endianness : e);\n    this.position += 2;\n};\n/**\n  Writes an 8-bit unsigned  int to the DataStream.\n\n  @param {number} v Number to write.\n */ DataStream.prototype.writeUint8 = function(v) {\n    this._realloc(1);\n    this._dataView.setUint8(this.position, v);\n    this.position += 1;\n};\n/**\n  Writes a 32-bit float to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */ DataStream.prototype.writeFloat32 = function(v, e) {\n    this._realloc(4);\n    this._dataView.setFloat32(this.position, v, e == null ? this.endianness : e);\n    this.position += 4;\n};\n/**\n  Writes a 64-bit float to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */ DataStream.prototype.writeFloat64 = function(v, e) {\n    this._realloc(8);\n    this._dataView.setFloat64(this.position, v, e == null ? this.endianness : e);\n    this.position += 8;\n};\n/**\n  Write a UCS-2 string of desired endianness to the DataStream. The\n  lengthOverride argument lets you define the number of characters to write.\n  If the string is shorter than lengthOverride, the extra space is padded with\n  zeroes.\n\n  @param {string} str The string to write.\n  @param {?boolean} endianness The endianness to use for the written string data.\n  @param {?number} lengthOverride The number of characters to write.\n */ DataStream.prototype.writeUCS2String = function(str, endianness, lengthOverride) {\n    if (lengthOverride == null) lengthOverride = str.length;\n    for(var i1 = 0; i1 < str.length && i1 < lengthOverride; i1++)this.writeUint16(str.charCodeAt(i1), endianness);\n    for(; i1 < lengthOverride; i1++)this.writeUint16(0);\n};\n/**\n  Writes a string of desired length and encoding to the DataStream.\n\n  @param {string} s The string to write.\n  @param {?string} encoding The encoding for the written string data.\n                            Defaults to ASCII.\n  @param {?number} length The number of characters to write.\n */ DataStream.prototype.writeString = function(s, encoding, length) {\n    var i1 = 0;\n    if (encoding == null || encoding == \"ASCII\") {\n        if (length != null) {\n            var len = Math.min(s.length, length);\n            for(i1 = 0; i1 < len; i1++)this.writeUint8(s.charCodeAt(i1));\n            for(; i1 < length; i1++)this.writeUint8(0);\n        } else for(i1 = 0; i1 < s.length; i1++)this.writeUint8(s.charCodeAt(i1));\n    } else this.writeUint8Array(new TextEncoder(encoding).encode(s.substring(0, length)));\n};\n/**\n  Writes a null-terminated string to DataStream and zero-pads it to length\n  bytes. If length is not given, writes the string followed by a zero.\n  If string is longer than length, the written part of the string does not have\n  a trailing zero.\n\n  @param {string} s The string to write.\n  @param {?number} length The number of characters to write.\n */ DataStream.prototype.writeCString = function(s, length) {\n    var i1 = 0;\n    if (length != null) {\n        var len = Math.min(s.length, length);\n        for(i1 = 0; i1 < len; i1++)this.writeUint8(s.charCodeAt(i1));\n        for(; i1 < length; i1++)this.writeUint8(0);\n    } else {\n        for(i1 = 0; i1 < s.length; i1++)this.writeUint8(s.charCodeAt(i1));\n        this.writeUint8(0);\n    }\n};\n/**\n  Writes a struct to the DataStream. Takes a structDefinition that gives the\n  types and a struct object that gives the values. Refer to readStruct for the\n  structure of structDefinition.\n\n  @param {Object} structDefinition Type definition of the struct.\n  @param {Object} struct The struct data object.\n  */ DataStream.prototype.writeStruct = function(structDefinition, struct) {\n    for(var i1 = 0; i1 < structDefinition.length; i1 += 2){\n        var t = structDefinition[i1 + 1];\n        this.writeType(t, struct[structDefinition[i1]], struct);\n    }\n};\n/**\n  Writes object v of type t to the DataStream.\n\n  @param {Object} t Type of data to write.\n  @param {Object} v Value of data to write.\n  @param {Object} struct Struct to pass to write callback functions.\n  */ DataStream.prototype.writeType = function(t, v, struct) {\n    var tp;\n    if (typeof t == \"function\") return t(this, v);\n    else if (typeof t == \"object\" && !(t instanceof Array)) return t.set(this, v, struct);\n    var lengthOverride = null;\n    var charset = \"ASCII\";\n    var pos = this.position;\n    if (typeof t == 'string' && /:/.test(t)) {\n        tp = t.split(\":\");\n        t = tp[0];\n        lengthOverride = parseInt(tp[1]);\n    }\n    if (typeof t == 'string' && /,/.test(t)) {\n        tp = t.split(\",\");\n        t = tp[0];\n        charset = parseInt(tp[1]);\n    }\n    switch(t){\n        case 'uint8':\n            this.writeUint8(v);\n            break;\n        case 'int8':\n            this.writeInt8(v);\n            break;\n        case 'uint16':\n            this.writeUint16(v, this.endianness);\n            break;\n        case 'int16':\n            this.writeInt16(v, this.endianness);\n            break;\n        case 'uint32':\n            this.writeUint32(v, this.endianness);\n            break;\n        case 'int32':\n            this.writeInt32(v, this.endianness);\n            break;\n        case 'float32':\n            this.writeFloat32(v, this.endianness);\n            break;\n        case 'float64':\n            this.writeFloat64(v, this.endianness);\n            break;\n        case 'uint16be':\n            this.writeUint16(v, DataStream.BIG_ENDIAN);\n            break;\n        case 'int16be':\n            this.writeInt16(v, DataStream.BIG_ENDIAN);\n            break;\n        case 'uint32be':\n            this.writeUint32(v, DataStream.BIG_ENDIAN);\n            break;\n        case 'int32be':\n            this.writeInt32(v, DataStream.BIG_ENDIAN);\n            break;\n        case 'float32be':\n            this.writeFloat32(v, DataStream.BIG_ENDIAN);\n            break;\n        case 'float64be':\n            this.writeFloat64(v, DataStream.BIG_ENDIAN);\n            break;\n        case 'uint16le':\n            this.writeUint16(v, DataStream.LITTLE_ENDIAN);\n            break;\n        case 'int16le':\n            this.writeInt16(v, DataStream.LITTLE_ENDIAN);\n            break;\n        case 'uint32le':\n            this.writeUint32(v, DataStream.LITTLE_ENDIAN);\n            break;\n        case 'int32le':\n            this.writeInt32(v, DataStream.LITTLE_ENDIAN);\n            break;\n        case 'float32le':\n            this.writeFloat32(v, DataStream.LITTLE_ENDIAN);\n            break;\n        case 'float64le':\n            this.writeFloat64(v, DataStream.LITTLE_ENDIAN);\n            break;\n        case 'cstring':\n            this.writeCString(v, lengthOverride);\n            break;\n        case 'string':\n            this.writeString(v, charset, lengthOverride);\n            break;\n        case 'u16string':\n            this.writeUCS2String(v, this.endianness, lengthOverride);\n            break;\n        case 'u16stringle':\n            this.writeUCS2String(v, DataStream.LITTLE_ENDIAN, lengthOverride);\n            break;\n        case 'u16stringbe':\n            this.writeUCS2String(v, DataStream.BIG_ENDIAN, lengthOverride);\n            break;\n        default:\n            if (t.length == 3) {\n                var ta = t[1];\n                for(var i1 = 0; i1 < v.length; i1++)this.writeType(ta, v[i1]);\n                break;\n            } else {\n                this.writeStruct(t, v);\n                break;\n            }\n    }\n    if (lengthOverride != null) {\n        this.position = pos;\n        this._realloc(lengthOverride);\n        this.position = pos + lengthOverride;\n    }\n};\nDataStream.prototype.writeUint64 = function(v) {\n    var h = Math.floor(v / MAX_SIZE);\n    this.writeUint32(h);\n    this.writeUint32(v & 0xFFFFFFFF);\n};\nDataStream.prototype.writeUint24 = function(v) {\n    this.writeUint8((v & 0x00FF0000) >> 16);\n    this.writeUint8((v & 0x0000FF00) >> 8);\n    this.writeUint8(v & 0x000000FF);\n};\nDataStream.prototype.adjustUint32 = function(position, value) {\n    var pos = this.position;\n    this.seek(position);\n    this.writeUint32(value);\n    this.seek(pos);\n};\n// file:src/DataStream-map.js\n/**\n  Maps an Int32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int32Array to the DataStream backing buffer.\n  */ DataStream.prototype.mapInt32Array = function(length, e) {\n    this._realloc(length * 4);\n    var arr = new Int32Array(this._buffer, this.byteOffset + this.position, length);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += length * 4;\n    return arr;\n};\n/**\n  Maps an Int16Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int16Array to the DataStream backing buffer.\n  */ DataStream.prototype.mapInt16Array = function(length, e) {\n    this._realloc(length * 2);\n    var arr = new Int16Array(this._buffer, this.byteOffset + this.position, length);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += length * 2;\n    return arr;\n};\n/**\n  Maps an Int8Array into the DataStream buffer.\n\n  Nice for quickly reading in data.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int8Array to the DataStream backing buffer.\n  */ DataStream.prototype.mapInt8Array = function(length) {\n    this._realloc(length * 1);\n    var arr = new Int8Array(this._buffer, this.byteOffset + this.position, length);\n    this.position += length * 1;\n    return arr;\n};\n/**\n  Maps a Uint32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint32Array to the DataStream backing buffer.\n  */ DataStream.prototype.mapUint32Array = function(length, e) {\n    this._realloc(length * 4);\n    var arr = new Uint32Array(this._buffer, this.byteOffset + this.position, length);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += length * 4;\n    return arr;\n};\n/**\n  Maps a Uint16Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint16Array to the DataStream backing buffer.\n  */ DataStream.prototype.mapUint16Array = function(length, e) {\n    this._realloc(length * 2);\n    var arr = new Uint16Array(this._buffer, this.byteOffset + this.position, length);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += length * 2;\n    return arr;\n};\n/**\n  Maps a Float64Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Float64Array to the DataStream backing buffer.\n  */ DataStream.prototype.mapFloat64Array = function(length, e) {\n    this._realloc(length * 8);\n    var arr = new Float64Array(this._buffer, this.byteOffset + this.position, length);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += length * 8;\n    return arr;\n};\n/**\n  Maps a Float32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Float32Array to the DataStream backing buffer.\n  */ DataStream.prototype.mapFloat32Array = function(length, e) {\n    this._realloc(length * 4);\n    var arr = new Float32Array(this._buffer, this.byteOffset + this.position, length);\n    DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n    this.position += length * 4;\n    return arr;\n};\n// file:src/buffer.js\n/**\n * MultiBufferStream is a class that acts as a SimpleStream for parsing \n * It holds several, possibly non-contiguous ArrayBuffer objects, each with a fileStart property \n * containing the offset for the buffer data in an original/virtual file \n *\n * It inherits also from DataStream for all read/write/alloc operations\n */ /**\n * Constructor\n */ var MultiBufferStream = function(buffer) {\n    /* List of ArrayBuffers, with a fileStart property, sorted in fileStart order and non overlapping */ this.buffers = [];\n    this.bufferIndex = -1;\n    if (buffer) {\n        this.insertBuffer(buffer);\n        this.bufferIndex = 0;\n    }\n};\nMultiBufferStream.prototype = new DataStream(new ArrayBuffer(), 0, DataStream.BIG_ENDIAN);\n/************************************************************************************\n  Methods for the managnement of the buffers (insertion, removal, concatenation, ...)\n ***********************************************************************************/ MultiBufferStream.prototype.initialized = function() {\n    var firstBuffer;\n    if (this.bufferIndex > -1) return true;\n    else if (this.buffers.length > 0) {\n        firstBuffer = this.buffers[0];\n        if (firstBuffer.fileStart === 0) {\n            this.buffer = firstBuffer;\n            this.bufferIndex = 0;\n            Log.debug(\"MultiBufferStream\", \"Stream ready for parsing\");\n            return true;\n        } else {\n            Log.warn(\"MultiBufferStream\", \"The first buffer should have a fileStart of 0\");\n            this.logBufferLevel();\n            return false;\n        }\n    } else {\n        Log.warn(\"MultiBufferStream\", \"No buffer to start parsing from\");\n        this.logBufferLevel();\n        return false;\n    }\n};\n/**\n * helper functions to concatenate two ArrayBuffer objects\n * @param  {ArrayBuffer} buffer1 \n * @param  {ArrayBuffer} buffer2 \n * @return {ArrayBuffer} the concatenation of buffer1 and buffer2 in that order\n */ ArrayBuffer.concat = function(buffer1, buffer2) {\n    Log.debug(\"ArrayBuffer\", \"Trying to create a new buffer of size: \" + (buffer1.byteLength + buffer2.byteLength));\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp.buffer;\n};\n/**\n * Reduces the size of a given buffer, but taking the part between offset and offset+newlength\n * @param  {ArrayBuffer} buffer    \n * @param  {Number}      offset    the start of new buffer\n * @param  {Number}      newLength the length of the new buffer\n * @return {ArrayBuffer}           the new buffer\n */ MultiBufferStream.prototype.reduceBuffer = function(buffer, offset, newLength) {\n    var smallB;\n    smallB = new Uint8Array(newLength);\n    smallB.set(new Uint8Array(buffer, offset, newLength));\n    smallB.buffer.fileStart = buffer.fileStart + offset;\n    smallB.buffer.usedBytes = 0;\n    return smallB.buffer;\n};\n/**\n * Inserts the new buffer in the sorted list of buffers,\n *  making sure, it is not overlapping with existing ones (possibly reducing its size).\n *  if the new buffer overrides/replaces the 0-th buffer (for instance because it is bigger), \n *  updates the DataStream buffer for parsing \n*/ MultiBufferStream.prototype.insertBuffer = function(ab) {\n    var to_add = true;\n    /* TODO: improve insertion if many buffers */ for(var i1 = 0; i1 < this.buffers.length; i1++){\n        var b = this.buffers[i1];\n        if (ab.fileStart <= b.fileStart) {\n            /* the insertion position is found */ if (ab.fileStart === b.fileStart) {\n                /* The new buffer overlaps with an existing buffer */ if (ab.byteLength > b.byteLength) {\n                    /* the new buffer is bigger than the existing one\n\t\t\t\t\t   remove the existing buffer and try again to insert \n\t\t\t\t\t   the new buffer to check overlap with the next ones */ this.buffers.splice(i1, 1);\n                    i1--;\n                    continue;\n                } else /* the new buffer is smaller than the existing one, just drop it */ Log.warn(\"MultiBufferStream\", \"Buffer (fileStart: \" + ab.fileStart + \" - Length: \" + ab.byteLength + \") already appended, ignoring\");\n            } else {\n                /* The beginning of the new buffer is not overlapping with an existing buffer\n\t\t\t\t   let's check the end of it */ if (ab.fileStart + ab.byteLength <= b.fileStart) ;\n                else /* There is some overlap, cut the new buffer short, and add it*/ ab = this.reduceBuffer(ab, 0, b.fileStart - ab.fileStart);\n                Log.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \" + ab.fileStart + \" - Length: \" + ab.byteLength + \")\");\n                this.buffers.splice(i1, 0, ab);\n                /* if this new buffer is inserted in the first place in the list of the buffer, \n\t\t\t\t   and the DataStream is initialized, make it the buffer used for parsing */ if (i1 === 0) this.buffer = ab;\n            }\n            to_add = false;\n            break;\n        } else if (ab.fileStart < b.fileStart + b.byteLength) {\n            /* the new buffer overlaps its beginning with the end of the current buffer */ var offset = b.fileStart + b.byteLength - ab.fileStart;\n            var newLength = ab.byteLength - offset;\n            if (newLength > 0) /* the new buffer is bigger than the current overlap, drop the overlapping part and try again inserting the remaining buffer */ ab = this.reduceBuffer(ab, offset, newLength);\n            else {\n                /* the content of the new buffer is entirely contained in the existing buffer, drop it entirely */ to_add = false;\n                break;\n            }\n        }\n    }\n    /* if the buffer has not been added, we can add it at the end */ if (to_add) {\n        Log.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \" + ab.fileStart + \" - Length: \" + ab.byteLength + \")\");\n        this.buffers.push(ab);\n        /* if this new buffer is inserted in the first place in the list of the buffer, \n\t\t   and the DataStream is initialized, make it the buffer used for parsing */ if (i1 === 0) this.buffer = ab;\n    }\n};\n/**\n * Displays the status of the buffers (number and used bytes)\n * @param  {Object} info callback method for display\n */ MultiBufferStream.prototype.logBufferLevel = function(info) {\n    var i1;\n    var buffer;\n    var used, total;\n    var ranges = [];\n    var range;\n    var bufferedString = \"\";\n    used = 0;\n    total = 0;\n    for(i1 = 0; i1 < this.buffers.length; i1++){\n        buffer = this.buffers[i1];\n        if (i1 === 0) {\n            range = {};\n            ranges.push(range);\n            range.start = buffer.fileStart;\n            range.end = buffer.fileStart + buffer.byteLength;\n            bufferedString += \"[\" + range.start + \"-\";\n        } else if (range.end === buffer.fileStart) range.end = buffer.fileStart + buffer.byteLength;\n        else {\n            range = {};\n            range.start = buffer.fileStart;\n            bufferedString += ranges[ranges.length - 1].end - 1 + \"], [\" + range.start + \"-\";\n            range.end = buffer.fileStart + buffer.byteLength;\n            ranges.push(range);\n        }\n        used += buffer.usedBytes;\n        total += buffer.byteLength;\n    }\n    if (ranges.length > 0) bufferedString += range.end - 1 + \"]\";\n    var log = info ? Log.info : Log.debug;\n    if (this.buffers.length === 0) log(\"MultiBufferStream\", \"No more buffer in memory\");\n    else log(\"MultiBufferStream\", \"\" + this.buffers.length + \" stored buffer(s) (\" + used + \"/\" + total + \" bytes), continuous ranges: \" + bufferedString);\n};\nMultiBufferStream.prototype.cleanBuffers = function() {\n    var i1;\n    var buffer;\n    for(i1 = 0; i1 < this.buffers.length; i1++){\n        buffer = this.buffers[i1];\n        if (buffer.usedBytes === buffer.byteLength) {\n            Log.debug(\"MultiBufferStream\", \"Removing buffer #\" + i1);\n            this.buffers.splice(i1, 1);\n            i1--;\n        }\n    }\n};\nMultiBufferStream.prototype.mergeNextBuffer = function() {\n    var next_buffer;\n    if (this.bufferIndex + 1 < this.buffers.length) {\n        next_buffer = this.buffers[this.bufferIndex + 1];\n        if (next_buffer.fileStart === this.buffer.fileStart + this.buffer.byteLength) {\n            var oldLength = this.buffer.byteLength;\n            var oldUsedBytes = this.buffer.usedBytes;\n            var oldFileStart = this.buffer.fileStart;\n            this.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, next_buffer);\n            this.buffer = this.buffers[this.bufferIndex];\n            this.buffers.splice(this.bufferIndex + 1, 1);\n            this.buffer.usedBytes = oldUsedBytes; /* TODO: should it be += ? */ \n            this.buffer.fileStart = oldFileStart;\n            Log.debug(\"ISOFile\", \"Concatenating buffer for box parsing (length: \" + oldLength + \"->\" + this.buffer.byteLength + \")\");\n            return true;\n        } else return false;\n    } else return false;\n};\n/*************************************************************************\n  Seek-related functions\n *************************************************************************/ /**\n * Finds the buffer that holds the given file position\n * @param  {Boolean} fromStart    indicates if the search should start from the current buffer (false) \n *                                or from the first buffer (true)\n * @param  {Number}  filePosition position in the file to seek to\n * @param  {Boolean} markAsUsed   indicates if the bytes in between the current position and the seek position \n *                                should be marked as used for garbage collection\n * @return {Number}               the index of the buffer holding the seeked file position, -1 if not found.\n */ MultiBufferStream.prototype.findPosition = function(fromStart, filePosition, markAsUsed) {\n    var i1;\n    var abuffer = null;\n    var index = -1;\n    /* find the buffer with the largest position smaller than the given position */ if (fromStart === true) /* the reposition can be in the past, we need to check from the beginning of the list of buffers */ i1 = 0;\n    else i1 = this.bufferIndex;\n    while(i1 < this.buffers.length){\n        abuffer = this.buffers[i1];\n        if (abuffer.fileStart <= filePosition) {\n            index = i1;\n            if (markAsUsed) {\n                if (abuffer.fileStart + abuffer.byteLength <= filePosition) abuffer.usedBytes = abuffer.byteLength;\n                else abuffer.usedBytes = filePosition - abuffer.fileStart;\n                this.logBufferLevel();\n            }\n        } else break;\n        i1++;\n    }\n    if (index !== -1) {\n        abuffer = this.buffers[index];\n        if (abuffer.fileStart + abuffer.byteLength >= filePosition) {\n            Log.debug(\"MultiBufferStream\", \"Found position in existing buffer #\" + index);\n            return index;\n        } else return -1;\n    } else return -1;\n};\n/**\n * Finds the largest file position contained in a buffer or in the next buffers if they are contiguous (no gap)\n * starting from the given buffer index or from the current buffer if the index is not given\n *\n * @param  {Number} inputindex Index of the buffer to start from\n * @return {Number}            The largest file position found in the buffers\n */ MultiBufferStream.prototype.findEndContiguousBuf = function(inputindex) {\n    var i1;\n    var currentBuf;\n    var nextBuf;\n    var index = inputindex !== undefined ? inputindex : this.bufferIndex;\n    currentBuf = this.buffers[index];\n    /* find the end of the contiguous range of data */ if (this.buffers.length > index + 1) for(i1 = index + 1; i1 < this.buffers.length; i1++){\n        nextBuf = this.buffers[i1];\n        if (nextBuf.fileStart === currentBuf.fileStart + currentBuf.byteLength) currentBuf = nextBuf;\n        else break;\n    }\n    /* return the position of last byte in the file that we have */ return currentBuf.fileStart + currentBuf.byteLength;\n};\n/**\n * Returns the largest file position contained in the buffers, larger than the given position\n * @param  {Number} pos the file position to start from\n * @return {Number}     the largest position in the current buffer or in the buffer and the next contiguous \n *                      buffer that holds the given position\n */ MultiBufferStream.prototype.getEndFilePositionAfter = function(pos) {\n    var index = this.findPosition(true, pos, false);\n    if (index !== -1) return this.findEndContiguousBuf(index);\n    else return pos;\n};\n/*************************************************************************\n  Garbage collection related functions\n *************************************************************************/ /**\n * Marks a given number of bytes as used in the current buffer for garbage collection\n * @param {Number} nbBytes \n */ MultiBufferStream.prototype.addUsedBytes = function(nbBytes) {\n    this.buffer.usedBytes += nbBytes;\n    this.logBufferLevel();\n};\n/**\n * Marks the entire current buffer as used, ready for garbage collection\n */ MultiBufferStream.prototype.setAllUsedBytes = function() {\n    this.buffer.usedBytes = this.buffer.byteLength;\n    this.logBufferLevel();\n};\n/*************************************************************************\n  Common API between MultiBufferStream and SimpleStream\n *************************************************************************/ /**\n * Tries to seek to a given file position\n * if possible, repositions the parsing from there and returns true \n * if not possible, does not change anything and returns false \n * @param  {Number}  filePosition position in the file to seek to\n * @param  {Boolean} fromStart    indicates if the search should start from the current buffer (false) \n *                                or from the first buffer (true)\n * @param  {Boolean} markAsUsed   indicates if the bytes in between the current position and the seek position \n *                                should be marked as used for garbage collection\n * @return {Boolean}              true if the seek succeeded, false otherwise\n */ MultiBufferStream.prototype.seek = function(filePosition, fromStart, markAsUsed) {\n    var index;\n    index = this.findPosition(fromStart, filePosition, markAsUsed);\n    if (index !== -1) {\n        this.buffer = this.buffers[index];\n        this.bufferIndex = index;\n        this.position = filePosition - this.buffer.fileStart;\n        Log.debug(\"MultiBufferStream\", \"Repositioning parser at buffer position: \" + this.position);\n        return true;\n    } else {\n        Log.debug(\"MultiBufferStream\", \"Position \" + filePosition + \" not found in buffered data\");\n        return false;\n    }\n};\n/**\n * Returns the current position in the file\n * @return {Number} the position in the file\n */ MultiBufferStream.prototype.getPosition = function() {\n    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null) throw \"Error accessing position in the MultiBufferStream\";\n    return this.buffers[this.bufferIndex].fileStart + this.position;\n};\n/**\n * Returns the length of the current buffer\n * @return {Number} the length of the current buffer\n */ MultiBufferStream.prototype.getLength = function() {\n    return this.byteLength;\n};\nMultiBufferStream.prototype.getEndPosition = function() {\n    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null) throw \"Error accessing position in the MultiBufferStream\";\n    return this.buffers[this.bufferIndex].fileStart + this.byteLength;\n};\nexports.MultiBufferStream = MultiBufferStream;\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ var MPEG4DescriptorParser = function() {\n    var ES_DescrTag = 0x03;\n    var DecoderConfigDescrTag = 0x04;\n    var DecSpecificInfoTag = 0x05;\n    var SLConfigDescrTag = 0x06;\n    var descTagToName = [];\n    descTagToName[ES_DescrTag] = \"ES_Descriptor\";\n    descTagToName[DecoderConfigDescrTag] = \"DecoderConfigDescriptor\";\n    descTagToName[DecSpecificInfoTag] = \"DecoderSpecificInfo\";\n    descTagToName[SLConfigDescrTag] = \"SLConfigDescriptor\";\n    this.getDescriptorName = function(tag) {\n        return descTagToName[tag];\n    };\n    var that = this;\n    var classes = {};\n    this.parseOneDescriptor = function(stream) {\n        var hdrSize = 0;\n        var size = 0;\n        var tag;\n        var desc;\n        var byteRead;\n        tag = stream.readUint8();\n        hdrSize++;\n        byteRead = stream.readUint8();\n        hdrSize++;\n        while(byteRead & 0x80){\n            size = (byteRead & 0x7F) << 7;\n            byteRead = stream.readUint8();\n            hdrSize++;\n        }\n        size += byteRead & 0x7F;\n        Log.debug(\"MPEG4DescriptorParser\", \"Found \" + (descTagToName[tag] || \"Descriptor \" + tag) + \", size \" + size + \" at position \" + stream.getPosition());\n        if (descTagToName[tag]) desc = new classes[descTagToName[tag]](size);\n        else desc = new classes.Descriptor(size);\n        desc.parse(stream);\n        return desc;\n    };\n    classes.Descriptor = function(_tag, _size) {\n        this.tag = _tag;\n        this.size = _size;\n        this.descs = [];\n    };\n    classes.Descriptor.prototype.parse = function(stream) {\n        this.data = stream.readUint8Array(this.size);\n    };\n    classes.Descriptor.prototype.findDescriptor = function(tag) {\n        for(var i1 = 0; i1 < this.descs.length; i1++){\n            if (this.descs[i1].tag == tag) return this.descs[i1];\n        }\n        return null;\n    };\n    classes.Descriptor.prototype.parseRemainingDescriptors = function(stream) {\n        var start = stream.position;\n        while(stream.position < start + this.size){\n            var desc = that.parseOneDescriptor(stream);\n            this.descs.push(desc);\n        }\n    };\n    classes.ES_Descriptor = function(size) {\n        classes.Descriptor.call(this, ES_DescrTag, size);\n    };\n    classes.ES_Descriptor.prototype = new classes.Descriptor();\n    classes.ES_Descriptor.prototype.parse = function(stream) {\n        this.ES_ID = stream.readUint16();\n        this.flags = stream.readUint8();\n        this.size -= 3;\n        if (this.flags & 0x80) {\n            this.dependsOn_ES_ID = stream.readUint16();\n            this.size -= 2;\n        } else this.dependsOn_ES_ID = 0;\n        if (this.flags & 0x40) {\n            var l = stream.readUint8();\n            this.URL = stream.readString(l);\n            this.size -= l + 1;\n        } else this.URL = \"\";\n        if (this.flags & 0x20) {\n            this.OCR_ES_ID = stream.readUint16();\n            this.size -= 2;\n        } else this.OCR_ES_ID = 0;\n        this.parseRemainingDescriptors(stream);\n    };\n    classes.ES_Descriptor.prototype.getOTI = function(stream) {\n        var dcd = this.findDescriptor(DecoderConfigDescrTag);\n        if (dcd) return dcd.oti;\n        else return 0;\n    };\n    classes.ES_Descriptor.prototype.getAudioConfig = function(stream) {\n        var dcd = this.findDescriptor(DecoderConfigDescrTag);\n        if (!dcd) return null;\n        var dsi = dcd.findDescriptor(DecSpecificInfoTag);\n        if (dsi && dsi.data) {\n            var audioObjectType = (dsi.data[0] & 0xF8) >> 3;\n            if (audioObjectType === 31 && dsi.data.length >= 2) audioObjectType = 32 + ((dsi.data[0] & 0x7) << 3) + ((dsi.data[1] & 0xE0) >> 5);\n            return audioObjectType;\n        } else return null;\n    };\n    classes.DecoderConfigDescriptor = function(size) {\n        classes.Descriptor.call(this, DecoderConfigDescrTag, size);\n    };\n    classes.DecoderConfigDescriptor.prototype = new classes.Descriptor();\n    classes.DecoderConfigDescriptor.prototype.parse = function(stream) {\n        this.oti = stream.readUint8();\n        this.streamType = stream.readUint8();\n        this.upStream = (this.streamType >> 1 & 1) !== 0;\n        this.streamType = this.streamType >>> 2;\n        this.bufferSize = stream.readUint24();\n        this.maxBitrate = stream.readUint32();\n        this.avgBitrate = stream.readUint32();\n        this.size -= 13;\n        this.parseRemainingDescriptors(stream);\n    };\n    classes.DecoderSpecificInfo = function(size) {\n        classes.Descriptor.call(this, DecSpecificInfoTag, size);\n    };\n    classes.DecoderSpecificInfo.prototype = new classes.Descriptor();\n    classes.SLConfigDescriptor = function(size) {\n        classes.Descriptor.call(this, SLConfigDescrTag, size);\n    };\n    classes.SLConfigDescriptor.prototype = new classes.Descriptor();\n    return this;\n};\nexports.MPEG4DescriptorParser = MPEG4DescriptorParser;\n// file:src/box.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ var BoxParser = {\n    ERR_INVALID_DATA: -1,\n    ERR_NOT_ENOUGH_DATA: 0,\n    OK: 1,\n    // Boxes to be created with default parsing\n    BASIC_BOXES: [\n        \"mdat\",\n        \"idat\",\n        \"free\",\n        \"skip\",\n        \"meco\",\n        \"strk\"\n    ],\n    FULL_BOXES: [\n        \"hmhd\",\n        \"nmhd\",\n        \"iods\",\n        \"xml \",\n        \"bxml\",\n        \"ipro\",\n        \"mere\"\n    ],\n    CONTAINER_BOXES: [\n        [\n            \"moov\",\n            [\n                \"trak\",\n                \"pssh\"\n            ]\n        ],\n        [\n            \"trak\"\n        ],\n        [\n            \"edts\"\n        ],\n        [\n            \"mdia\"\n        ],\n        [\n            \"minf\"\n        ],\n        [\n            \"dinf\"\n        ],\n        [\n            \"stbl\",\n            [\n                \"sgpd\",\n                \"sbgp\"\n            ]\n        ],\n        [\n            \"mvex\",\n            [\n                \"trex\"\n            ]\n        ],\n        [\n            \"moof\",\n            [\n                \"traf\"\n            ]\n        ],\n        [\n            \"traf\",\n            [\n                \"trun\",\n                \"sgpd\",\n                \"sbgp\"\n            ]\n        ],\n        [\n            \"vttc\"\n        ],\n        [\n            \"tref\"\n        ],\n        [\n            \"iref\"\n        ],\n        [\n            \"mfra\",\n            [\n                \"tfra\"\n            ]\n        ],\n        [\n            \"meco\"\n        ],\n        [\n            \"hnti\"\n        ],\n        [\n            \"hinf\"\n        ],\n        [\n            \"strk\"\n        ],\n        [\n            \"strd\"\n        ],\n        [\n            \"sinf\"\n        ],\n        [\n            \"rinf\"\n        ],\n        [\n            \"schi\"\n        ],\n        [\n            \"trgr\"\n        ],\n        [\n            \"udta\",\n            [\n                \"kind\"\n            ]\n        ],\n        [\n            \"iprp\",\n            [\n                \"ipma\"\n            ]\n        ],\n        [\n            \"ipco\"\n        ],\n        [\n            \"grpl\"\n        ],\n        [\n            \"j2kH\"\n        ],\n        [\n            \"etyp\",\n            [\n                \"tyco\"\n            ]\n        ]\n    ],\n    // Boxes effectively created\n    boxCodes: [],\n    fullBoxCodes: [],\n    containerBoxCodes: [],\n    sampleEntryCodes: {},\n    sampleGroupEntryCodes: [],\n    trackGroupTypes: [],\n    UUIDBoxes: {},\n    UUIDs: [],\n    initialize: function() {\n        BoxParser.FullBox.prototype = new BoxParser.Box();\n        BoxParser.ContainerBox.prototype = new BoxParser.Box();\n        BoxParser.SampleEntry.prototype = new BoxParser.Box();\n        BoxParser.TrackGroupTypeBox.prototype = new BoxParser.FullBox();\n        /* creating constructors for simple boxes */ BoxParser.BASIC_BOXES.forEach(function(type) {\n            BoxParser.createBoxCtor(type);\n        });\n        BoxParser.FULL_BOXES.forEach(function(type) {\n            BoxParser.createFullBoxCtor(type);\n        });\n        BoxParser.CONTAINER_BOXES.forEach(function(types) {\n            BoxParser.createContainerBoxCtor(types[0], null, types[1]);\n        });\n    },\n    Box: function(_type, _size, _uuid) {\n        this.type = _type;\n        this.size = _size;\n        this.uuid = _uuid;\n    },\n    FullBox: function(type, size, uuid) {\n        BoxParser.Box.call(this, type, size, uuid);\n        this.flags = 0;\n        this.version = 0;\n    },\n    ContainerBox: function(type, size, uuid) {\n        BoxParser.Box.call(this, type, size, uuid);\n        this.boxes = [];\n    },\n    SampleEntry: function(type, size, hdr_size, start) {\n        BoxParser.ContainerBox.call(this, type, size);\n        this.hdr_size = hdr_size;\n        this.start = start;\n    },\n    SampleGroupEntry: function(type) {\n        this.grouping_type = type;\n    },\n    TrackGroupTypeBox: function(type, size) {\n        BoxParser.FullBox.call(this, type, size);\n    },\n    createBoxCtor: function(type, parseMethod) {\n        BoxParser.boxCodes.push(type);\n        BoxParser[type + \"Box\"] = function(size) {\n            BoxParser.Box.call(this, type, size);\n        };\n        BoxParser[type + \"Box\"].prototype = new BoxParser.Box();\n        if (parseMethod) BoxParser[type + \"Box\"].prototype.parse = parseMethod;\n    },\n    createFullBoxCtor: function(type, parseMethod) {\n        //BoxParser.fullBoxCodes.push(type);\n        BoxParser[type + \"Box\"] = function(size) {\n            BoxParser.FullBox.call(this, type, size);\n        };\n        BoxParser[type + \"Box\"].prototype = new BoxParser.FullBox();\n        BoxParser[type + \"Box\"].prototype.parse = function(stream) {\n            this.parseFullHeader(stream);\n            if (parseMethod) parseMethod.call(this, stream);\n        };\n    },\n    addSubBoxArrays: function(subBoxNames) {\n        if (subBoxNames) {\n            this.subBoxNames = subBoxNames;\n            var nbSubBoxes = subBoxNames.length;\n            for(var k = 0; k < nbSubBoxes; k++)this[subBoxNames[k] + \"s\"] = [];\n        }\n    },\n    createContainerBoxCtor: function(type, parseMethod, subBoxNames) {\n        //BoxParser.containerBoxCodes.push(type);\n        BoxParser[type + \"Box\"] = function(size) {\n            BoxParser.ContainerBox.call(this, type, size);\n            BoxParser.addSubBoxArrays.call(this, subBoxNames);\n        };\n        BoxParser[type + \"Box\"].prototype = new BoxParser.ContainerBox();\n        if (parseMethod) BoxParser[type + \"Box\"].prototype.parse = parseMethod;\n    },\n    createMediaSampleEntryCtor: function(mediaType, parseMethod, subBoxNames) {\n        BoxParser.sampleEntryCodes[mediaType] = [];\n        BoxParser[mediaType + \"SampleEntry\"] = function(type, size) {\n            BoxParser.SampleEntry.call(this, type, size);\n            BoxParser.addSubBoxArrays.call(this, subBoxNames);\n        };\n        BoxParser[mediaType + \"SampleEntry\"].prototype = new BoxParser.SampleEntry();\n        if (parseMethod) BoxParser[mediaType + \"SampleEntry\"].prototype.parse = parseMethod;\n    },\n    createSampleEntryCtor: function(mediaType, type, parseMethod, subBoxNames) {\n        BoxParser.sampleEntryCodes[mediaType].push(type);\n        BoxParser[type + \"SampleEntry\"] = function(size) {\n            BoxParser[mediaType + \"SampleEntry\"].call(this, type, size);\n            BoxParser.addSubBoxArrays.call(this, subBoxNames);\n        };\n        BoxParser[type + \"SampleEntry\"].prototype = new BoxParser[mediaType + \"SampleEntry\"]();\n        if (parseMethod) BoxParser[type + \"SampleEntry\"].prototype.parse = parseMethod;\n    },\n    createEncryptedSampleEntryCtor: function(mediaType, type, parseMethod) {\n        BoxParser.createSampleEntryCtor.call(this, mediaType, type, parseMethod, [\n            \"sinf\"\n        ]);\n    },\n    createSampleGroupCtor: function(type, parseMethod) {\n        //BoxParser.sampleGroupEntryCodes.push(type);\n        BoxParser[type + \"SampleGroupEntry\"] = function(size) {\n            BoxParser.SampleGroupEntry.call(this, type, size);\n        };\n        BoxParser[type + \"SampleGroupEntry\"].prototype = new BoxParser.SampleGroupEntry();\n        if (parseMethod) BoxParser[type + \"SampleGroupEntry\"].prototype.parse = parseMethod;\n    },\n    createTrackGroupCtor: function(type, parseMethod) {\n        //BoxParser.trackGroupTypes.push(type);\n        BoxParser[type + \"TrackGroupTypeBox\"] = function(size) {\n            BoxParser.TrackGroupTypeBox.call(this, type, size);\n        };\n        BoxParser[type + \"TrackGroupTypeBox\"].prototype = new BoxParser.TrackGroupTypeBox();\n        if (parseMethod) BoxParser[type + \"TrackGroupTypeBox\"].prototype.parse = parseMethod;\n    },\n    createUUIDBox: function(uuid, isFullBox, isContainerBox, parseMethod) {\n        BoxParser.UUIDs.push(uuid);\n        BoxParser.UUIDBoxes[uuid] = function(size) {\n            if (isFullBox) BoxParser.FullBox.call(this, \"uuid\", size, uuid);\n            else if (isContainerBox) BoxParser.ContainerBox.call(this, \"uuid\", size, uuid);\n            else BoxParser.Box.call(this, \"uuid\", size, uuid);\n        };\n        BoxParser.UUIDBoxes[uuid].prototype = isFullBox ? new BoxParser.FullBox() : isContainerBox ? new BoxParser.ContainerBox() : new BoxParser.Box();\n        if (parseMethod) {\n            if (isFullBox) BoxParser.UUIDBoxes[uuid].prototype.parse = function(stream) {\n                this.parseFullHeader(stream);\n                if (parseMethod) parseMethod.call(this, stream);\n            };\n            else BoxParser.UUIDBoxes[uuid].prototype.parse = parseMethod;\n        }\n    }\n};\nBoxParser.initialize();\nBoxParser.TKHD_FLAG_ENABLED = 0x000001;\nBoxParser.TKHD_FLAG_IN_MOVIE = 0x000002;\nBoxParser.TKHD_FLAG_IN_PREVIEW = 0x000004;\nBoxParser.TFHD_FLAG_BASE_DATA_OFFSET = 0x01;\nBoxParser.TFHD_FLAG_SAMPLE_DESC = 0x02;\nBoxParser.TFHD_FLAG_SAMPLE_DUR = 0x08;\nBoxParser.TFHD_FLAG_SAMPLE_SIZE = 0x10;\nBoxParser.TFHD_FLAG_SAMPLE_FLAGS = 0x20;\nBoxParser.TFHD_FLAG_DUR_EMPTY = 0x10000;\nBoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF = 0x20000;\nBoxParser.TRUN_FLAGS_DATA_OFFSET = 0x01;\nBoxParser.TRUN_FLAGS_FIRST_FLAG = 0x04;\nBoxParser.TRUN_FLAGS_DURATION = 0x100;\nBoxParser.TRUN_FLAGS_SIZE = 0x200;\nBoxParser.TRUN_FLAGS_FLAGS = 0x400;\nBoxParser.TRUN_FLAGS_CTS_OFFSET = 0x800;\nBoxParser.Box.prototype.add = function(name) {\n    return this.addBox(new BoxParser[name + \"Box\"]());\n};\nBoxParser.Box.prototype.addBox = function(box1) {\n    this.boxes.push(box1);\n    if (this[box1.type + \"s\"]) this[box1.type + \"s\"].push(box1);\n    else this[box1.type] = box1;\n    return box1;\n};\nBoxParser.Box.prototype.set = function(prop, value) {\n    this[prop] = value;\n    return this;\n};\nBoxParser.Box.prototype.addEntry = function(value, _prop) {\n    var prop = _prop || \"entries\";\n    if (!this[prop]) this[prop] = [];\n    this[prop].push(value);\n    return this;\n};\nexports.BoxParser = BoxParser;\n// file:src/box-parse.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ BoxParser.parseUUID = function(stream) {\n    return BoxParser.parseHex16(stream);\n};\nBoxParser.parseHex16 = function(stream) {\n    var hex16 = \"\";\n    for(var i1 = 0; i1 < 16; i1++){\n        var hex = stream.readUint8().toString(16);\n        hex16 += hex.length === 1 ? \"0\" + hex : hex;\n    }\n    return hex16;\n};\nBoxParser.parseOneBox = function(stream, headerOnly, parentSize) {\n    var box1;\n    var start = stream.getPosition();\n    var hdr_size = 0;\n    var diff;\n    var uuid;\n    if (stream.getEndPosition() - start < 8) {\n        Log.debug(\"BoxParser\", \"Not enough data in stream to parse the type and size of the box\");\n        return {\n            code: BoxParser.ERR_NOT_ENOUGH_DATA\n        };\n    }\n    if (parentSize && parentSize < 8) {\n        Log.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a new box\");\n        return {\n            code: BoxParser.ERR_NOT_ENOUGH_DATA\n        };\n    }\n    var size = stream.readUint32();\n    var type = stream.readString(4);\n    var box_type = type;\n    Log.debug(\"BoxParser\", \"Found box of type '\" + type + \"' and size \" + size + \" at position \" + start);\n    hdr_size = 8;\n    if (type == \"uuid\") {\n        if (stream.getEndPosition() - stream.getPosition() < 16 || parentSize - hdr_size < 16) {\n            stream.seek(start);\n            Log.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a UUID box\");\n            return {\n                code: BoxParser.ERR_NOT_ENOUGH_DATA\n            };\n        }\n        uuid = BoxParser.parseUUID(stream);\n        hdr_size += 16;\n        box_type = uuid;\n    }\n    if (size == 1) {\n        if (stream.getEndPosition() - stream.getPosition() < 8 || parentSize && parentSize - hdr_size < 8) {\n            stream.seek(start);\n            Log.warn(\"BoxParser\", \"Not enough data in stream to parse the extended size of the \\\"\" + type + \"\\\" box\");\n            return {\n                code: BoxParser.ERR_NOT_ENOUGH_DATA\n            };\n        }\n        size = stream.readUint64();\n        hdr_size += 8;\n    } else if (size === 0) {\n        /* box extends till the end of file or invalid file */ if (parentSize) size = parentSize;\n        else /* box extends till the end of file */ if (type !== \"mdat\") {\n            Log.error(\"BoxParser\", \"Unlimited box size not supported for type: '\" + type + \"'\");\n            box1 = new BoxParser.Box(type, size);\n            return {\n                code: BoxParser.OK,\n                box: box1,\n                size: box1.size\n            };\n        }\n    }\n    if (size !== 0 && size < hdr_size) {\n        Log.error(\"BoxParser\", \"Box of type \" + type + \" has an invalid size \" + size + \" (too small to be a box)\");\n        return {\n            code: BoxParser.ERR_NOT_ENOUGH_DATA,\n            type: type,\n            size: size,\n            hdr_size: hdr_size,\n            start: start\n        };\n    }\n    if (size !== 0 && parentSize && size > parentSize) {\n        Log.error(\"BoxParser\", \"Box of type '\" + type + \"' has a size \" + size + \" greater than its container size \" + parentSize);\n        return {\n            code: BoxParser.ERR_NOT_ENOUGH_DATA,\n            type: type,\n            size: size,\n            hdr_size: hdr_size,\n            start: start\n        };\n    }\n    if (size !== 0 && start + size > stream.getEndPosition()) {\n        stream.seek(start);\n        Log.info(\"BoxParser\", \"Not enough data in stream to parse the entire '\" + type + \"' box\");\n        return {\n            code: BoxParser.ERR_NOT_ENOUGH_DATA,\n            type: type,\n            size: size,\n            hdr_size: hdr_size,\n            start: start\n        };\n    }\n    if (headerOnly) return {\n        code: BoxParser.OK,\n        type: type,\n        size: size,\n        hdr_size: hdr_size,\n        start: start\n    };\n    else if (BoxParser[type + \"Box\"]) box1 = new BoxParser[type + \"Box\"](size);\n    else {\n        if (type !== \"uuid\") {\n            Log.warn(\"BoxParser\", \"Unknown box type: '\" + type + \"'\");\n            box1 = new BoxParser.Box(type, size);\n            box1.has_unparsed_data = true;\n        } else if (BoxParser.UUIDBoxes[uuid]) box1 = new BoxParser.UUIDBoxes[uuid](size);\n        else {\n            Log.warn(\"BoxParser\", \"Unknown uuid type: '\" + uuid + \"'\");\n            box1 = new BoxParser.Box(type, size);\n            box1.uuid = uuid;\n            box1.has_unparsed_data = true;\n        }\n    }\n    box1.hdr_size = hdr_size;\n    /* recording the position of the box in the input stream */ box1.start = start;\n    if (box1.write === BoxParser.Box.prototype.write && box1.type !== \"mdat\") {\n        Log.info(\"BoxParser\", \"'\" + box_type + \"' box writing not yet implemented, keeping unparsed data in memory for later write\");\n        box1.parseDataAndRewind(stream);\n    }\n    box1.parse(stream);\n    diff = stream.getPosition() - (box1.start + box1.size);\n    if (diff < 0) {\n        Log.warn(\"BoxParser\", \"Parsing of box '\" + box_type + \"' did not read the entire indicated box data size (missing \" + -diff + \" bytes), seeking forward\");\n        stream.seek(box1.start + box1.size);\n    } else if (diff > 0) {\n        Log.error(\"BoxParser\", \"Parsing of box '\" + box_type + \"' read \" + diff + \" more bytes than the indicated box data size, seeking backwards\");\n        if (box1.size !== 0) stream.seek(box1.start + box1.size);\n    }\n    return {\n        code: BoxParser.OK,\n        box: box1,\n        size: box1.size\n    };\n};\nBoxParser.Box.prototype.parse = function(stream) {\n    if (this.type != \"mdat\") this.data = stream.readUint8Array(this.size - this.hdr_size);\n    else if (this.size === 0) stream.seek(stream.getEndPosition());\n    else stream.seek(this.start + this.size);\n};\n/* Used to parse a box without consuming its data, to allow detailled parsing\n   Useful for boxes for which a write method is not yet implemented */ BoxParser.Box.prototype.parseDataAndRewind = function(stream) {\n    this.data = stream.readUint8Array(this.size - this.hdr_size);\n    // rewinding\n    stream.position -= this.size - this.hdr_size;\n};\nBoxParser.FullBox.prototype.parseDataAndRewind = function(stream) {\n    this.parseFullHeader(stream);\n    this.data = stream.readUint8Array(this.size - this.hdr_size);\n    // restore the header size as if the full header had not been parsed\n    this.hdr_size -= 4;\n    // rewinding\n    stream.position -= this.size - this.hdr_size;\n};\nBoxParser.FullBox.prototype.parseFullHeader = function(stream) {\n    this.version = stream.readUint8();\n    this.flags = stream.readUint24();\n    this.hdr_size += 4;\n};\nBoxParser.FullBox.prototype.parse = function(stream) {\n    this.parseFullHeader(stream);\n    this.data = stream.readUint8Array(this.size - this.hdr_size);\n};\nBoxParser.ContainerBox.prototype.parse = function(stream) {\n    var ret1;\n    var box1;\n    while(stream.getPosition() < this.start + this.size){\n        ret1 = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n        if (ret1.code === BoxParser.OK) {\n            box1 = ret1.box;\n            /* store the box in the 'boxes' array to preserve box order (for offset) but also store box in a property for more direct access */ this.boxes.push(box1);\n            if (this.subBoxNames && this.subBoxNames.indexOf(box1.type) != -1) this[this.subBoxNames[this.subBoxNames.indexOf(box1.type)] + \"s\"].push(box1);\n            else {\n                var box_type = box1.type !== \"uuid\" ? box1.type : box1.uuid;\n                if (this[box_type]) Log.warn(\"Box of type \" + box_type + \" already stored in field of this type\");\n                else this[box_type] = box1;\n            }\n        } else return;\n    }\n};\nBoxParser.Box.prototype.parseLanguage = function(stream) {\n    this.language = stream.readUint16();\n    var chars = [];\n    chars[0] = this.language >> 10 & 0x1F;\n    chars[1] = this.language >> 5 & 0x1F;\n    chars[2] = this.language & 0x1F;\n    this.languageString = String.fromCharCode(chars[0] + 0x60, chars[1] + 0x60, chars[2] + 0x60);\n};\n// file:src/parsing/sampleentries/sampleentry.js\nBoxParser.SAMPLE_ENTRY_TYPE_VISUAL = \"Visual\";\nBoxParser.SAMPLE_ENTRY_TYPE_AUDIO = \"Audio\";\nBoxParser.SAMPLE_ENTRY_TYPE_HINT = \"Hint\";\nBoxParser.SAMPLE_ENTRY_TYPE_METADATA = \"Metadata\";\nBoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE = \"Subtitle\";\nBoxParser.SAMPLE_ENTRY_TYPE_SYSTEM = \"System\";\nBoxParser.SAMPLE_ENTRY_TYPE_TEXT = \"Text\";\nBoxParser.SampleEntry.prototype.parseHeader = function(stream) {\n    stream.readUint8Array(6);\n    this.data_reference_index = stream.readUint16();\n    this.hdr_size += 8;\n};\nBoxParser.SampleEntry.prototype.parse = function(stream) {\n    this.parseHeader(stream);\n    this.data = stream.readUint8Array(this.size - this.hdr_size);\n};\nBoxParser.SampleEntry.prototype.parseDataAndRewind = function(stream) {\n    this.parseHeader(stream);\n    this.data = stream.readUint8Array(this.size - this.hdr_size);\n    // restore the header size as if the sample entry header had not been parsed\n    this.hdr_size -= 8;\n    // rewinding\n    stream.position -= this.size - this.hdr_size;\n};\nBoxParser.SampleEntry.prototype.parseFooter = function(stream) {\n    BoxParser.ContainerBox.prototype.parse.call(this, stream);\n};\n// Base SampleEntry types with default parsing\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_HINT);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_TEXT);\n//Base SampleEntry types for Audio and Video with specific parsing\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, function(stream) {\n    var compressorname_length;\n    this.parseHeader(stream);\n    stream.readUint16();\n    stream.readUint16();\n    stream.readUint32Array(3);\n    this.width = stream.readUint16();\n    this.height = stream.readUint16();\n    this.horizresolution = stream.readUint32();\n    this.vertresolution = stream.readUint32();\n    stream.readUint32();\n    this.frame_count = stream.readUint16();\n    compressorname_length = Math.min(31, stream.readUint8());\n    this.compressorname = stream.readString(compressorname_length);\n    if (compressorname_length < 31) stream.readString(31 - compressorname_length);\n    this.depth = stream.readUint16();\n    stream.readUint16();\n    this.parseFooter(stream);\n});\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, function(stream) {\n    this.parseHeader(stream);\n    stream.readUint32Array(2);\n    this.channel_count = stream.readUint16();\n    this.samplesize = stream.readUint16();\n    stream.readUint16();\n    stream.readUint16();\n    this.samplerate = stream.readUint32() / 65536;\n    this.parseFooter(stream);\n});\n// Sample entries inheriting from Audio and Video\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc4\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"av01\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"dav1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"hvc1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"hev1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"hvt1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"lhe1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"dvh1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"dvhe\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vvc1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vvi1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vvs1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vvcN\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vp08\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vp09\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avs3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"j2ki\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"mjp2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"mjpg\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"uncv\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"mp4a\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"ac-3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"ac-4\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"ec-3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"Opus\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"mha1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"mha2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"mhm1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"mhm2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"fLaC\");\n// Encrypted sample entries\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"encv\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \"enca\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"encu\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM, \"encs\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_TEXT, \"enct\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"encm\");\n// file:src/parsing/a1lx.js\nBoxParser.createBoxCtor(\"a1lx\", function(stream) {\n    var large_size = stream.readUint8() & 1;\n    var FieldLength = ((large_size & 1) + 1) * 16;\n    this.layer_size = [];\n    for(var i1 = 0; i1 < 3; i1++)if (FieldLength == 16) this.layer_size[i1] = stream.readUint16();\n    else this.layer_size[i1] = stream.readUint32();\n}); // file:src/parsing/a1op.js\nBoxParser.createBoxCtor(\"a1op\", function(stream) {\n    this.op_index = stream.readUint8();\n}); // file:src/parsing/auxC.js\nBoxParser.createFullBoxCtor(\"auxC\", function(stream) {\n    this.aux_type = stream.readCString();\n    var aux_subtype_length = this.size - this.hdr_size - (this.aux_type.length + 1);\n    this.aux_subtype = stream.readUint8Array(aux_subtype_length);\n}); // file:src/parsing/av1C.js\nBoxParser.createBoxCtor(\"av1C\", function(stream) {\n    var i1;\n    var toparse;\n    var tmp = stream.readUint8();\n    if (tmp >> 7 & false) {\n        Log.error(\"av1C marker problem\");\n        return;\n    }\n    this.version = tmp & 0x7F;\n    if (this.version !== 1) {\n        Log.error(\"av1C version \" + this.version + \" not supported\");\n        return;\n    }\n    tmp = stream.readUint8();\n    this.seq_profile = tmp >> 5 & 0x7;\n    this.seq_level_idx_0 = tmp & 0x1F;\n    tmp = stream.readUint8();\n    this.seq_tier_0 = tmp >> 7 & 0x1;\n    this.high_bitdepth = tmp >> 6 & 0x1;\n    this.twelve_bit = tmp >> 5 & 0x1;\n    this.monochrome = tmp >> 4 & 0x1;\n    this.chroma_subsampling_x = tmp >> 3 & 0x1;\n    this.chroma_subsampling_y = tmp >> 2 & 0x1;\n    this.chroma_sample_position = tmp & 0x3;\n    tmp = stream.readUint8();\n    this.reserved_1 = tmp >> 5 & 0x7;\n    if (this.reserved_1 !== 0) {\n        Log.error(\"av1C reserved_1 parsing problem\");\n        return;\n    }\n    this.initial_presentation_delay_present = tmp >> 4 & 0x1;\n    if (this.initial_presentation_delay_present === 1) this.initial_presentation_delay_minus_one = tmp & 0xF;\n    else {\n        this.reserved_2 = tmp & 0xF;\n        if (this.reserved_2 !== 0) {\n            Log.error(\"av1C reserved_2 parsing problem\");\n            return;\n        }\n    }\n    var configOBUs_length = this.size - this.hdr_size - 4;\n    this.configOBUs = stream.readUint8Array(configOBUs_length);\n});\n// file:src/parsing/avcC.js\nBoxParser.createBoxCtor(\"avcC\", function(stream) {\n    var i1;\n    var toparse;\n    this.configurationVersion = stream.readUint8();\n    this.AVCProfileIndication = stream.readUint8();\n    this.profile_compatibility = stream.readUint8();\n    this.AVCLevelIndication = stream.readUint8();\n    this.lengthSizeMinusOne = stream.readUint8() & 0x3;\n    this.nb_SPS_nalus = stream.readUint8() & 0x1F;\n    toparse = this.size - this.hdr_size - 6;\n    this.SPS = [];\n    for(i1 = 0; i1 < this.nb_SPS_nalus; i1++){\n        this.SPS[i1] = {};\n        this.SPS[i1].length = stream.readUint16();\n        this.SPS[i1].nalu = stream.readUint8Array(this.SPS[i1].length);\n        toparse -= 2 + this.SPS[i1].length;\n    }\n    this.nb_PPS_nalus = stream.readUint8();\n    toparse--;\n    this.PPS = [];\n    for(i1 = 0; i1 < this.nb_PPS_nalus; i1++){\n        this.PPS[i1] = {};\n        this.PPS[i1].length = stream.readUint16();\n        this.PPS[i1].nalu = stream.readUint8Array(this.PPS[i1].length);\n        toparse -= 2 + this.PPS[i1].length;\n    }\n    if (toparse > 0) this.ext = stream.readUint8Array(toparse);\n});\n// file:src/parsing/btrt.js\nBoxParser.createBoxCtor(\"btrt\", function(stream) {\n    this.bufferSizeDB = stream.readUint32();\n    this.maxBitrate = stream.readUint32();\n    this.avgBitrate = stream.readUint32();\n});\n// file:src/parsing/ccst.js\nBoxParser.createFullBoxCtor(\"ccst\", function(stream) {\n    var flags = stream.readUint8();\n    this.all_ref_pics_intra = (flags & 0x80) == 0x80;\n    this.intra_pred_used = (flags & 0x40) == 0x40;\n    this.max_ref_per_pic = (flags & 0x3f) >> 2;\n    stream.readUint24();\n});\n// file:src/parsing/cdef.js\nBoxParser.createBoxCtor(\"cdef\", function(stream) {\n    var i1;\n    this.channel_count = stream.readUint16();\n    this.channel_indexes = [];\n    this.channel_types = [];\n    this.channel_associations = [];\n    for(i1 = 0; i1 < this.channel_count; i1++){\n        this.channel_indexes.push(stream.readUint16());\n        this.channel_types.push(stream.readUint16());\n        this.channel_associations.push(stream.readUint16());\n    }\n});\n// file:src/parsing/clap.js\nBoxParser.createBoxCtor(\"clap\", function(stream) {\n    this.cleanApertureWidthN = stream.readUint32();\n    this.cleanApertureWidthD = stream.readUint32();\n    this.cleanApertureHeightN = stream.readUint32();\n    this.cleanApertureHeightD = stream.readUint32();\n    this.horizOffN = stream.readUint32();\n    this.horizOffD = stream.readUint32();\n    this.vertOffN = stream.readUint32();\n    this.vertOffD = stream.readUint32();\n}); // file:src/parsing/clli.js\nBoxParser.createBoxCtor(\"clli\", function(stream) {\n    this.max_content_light_level = stream.readUint16();\n    this.max_pic_average_light_level = stream.readUint16();\n});\n// file:src/parsing/cmex.js\nBoxParser.createFullBoxCtor(\"cmex\", function(stream) {\n    if (this.flags & 0x1) this.pos_x = stream.readInt32();\n    if (this.flags & 0x2) this.pos_y = stream.readInt32();\n    if (this.flags & 0x4) this.pos_z = stream.readInt32();\n    if (this.flags & 0x8) {\n        if (this.version == 0) {\n            if (this.flags & 0x10) {\n                this.quat_x = stream.readInt32();\n                this.quat_y = stream.readInt32();\n                this.quat_z = stream.readInt32();\n            } else {\n                this.quat_x = stream.readInt16();\n                this.quat_y = stream.readInt16();\n                this.quat_z = stream.readInt16();\n            }\n        } else this.version;\n    }\n    if (this.flags & 0x20) this.id = stream.readUint32();\n});\n// file:src/parsing/cmin.js\nBoxParser.createFullBoxCtor(\"cmin\", function(stream) {\n    this.focal_length_x = stream.readInt32();\n    this.principal_point_x = stream.readInt32();\n    this.principal_point_y = stream.readInt32();\n    if (this.flags & 0x1) {\n        this.focal_length_y = stream.readInt32();\n        this.skew_factor = stream.readInt32();\n    }\n}); // file:src/parsing/cmpd.js\nBoxParser.createBoxCtor(\"cmpd\", function(stream) {\n    this.component_count = stream.readUint32();\n    this.component_types = [];\n    this.component_type_urls = [];\n    for(i = 0; i < this.component_count; i++){\n        var component_type = stream.readUint16();\n        this.component_types.push(component_type);\n        if (component_type >= 0x8000) this.component_type_urls.push(stream.readCString());\n    }\n}); // file:src/parsing/co64.js\nBoxParser.createFullBoxCtor(\"co64\", function(stream) {\n    var entry_count1;\n    var i1;\n    entry_count1 = stream.readUint32();\n    this.chunk_offsets = [];\n    if (this.version === 0) for(i1 = 0; i1 < entry_count1; i1++)this.chunk_offsets.push(stream.readUint64());\n});\n// file:src/parsing/CoLL.js\nBoxParser.createFullBoxCtor(\"CoLL\", function(stream) {\n    this.maxCLL = stream.readUint16();\n    this.maxFALL = stream.readUint16();\n});\n// file:src/parsing/colr.js\nBoxParser.createBoxCtor(\"colr\", function(stream) {\n    this.colour_type = stream.readString(4);\n    if (this.colour_type === 'nclx') {\n        this.colour_primaries = stream.readUint16();\n        this.transfer_characteristics = stream.readUint16();\n        this.matrix_coefficients = stream.readUint16();\n        var tmp = stream.readUint8();\n        this.full_range_flag = tmp >> 7;\n    } else if (this.colour_type === 'rICC') this.ICC_profile = stream.readUint8Array(this.size - 4);\n    else if (this.colour_type === 'prof') this.ICC_profile = stream.readUint8Array(this.size - 4);\n}); // file:src/parsing/cprt.js\nBoxParser.createFullBoxCtor(\"cprt\", function(stream) {\n    this.parseLanguage(stream);\n    this.notice = stream.readCString();\n});\n// file:src/parsing/cslg.js\nBoxParser.createFullBoxCtor(\"cslg\", function(stream) {\n    var entry_count1;\n    if (this.version === 0) {\n        this.compositionToDTSShift = stream.readInt32(); /* signed */ \n        this.leastDecodeToDisplayDelta = stream.readInt32(); /* signed */ \n        this.greatestDecodeToDisplayDelta = stream.readInt32(); /* signed */ \n        this.compositionStartTime = stream.readInt32(); /* signed */ \n        this.compositionEndTime = stream.readInt32(); /* signed */ \n    }\n});\n// file:src/parsing/ctts.js\nBoxParser.createFullBoxCtor(\"ctts\", function(stream) {\n    var entry_count1;\n    var i1;\n    entry_count1 = stream.readUint32();\n    this.sample_counts = [];\n    this.sample_offsets = [];\n    if (this.version === 0) for(i1 = 0; i1 < entry_count1; i1++){\n        this.sample_counts.push(stream.readUint32());\n        /* some files are buggy and declare version=0 while using signed offsets.\n\t\t\t   The likelyhood of using the most significant bit in a 32-bits time offset is very low,\n\t\t\t   so using signed value here as well */ var value = stream.readInt32();\n        if (value < 0) Log.warn(\"BoxParser\", \"ctts box uses negative values without using version 1\");\n        this.sample_offsets.push(value);\n    }\n    else if (this.version == 1) for(i1 = 0; i1 < entry_count1; i1++){\n        this.sample_counts.push(stream.readUint32());\n        this.sample_offsets.push(stream.readInt32()); /* signed */ \n    }\n});\n// file:src/parsing/dac3.js\nBoxParser.createBoxCtor(\"dac3\", function(stream) {\n    var tmp_byte1 = stream.readUint8();\n    var tmp_byte2 = stream.readUint8();\n    var tmp_byte3 = stream.readUint8();\n    this.fscod = tmp_byte1 >> 6;\n    this.bsid = tmp_byte1 >> 1 & 0x1F;\n    this.bsmod = (tmp_byte1 & 0x1) << 2 | tmp_byte2 >> 6 & 0x3;\n    this.acmod = tmp_byte2 >> 3 & 0x7;\n    this.lfeon = tmp_byte2 >> 2 & 0x1;\n    this.bit_rate_code = tmp_byte2 & 0x3 | tmp_byte3 >> 5 & 0x7;\n});\n// file:src/parsing/dec3.js\nBoxParser.createBoxCtor(\"dec3\", function(stream) {\n    var tmp_16 = stream.readUint16();\n    this.data_rate = tmp_16 >> 3;\n    this.num_ind_sub = tmp_16 & 0x7;\n    this.ind_subs = [];\n    for(var i1 = 0; i1 < this.num_ind_sub + 1; i1++){\n        var ind_sub = {};\n        this.ind_subs.push(ind_sub);\n        var tmp_byte1 = stream.readUint8();\n        var tmp_byte2 = stream.readUint8();\n        var tmp_byte3 = stream.readUint8();\n        ind_sub.fscod = tmp_byte1 >> 6;\n        ind_sub.bsid = tmp_byte1 >> 1 & 0x1F;\n        ind_sub.bsmod = (tmp_byte1 & 0x1) << 4 | tmp_byte2 >> 4 & 0xF;\n        ind_sub.acmod = tmp_byte2 >> 1 & 0x7;\n        ind_sub.lfeon = tmp_byte2 & 0x1;\n        ind_sub.num_dep_sub = tmp_byte3 >> 1 & 0xF;\n        if (ind_sub.num_dep_sub > 0) ind_sub.chan_loc = (tmp_byte3 & 0x1) << 8 | stream.readUint8();\n    }\n});\n// file:src/parsing/dfLa.js\nBoxParser.createFullBoxCtor(\"dfLa\", function(stream) {\n    var BLOCKTYPE_MASK = 0x7F;\n    var LASTMETADATABLOCKFLAG_MASK = 0x80;\n    var boxesFound = [];\n    var knownBlockTypes = [\n        \"STREAMINFO\",\n        \"PADDING\",\n        \"APPLICATION\",\n        \"SEEKTABLE\",\n        \"VORBIS_COMMENT\",\n        \"CUESHEET\",\n        \"PICTURE\",\n        \"RESERVED\"\n    ];\n    // for (i=0; ; i++) { // to end of box\n    do {\n        var flagAndType = stream.readUint8();\n        var type = Math.min(flagAndType & BLOCKTYPE_MASK, knownBlockTypes.length - 1);\n        // if this is a STREAMINFO block, read the true samplerate since this\n        // can be different to the AudioSampleEntry samplerate.\n        if (!type) {\n            // read past all the other stuff\n            stream.readUint8Array(13);\n            // extract samplerate\n            this.samplerate = stream.readUint32() >> 12;\n            // read to end of STREAMINFO\n            stream.readUint8Array(20);\n        } else // not interested in other block types so just discard length bytes\n        stream.readUint8Array(stream.readUint24());\n        boxesFound.push(knownBlockTypes[type]);\n        if (!!(flagAndType & LASTMETADATABLOCKFLAG_MASK)) break;\n    }while (true);\n    this.numMetadataBlocks = boxesFound.length + \" (\" + boxesFound.join(\", \") + \")\";\n});\n// file:src/parsing/dimm.js\nBoxParser.createBoxCtor(\"dimm\", function(stream) {\n    this.bytessent = stream.readUint64();\n});\n// file:src/parsing/dmax.js\nBoxParser.createBoxCtor(\"dmax\", function(stream) {\n    this.time = stream.readUint32();\n});\n// file:src/parsing/dmed.js\nBoxParser.createBoxCtor(\"dmed\", function(stream) {\n    this.bytessent = stream.readUint64();\n});\n// file:src/parsing/dOps.js\nBoxParser.createBoxCtor(\"dOps\", function(stream) {\n    this.Version = stream.readUint8();\n    this.OutputChannelCount = stream.readUint8();\n    this.PreSkip = stream.readUint16();\n    this.InputSampleRate = stream.readUint32();\n    this.OutputGain = stream.readInt16();\n    this.ChannelMappingFamily = stream.readUint8();\n    if (this.ChannelMappingFamily !== 0) {\n        this.StreamCount = stream.readUint8();\n        this.CoupledCount = stream.readUint8();\n        this.ChannelMapping = [];\n        for(var i1 = 0; i1 < this.OutputChannelCount; i1++)this.ChannelMapping[i1] = stream.readUint8();\n    }\n});\n// file:src/parsing/dref.js\nBoxParser.createFullBoxCtor(\"dref\", function(stream) {\n    var ret1;\n    var box1;\n    this.entries = [];\n    var entry_count1 = stream.readUint32();\n    for(var i1 = 0; i1 < entry_count1; i1++){\n        ret1 = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n        if (ret1.code === BoxParser.OK) {\n            box1 = ret1.box;\n            this.entries.push(box1);\n        } else return;\n    }\n});\n// file:src/parsing/drep.js\nBoxParser.createBoxCtor(\"drep\", function(stream) {\n    this.bytessent = stream.readUint64();\n});\n// file:src/parsing/elng.js\nBoxParser.createFullBoxCtor(\"elng\", function(stream) {\n    this.extended_language = stream.readString(this.size - this.hdr_size);\n});\n// file:src/parsing/elst.js\nBoxParser.createFullBoxCtor(\"elst\", function(stream) {\n    this.entries = [];\n    var entry_count1 = stream.readUint32();\n    for(var i1 = 0; i1 < entry_count1; i1++){\n        var entry = {};\n        this.entries.push(entry);\n        if (this.version === 1) {\n            entry.segment_duration = stream.readUint64();\n            entry.media_time = stream.readInt64();\n        } else {\n            entry.segment_duration = stream.readUint32();\n            entry.media_time = stream.readInt32();\n        }\n        entry.media_rate_integer = stream.readInt16();\n        entry.media_rate_fraction = stream.readInt16();\n    }\n});\n// file:src/parsing/emsg.js\nBoxParser.createFullBoxCtor(\"emsg\", function(stream) {\n    if (this.version == 1) {\n        this.timescale = stream.readUint32();\n        this.presentation_time = stream.readUint64();\n        this.event_duration = stream.readUint32();\n        this.id = stream.readUint32();\n        this.scheme_id_uri = stream.readCString();\n        this.value = stream.readCString();\n    } else {\n        this.scheme_id_uri = stream.readCString();\n        this.value = stream.readCString();\n        this.timescale = stream.readUint32();\n        this.presentation_time_delta = stream.readUint32();\n        this.event_duration = stream.readUint32();\n        this.id = stream.readUint32();\n    }\n    var message_size = this.size - this.hdr_size - (16 + (this.scheme_id_uri.length + 1) + (this.value.length + 1));\n    if (this.version == 1) message_size -= 4;\n    this.message_data = stream.readUint8Array(message_size);\n});\n// file:src/parsing/EntityToGroup.js\n// ISO/IEC 14496-12:2022 Section 8.18.3 Entity to group box\nBoxParser.createEntityToGroupCtor = function(type, parseMethod) {\n    BoxParser[type + \"Box\"] = function(size) {\n        BoxParser.FullBox.call(this, type, size);\n    };\n    BoxParser[type + \"Box\"].prototype = new BoxParser.FullBox();\n    BoxParser[type + \"Box\"].prototype.parse = function(stream) {\n        this.parseFullHeader(stream);\n        if (parseMethod) parseMethod.call(this, stream);\n        else {\n            this.group_id = stream.readUint32();\n            this.num_entities_in_group = stream.readUint32();\n            this.entity_ids = [];\n            for(i = 0; i < this.num_entities_in_group; i++){\n                var entity_id = stream.readUint32();\n                this.entity_ids.push(entity_id);\n            }\n        }\n    };\n};\n// Auto exposure bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.2.1)\nBoxParser.createEntityToGroupCtor(\"aebr\");\n// Flash exposure bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.5.1)\nBoxParser.createEntityToGroupCtor(\"afbr\");\n// Album collection (ISO/IEC 23008-12:2022 Section 6.8.7.1)\nBoxParser.createEntityToGroupCtor(\"albc\");\n// Alternative entity (ISO/IEC 14496-12:2022 Section 8.18.3.1)\nBoxParser.createEntityToGroupCtor(\"altr\");\n// Burst image entity group (ISO/IEC 23008-12:2022 Section 6.8.2.2)\nBoxParser.createEntityToGroupCtor(\"brst\");\n// Depth of field bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.6.1)\nBoxParser.createEntityToGroupCtor(\"dobr\");\n// Equivalent entity (ISO/IEC 23008-12:2022 Section 6.8.1.1)\nBoxParser.createEntityToGroupCtor(\"eqiv\");\n// Favourites collection (ISO/IEC 23008-12:2022 Section 6.8.7.2)\nBoxParser.createEntityToGroupCtor(\"favc\");\n// Focus bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.4.1)\nBoxParser.createEntityToGroupCtor(\"fobr\");\n// Audio to image entity group (ISO/IEC 23008-12:2022 Section 6.8.4)\nBoxParser.createEntityToGroupCtor(\"iaug\");\n// Panorama (ISO/IEC 23008-12:2022 Section 6.8.8.1)\nBoxParser.createEntityToGroupCtor(\"pano\");\n// Slideshow (ISO/IEC 23008-12:2022 Section 6.8.9.1)\nBoxParser.createEntityToGroupCtor(\"slid\");\n// Stereo pair (ISO/IEC 23008-12:2022 Section 6.8.5)\nBoxParser.createEntityToGroupCtor(\"ster\");\n// Time-synchronised capture entity group (ISO/IEC 23008-12:2022 Section 6.8.3)\nBoxParser.createEntityToGroupCtor(\"tsyn\");\n// White balance bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.3.1)\nBoxParser.createEntityToGroupCtor(\"wbbr\");\n// Alternative entity (ISO/IEC 23008-12:2022 AMD1 Section 6.8.10)\nBoxParser.createEntityToGroupCtor(\"prgr\");\n// Image Pyramid entity group (ISO/IEC 23008-12:20xx Section 6.8.11)\nBoxParser.createEntityToGroupCtor(\"pymd\", function(stream) {\n    this.group_id = stream.readUint32();\n    this.num_entities_in_group = stream.readUint32();\n    this.entity_ids = [];\n    for(var i1 = 0; i1 < this.num_entities_in_group; i1++){\n        var entity_id = stream.readUint32();\n        this.entity_ids.push(entity_id);\n    }\n    this.tile_size_x = stream.readUint16();\n    this.tile_size_y = stream.readUint16();\n    this.layer_binning = [];\n    this.tiles_in_layer_column_minus1 = [];\n    this.tiles_in_layer_row_minus1 = [];\n    for(i1 = 0; i1 < this.num_entities_in_group; i1++){\n        this.layer_binning[i1] = stream.readUint16();\n        this.tiles_in_layer_row_minus1[i1] = stream.readUint16();\n        this.tiles_in_layer_column_minus1[i1] = stream.readUint16();\n    }\n});\n// file:src/parsing/esds.js\nBoxParser.createFullBoxCtor(\"esds\", function(stream) {\n    var esd_data = stream.readUint8Array(this.size - this.hdr_size);\n    this.data = esd_data;\n    if (typeof MPEG4DescriptorParser !== \"undefined\") {\n        var esd_parser = new MPEG4DescriptorParser();\n        this.esd = esd_parser.parseOneDescriptor(new DataStream(esd_data.buffer, 0, DataStream.BIG_ENDIAN));\n    }\n});\n// file:src/parsing/fiel.js\nBoxParser.createBoxCtor(\"fiel\", function(stream) {\n    this.fieldCount = stream.readUint8();\n    this.fieldOrdering = stream.readUint8();\n});\n// file:src/parsing/frma.js\nBoxParser.createBoxCtor(\"frma\", function(stream) {\n    this.data_format = stream.readString(4);\n});\n// file:src/parsing/ftyp.js\nBoxParser.createBoxCtor(\"ftyp\", function(stream) {\n    var toparse = this.size - this.hdr_size;\n    this.major_brand = stream.readString(4);\n    this.minor_version = stream.readUint32();\n    toparse -= 8;\n    this.compatible_brands = [];\n    var i1 = 0;\n    while(toparse >= 4){\n        this.compatible_brands[i1] = stream.readString(4);\n        toparse -= 4;\n        i1++;\n    }\n});\n// file:src/parsing/hdlr.js\nBoxParser.createFullBoxCtor(\"hdlr\", function(stream) {\n    if (this.version === 0) {\n        stream.readUint32();\n        this.handler = stream.readString(4);\n        stream.readUint32Array(3);\n        this.name = stream.readString(this.size - this.hdr_size - 20);\n        if (this.name[this.name.length - 1] === '\\0') this.name = this.name.slice(0, -1);\n    }\n});\n// file:src/parsing/hvcC.js\nBoxParser.createBoxCtor(\"hvcC\", function(stream) {\n    var i1, j;\n    var nb_nalus;\n    var length;\n    var tmp_byte;\n    this.configurationVersion = stream.readUint8();\n    tmp_byte = stream.readUint8();\n    this.general_profile_space = tmp_byte >> 6;\n    this.general_tier_flag = (tmp_byte & 0x20) >> 5;\n    this.general_profile_idc = tmp_byte & 0x1F;\n    this.general_profile_compatibility = stream.readUint32();\n    this.general_constraint_indicator = stream.readUint8Array(6);\n    this.general_level_idc = stream.readUint8();\n    this.min_spatial_segmentation_idc = stream.readUint16() & 0xFFF;\n    this.parallelismType = stream.readUint8() & 0x3;\n    this.chroma_format_idc = stream.readUint8() & 0x3;\n    this.bit_depth_luma_minus8 = stream.readUint8() & 0x7;\n    this.bit_depth_chroma_minus8 = stream.readUint8() & 0x7;\n    this.avgFrameRate = stream.readUint16();\n    tmp_byte = stream.readUint8();\n    this.constantFrameRate = tmp_byte >> 6;\n    this.numTemporalLayers = (tmp_byte & 0XD) >> 3;\n    this.temporalIdNested = (tmp_byte & 0X4) >> 2;\n    this.lengthSizeMinusOne = tmp_byte & 0X3;\n    this.nalu_arrays = [];\n    var numOfArrays = stream.readUint8();\n    for(i1 = 0; i1 < numOfArrays; i1++){\n        var nalu_array = [];\n        this.nalu_arrays.push(nalu_array);\n        tmp_byte = stream.readUint8();\n        nalu_array.completeness = (tmp_byte & 0x80) >> 7;\n        nalu_array.nalu_type = tmp_byte & 0x3F;\n        var numNalus = stream.readUint16();\n        for(j = 0; j < numNalus; j++){\n            var nalu = {};\n            nalu_array.push(nalu);\n            length = stream.readUint16();\n            nalu.data = stream.readUint8Array(length);\n        }\n    }\n});\n// file:src/parsing/iinf.js\nBoxParser.createFullBoxCtor(\"iinf\", function(stream) {\n    var ret1;\n    if (this.version === 0) this.entry_count = stream.readUint16();\n    else this.entry_count = stream.readUint32();\n    this.item_infos = [];\n    for(var i1 = 0; i1 < this.entry_count; i1++){\n        ret1 = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n        if (ret1.code === BoxParser.OK) {\n            if (ret1.box.type !== \"infe\") Log.error(\"BoxParser\", \"Expected 'infe' box, got \" + ret1.box.type);\n            this.item_infos[i1] = ret1.box;\n        } else return;\n    }\n});\n// file:src/parsing/iloc.js\nBoxParser.createFullBoxCtor(\"iloc\", function(stream) {\n    var byte;\n    byte = stream.readUint8();\n    this.offset_size = byte >> 4 & 0xF;\n    this.length_size = byte & 0xF;\n    byte = stream.readUint8();\n    this.base_offset_size = byte >> 4 & 0xF;\n    if (this.version === 1 || this.version === 2) this.index_size = byte & 0xF;\n    else this.index_size = 0;\n    this.items = [];\n    var item_count = 0;\n    if (this.version < 2) item_count = stream.readUint16();\n    else if (this.version === 2) item_count = stream.readUint32();\n    else throw \"version of iloc box not supported\";\n    for(var i1 = 0; i1 < item_count; i1++){\n        var item = {};\n        this.items.push(item);\n        if (this.version < 2) item.item_ID = stream.readUint16();\n        else if (this.version === 2) item.item_ID = stream.readUint32();\n        else throw \"version of iloc box not supported\";\n        if (this.version === 1 || this.version === 2) item.construction_method = stream.readUint16() & 0xF;\n        else item.construction_method = 0;\n        item.data_reference_index = stream.readUint16();\n        switch(this.base_offset_size){\n            case 0:\n                item.base_offset = 0;\n                break;\n            case 4:\n                item.base_offset = stream.readUint32();\n                break;\n            case 8:\n                item.base_offset = stream.readUint64();\n                break;\n            default:\n                throw \"Error reading base offset size\";\n        }\n        var extent_count = stream.readUint16();\n        item.extents = [];\n        for(var j = 0; j < extent_count; j++){\n            var extent = {};\n            item.extents.push(extent);\n            if (this.version === 1 || this.version === 2) switch(this.index_size){\n                case 0:\n                    extent.extent_index = 0;\n                    break;\n                case 4:\n                    extent.extent_index = stream.readUint32();\n                    break;\n                case 8:\n                    extent.extent_index = stream.readUint64();\n                    break;\n                default:\n                    throw \"Error reading extent index\";\n            }\n            switch(this.offset_size){\n                case 0:\n                    extent.extent_offset = 0;\n                    break;\n                case 4:\n                    extent.extent_offset = stream.readUint32();\n                    break;\n                case 8:\n                    extent.extent_offset = stream.readUint64();\n                    break;\n                default:\n                    throw \"Error reading extent index\";\n            }\n            switch(this.length_size){\n                case 0:\n                    extent.extent_length = 0;\n                    break;\n                case 4:\n                    extent.extent_length = stream.readUint32();\n                    break;\n                case 8:\n                    extent.extent_length = stream.readUint64();\n                    break;\n                default:\n                    throw \"Error reading extent index\";\n            }\n        }\n    }\n});\n// file:src/parsing/imir.js\nBoxParser.createBoxCtor(\"imir\", function(stream) {\n    var tmp = stream.readUint8();\n    this.reserved = tmp >> 7;\n    this.axis = tmp & 1;\n}); // file:src/parsing/infe.js\nBoxParser.createFullBoxCtor(\"infe\", function(stream) {\n    if (this.version === 0 || this.version === 1) {\n        this.item_ID = stream.readUint16();\n        this.item_protection_index = stream.readUint16();\n        this.item_name = stream.readCString();\n        this.content_type = stream.readCString();\n        this.content_encoding = stream.readCString();\n    }\n    if (this.version === 1) {\n        this.extension_type = stream.readString(4);\n        Log.warn(\"BoxParser\", \"Cannot parse extension type\");\n        stream.seek(this.start + this.size);\n        return;\n    }\n    if (this.version >= 2) {\n        if (this.version === 2) this.item_ID = stream.readUint16();\n        else if (this.version === 3) this.item_ID = stream.readUint32();\n        this.item_protection_index = stream.readUint16();\n        this.item_type = stream.readString(4);\n        this.item_name = stream.readCString();\n        if (this.item_type === \"mime\") {\n            this.content_type = stream.readCString();\n            this.content_encoding = stream.readCString();\n        } else if (this.item_type === \"uri \") this.item_uri_type = stream.readCString();\n    }\n});\n// file:src/parsing/ipma.js\nBoxParser.createFullBoxCtor(\"ipma\", function(stream) {\n    var i1, j;\n    entry_count = stream.readUint32();\n    this.associations = [];\n    for(i1 = 0; i1 < entry_count; i1++){\n        var item_assoc = {};\n        this.associations.push(item_assoc);\n        if (this.version < 1) item_assoc.id = stream.readUint16();\n        else item_assoc.id = stream.readUint32();\n        var association_count = stream.readUint8();\n        item_assoc.props = [];\n        for(j = 0; j < association_count; j++){\n            var tmp = stream.readUint8();\n            var p = {};\n            item_assoc.props.push(p);\n            p.essential = (tmp & 0x80) >> 7 === 1;\n            if (this.flags & 0x1) p.property_index = (tmp & 0x7F) << 8 | stream.readUint8();\n            else p.property_index = tmp & 0x7F;\n        }\n    }\n});\n// file:src/parsing/iref.js\nBoxParser.createFullBoxCtor(\"iref\", function(stream) {\n    var ret1;\n    var entryCount;\n    var box1;\n    this.references = [];\n    while(stream.getPosition() < this.start + this.size){\n        ret1 = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n        if (ret1.code === BoxParser.OK) {\n            if (this.version === 0) box1 = new BoxParser.SingleItemTypeReferenceBox(ret1.type, ret1.size, ret1.hdr_size, ret1.start);\n            else box1 = new BoxParser.SingleItemTypeReferenceBoxLarge(ret1.type, ret1.size, ret1.hdr_size, ret1.start);\n            if (box1.write === BoxParser.Box.prototype.write && box1.type !== \"mdat\") {\n                Log.warn(\"BoxParser\", box1.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\");\n                box1.parseDataAndRewind(stream);\n            }\n            box1.parse(stream);\n            this.references.push(box1);\n        } else return;\n    }\n});\n// file:src/parsing/irot.js\nBoxParser.createBoxCtor(\"irot\", function(stream) {\n    this.angle = stream.readUint8() & 0x3;\n});\n// file:src/parsing/ispe.js\nBoxParser.createFullBoxCtor(\"ispe\", function(stream) {\n    this.image_width = stream.readUint32();\n    this.image_height = stream.readUint32();\n}); // file:src/parsing/kind.js\nBoxParser.createFullBoxCtor(\"kind\", function(stream) {\n    this.schemeURI = stream.readCString();\n    this.value = stream.readCString();\n});\n// file:src/parsing/leva.js\nBoxParser.createFullBoxCtor(\"leva\", function(stream) {\n    var count = stream.readUint8();\n    this.levels = [];\n    for(var i1 = 0; i1 < count; i1++){\n        var level = {};\n        this.levels[i1] = level;\n        level.track_ID = stream.readUint32();\n        var tmp_byte = stream.readUint8();\n        level.padding_flag = tmp_byte >> 7;\n        level.assignment_type = tmp_byte & 0x7F;\n        switch(level.assignment_type){\n            case 0:\n                level.grouping_type = stream.readString(4);\n                break;\n            case 1:\n                level.grouping_type = stream.readString(4);\n                level.grouping_type_parameter = stream.readUint32();\n                break;\n            case 2:\n                break;\n            case 3:\n                break;\n            case 4:\n                level.sub_track_id = stream.readUint32();\n                break;\n            default:\n                Log.warn(\"BoxParser\", \"Unknown leva assignement type\");\n        }\n    }\n});\n// file:src/parsing/lhvC.js\nBoxParser.createBoxCtor(\"lhvC\", function(stream) {\n    var i1, j;\n    var tmp_byte;\n    this.configurationVersion = stream.readUint8();\n    this.min_spatial_segmentation_idc = stream.readUint16() & 0xFFF;\n    this.parallelismType = stream.readUint8() & 0x3;\n    tmp_byte = stream.readUint8();\n    this.numTemporalLayers = (tmp_byte & 0XD) >> 3;\n    this.temporalIdNested = (tmp_byte & 0X4) >> 2;\n    this.lengthSizeMinusOne = tmp_byte & 0X3;\n    this.nalu_arrays = [];\n    var numOfArrays = stream.readUint8();\n    for(i1 = 0; i1 < numOfArrays; i1++){\n        var nalu_array = [];\n        this.nalu_arrays.push(nalu_array);\n        tmp_byte = stream.readUint8();\n        nalu_array.completeness = (tmp_byte & 0x80) >> 7;\n        nalu_array.nalu_type = tmp_byte & 0x3F;\n        var numNalus = stream.readUint16();\n        for(j = 0; j < numNalus; j++){\n            var nalu = {};\n            nalu_array.push(nalu);\n            var length = stream.readUint16();\n            nalu.data = stream.readUint8Array(length);\n        }\n    }\n});\n// file:src/parsing/lsel.js\nBoxParser.createBoxCtor(\"lsel\", function(stream) {\n    this.layer_id = stream.readUint16();\n}); // file:src/parsing/maxr.js\nBoxParser.createBoxCtor(\"maxr\", function(stream) {\n    this.period = stream.readUint32();\n    this.bytes = stream.readUint32();\n});\n// file:src/parsing/mdcv.js\nfunction ColorPoint(x, y) {\n    this.x = x;\n    this.y = y;\n}\nColorPoint.prototype.toString = function() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n};\nBoxParser.createBoxCtor(\"mdcv\", function(stream) {\n    this.display_primaries = [];\n    this.display_primaries[0] = new ColorPoint(stream.readUint16(), stream.readUint16());\n    this.display_primaries[1] = new ColorPoint(stream.readUint16(), stream.readUint16());\n    this.display_primaries[2] = new ColorPoint(stream.readUint16(), stream.readUint16());\n    this.white_point = new ColorPoint(stream.readUint16(), stream.readUint16());\n    this.max_display_mastering_luminance = stream.readUint32();\n    this.min_display_mastering_luminance = stream.readUint32();\n});\n// file:src/parsing/mdhd.js\nBoxParser.createFullBoxCtor(\"mdhd\", function(stream) {\n    if (this.version == 1) {\n        this.creation_time = stream.readUint64();\n        this.modification_time = stream.readUint64();\n        this.timescale = stream.readUint32();\n        this.duration = stream.readUint64();\n    } else {\n        this.creation_time = stream.readUint32();\n        this.modification_time = stream.readUint32();\n        this.timescale = stream.readUint32();\n        this.duration = stream.readUint32();\n    }\n    this.parseLanguage(stream);\n    stream.readUint16();\n});\n// file:src/parsing/mehd.js\nBoxParser.createFullBoxCtor(\"mehd\", function(stream) {\n    if (this.flags & 0x1) {\n        Log.warn(\"BoxParser\", \"mehd box incorrectly uses flags set to 1, converting version to 1\");\n        this.version = 1;\n    }\n    if (this.version == 1) this.fragment_duration = stream.readUint64();\n    else this.fragment_duration = stream.readUint32();\n});\n// file:src/parsing/meta.js\nBoxParser.createFullBoxCtor(\"meta\", function(stream) {\n    this.boxes = [];\n    BoxParser.ContainerBox.prototype.parse.call(this, stream);\n});\n// file:src/parsing/mfhd.js\nBoxParser.createFullBoxCtor(\"mfhd\", function(stream) {\n    this.sequence_number = stream.readUint32();\n});\n// file:src/parsing/mfro.js\nBoxParser.createFullBoxCtor(\"mfro\", function(stream) {\n    this._size = stream.readUint32();\n});\n// file:src/parsing/mskC.js\nBoxParser.createFullBoxCtor(\"mskC\", function(stream) {\n    this.bits_per_pixel = stream.readUint8();\n});\n// file:src/parsing/mvhd.js\nBoxParser.createFullBoxCtor(\"mvhd\", function(stream) {\n    if (this.version == 1) {\n        this.creation_time = stream.readUint64();\n        this.modification_time = stream.readUint64();\n        this.timescale = stream.readUint32();\n        this.duration = stream.readUint64();\n    } else {\n        this.creation_time = stream.readUint32();\n        this.modification_time = stream.readUint32();\n        this.timescale = stream.readUint32();\n        this.duration = stream.readUint32();\n    }\n    this.rate = stream.readUint32();\n    this.volume = stream.readUint16() >> 8;\n    stream.readUint16();\n    stream.readUint32Array(2);\n    this.matrix = stream.readUint32Array(9);\n    stream.readUint32Array(6);\n    this.next_track_id = stream.readUint32();\n});\n// file:src/parsing/npck.js\nBoxParser.createBoxCtor(\"npck\", function(stream) {\n    this.packetssent = stream.readUint32();\n});\n// file:src/parsing/nump.js\nBoxParser.createBoxCtor(\"nump\", function(stream) {\n    this.packetssent = stream.readUint64();\n});\n// file:src/parsing/padb.js\nBoxParser.createFullBoxCtor(\"padb\", function(stream) {\n    var sample_count = stream.readUint32();\n    this.padbits = [];\n    for(var i1 = 0; i1 < Math.floor((sample_count + 1) / 2); i1++)this.padbits = stream.readUint8();\n});\n// file:src/parsing/pasp.js\nBoxParser.createBoxCtor(\"pasp\", function(stream) {\n    this.hSpacing = stream.readUint32();\n    this.vSpacing = stream.readUint32();\n}); // file:src/parsing/payl.js\nBoxParser.createBoxCtor(\"payl\", function(stream) {\n    this.text = stream.readString(this.size - this.hdr_size);\n});\n// file:src/parsing/payt.js\nBoxParser.createBoxCtor(\"payt\", function(stream) {\n    this.payloadID = stream.readUint32();\n    var count = stream.readUint8();\n    this.rtpmap_string = stream.readString(count);\n});\n// file:src/parsing/pdin.js\nBoxParser.createFullBoxCtor(\"pdin\", function(stream) {\n    var count = (this.size - this.hdr_size) / 8;\n    this.rate = [];\n    this.initial_delay = [];\n    for(var i1 = 0; i1 < count; i1++){\n        this.rate[i1] = stream.readUint32();\n        this.initial_delay[i1] = stream.readUint32();\n    }\n});\n// file:src/parsing/pitm.js\nBoxParser.createFullBoxCtor(\"pitm\", function(stream) {\n    if (this.version === 0) this.item_id = stream.readUint16();\n    else this.item_id = stream.readUint32();\n});\n// file:src/parsing/pixi.js\nBoxParser.createFullBoxCtor(\"pixi\", function(stream) {\n    var i1;\n    this.num_channels = stream.readUint8();\n    this.bits_per_channels = [];\n    for(i1 = 0; i1 < this.num_channels; i1++)this.bits_per_channels[i1] = stream.readUint8();\n});\n// file:src/parsing/pmax.js\nBoxParser.createBoxCtor(\"pmax\", function(stream) {\n    this.bytes = stream.readUint32();\n});\n// file:src/parsing/prdi.js\nBoxParser.createFullBoxCtor(\"prdi\", function(stream) {\n    this.step_count = stream.readUint16();\n    this.item_count = [];\n    if (this.flags & 0x2) for(var i1 = 0; i1 < this.step_count; i1++)this.item_count[i1] = stream.readUint16();\n}); // file:src/parsing/prft.js\nBoxParser.createFullBoxCtor(\"prft\", function(stream) {\n    this.ref_track_id = stream.readUint32();\n    this.ntp_timestamp = stream.readUint64();\n    if (this.version === 0) this.media_time = stream.readUint32();\n    else this.media_time = stream.readUint64();\n});\n// file:src/parsing/pssh.js\nBoxParser.createFullBoxCtor(\"pssh\", function(stream) {\n    this.system_id = BoxParser.parseHex16(stream);\n    if (this.version > 0) {\n        var count = stream.readUint32();\n        this.kid = [];\n        for(var i1 = 0; i1 < count; i1++)this.kid[i1] = BoxParser.parseHex16(stream);\n    }\n    var datasize = stream.readUint32();\n    if (datasize > 0) this.data = stream.readUint8Array(datasize);\n});\n// file:src/parsing/qt/clef.js\nBoxParser.createFullBoxCtor(\"clef\", function(stream) {\n    this.width = stream.readUint32();\n    this.height = stream.readUint32();\n}); // file:src/parsing/qt/enof.js\nBoxParser.createFullBoxCtor(\"enof\", function(stream) {\n    this.width = stream.readUint32();\n    this.height = stream.readUint32();\n}); // file:src/parsing/qt/prof.js\nBoxParser.createFullBoxCtor(\"prof\", function(stream) {\n    this.width = stream.readUint32();\n    this.height = stream.readUint32();\n}); // file:src/parsing/qt/tapt.js\nBoxParser.createContainerBoxCtor(\"tapt\", null, [\n    \"clef\",\n    \"prof\",\n    \"enof\"\n]); // file:src/parsing/rtp.js\nBoxParser.createBoxCtor(\"rtp \", function(stream) {\n    this.descriptionformat = stream.readString(4);\n    this.sdptext = stream.readString(this.size - this.hdr_size - 4);\n});\n// file:src/parsing/saio.js\nBoxParser.createFullBoxCtor(\"saio\", function(stream) {\n    if (this.flags & 0x1) {\n        this.aux_info_type = stream.readUint32();\n        this.aux_info_type_parameter = stream.readUint32();\n    }\n    var count = stream.readUint32();\n    this.offset = [];\n    for(var i1 = 0; i1 < count; i1++)if (this.version === 0) this.offset[i1] = stream.readUint32();\n    else this.offset[i1] = stream.readUint64();\n});\n// file:src/parsing/saiz.js\nBoxParser.createFullBoxCtor(\"saiz\", function(stream) {\n    if (this.flags & 0x1) {\n        this.aux_info_type = stream.readUint32();\n        this.aux_info_type_parameter = stream.readUint32();\n    }\n    this.default_sample_info_size = stream.readUint8();\n    var count = stream.readUint32();\n    this.sample_info_size = [];\n    if (this.default_sample_info_size === 0) for(var i1 = 0; i1 < count; i1++)this.sample_info_size[i1] = stream.readUint8();\n});\n// file:src/parsing/sampleentries/mett.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"mett\", function(stream) {\n    this.parseHeader(stream);\n    this.content_encoding = stream.readCString();\n    this.mime_format = stream.readCString();\n    this.parseFooter(stream);\n});\n// file:src/parsing/sampleentries/metx.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"metx\", function(stream) {\n    this.parseHeader(stream);\n    this.content_encoding = stream.readCString();\n    this.namespace = stream.readCString();\n    this.schema_location = stream.readCString();\n    this.parseFooter(stream);\n});\n// file:src/parsing/sampleentries/sbtt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"sbtt\", function(stream) {\n    this.parseHeader(stream);\n    this.content_encoding = stream.readCString();\n    this.mime_format = stream.readCString();\n    this.parseFooter(stream);\n});\n// file:src/parsing/sampleentries/stpp.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stpp\", function(stream) {\n    this.parseHeader(stream);\n    this.namespace = stream.readCString();\n    this.schema_location = stream.readCString();\n    this.auxiliary_mime_types = stream.readCString();\n    this.parseFooter(stream);\n});\n// file:src/parsing/sampleentries/stxt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stxt\", function(stream) {\n    this.parseHeader(stream);\n    this.content_encoding = stream.readCString();\n    this.mime_format = stream.readCString();\n    this.parseFooter(stream);\n});\n// file:src/parsing/sampleentries/tx3g.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"tx3g\", function(stream) {\n    this.parseHeader(stream);\n    this.displayFlags = stream.readUint32();\n    this.horizontal_justification = stream.readInt8();\n    this.vertical_justification = stream.readInt8();\n    this.bg_color_rgba = stream.readUint8Array(4);\n    this.box_record = stream.readInt16Array(4);\n    this.style_record = stream.readUint8Array(12);\n    this.parseFooter(stream);\n});\n// file:src/parsing/sampleentries/wvtt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"wvtt\", function(stream) {\n    this.parseHeader(stream);\n    this.parseFooter(stream);\n});\n// file:src/parsing/samplegroups/alst.js\nBoxParser.createSampleGroupCtor(\"alst\", function(stream) {\n    var i1;\n    var roll_count = stream.readUint16();\n    this.first_output_sample = stream.readUint16();\n    this.sample_offset = [];\n    for(i1 = 0; i1 < roll_count; i1++)this.sample_offset[i1] = stream.readUint32();\n    var remaining = this.description_length - 4 - 4 * roll_count;\n    this.num_output_samples = [];\n    this.num_total_samples = [];\n    for(i1 = 0; i1 < remaining / 4; i1++){\n        this.num_output_samples[i1] = stream.readUint16();\n        this.num_total_samples[i1] = stream.readUint16();\n    }\n});\n// file:src/parsing/samplegroups/avll.js\nBoxParser.createSampleGroupCtor(\"avll\", function(stream) {\n    this.layerNumber = stream.readUint8();\n    this.accurateStatisticsFlag = stream.readUint8();\n    this.avgBitRate = stream.readUint16();\n    this.avgFrameRate = stream.readUint16();\n});\n// file:src/parsing/samplegroups/avss.js\nBoxParser.createSampleGroupCtor(\"avss\", function(stream) {\n    this.subSequenceIdentifier = stream.readUint16();\n    this.layerNumber = stream.readUint8();\n    var tmp_byte = stream.readUint8();\n    this.durationFlag = tmp_byte >> 7;\n    this.avgRateFlag = tmp_byte >> 6 & 0x1;\n    if (this.durationFlag) this.duration = stream.readUint32();\n    if (this.avgRateFlag) {\n        this.accurateStatisticsFlag = stream.readUint8();\n        this.avgBitRate = stream.readUint16();\n        this.avgFrameRate = stream.readUint16();\n    }\n    this.dependency = [];\n    var numReferences = stream.readUint8();\n    for(var i1 = 0; i1 < numReferences; i1++){\n        var dependencyInfo = {};\n        this.dependency.push(dependencyInfo);\n        dependencyInfo.subSeqDirectionFlag = stream.readUint8();\n        dependencyInfo.layerNumber = stream.readUint8();\n        dependencyInfo.subSequenceIdentifier = stream.readUint16();\n    }\n});\n// file:src/parsing/samplegroups/dtrt.js\nBoxParser.createSampleGroupCtor(\"dtrt\", function(stream) {\n    Log.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n});\n// file:src/parsing/samplegroups/mvif.js\nBoxParser.createSampleGroupCtor(\"mvif\", function(stream) {\n    Log.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n});\n// file:src/parsing/samplegroups/prol.js\nBoxParser.createSampleGroupCtor(\"prol\", function(stream) {\n    this.roll_distance = stream.readInt16();\n});\n// file:src/parsing/samplegroups/rap.js\nBoxParser.createSampleGroupCtor(\"rap \", function(stream) {\n    var tmp_byte = stream.readUint8();\n    this.num_leading_samples_known = tmp_byte >> 7;\n    this.num_leading_samples = tmp_byte & 0x7F;\n});\n// file:src/parsing/samplegroups/rash.js\nBoxParser.createSampleGroupCtor(\"rash\", function(stream) {\n    this.operation_point_count = stream.readUint16();\n    if (this.description_length !== 2 + (this.operation_point_count === 1 ? 2 : this.operation_point_count * 6) + 9) {\n        Log.warn(\"BoxParser\", \"Mismatch in \" + this.grouping_type + \" sample group length\");\n        this.data = stream.readUint8Array(this.description_length - 2);\n    } else {\n        if (this.operation_point_count === 1) this.target_rate_share = stream.readUint16();\n        else {\n            this.target_rate_share = [];\n            this.available_bitrate = [];\n            for(var i1 = 0; i1 < this.operation_point_count; i1++){\n                this.available_bitrate[i1] = stream.readUint32();\n                this.target_rate_share[i1] = stream.readUint16();\n            }\n        }\n        this.maximum_bitrate = stream.readUint32();\n        this.minimum_bitrate = stream.readUint32();\n        this.discard_priority = stream.readUint8();\n    }\n});\n// file:src/parsing/samplegroups/roll.js\nBoxParser.createSampleGroupCtor(\"roll\", function(stream) {\n    this.roll_distance = stream.readInt16();\n});\n// file:src/parsing/samplegroups/samplegroup.js\nBoxParser.SampleGroupEntry.prototype.parse = function(stream) {\n    Log.warn(\"BoxParser\", \"Unknown Sample Group type: \" + this.grouping_type);\n    this.data = stream.readUint8Array(this.description_length);\n};\n// file:src/parsing/samplegroups/scif.js\nBoxParser.createSampleGroupCtor(\"scif\", function(stream) {\n    Log.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n});\n// file:src/parsing/samplegroups/scnm.js\nBoxParser.createSampleGroupCtor(\"scnm\", function(stream) {\n    Log.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n});\n// file:src/parsing/samplegroups/seig.js\nBoxParser.createSampleGroupCtor(\"seig\", function(stream) {\n    this.reserved = stream.readUint8();\n    var tmp = stream.readUint8();\n    this.crypt_byte_block = tmp >> 4;\n    this.skip_byte_block = tmp & 0xF;\n    this.isProtected = stream.readUint8();\n    this.Per_Sample_IV_Size = stream.readUint8();\n    this.KID = BoxParser.parseHex16(stream);\n    this.constant_IV_size = 0;\n    this.constant_IV = 0;\n    if (this.isProtected === 1 && this.Per_Sample_IV_Size === 0) {\n        this.constant_IV_size = stream.readUint8();\n        this.constant_IV = stream.readUint8Array(this.constant_IV_size);\n    }\n});\n// file:src/parsing/samplegroups/stsa.js\nBoxParser.createSampleGroupCtor(\"stsa\", function(stream) {\n    Log.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n});\n// file:src/parsing/samplegroups/sync.js\nBoxParser.createSampleGroupCtor(\"sync\", function(stream) {\n    var tmp_byte = stream.readUint8();\n    this.NAL_unit_type = tmp_byte & 0x3F;\n});\n// file:src/parsing/samplegroups/tele.js\nBoxParser.createSampleGroupCtor(\"tele\", function(stream) {\n    var tmp_byte = stream.readUint8();\n    this.level_independently_decodable = tmp_byte >> 7;\n});\n// file:src/parsing/samplegroups/tsas.js\nBoxParser.createSampleGroupCtor(\"tsas\", function(stream) {\n    Log.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n});\n// file:src/parsing/samplegroups/tscl.js\nBoxParser.createSampleGroupCtor(\"tscl\", function(stream) {\n    Log.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n});\n// file:src/parsing/samplegroups/vipr.js\nBoxParser.createSampleGroupCtor(\"vipr\", function(stream) {\n    Log.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n});\n// file:src/parsing/sbgp.js\nBoxParser.createFullBoxCtor(\"sbgp\", function(stream) {\n    this.grouping_type = stream.readString(4);\n    if (this.version === 1) this.grouping_type_parameter = stream.readUint32();\n    else this.grouping_type_parameter = 0;\n    this.entries = [];\n    var entry_count1 = stream.readUint32();\n    for(var i1 = 0; i1 < entry_count1; i1++){\n        var entry = {};\n        this.entries.push(entry);\n        entry.sample_count = stream.readInt32();\n        entry.group_description_index = stream.readInt32();\n    }\n});\n// file:src/parsing/sbpm.js\nfunction Pixel(row, col) {\n    this.bad_pixel_row = row;\n    this.bad_pixel_column = col;\n}\nPixel.prototype.toString = function pixelToString() {\n    return \"[row: \" + this.bad_pixel_row + \", column: \" + this.bad_pixel_column + \"]\";\n};\nBoxParser.createFullBoxCtor(\"sbpm\", function(stream) {\n    var i1;\n    this.component_count = stream.readUint16();\n    this.component_index = [];\n    for(i1 = 0; i1 < this.component_count; i1++)this.component_index.push(stream.readUint16());\n    var flags = stream.readUint8();\n    this.correction_applied = 0x80 == (flags & 0x80);\n    this.num_bad_rows = stream.readUint32();\n    this.num_bad_cols = stream.readUint32();\n    this.num_bad_pixels = stream.readUint32();\n    this.bad_rows = [];\n    this.bad_columns = [];\n    this.bad_pixels = [];\n    for(i1 = 0; i1 < this.num_bad_rows; i1++)this.bad_rows.push(stream.readUint32());\n    for(i1 = 0; i1 < this.num_bad_cols; i1++)this.bad_columns.push(stream.readUint32());\n    for(i1 = 0; i1 < this.num_bad_pixels; i1++){\n        var row = stream.readUint32();\n        var col = stream.readUint32();\n        this.bad_pixels.push(new Pixel(row, col));\n    }\n});\n// file:src/parsing/schm.js\nBoxParser.createFullBoxCtor(\"schm\", function(stream) {\n    this.scheme_type = stream.readString(4);\n    this.scheme_version = stream.readUint32();\n    if (this.flags & 0x000001) this.scheme_uri = stream.readString(this.size - this.hdr_size - 8);\n});\n// file:src/parsing/sdp.js\nBoxParser.createBoxCtor(\"sdp \", function(stream) {\n    this.sdptext = stream.readString(this.size - this.hdr_size);\n});\n// file:src/parsing/sdtp.js\nBoxParser.createFullBoxCtor(\"sdtp\", function(stream) {\n    var tmp_byte;\n    var count = this.size - this.hdr_size;\n    this.is_leading = [];\n    this.sample_depends_on = [];\n    this.sample_is_depended_on = [];\n    this.sample_has_redundancy = [];\n    for(var i1 = 0; i1 < count; i1++){\n        tmp_byte = stream.readUint8();\n        this.is_leading[i1] = tmp_byte >> 6;\n        this.sample_depends_on[i1] = tmp_byte >> 4 & 0x3;\n        this.sample_is_depended_on[i1] = tmp_byte >> 2 & 0x3;\n        this.sample_has_redundancy[i1] = tmp_byte & 0x3;\n    }\n});\n// file:src/parsing/senc.js\n// Cannot be fully parsed because Per_Sample_IV_Size needs to be known\nBoxParser.createFullBoxCtor(\"senc\" /*, function(stream) {\r\n\tthis.parseFullHeader(stream);\r\n\tvar sample_count = stream.readUint32();\r\n\tthis.samples = [];\r\n\tfor (var i = 0; i < sample_count; i++) {\r\n\t\tvar sample = {};\r\n\t\t// tenc.default_Per_Sample_IV_Size or seig.Per_Sample_IV_Size\r\n\t\tsample.InitializationVector = this.readUint8Array(Per_Sample_IV_Size*8);\r\n\t\tif (this.flags & 0x2) {\r\n\t\t\tsample.subsamples = [];\r\n\t\t\tsubsample_count = stream.readUint16();\r\n\t\t\tfor (var j = 0; j < subsample_count; j++) {\r\n\t\t\t\tvar subsample = {};\r\n\t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\r\n\t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\r\n\t\t\t\tsample.subsamples.push(subsample);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// TODO\r\n\t\tthis.samples.push(sample);\r\n\t}\r\n}*/ );\n// file:src/parsing/sgpd.js\nBoxParser.createFullBoxCtor(\"sgpd\", function(stream) {\n    this.grouping_type = stream.readString(4);\n    Log.debug(\"BoxParser\", \"Found Sample Groups of type \" + this.grouping_type);\n    if (this.version === 1) this.default_length = stream.readUint32();\n    else this.default_length = 0;\n    if (this.version >= 2) this.default_group_description_index = stream.readUint32();\n    this.entries = [];\n    var entry_count1 = stream.readUint32();\n    for(var i1 = 0; i1 < entry_count1; i1++){\n        var entry;\n        if (BoxParser[this.grouping_type + \"SampleGroupEntry\"]) entry = new BoxParser[this.grouping_type + \"SampleGroupEntry\"](this.grouping_type);\n        else entry = new BoxParser.SampleGroupEntry(this.grouping_type);\n        this.entries.push(entry);\n        if (this.version === 1) {\n            if (this.default_length === 0) entry.description_length = stream.readUint32();\n            else entry.description_length = this.default_length;\n        } else entry.description_length = this.default_length;\n        if (entry.write === BoxParser.SampleGroupEntry.prototype.write) {\n            Log.info(\"BoxParser\", \"SampleGroup for type \" + this.grouping_type + \" writing not yet implemented, keeping unparsed data in memory for later write\");\n            // storing data\n            entry.data = stream.readUint8Array(entry.description_length);\n            // rewinding\n            stream.position -= entry.description_length;\n        }\n        entry.parse(stream);\n    }\n});\n// file:src/parsing/sidx.js\nBoxParser.createFullBoxCtor(\"sidx\", function(stream) {\n    this.reference_ID = stream.readUint32();\n    this.timescale = stream.readUint32();\n    if (this.version === 0) {\n        this.earliest_presentation_time = stream.readUint32();\n        this.first_offset = stream.readUint32();\n    } else {\n        this.earliest_presentation_time = stream.readUint64();\n        this.first_offset = stream.readUint64();\n    }\n    stream.readUint16();\n    this.references = [];\n    var count = stream.readUint16();\n    for(var i1 = 0; i1 < count; i1++){\n        var ref = {};\n        this.references.push(ref);\n        var tmp_32 = stream.readUint32();\n        ref.reference_type = tmp_32 >> 31 & 0x1;\n        ref.referenced_size = tmp_32 & 0x7FFFFFFF;\n        ref.subsegment_duration = stream.readUint32();\n        tmp_32 = stream.readUint32();\n        ref.starts_with_SAP = tmp_32 >> 31 & 0x1;\n        ref.SAP_type = tmp_32 >> 28 & 0x7;\n        ref.SAP_delta_time = tmp_32 & 0xFFFFFFF;\n    }\n});\n// file:src/parsing/singleitemtypereference.js\nBoxParser.SingleItemTypeReferenceBox = function(type, size, hdr_size, start) {\n    BoxParser.Box.call(this, type, size);\n    this.hdr_size = hdr_size;\n    this.start = start;\n};\nBoxParser.SingleItemTypeReferenceBox.prototype = new BoxParser.Box();\nBoxParser.SingleItemTypeReferenceBox.prototype.parse = function(stream) {\n    this.from_item_ID = stream.readUint16();\n    var count = stream.readUint16();\n    this.references = [];\n    for(var i1 = 0; i1 < count; i1++){\n        this.references[i1] = {};\n        this.references[i1].to_item_ID = stream.readUint16();\n    }\n};\n// file:src/parsing/singleitemtypereferencelarge.js\nBoxParser.SingleItemTypeReferenceBoxLarge = function(type, size, hdr_size, start) {\n    BoxParser.Box.call(this, type, size);\n    this.hdr_size = hdr_size;\n    this.start = start;\n};\nBoxParser.SingleItemTypeReferenceBoxLarge.prototype = new BoxParser.Box();\nBoxParser.SingleItemTypeReferenceBoxLarge.prototype.parse = function(stream) {\n    this.from_item_ID = stream.readUint32();\n    var count = stream.readUint16();\n    this.references = [];\n    for(var i1 = 0; i1 < count; i1++){\n        this.references[i1] = {};\n        this.references[i1].to_item_ID = stream.readUint32();\n    }\n};\n// file:src/parsing/SmDm.js\nBoxParser.createFullBoxCtor(\"SmDm\", function(stream) {\n    this.primaryRChromaticity_x = stream.readUint16();\n    this.primaryRChromaticity_y = stream.readUint16();\n    this.primaryGChromaticity_x = stream.readUint16();\n    this.primaryGChromaticity_y = stream.readUint16();\n    this.primaryBChromaticity_x = stream.readUint16();\n    this.primaryBChromaticity_y = stream.readUint16();\n    this.whitePointChromaticity_x = stream.readUint16();\n    this.whitePointChromaticity_y = stream.readUint16();\n    this.luminanceMax = stream.readUint32();\n    this.luminanceMin = stream.readUint32();\n});\n// file:src/parsing/smhd.js\nBoxParser.createFullBoxCtor(\"smhd\", function(stream) {\n    this.balance = stream.readUint16();\n    stream.readUint16();\n});\n// file:src/parsing/ssix.js\nBoxParser.createFullBoxCtor(\"ssix\", function(stream) {\n    this.subsegments = [];\n    var subsegment_count = stream.readUint32();\n    for(var i1 = 0; i1 < subsegment_count; i1++){\n        var subsegment = {};\n        this.subsegments.push(subsegment);\n        subsegment.ranges = [];\n        var range_count = stream.readUint32();\n        for(var j = 0; j < range_count; j++){\n            var range = {};\n            subsegment.ranges.push(range);\n            range.level = stream.readUint8();\n            range.range_size = stream.readUint24();\n        }\n    }\n});\n// file:src/parsing/stco.js\nBoxParser.createFullBoxCtor(\"stco\", function(stream) {\n    var entry_count1;\n    entry_count1 = stream.readUint32();\n    this.chunk_offsets = [];\n    if (this.version === 0) for(var i1 = 0; i1 < entry_count1; i1++)this.chunk_offsets.push(stream.readUint32());\n});\n// file:src/parsing/stdp.js\nBoxParser.createFullBoxCtor(\"stdp\", function(stream) {\n    var count = (this.size - this.hdr_size) / 2;\n    this.priority = [];\n    for(var i1 = 0; i1 < count; i1++)this.priority[i1] = stream.readUint16();\n});\n// file:src/parsing/sthd.js\nBoxParser.createFullBoxCtor(\"sthd\");\n// file:src/parsing/stri.js\nBoxParser.createFullBoxCtor(\"stri\", function(stream) {\n    this.switch_group = stream.readUint16();\n    this.alternate_group = stream.readUint16();\n    this.sub_track_id = stream.readUint32();\n    var count = (this.size - this.hdr_size - 8) / 4;\n    this.attribute_list = [];\n    for(var i1 = 0; i1 < count; i1++)this.attribute_list[i1] = stream.readUint32();\n});\n// file:src/parsing/stsc.js\nBoxParser.createFullBoxCtor(\"stsc\", function(stream) {\n    var entry_count1;\n    var i1;\n    entry_count1 = stream.readUint32();\n    this.first_chunk = [];\n    this.samples_per_chunk = [];\n    this.sample_description_index = [];\n    if (this.version === 0) for(i1 = 0; i1 < entry_count1; i1++){\n        this.first_chunk.push(stream.readUint32());\n        this.samples_per_chunk.push(stream.readUint32());\n        this.sample_description_index.push(stream.readUint32());\n    }\n});\n// file:src/parsing/stsd.js\nBoxParser.createFullBoxCtor(\"stsd\", function(stream) {\n    var i1;\n    var ret1;\n    var entryCount;\n    var box1;\n    this.entries = [];\n    entryCount = stream.readUint32();\n    for(i1 = 1; i1 <= entryCount; i1++){\n        ret1 = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n        if (ret1.code === BoxParser.OK) {\n            if (BoxParser[ret1.type + \"SampleEntry\"]) {\n                box1 = new BoxParser[ret1.type + \"SampleEntry\"](ret1.size);\n                box1.hdr_size = ret1.hdr_size;\n                box1.start = ret1.start;\n            } else {\n                Log.warn(\"BoxParser\", \"Unknown sample entry type: \" + ret1.type);\n                box1 = new BoxParser.SampleEntry(ret1.type, ret1.size, ret1.hdr_size, ret1.start);\n            }\n            if (box1.write === BoxParser.SampleEntry.prototype.write) {\n                Log.info(\"BoxParser\", \"SampleEntry \" + box1.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\");\n                box1.parseDataAndRewind(stream);\n            }\n            box1.parse(stream);\n            this.entries.push(box1);\n        } else return;\n    }\n});\n// file:src/parsing/stsg.js\nBoxParser.createFullBoxCtor(\"stsg\", function(stream) {\n    this.grouping_type = stream.readUint32();\n    var count = stream.readUint16();\n    this.group_description_index = [];\n    for(var i1 = 0; i1 < count; i1++)this.group_description_index[i1] = stream.readUint32();\n});\n// file:src/parsing/stsh.js\nBoxParser.createFullBoxCtor(\"stsh\", function(stream) {\n    var entry_count1;\n    var i1;\n    entry_count1 = stream.readUint32();\n    this.shadowed_sample_numbers = [];\n    this.sync_sample_numbers = [];\n    if (this.version === 0) for(i1 = 0; i1 < entry_count1; i1++){\n        this.shadowed_sample_numbers.push(stream.readUint32());\n        this.sync_sample_numbers.push(stream.readUint32());\n    }\n});\n// file:src/parsing/stss.js\nBoxParser.createFullBoxCtor(\"stss\", function(stream) {\n    var i1;\n    var entry_count1;\n    entry_count1 = stream.readUint32();\n    if (this.version === 0) {\n        this.sample_numbers = [];\n        for(i1 = 0; i1 < entry_count1; i1++)this.sample_numbers.push(stream.readUint32());\n    }\n});\n// file:src/parsing/stsz.js\nBoxParser.createFullBoxCtor(\"stsz\", function(stream) {\n    var i1;\n    this.sample_sizes = [];\n    if (this.version === 0) {\n        this.sample_size = stream.readUint32();\n        this.sample_count = stream.readUint32();\n        for(i1 = 0; i1 < this.sample_count; i1++)if (this.sample_size === 0) this.sample_sizes.push(stream.readUint32());\n        else this.sample_sizes[i1] = this.sample_size;\n    }\n});\n// file:src/parsing/stts.js\nBoxParser.createFullBoxCtor(\"stts\", function(stream) {\n    var entry_count1;\n    var i1;\n    var delta;\n    entry_count1 = stream.readUint32();\n    this.sample_counts = [];\n    this.sample_deltas = [];\n    if (this.version === 0) for(i1 = 0; i1 < entry_count1; i1++){\n        this.sample_counts.push(stream.readUint32());\n        delta = stream.readInt32();\n        if (delta < 0) {\n            Log.warn(\"BoxParser\", \"File uses negative stts sample delta, using value 1 instead, sync may be lost!\");\n            delta = 1;\n        }\n        this.sample_deltas.push(delta);\n    }\n});\n// file:src/parsing/stvi.js\nBoxParser.createFullBoxCtor(\"stvi\", function(stream) {\n    var tmp32 = stream.readUint32();\n    this.single_view_allowed = tmp32 & 0x3;\n    this.stereo_scheme = stream.readUint32();\n    var length = stream.readUint32();\n    this.stereo_indication_type = stream.readString(length);\n    var ret1;\n    var box1;\n    this.boxes = [];\n    while(stream.getPosition() < this.start + this.size){\n        ret1 = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n        if (ret1.code === BoxParser.OK) {\n            box1 = ret1.box;\n            this.boxes.push(box1);\n            this[box1.type] = box1;\n        } else return;\n    }\n});\n// file:src/parsing/styp.js\nBoxParser.createBoxCtor(\"styp\", function(stream) {\n    BoxParser.ftypBox.prototype.parse.call(this, stream);\n});\n// file:src/parsing/stz2.js\nBoxParser.createFullBoxCtor(\"stz2\", function(stream) {\n    var i1;\n    var sample_size;\n    var sample_count;\n    this.sample_sizes = [];\n    if (this.version === 0) {\n        this.reserved = stream.readUint24();\n        this.field_size = stream.readUint8();\n        sample_count = stream.readUint32();\n        if (this.field_size === 4) for(i1 = 0; i1 < sample_count; i1 += 2){\n            var tmp = stream.readUint8();\n            this.sample_sizes[i1] = tmp >> 4 & 0xF;\n            this.sample_sizes[i1 + 1] = tmp & 0xF;\n        }\n        else if (this.field_size === 8) for(i1 = 0; i1 < sample_count; i1++)this.sample_sizes[i1] = stream.readUint8();\n        else if (this.field_size === 16) for(i1 = 0; i1 < sample_count; i1++)this.sample_sizes[i1] = stream.readUint16();\n        else Log.error(\"BoxParser\", \"Error in length field in stz2 box\");\n    }\n});\n// file:src/parsing/subs.js\nBoxParser.createFullBoxCtor(\"subs\", function(stream) {\n    var i1, j;\n    var entry_count1;\n    var subsample_count;\n    entry_count1 = stream.readUint32();\n    this.entries = [];\n    for(i1 = 0; i1 < entry_count1; i1++){\n        var sampleInfo = {};\n        this.entries[i1] = sampleInfo;\n        sampleInfo.sample_delta = stream.readUint32();\n        sampleInfo.subsamples = [];\n        subsample_count = stream.readUint16();\n        if (subsample_count > 0) for(j = 0; j < subsample_count; j++){\n            var subsample = {};\n            sampleInfo.subsamples.push(subsample);\n            if (this.version == 1) subsample.size = stream.readUint32();\n            else subsample.size = stream.readUint16();\n            subsample.priority = stream.readUint8();\n            subsample.discardable = stream.readUint8();\n            subsample.codec_specific_parameters = stream.readUint32();\n        }\n    }\n});\n// file:src/parsing/tenc.js\nBoxParser.createFullBoxCtor(\"tenc\", function(stream) {\n    stream.readUint8(); // reserved\n    if (this.version === 0) stream.readUint8();\n    else {\n        var tmp = stream.readUint8();\n        this.default_crypt_byte_block = tmp >> 4 & 0xF;\n        this.default_skip_byte_block = tmp & 0xF;\n    }\n    this.default_isProtected = stream.readUint8();\n    this.default_Per_Sample_IV_Size = stream.readUint8();\n    this.default_KID = BoxParser.parseHex16(stream);\n    if (this.default_isProtected === 1 && this.default_Per_Sample_IV_Size === 0) {\n        this.default_constant_IV_size = stream.readUint8();\n        this.default_constant_IV = stream.readUint8Array(this.default_constant_IV_size);\n    }\n}); // file:src/parsing/tfdt.js\nBoxParser.createFullBoxCtor(\"tfdt\", function(stream) {\n    if (this.version == 1) this.baseMediaDecodeTime = stream.readUint64();\n    else this.baseMediaDecodeTime = stream.readUint32();\n});\n// file:src/parsing/tfhd.js\nBoxParser.createFullBoxCtor(\"tfhd\", function(stream) {\n    var readBytes = 0;\n    this.track_id = stream.readUint32();\n    if (this.size - this.hdr_size > readBytes && this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) {\n        this.base_data_offset = stream.readUint64();\n        readBytes += 8;\n    } else this.base_data_offset = 0;\n    if (this.size - this.hdr_size > readBytes && this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) {\n        this.default_sample_description_index = stream.readUint32();\n        readBytes += 4;\n    } else this.default_sample_description_index = 0;\n    if (this.size - this.hdr_size > readBytes && this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) {\n        this.default_sample_duration = stream.readUint32();\n        readBytes += 4;\n    } else this.default_sample_duration = 0;\n    if (this.size - this.hdr_size > readBytes && this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) {\n        this.default_sample_size = stream.readUint32();\n        readBytes += 4;\n    } else this.default_sample_size = 0;\n    if (this.size - this.hdr_size > readBytes && this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) {\n        this.default_sample_flags = stream.readUint32();\n        readBytes += 4;\n    } else this.default_sample_flags = 0;\n});\n// file:src/parsing/tfra.js\nBoxParser.createFullBoxCtor(\"tfra\", function(stream) {\n    this.track_ID = stream.readUint32();\n    stream.readUint24();\n    var tmp_byte = stream.readUint8();\n    this.length_size_of_traf_num = tmp_byte >> 4 & 0x3;\n    this.length_size_of_trun_num = tmp_byte >> 2 & 0x3;\n    this.length_size_of_sample_num = tmp_byte & 0x3;\n    this.entries = [];\n    var number_of_entries = stream.readUint32();\n    for(var i1 = 0; i1 < number_of_entries; i1++){\n        if (this.version === 1) {\n            this.time = stream.readUint64();\n            this.moof_offset = stream.readUint64();\n        } else {\n            this.time = stream.readUint32();\n            this.moof_offset = stream.readUint32();\n        }\n        this.traf_number = stream[\"readUint\" + 8 * (this.length_size_of_traf_num + 1)]();\n        this.trun_number = stream[\"readUint\" + 8 * (this.length_size_of_trun_num + 1)]();\n        this.sample_number = stream[\"readUint\" + 8 * (this.length_size_of_sample_num + 1)]();\n    }\n});\n// file:src/parsing/tkhd.js\nBoxParser.createFullBoxCtor(\"tkhd\", function(stream) {\n    if (this.version == 1) {\n        this.creation_time = stream.readUint64();\n        this.modification_time = stream.readUint64();\n        this.track_id = stream.readUint32();\n        stream.readUint32();\n        this.duration = stream.readUint64();\n    } else {\n        this.creation_time = stream.readUint32();\n        this.modification_time = stream.readUint32();\n        this.track_id = stream.readUint32();\n        stream.readUint32();\n        this.duration = stream.readUint32();\n    }\n    stream.readUint32Array(2);\n    this.layer = stream.readInt16();\n    this.alternate_group = stream.readInt16();\n    this.volume = stream.readInt16() >> 8;\n    stream.readUint16();\n    this.matrix = stream.readInt32Array(9);\n    this.width = stream.readUint32();\n    this.height = stream.readUint32();\n});\n// file:src/parsing/tmax.js\nBoxParser.createBoxCtor(\"tmax\", function(stream) {\n    this.time = stream.readUint32();\n});\n// file:src/parsing/tmin.js\nBoxParser.createBoxCtor(\"tmin\", function(stream) {\n    this.time = stream.readUint32();\n});\n// file:src/parsing/totl.js\nBoxParser.createBoxCtor(\"totl\", function(stream) {\n    this.bytessent = stream.readUint32();\n});\n// file:src/parsing/tpay.js\nBoxParser.createBoxCtor(\"tpay\", function(stream) {\n    this.bytessent = stream.readUint32();\n});\n// file:src/parsing/tpyl.js\nBoxParser.createBoxCtor(\"tpyl\", function(stream) {\n    this.bytessent = stream.readUint64();\n});\n// file:src/parsing/TrackGroup.js\nBoxParser.TrackGroupTypeBox.prototype.parse = function(stream) {\n    this.parseFullHeader(stream);\n    this.track_group_id = stream.readUint32();\n};\n// file:src/parsing/trackgroups/msrc.js\nBoxParser.createTrackGroupCtor(\"msrc\"); // file:src/parsing/TrakReference.js\nBoxParser.TrackReferenceTypeBox = function(type, size, hdr_size, start) {\n    BoxParser.Box.call(this, type, size);\n    this.hdr_size = hdr_size;\n    this.start = start;\n};\nBoxParser.TrackReferenceTypeBox.prototype = new BoxParser.Box();\nBoxParser.TrackReferenceTypeBox.prototype.parse = function(stream) {\n    this.track_ids = stream.readUint32Array((this.size - this.hdr_size) / 4);\n};\n// file:src/parsing/tref.js\nBoxParser.trefBox.prototype.parse = function(stream) {\n    var ret1;\n    var box1;\n    while(stream.getPosition() < this.start + this.size){\n        ret1 = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n        if (ret1.code === BoxParser.OK) {\n            box1 = new BoxParser.TrackReferenceTypeBox(ret1.type, ret1.size, ret1.hdr_size, ret1.start);\n            if (box1.write === BoxParser.Box.prototype.write && box1.type !== \"mdat\") {\n                Log.info(\"BoxParser\", \"TrackReference \" + box1.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\");\n                box1.parseDataAndRewind(stream);\n            }\n            box1.parse(stream);\n            this.boxes.push(box1);\n        } else return;\n    }\n};\n// file:src/parsing/trep.js\nBoxParser.createFullBoxCtor(\"trep\", function(stream) {\n    this.track_ID = stream.readUint32();\n    this.boxes = [];\n    while(stream.getPosition() < this.start + this.size){\n        ret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n        if (ret.code === BoxParser.OK) {\n            box = ret.box;\n            this.boxes.push(box);\n        } else return;\n    }\n});\n// file:src/parsing/trex.js\nBoxParser.createFullBoxCtor(\"trex\", function(stream) {\n    this.track_id = stream.readUint32();\n    this.default_sample_description_index = stream.readUint32();\n    this.default_sample_duration = stream.readUint32();\n    this.default_sample_size = stream.readUint32();\n    this.default_sample_flags = stream.readUint32();\n});\n// file:src/parsing/trpy.js\nBoxParser.createBoxCtor(\"trpy\", function(stream) {\n    this.bytessent = stream.readUint64();\n});\n// file:src/parsing/trun.js\nBoxParser.createFullBoxCtor(\"trun\", function(stream) {\n    var readBytes = 0;\n    this.sample_count = stream.readUint32();\n    readBytes += 4;\n    if (this.size - this.hdr_size > readBytes && this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) {\n        this.data_offset = stream.readInt32(); //signed\n        readBytes += 4;\n    } else this.data_offset = 0;\n    if (this.size - this.hdr_size > readBytes && this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) {\n        this.first_sample_flags = stream.readUint32();\n        readBytes += 4;\n    } else this.first_sample_flags = 0;\n    this.sample_duration = [];\n    this.sample_size = [];\n    this.sample_flags = [];\n    this.sample_composition_time_offset = [];\n    if (this.size - this.hdr_size > readBytes) for(var i1 = 0; i1 < this.sample_count; i1++){\n        if (this.flags & BoxParser.TRUN_FLAGS_DURATION) this.sample_duration[i1] = stream.readUint32();\n        if (this.flags & BoxParser.TRUN_FLAGS_SIZE) this.sample_size[i1] = stream.readUint32();\n        if (this.flags & BoxParser.TRUN_FLAGS_FLAGS) this.sample_flags[i1] = stream.readUint32();\n        if (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n            if (this.version === 0) this.sample_composition_time_offset[i1] = stream.readUint32();\n            else this.sample_composition_time_offset[i1] = stream.readInt32(); //signed\n        }\n    }\n});\n// file:src/parsing/tsel.js\nBoxParser.createFullBoxCtor(\"tsel\", function(stream) {\n    this.switch_group = stream.readUint32();\n    var count = (this.size - this.hdr_size - 4) / 4;\n    this.attribute_list = [];\n    for(var i1 = 0; i1 < count; i1++)this.attribute_list[i1] = stream.readUint32();\n});\n// file:src/parsing/txtC.js\nBoxParser.createFullBoxCtor(\"txtC\", function(stream) {\n    this.config = stream.readCString();\n});\n// file:src/parsing/tyco.js\nBoxParser.createBoxCtor(\"tyco\", function(stream) {\n    var count = (this.size - this.hdr_size) / 4;\n    this.compatible_brands = [];\n    for(var i1 = 0; i1 < count; i1++)this.compatible_brands[i1] = stream.readString(4);\n});\n// file:src/parsing/udes.js\nBoxParser.createFullBoxCtor(\"udes\", function(stream) {\n    this.lang = stream.readCString();\n    this.name = stream.readCString();\n    this.description = stream.readCString();\n    this.tags = stream.readCString();\n});\n// file:src/parsing/uncC.js\nBoxParser.createFullBoxCtor(\"uncC\", function(stream) {\n    var i1;\n    this.profile = stream.readUint32();\n    if (this.version == 1) ;\n    else if (this.version == 0) {\n        this.component_count = stream.readUint32();\n        this.component_index = [];\n        this.component_bit_depth_minus_one = [];\n        this.component_format = [];\n        this.component_align_size = [];\n        for(i1 = 0; i1 < this.component_count; i1++){\n            this.component_index.push(stream.readUint16());\n            this.component_bit_depth_minus_one.push(stream.readUint8());\n            this.component_format.push(stream.readUint8());\n            this.component_align_size.push(stream.readUint8());\n        }\n        this.sampling_type = stream.readUint8();\n        this.interleave_type = stream.readUint8();\n        this.block_size = stream.readUint8();\n        var flags = stream.readUint8();\n        this.component_little_endian = flags >> 7 & 0x1;\n        this.block_pad_lsb = flags >> 6 & 0x1;\n        this.block_little_endian = flags >> 5 & 0x1;\n        this.block_reversed = flags >> 4 & 0x1;\n        this.pad_unknown = flags >> 3 & 0x1;\n        this.pixel_size = stream.readUint32();\n        this.row_align_size = stream.readUint32();\n        this.tile_align_size = stream.readUint32();\n        this.num_tile_cols_minus_one = stream.readUint32();\n        this.num_tile_rows_minus_one = stream.readUint32();\n    }\n});\n// file:src/parsing/url.js\nBoxParser.createFullBoxCtor(\"url \", function(stream) {\n    if (this.flags !== 0x000001) this.location = stream.readCString();\n});\n// file:src/parsing/urn.js\nBoxParser.createFullBoxCtor(\"urn \", function(stream) {\n    this.name = stream.readCString();\n    if (this.size - this.hdr_size - this.name.length - 1 > 0) this.location = stream.readCString();\n});\n// file:src/parsing/uuid/piff/piffLsm.js\nBoxParser.createUUIDBox(\"a5d40b30e81411ddba2f0800200c9a66\", true, false, function(stream) {\n    this.LiveServerManifest = stream.readString(this.size - this.hdr_size).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}); // file:src/parsing/uuid/piff/piffPssh.js\nBoxParser.createUUIDBox(\"d08a4f1810f34a82b6c832d8aba183d3\", true, false, function(stream) {\n    this.system_id = BoxParser.parseHex16(stream);\n    var datasize = stream.readUint32();\n    if (datasize > 0) this.data = stream.readUint8Array(datasize);\n});\n// file:src/parsing/uuid/piff/piffSenc.js\nBoxParser.createUUIDBox(\"a2394f525a9b4f14a2446c427c648df4\", true, false);\n// file:src/parsing/uuid/piff/piffTenc.js\nBoxParser.createUUIDBox(\"8974dbce7be74c5184f97148f9882554\", true, false, function(stream) {\n    this.default_AlgorithmID = stream.readUint24();\n    this.default_IV_size = stream.readUint8();\n    this.default_KID = BoxParser.parseHex16(stream);\n}); // file:src/parsing/uuid/piff/piffTfrf.js\nBoxParser.createUUIDBox(\"d4807ef2ca3946958e5426cb9e46a79f\", true, false, function(stream) {\n    this.fragment_count = stream.readUint8();\n    this.entries = [];\n    for(var i1 = 0; i1 < this.fragment_count; i1++){\n        var entry = {};\n        var absolute_time = 0;\n        var absolute_duration = 0;\n        if (this.version === 1) {\n            absolute_time = stream.readUint64();\n            absolute_duration = stream.readUint64();\n        } else {\n            absolute_time = stream.readUint32();\n            absolute_duration = stream.readUint32();\n        }\n        entry.absolute_time = absolute_time;\n        entry.absolute_duration = absolute_duration;\n        this.entries.push(entry);\n    }\n}); // file:src/parsing/uuid/piff/piffTfxd.js\nBoxParser.createUUIDBox(\"6d1d9b0542d544e680e2141daff757b2\", true, false, function(stream) {\n    if (this.version === 1) {\n        this.absolute_time = stream.readUint64();\n        this.duration = stream.readUint64();\n    } else {\n        this.absolute_time = stream.readUint32();\n        this.duration = stream.readUint32();\n    }\n}); // file:src/parsing/vmhd.js\nBoxParser.createFullBoxCtor(\"vmhd\", function(stream) {\n    this.graphicsmode = stream.readUint16();\n    this.opcolor = stream.readUint16Array(3);\n});\n// file:src/parsing/vpcC.js\nBoxParser.createFullBoxCtor(\"vpcC\", function(stream) {\n    var tmp;\n    if (this.version === 1) {\n        this.profile = stream.readUint8();\n        this.level = stream.readUint8();\n        tmp = stream.readUint8();\n        this.bitDepth = tmp >> 4;\n        this.chromaSubsampling = tmp >> 1 & 0x7;\n        this.videoFullRangeFlag = tmp & 0x1;\n        this.colourPrimaries = stream.readUint8();\n        this.transferCharacteristics = stream.readUint8();\n        this.matrixCoefficients = stream.readUint8();\n        this.codecIntializationDataSize = stream.readUint16();\n        this.codecIntializationData = stream.readUint8Array(this.codecIntializationDataSize);\n    } else {\n        this.profile = stream.readUint8();\n        this.level = stream.readUint8();\n        tmp = stream.readUint8();\n        this.bitDepth = tmp >> 4 & 0xF;\n        this.colorSpace = tmp & 0xF;\n        tmp = stream.readUint8();\n        this.chromaSubsampling = tmp >> 4 & 0xF;\n        this.transferFunction = tmp >> 1 & 0x7;\n        this.videoFullRangeFlag = tmp & 0x1;\n        this.codecIntializationDataSize = stream.readUint16();\n        this.codecIntializationData = stream.readUint8Array(this.codecIntializationDataSize);\n    }\n}); // file:src/parsing/vttC.js\nBoxParser.createBoxCtor(\"vttC\", function(stream) {\n    this.text = stream.readString(this.size - this.hdr_size);\n});\n// file:src/parsing/vvcC.js\nBoxParser.createFullBoxCtor(\"vvcC\", function(stream) {\n    var i1, j;\n    // helper object to simplify extracting individual bits\n    var bitReader = {\n        held_bits: undefined,\n        num_held_bits: 0,\n        stream_read_1_bytes: function(strm1) {\n            this.held_bits = strm1.readUint8();\n            this.num_held_bits = 8;\n        },\n        stream_read_2_bytes: function(strm1) {\n            this.held_bits = strm1.readUint16();\n            this.num_held_bits = 16;\n        },\n        extract_bits: function(num_bits) {\n            var ret1 = this.held_bits >> this.num_held_bits - num_bits & (1 << num_bits) - 1;\n            this.num_held_bits -= num_bits;\n            return ret1;\n        }\n    };\n    // VvcDecoderConfigurationRecord\n    bitReader.stream_read_1_bytes(stream);\n    bitReader.extract_bits(5); // reserved\n    this.lengthSizeMinusOne = bitReader.extract_bits(2);\n    this.ptl_present_flag = bitReader.extract_bits(1);\n    if (this.ptl_present_flag) {\n        bitReader.stream_read_2_bytes(stream);\n        this.ols_idx = bitReader.extract_bits(9);\n        this.num_sublayers = bitReader.extract_bits(3);\n        this.constant_frame_rate = bitReader.extract_bits(2);\n        this.chroma_format_idc = bitReader.extract_bits(2);\n        bitReader.stream_read_1_bytes(stream);\n        this.bit_depth_minus8 = bitReader.extract_bits(3);\n        bitReader.extract_bits(5); // reserved\n        bitReader.stream_read_2_bytes(stream);\n        bitReader.extract_bits(2); // reserved\n        this.num_bytes_constraint_info = bitReader.extract_bits(6);\n        this.general_profile_idc = bitReader.extract_bits(7);\n        this.general_tier_flag = bitReader.extract_bits(1);\n        this.general_level_idc = stream.readUint8();\n        bitReader.stream_read_1_bytes(stream);\n        this.ptl_frame_only_constraint_flag = bitReader.extract_bits(1);\n        this.ptl_multilayer_enabled_flag = bitReader.extract_bits(1);\n        this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info);\n        if (this.num_bytes_constraint_info) {\n            for(i1 = 0; i1 < this.num_bytes_constraint_info - 1; i1++){\n                var cnstr1 = bitReader.extract_bits(6);\n                bitReader.stream_read_1_bytes(stream);\n                var cnstr2 = bitReader.extract_bits(2);\n                this.general_constraint_info[i1] = cnstr1 << 2 | cnstr2;\n            }\n            this.general_constraint_info[this.num_bytes_constraint_info - 1] = bitReader.extract_bits(6);\n        } else //forbidden in spec!\n        bitReader.extract_bits(6);\n        if (this.num_sublayers > 1) {\n            bitReader.stream_read_1_bytes(stream);\n            this.ptl_sublayer_present_mask = 0;\n            for(j = this.num_sublayers - 2; j >= 0; --j){\n                var val = bitReader.extract_bits(1);\n                this.ptl_sublayer_present_mask |= val << j;\n            }\n            for(j = this.num_sublayers; j <= 8 && this.num_sublayers > 1; ++j)bitReader.extract_bits(1); // ptl_reserved_zero_bit\n            this.sublayer_level_idc = [];\n            for(j = this.num_sublayers - 2; j >= 0; --j)if (this.ptl_sublayer_present_mask & 1 << j) this.sublayer_level_idc[j] = stream.readUint8();\n        }\n        this.ptl_num_sub_profiles = stream.readUint8();\n        this.general_sub_profile_idc = [];\n        if (this.ptl_num_sub_profiles) for(i1 = 0; i1 < this.ptl_num_sub_profiles; i1++)this.general_sub_profile_idc.push(stream.readUint32());\n        this.max_picture_width = stream.readUint16();\n        this.max_picture_height = stream.readUint16();\n        this.avg_frame_rate = stream.readUint16();\n    }\n    var VVC_NALU_OPI = 12;\n    var VVC_NALU_DEC_PARAM = 13;\n    this.nalu_arrays = [];\n    var num_of_arrays = stream.readUint8();\n    for(i1 = 0; i1 < num_of_arrays; i1++){\n        var nalu_array = [];\n        this.nalu_arrays.push(nalu_array);\n        bitReader.stream_read_1_bytes(stream);\n        nalu_array.completeness = bitReader.extract_bits(1);\n        bitReader.extract_bits(2); // reserved\n        nalu_array.nalu_type = bitReader.extract_bits(5);\n        var numNalus = 1;\n        if (nalu_array.nalu_type != VVC_NALU_DEC_PARAM && nalu_array.nalu_type != VVC_NALU_OPI) numNalus = stream.readUint16();\n        for(j = 0; j < numNalus; j++){\n            var len = stream.readUint16();\n            nalu_array.push({\n                data: stream.readUint8Array(len),\n                length: len\n            });\n        }\n    }\n});\n// file:src/parsing/vvnC.js\nBoxParser.createFullBoxCtor(\"vvnC\", function(stream) {\n    // VvcNALUConfigBox\n    var tmp = strm.readUint8();\n    this.lengthSizeMinusOne = tmp & 0x3;\n});\n// file:src/box-codecs.js\nBoxParser.SampleEntry.prototype.isVideo = function() {\n    return false;\n};\nBoxParser.SampleEntry.prototype.isAudio = function() {\n    return false;\n};\nBoxParser.SampleEntry.prototype.isSubtitle = function() {\n    return false;\n};\nBoxParser.SampleEntry.prototype.isMetadata = function() {\n    return false;\n};\nBoxParser.SampleEntry.prototype.isHint = function() {\n    return false;\n};\nBoxParser.SampleEntry.prototype.getCodec = function() {\n    return this.type.replace('.', '');\n};\nBoxParser.SampleEntry.prototype.getWidth = function() {\n    return \"\";\n};\nBoxParser.SampleEntry.prototype.getHeight = function() {\n    return \"\";\n};\nBoxParser.SampleEntry.prototype.getChannelCount = function() {\n    return \"\";\n};\nBoxParser.SampleEntry.prototype.getSampleRate = function() {\n    return \"\";\n};\nBoxParser.SampleEntry.prototype.getSampleSize = function() {\n    return \"\";\n};\nBoxParser.VisualSampleEntry.prototype.isVideo = function() {\n    return true;\n};\nBoxParser.VisualSampleEntry.prototype.getWidth = function() {\n    return this.width;\n};\nBoxParser.VisualSampleEntry.prototype.getHeight = function() {\n    return this.height;\n};\nBoxParser.AudioSampleEntry.prototype.isAudio = function() {\n    return true;\n};\nBoxParser.AudioSampleEntry.prototype.getChannelCount = function() {\n    return this.channel_count;\n};\nBoxParser.AudioSampleEntry.prototype.getSampleRate = function() {\n    return this.samplerate;\n};\nBoxParser.AudioSampleEntry.prototype.getSampleSize = function() {\n    return this.samplesize;\n};\nBoxParser.SubtitleSampleEntry.prototype.isSubtitle = function() {\n    return true;\n};\nBoxParser.MetadataSampleEntry.prototype.isMetadata = function() {\n    return true;\n};\nBoxParser.decimalToHex = function(d, padding) {\n    var hex = Number(d).toString(16);\n    padding = typeof padding === \"undefined\" || padding === null ? padding = 2 : padding;\n    while(hex.length < padding)hex = \"0\" + hex;\n    return hex;\n};\nBoxParser.avc1SampleEntry.prototype.getCodec = BoxParser.avc2SampleEntry.prototype.getCodec = BoxParser.avc3SampleEntry.prototype.getCodec = BoxParser.avc4SampleEntry.prototype.getCodec = function() {\n    var baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n    if (this.avcC) return baseCodec + \".\" + BoxParser.decimalToHex(this.avcC.AVCProfileIndication) + \"\" + BoxParser.decimalToHex(this.avcC.profile_compatibility) + \"\" + BoxParser.decimalToHex(this.avcC.AVCLevelIndication);\n    else return baseCodec;\n};\nBoxParser.hev1SampleEntry.prototype.getCodec = BoxParser.hvc1SampleEntry.prototype.getCodec = function() {\n    var i1;\n    var baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n    if (this.hvcC) {\n        baseCodec += '.';\n        switch(this.hvcC.general_profile_space){\n            case 0:\n                baseCodec += '';\n                break;\n            case 1:\n                baseCodec += 'A';\n                break;\n            case 2:\n                baseCodec += 'B';\n                break;\n            case 3:\n                baseCodec += 'C';\n                break;\n        }\n        baseCodec += this.hvcC.general_profile_idc;\n        baseCodec += '.';\n        var val = this.hvcC.general_profile_compatibility;\n        var reversed = 0;\n        for(i1 = 0; i1 < 32; i1++){\n            reversed |= val & 1;\n            if (i1 == 31) break;\n            reversed <<= 1;\n            val >>= 1;\n        }\n        baseCodec += BoxParser.decimalToHex(reversed, 0);\n        baseCodec += '.';\n        if (this.hvcC.general_tier_flag === 0) baseCodec += 'L';\n        else baseCodec += 'H';\n        baseCodec += this.hvcC.general_level_idc;\n        var hasByte = false;\n        var constraint_string = \"\";\n        for(i1 = 5; i1 >= 0; i1--)if (this.hvcC.general_constraint_indicator[i1] || hasByte) {\n            constraint_string = \".\" + BoxParser.decimalToHex(this.hvcC.general_constraint_indicator[i1], 0) + constraint_string;\n            hasByte = true;\n        }\n        baseCodec += constraint_string;\n    }\n    return baseCodec;\n};\nBoxParser.vvc1SampleEntry.prototype.getCodec = BoxParser.vvi1SampleEntry.prototype.getCodec = function() {\n    var i1;\n    var baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n    if (this.vvcC) {\n        baseCodec += '.' + this.vvcC.general_profile_idc;\n        if (this.vvcC.general_tier_flag) baseCodec += '.H';\n        else baseCodec += '.L';\n        baseCodec += this.vvcC.general_level_idc;\n        var constraint_string = \"\";\n        if (this.vvcC.general_constraint_info) {\n            var bytes = [];\n            var byte = 0;\n            byte |= this.vvcC.ptl_frame_only_constraint << 7;\n            byte |= this.vvcC.ptl_multilayer_enabled << 6;\n            var last_nonzero;\n            for(i1 = 0; i1 < this.vvcC.general_constraint_info.length; ++i1){\n                byte |= this.vvcC.general_constraint_info[i1] >> 2 & 0x3f;\n                bytes.push(byte);\n                if (byte) last_nonzero = i1;\n                byte = this.vvcC.general_constraint_info[i1] >> 2 & 0x03;\n            }\n            if (last_nonzero === undefined) constraint_string = \".CA\";\n            else {\n                constraint_string = \".C\";\n                var base32_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n                var held_bits = 0;\n                var num_held_bits = 0;\n                for(i1 = 0; i1 <= last_nonzero; ++i1){\n                    held_bits = held_bits << 8 | bytes[i1];\n                    num_held_bits += 8;\n                    while(num_held_bits >= 5){\n                        var val = held_bits >> num_held_bits - 5 & 0x1f;\n                        constraint_string += base32_chars[val];\n                        num_held_bits -= 5;\n                        held_bits &= (1 << num_held_bits) - 1;\n                    }\n                }\n                if (num_held_bits) {\n                    held_bits <<= 5 - num_held_bits; // right-pad with zeros to 5 bits (is this correct?)\n                    constraint_string += base32_chars[held_bits & 0x1f];\n                }\n            }\n        }\n        baseCodec += constraint_string;\n    }\n    return baseCodec;\n};\nBoxParser.mp4aSampleEntry.prototype.getCodec = function() {\n    var baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n    if (this.esds && this.esds.esd) {\n        var oti = this.esds.esd.getOTI();\n        var dsi = this.esds.esd.getAudioConfig();\n        return baseCodec + \".\" + BoxParser.decimalToHex(oti) + (dsi ? \".\" + dsi : \"\");\n    } else return baseCodec;\n};\nBoxParser.stxtSampleEntry.prototype.getCodec = function() {\n    var baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n    if (this.mime_format) return baseCodec + \".\" + this.mime_format;\n    else return baseCodec;\n};\nBoxParser.vp08SampleEntry.prototype.getCodec = BoxParser.vp09SampleEntry.prototype.getCodec = function() {\n    var baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n    var level = this.vpcC.level;\n    if (level == 0) level = \"00\";\n    var bitDepth = this.vpcC.bitDepth;\n    if (bitDepth == 8) bitDepth = \"08\";\n    return baseCodec + \".0\" + this.vpcC.profile + \".\" + level + \".\" + bitDepth;\n};\nBoxParser.av01SampleEntry.prototype.getCodec = function() {\n    var baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n    var level = this.av1C.seq_level_idx_0;\n    if (level < 10) level = \"0\" + level;\n    var bitdepth;\n    if (this.av1C.seq_profile === 2 && this.av1C.high_bitdepth === 1) bitdepth = this.av1C.twelve_bit === 1 ? \"12\" : \"10\";\n    else if (this.av1C.seq_profile <= 2) bitdepth = this.av1C.high_bitdepth === 1 ? \"10\" : \"08\";\n    // TODO need to parse the SH to find color config\n    return baseCodec + \".\" + this.av1C.seq_profile + \".\" + level + (this.av1C.seq_tier_0 ? \"H\" : \"M\") + \".\" + bitdepth; //+\".\"+this.av1C.monochrome+\".\"+this.av1C.chroma_subsampling_x+\"\"+this.av1C.chroma_subsampling_y+\"\"+this.av1C.chroma_sample_position;\n};\n// file:src/box-write.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ BoxParser.Box.prototype.writeHeader = function(stream, msg) {\n    this.size += 8;\n    if (this.size > MAX_SIZE) this.size += 8;\n    if (this.type === \"uuid\") this.size += 16;\n    Log.debug(\"BoxWriter\", \"Writing box \" + this.type + \" of size: \" + this.size + \" at position \" + stream.getPosition() + (msg || \"\"));\n    if (this.size > MAX_SIZE) stream.writeUint32(1);\n    else {\n        this.sizePosition = stream.getPosition();\n        stream.writeUint32(this.size);\n    }\n    stream.writeString(this.type, null, 4);\n    if (this.type === \"uuid\") stream.writeUint8Array(this.uuid);\n    if (this.size > MAX_SIZE) stream.writeUint64(this.size);\n};\nBoxParser.FullBox.prototype.writeHeader = function(stream) {\n    this.size += 4;\n    BoxParser.Box.prototype.writeHeader.call(this, stream, \" v=\" + this.version + \" f=\" + this.flags);\n    stream.writeUint8(this.version);\n    stream.writeUint24(this.flags);\n};\nBoxParser.Box.prototype.write = function(stream) {\n    if (this.type === \"mdat\") /* TODO: fix this */ {\n        if (this.data) {\n            this.size = this.data.length;\n            this.writeHeader(stream);\n            stream.writeUint8Array(this.data);\n        }\n    } else {\n        this.size = this.data ? this.data.length : 0;\n        this.writeHeader(stream);\n        if (this.data) stream.writeUint8Array(this.data);\n    }\n};\nBoxParser.ContainerBox.prototype.write = function(stream) {\n    this.size = 0;\n    this.writeHeader(stream);\n    for(var i1 = 0; i1 < this.boxes.length; i1++)if (this.boxes[i1]) {\n        this.boxes[i1].write(stream);\n        this.size += this.boxes[i1].size;\n    }\n    /* adjusting the size, now that all sub-boxes are known */ Log.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size);\n    stream.adjustUint32(this.sizePosition, this.size);\n};\nBoxParser.TrackReferenceTypeBox.prototype.write = function(stream) {\n    this.size = this.track_ids.length * 4;\n    this.writeHeader(stream);\n    stream.writeUint32Array(this.track_ids);\n};\n// file:src/writing/avcC.js\nBoxParser.avcCBox.prototype.write = function(stream) {\n    var i1;\n    this.size = 7;\n    for(i1 = 0; i1 < this.SPS.length; i1++)this.size += 2 + this.SPS[i1].length;\n    for(i1 = 0; i1 < this.PPS.length; i1++)this.size += 2 + this.PPS[i1].length;\n    if (this.ext) this.size += this.ext.length;\n    this.writeHeader(stream);\n    stream.writeUint8(this.configurationVersion);\n    stream.writeUint8(this.AVCProfileIndication);\n    stream.writeUint8(this.profile_compatibility);\n    stream.writeUint8(this.AVCLevelIndication);\n    stream.writeUint8(this.lengthSizeMinusOne + 252);\n    stream.writeUint8(this.SPS.length + 224);\n    for(i1 = 0; i1 < this.SPS.length; i1++){\n        stream.writeUint16(this.SPS[i1].length);\n        stream.writeUint8Array(this.SPS[i1].nalu);\n    }\n    stream.writeUint8(this.PPS.length);\n    for(i1 = 0; i1 < this.PPS.length; i1++){\n        stream.writeUint16(this.PPS[i1].length);\n        stream.writeUint8Array(this.PPS[i1].nalu);\n    }\n    if (this.ext) stream.writeUint8Array(this.ext);\n};\n// file:src/writing/co64.js\nBoxParser.co64Box.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4 + 8 * this.chunk_offsets.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.chunk_offsets.length);\n    for(i1 = 0; i1 < this.chunk_offsets.length; i1++)stream.writeUint64(this.chunk_offsets[i1]);\n};\n// file:src/writing/cslg.js\nBoxParser.cslgBox.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 0;\n    this.size = 20;\n    this.writeHeader(stream);\n    stream.writeInt32(this.compositionToDTSShift);\n    stream.writeInt32(this.leastDecodeToDisplayDelta);\n    stream.writeInt32(this.greatestDecodeToDisplayDelta);\n    stream.writeInt32(this.compositionStartTime);\n    stream.writeInt32(this.compositionEndTime);\n};\n// file:src/writing/ctts.js\nBoxParser.cttsBox.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4 + 8 * this.sample_counts.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.sample_counts.length);\n    for(i1 = 0; i1 < this.sample_counts.length; i1++){\n        stream.writeUint32(this.sample_counts[i1]);\n        if (this.version === 1) stream.writeInt32(this.sample_offsets[i1]); /* signed */ \n        else stream.writeUint32(this.sample_offsets[i1]); /* unsigned */ \n    }\n};\n// file:src/writing/dref.js\nBoxParser.drefBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4; //\n    this.writeHeader(stream);\n    stream.writeUint32(this.entries.length);\n    for(var i1 = 0; i1 < this.entries.length; i1++){\n        this.entries[i1].write(stream);\n        this.size += this.entries[i1].size;\n    }\n    /* adjusting the size, now that all sub-boxes are known */ Log.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size);\n    stream.adjustUint32(this.sizePosition, this.size);\n};\n// file:src/writing/elng.js\nBoxParser.elngBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = this.extended_language.length;\n    this.writeHeader(stream);\n    stream.writeString(this.extended_language);\n};\n// file:src/writing/elst.js\nBoxParser.elstBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4 + 12 * this.entries.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.entries.length);\n    for(var i1 = 0; i1 < this.entries.length; i1++){\n        var entry = this.entries[i1];\n        stream.writeUint32(entry.segment_duration);\n        stream.writeInt32(entry.media_time);\n        stream.writeInt16(entry.media_rate_integer);\n        stream.writeInt16(entry.media_rate_fraction);\n    }\n};\n// file:src/writing/emsg.js\nBoxParser.emsgBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 16 + this.message_data.length + (this.scheme_id_uri.length + 1) + (this.value.length + 1);\n    this.writeHeader(stream);\n    stream.writeCString(this.scheme_id_uri);\n    stream.writeCString(this.value);\n    stream.writeUint32(this.timescale);\n    stream.writeUint32(this.presentation_time_delta);\n    stream.writeUint32(this.event_duration);\n    stream.writeUint32(this.id);\n    stream.writeUint8Array(this.message_data);\n};\n// file:src/writing/ftyp.js\nBoxParser.ftypBox.prototype.write = function(stream) {\n    this.size = 8 + 4 * this.compatible_brands.length;\n    this.writeHeader(stream);\n    stream.writeString(this.major_brand, null, 4);\n    stream.writeUint32(this.minor_version);\n    for(var i1 = 0; i1 < this.compatible_brands.length; i1++)stream.writeString(this.compatible_brands[i1], null, 4);\n};\n// file:src/writing/hdlr.js\nBoxParser.hdlrBox.prototype.write = function(stream) {\n    this.size = 20 + this.name.length + 1;\n    this.version = 0;\n    this.flags = 0;\n    this.writeHeader(stream);\n    stream.writeUint32(0);\n    stream.writeString(this.handler, null, 4);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeCString(this.name);\n};\n// file:src/writing/hvcC.js\nBoxParser.hvcCBox.prototype.write = function(stream) {\n    var i1, j;\n    this.size = 23;\n    for(i1 = 0; i1 < this.nalu_arrays.length; i1++){\n        this.size += 3;\n        for(j = 0; j < this.nalu_arrays[i1].length; j++)this.size += 2 + this.nalu_arrays[i1][j].data.length;\n    }\n    this.writeHeader(stream);\n    stream.writeUint8(this.configurationVersion);\n    stream.writeUint8((this.general_profile_space << 6) + (this.general_tier_flag << 5) + this.general_profile_idc);\n    stream.writeUint32(this.general_profile_compatibility);\n    stream.writeUint8Array(this.general_constraint_indicator);\n    stream.writeUint8(this.general_level_idc);\n    stream.writeUint16(this.min_spatial_segmentation_idc + 251658240);\n    stream.writeUint8(this.parallelismType + 252);\n    stream.writeUint8(this.chroma_format_idc + 252);\n    stream.writeUint8(this.bit_depth_luma_minus8 + 248);\n    stream.writeUint8(this.bit_depth_chroma_minus8 + 248);\n    stream.writeUint16(this.avgFrameRate);\n    stream.writeUint8((this.constantFrameRate << 6) + (this.numTemporalLayers << 3) + (this.temporalIdNested << 2) + this.lengthSizeMinusOne);\n    stream.writeUint8(this.nalu_arrays.length);\n    for(i1 = 0; i1 < this.nalu_arrays.length; i1++){\n        // bit(1) array_completeness + bit(1) reserved = 0 + bit(6) nal_unit_type\n        stream.writeUint8((this.nalu_arrays[i1].completeness << 7) + this.nalu_arrays[i1].nalu_type);\n        stream.writeUint16(this.nalu_arrays[i1].length);\n        for(j = 0; j < this.nalu_arrays[i1].length; j++){\n            stream.writeUint16(this.nalu_arrays[i1][j].data.length);\n            stream.writeUint8Array(this.nalu_arrays[i1][j].data);\n        }\n    }\n};\n// file:src/writing/kind.js\nBoxParser.kindBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = this.schemeURI.length + 1 + (this.value.length + 1);\n    this.writeHeader(stream);\n    stream.writeCString(this.schemeURI);\n    stream.writeCString(this.value);\n};\n// file:src/writing/mdhd.js\nBoxParser.mdhdBox.prototype.write = function(stream) {\n    this.size = 20;\n    this.flags = 0;\n    this.version = 0;\n    this.writeHeader(stream);\n    stream.writeUint32(this.creation_time);\n    stream.writeUint32(this.modification_time);\n    stream.writeUint32(this.timescale);\n    stream.writeUint32(this.duration);\n    stream.writeUint16(this.language);\n    stream.writeUint16(0);\n};\n// file:src/writing/mehd.js\nBoxParser.mehdBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4;\n    this.writeHeader(stream);\n    stream.writeUint32(this.fragment_duration);\n};\n// file:src/writing/mfhd.js\nBoxParser.mfhdBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4;\n    this.writeHeader(stream);\n    stream.writeUint32(this.sequence_number);\n};\n// file:src/writing/mvhd.js\nBoxParser.mvhdBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 96;\n    this.writeHeader(stream);\n    stream.writeUint32(this.creation_time);\n    stream.writeUint32(this.modification_time);\n    stream.writeUint32(this.timescale);\n    stream.writeUint32(this.duration);\n    stream.writeUint32(this.rate);\n    stream.writeUint16(this.volume << 8);\n    stream.writeUint16(0);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint32Array(this.matrix);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint32(this.next_track_id);\n};\n// file:src/writing/sampleentry.js\nBoxParser.SampleEntry.prototype.writeHeader = function(stream) {\n    this.size = 8;\n    BoxParser.Box.prototype.writeHeader.call(this, stream);\n    stream.writeUint8(0);\n    stream.writeUint8(0);\n    stream.writeUint8(0);\n    stream.writeUint8(0);\n    stream.writeUint8(0);\n    stream.writeUint8(0);\n    stream.writeUint16(this.data_reference_index);\n};\nBoxParser.SampleEntry.prototype.writeFooter = function(stream) {\n    for(var i1 = 0; i1 < this.boxes.length; i1++){\n        this.boxes[i1].write(stream);\n        this.size += this.boxes[i1].size;\n    }\n    Log.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size);\n    stream.adjustUint32(this.sizePosition, this.size);\n};\nBoxParser.SampleEntry.prototype.write = function(stream) {\n    this.writeHeader(stream);\n    stream.writeUint8Array(this.data);\n    this.size += this.data.length;\n    Log.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size);\n    stream.adjustUint32(this.sizePosition, this.size);\n};\nBoxParser.VisualSampleEntry.prototype.write = function(stream) {\n    this.writeHeader(stream);\n    this.size += 70;\n    stream.writeUint16(0);\n    stream.writeUint16(0);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint16(this.width);\n    stream.writeUint16(this.height);\n    stream.writeUint32(this.horizresolution);\n    stream.writeUint32(this.vertresolution);\n    stream.writeUint32(0);\n    stream.writeUint16(this.frame_count);\n    stream.writeUint8(Math.min(31, this.compressorname.length));\n    stream.writeString(this.compressorname, null, 31);\n    stream.writeUint16(this.depth);\n    stream.writeInt16(-1);\n    this.writeFooter(stream);\n};\nBoxParser.AudioSampleEntry.prototype.write = function(stream) {\n    this.writeHeader(stream);\n    this.size += 20;\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeUint16(this.channel_count);\n    stream.writeUint16(this.samplesize);\n    stream.writeUint16(0);\n    stream.writeUint16(0);\n    stream.writeUint32(this.samplerate << 16);\n    this.writeFooter(stream);\n};\nBoxParser.stppSampleEntry.prototype.write = function(stream) {\n    this.writeHeader(stream);\n    this.size += this.namespace.length + 1 + this.schema_location.length + 1 + this.auxiliary_mime_types.length + 1;\n    stream.writeCString(this.namespace);\n    stream.writeCString(this.schema_location);\n    stream.writeCString(this.auxiliary_mime_types);\n    this.writeFooter(stream);\n};\n// file:src/writing/samplegroups/samplegroup.js\nBoxParser.SampleGroupEntry.prototype.write = function(stream) {\n    stream.writeUint8Array(this.data);\n};\n// file:src/writing/sbgp.js\nBoxParser.sbgpBox.prototype.write = function(stream) {\n    this.version = 1;\n    this.flags = 0;\n    this.size = 12 + 8 * this.entries.length;\n    this.writeHeader(stream);\n    stream.writeString(this.grouping_type, null, 4);\n    stream.writeUint32(this.grouping_type_parameter);\n    stream.writeUint32(this.entries.length);\n    for(var i1 = 0; i1 < this.entries.length; i1++){\n        var entry = this.entries[i1];\n        stream.writeInt32(entry.sample_count);\n        stream.writeInt32(entry.group_description_index);\n    }\n};\n// file:src/writing/sgpd.js\nBoxParser.sgpdBox.prototype.write = function(stream) {\n    var i1;\n    var entry;\n    // leave version as read\n    // this.version;\n    this.flags = 0;\n    this.size = 12;\n    for(i1 = 0; i1 < this.entries.length; i1++){\n        entry = this.entries[i1];\n        if (this.version === 1) {\n            if (this.default_length === 0) this.size += 4;\n            this.size += entry.data.length;\n        }\n    }\n    this.writeHeader(stream);\n    stream.writeString(this.grouping_type, null, 4);\n    if (this.version === 1) stream.writeUint32(this.default_length);\n    if (this.version >= 2) stream.writeUint32(this.default_sample_description_index);\n    stream.writeUint32(this.entries.length);\n    for(i1 = 0; i1 < this.entries.length; i1++){\n        entry = this.entries[i1];\n        if (this.version === 1) {\n            if (this.default_length === 0) stream.writeUint32(entry.description_length);\n        }\n        entry.write(stream);\n    }\n};\n// file:src/writing/sidx.js\nBoxParser.sidxBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 20 + 12 * this.references.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.reference_ID);\n    stream.writeUint32(this.timescale);\n    stream.writeUint32(this.earliest_presentation_time);\n    stream.writeUint32(this.first_offset);\n    stream.writeUint16(0);\n    stream.writeUint16(this.references.length);\n    for(var i1 = 0; i1 < this.references.length; i1++){\n        var ref = this.references[i1];\n        stream.writeUint32(ref.reference_type << 31 | ref.referenced_size);\n        stream.writeUint32(ref.subsegment_duration);\n        stream.writeUint32(ref.starts_with_SAP << 31 | ref.SAP_type << 28 | ref.SAP_delta_time);\n    }\n};\n// file:src/writing/smhd.js\nBoxParser.smhdBox.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 1;\n    this.size = 4;\n    this.writeHeader(stream);\n    stream.writeUint16(this.balance);\n    stream.writeUint16(0);\n};\n// file:src/writing/stco.js\nBoxParser.stcoBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4 + 4 * this.chunk_offsets.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.chunk_offsets.length);\n    stream.writeUint32Array(this.chunk_offsets);\n};\n// file:src/writing/stsc.js\nBoxParser.stscBox.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4 + 12 * this.first_chunk.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.first_chunk.length);\n    for(i1 = 0; i1 < this.first_chunk.length; i1++){\n        stream.writeUint32(this.first_chunk[i1]);\n        stream.writeUint32(this.samples_per_chunk[i1]);\n        stream.writeUint32(this.sample_description_index[i1]);\n    }\n};\n// file:src/writing/stsd.js\nBoxParser.stsdBox.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 0;\n    this.size = 0;\n    this.writeHeader(stream);\n    stream.writeUint32(this.entries.length);\n    this.size += 4;\n    for(i1 = 0; i1 < this.entries.length; i1++){\n        this.entries[i1].write(stream);\n        this.size += this.entries[i1].size;\n    }\n    /* adjusting the size, now that all sub-boxes are known */ Log.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size);\n    stream.adjustUint32(this.sizePosition, this.size);\n};\n// file:src/writing/stsh.js\nBoxParser.stshBox.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4 + 8 * this.shadowed_sample_numbers.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.shadowed_sample_numbers.length);\n    for(i1 = 0; i1 < this.shadowed_sample_numbers.length; i1++){\n        stream.writeUint32(this.shadowed_sample_numbers[i1]);\n        stream.writeUint32(this.sync_sample_numbers[i1]);\n    }\n};\n// file:src/writing/stss.js\nBoxParser.stssBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4 + 4 * this.sample_numbers.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.sample_numbers.length);\n    stream.writeUint32Array(this.sample_numbers);\n};\n// file:src/writing/stsz.js\nBoxParser.stszBox.prototype.write = function(stream) {\n    var i1;\n    var constant = true;\n    this.version = 0;\n    this.flags = 0;\n    if (this.sample_sizes.length > 0) {\n        i1 = 0;\n        while(i1 + 1 < this.sample_sizes.length)if (this.sample_sizes[i1 + 1] !== this.sample_sizes[0]) {\n            constant = false;\n            break;\n        } else i1++;\n    } else constant = false;\n    this.size = 8;\n    if (!constant) this.size += 4 * this.sample_sizes.length;\n    this.writeHeader(stream);\n    if (!constant) stream.writeUint32(0);\n    else stream.writeUint32(this.sample_sizes[0]);\n    stream.writeUint32(this.sample_sizes.length);\n    if (!constant) stream.writeUint32Array(this.sample_sizes);\n};\n// file:src/writing/stts.js\nBoxParser.sttsBox.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 0;\n    this.size = 4 + 8 * this.sample_counts.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.sample_counts.length);\n    for(i1 = 0; i1 < this.sample_counts.length; i1++){\n        stream.writeUint32(this.sample_counts[i1]);\n        stream.writeUint32(this.sample_deltas[i1]);\n    }\n};\n// file:src/writing/tfdt.js\nBoxParser.tfdtBox.prototype.write = function(stream) {\n    var UINT32_MAX = Math.pow(2, 32) - 1;\n    // use version 1 if baseMediaDecodeTime does not fit 32 bits\n    this.version = this.baseMediaDecodeTime > UINT32_MAX ? 1 : 0;\n    this.flags = 0;\n    this.size = 4;\n    if (this.version === 1) this.size += 4;\n    this.writeHeader(stream);\n    if (this.version === 1) stream.writeUint64(this.baseMediaDecodeTime);\n    else stream.writeUint32(this.baseMediaDecodeTime);\n};\n// file:src/writing/tfhd.js\nBoxParser.tfhdBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.size = 4;\n    if (this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) this.size += 8;\n    if (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) this.size += 4;\n    if (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) this.size += 4;\n    if (this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) this.size += 4;\n    if (this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) this.size += 4;\n    this.writeHeader(stream);\n    stream.writeUint32(this.track_id);\n    if (this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) stream.writeUint64(this.base_data_offset);\n    if (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) stream.writeUint32(this.default_sample_description_index);\n    if (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) stream.writeUint32(this.default_sample_duration);\n    if (this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) stream.writeUint32(this.default_sample_size);\n    if (this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) stream.writeUint32(this.default_sample_flags);\n};\n// file:src/writing/tkhd.js\nBoxParser.tkhdBox.prototype.write = function(stream) {\n    this.version = 0;\n    //this.flags = 0;\n    this.size = 80;\n    this.writeHeader(stream);\n    stream.writeUint32(this.creation_time);\n    stream.writeUint32(this.modification_time);\n    stream.writeUint32(this.track_id);\n    stream.writeUint32(0);\n    stream.writeUint32(this.duration);\n    stream.writeUint32(0);\n    stream.writeUint32(0);\n    stream.writeInt16(this.layer);\n    stream.writeInt16(this.alternate_group);\n    stream.writeInt16(this.volume << 8);\n    stream.writeUint16(0);\n    stream.writeInt32Array(this.matrix);\n    stream.writeUint32(this.width);\n    stream.writeUint32(this.height);\n};\n// file:src/writing/trex.js\nBoxParser.trexBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = 20;\n    this.writeHeader(stream);\n    stream.writeUint32(this.track_id);\n    stream.writeUint32(this.default_sample_description_index);\n    stream.writeUint32(this.default_sample_duration);\n    stream.writeUint32(this.default_sample_size);\n    stream.writeUint32(this.default_sample_flags);\n};\n// file:src/writing/trun.js\nBoxParser.trunBox.prototype.write = function(stream) {\n    this.version = 0;\n    this.size = 4;\n    if (this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) this.size += 4;\n    if (this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) this.size += 4;\n    if (this.flags & BoxParser.TRUN_FLAGS_DURATION) this.size += 4 * this.sample_duration.length;\n    if (this.flags & BoxParser.TRUN_FLAGS_SIZE) this.size += 4 * this.sample_size.length;\n    if (this.flags & BoxParser.TRUN_FLAGS_FLAGS) this.size += 4 * this.sample_flags.length;\n    if (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) this.size += 4 * this.sample_composition_time_offset.length;\n    this.writeHeader(stream);\n    stream.writeUint32(this.sample_count);\n    if (this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) {\n        this.data_offset_position = stream.getPosition();\n        stream.writeInt32(this.data_offset); //signed\n    }\n    if (this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) stream.writeUint32(this.first_sample_flags);\n    for(var i1 = 0; i1 < this.sample_count; i1++){\n        if (this.flags & BoxParser.TRUN_FLAGS_DURATION) stream.writeUint32(this.sample_duration[i1]);\n        if (this.flags & BoxParser.TRUN_FLAGS_SIZE) stream.writeUint32(this.sample_size[i1]);\n        if (this.flags & BoxParser.TRUN_FLAGS_FLAGS) stream.writeUint32(this.sample_flags[i1]);\n        if (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n            if (this.version === 0) stream.writeUint32(this.sample_composition_time_offset[i1]);\n            else stream.writeInt32(this.sample_composition_time_offset[i1]); //signed\n        }\n    }\n};\n// file:src/writing/url.js\nBoxParser[\"url Box\"].prototype.write = function(stream) {\n    this.version = 0;\n    if (this.location) {\n        this.flags = 0;\n        this.size = this.location.length + 1;\n    } else {\n        this.flags = 0x000001;\n        this.size = 0;\n    }\n    this.writeHeader(stream);\n    if (this.location) stream.writeCString(this.location);\n};\n// file:src/writing/urn.js\nBoxParser[\"urn Box\"].prototype.write = function(stream) {\n    this.version = 0;\n    this.flags = 0;\n    this.size = this.name.length + 1 + (this.location ? this.location.length + 1 : 0);\n    this.writeHeader(stream);\n    stream.writeCString(this.name);\n    if (this.location) stream.writeCString(this.location);\n};\n// file:src/writing/vmhd.js\nBoxParser.vmhdBox.prototype.write = function(stream) {\n    var i1;\n    this.version = 0;\n    this.flags = 1;\n    this.size = 8;\n    this.writeHeader(stream);\n    stream.writeUint16(this.graphicsmode);\n    stream.writeUint16Array(this.opcolor);\n};\n// file:src/box-unpack.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ BoxParser.cttsBox.prototype.unpack = function(samples) {\n    var i1, j, k;\n    k = 0;\n    for(i1 = 0; i1 < this.sample_counts.length; i1++)for(j = 0; j < this.sample_counts[i1]; j++){\n        samples[k].pts = samples[k].dts + this.sample_offsets[i1];\n        k++;\n    }\n};\nBoxParser.sttsBox.prototype.unpack = function(samples) {\n    var i1, j, k;\n    k = 0;\n    for(i1 = 0; i1 < this.sample_counts.length; i1++)for(j = 0; j < this.sample_counts[i1]; j++){\n        if (k === 0) samples[k].dts = 0;\n        else samples[k].dts = samples[k - 1].dts + this.sample_deltas[i1];\n        k++;\n    }\n};\nBoxParser.stcoBox.prototype.unpack = function(samples) {\n    var i1;\n    for(i1 = 0; i1 < this.chunk_offsets.length; i1++)samples[i1].offset = this.chunk_offsets[i1];\n};\nBoxParser.stscBox.prototype.unpack = function(samples) {\n    var i1, j, k, l, m;\n    l = 0;\n    m = 0;\n    for(i1 = 0; i1 < this.first_chunk.length; i1++)for(j = 0; j < (i1 + 1 < this.first_chunk.length ? this.first_chunk[i1 + 1] : Infinity); j++){\n        m++;\n        for(k = 0; k < this.samples_per_chunk[i1]; k++){\n            if (samples[l]) {\n                samples[l].description_index = this.sample_description_index[i1];\n                samples[l].chunk_index = m;\n            } else return;\n            l++;\n        }\n    }\n};\nBoxParser.stszBox.prototype.unpack = function(samples) {\n    var i1;\n    for(i1 = 0; i1 < this.sample_sizes.length; i1++)samples[i1].size = this.sample_sizes[i1];\n};\n// file:src/box-diff.js\nBoxParser.DIFF_BOXES_PROP_NAMES = [\n    \"boxes\",\n    \"entries\",\n    \"references\",\n    \"subsamples\",\n    \"items\",\n    \"item_infos\",\n    \"extents\",\n    \"associations\",\n    \"subsegments\",\n    \"ranges\",\n    \"seekLists\",\n    \"seekPoints\",\n    \"esd\",\n    \"levels\"\n];\nBoxParser.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = [\n    \"compatible_brands\",\n    \"matrix\",\n    \"opcolor\",\n    \"sample_counts\",\n    \"sample_counts\",\n    \"sample_deltas\",\n    \"first_chunk\",\n    \"samples_per_chunk\",\n    \"sample_sizes\",\n    \"chunk_offsets\",\n    \"sample_offsets\",\n    \"sample_description_index\",\n    \"sample_duration\"\n];\nBoxParser.boxEqualFields = function(box_a, box_b) {\n    if (box_a && !box_b) return false;\n    var prop;\n    for(prop in box_a){\n        if (BoxParser.DIFF_BOXES_PROP_NAMES.indexOf(prop) > -1) continue;\n        else if (box_a[prop] instanceof BoxParser.Box || box_b[prop] instanceof BoxParser.Box) continue;\n        else if (typeof box_a[prop] === \"undefined\" || typeof box_b[prop] === \"undefined\") continue;\n        else if (typeof box_a[prop] === \"function\" || typeof box_b[prop] === \"function\") continue;\n        else if (box_a.subBoxNames && box_a.subBoxNames.indexOf(prop.slice(0, 4)) > -1 || box_b.subBoxNames && box_b.subBoxNames.indexOf(prop.slice(0, 4)) > -1) continue;\n        else {\n            if (prop === \"data\" || prop === \"start\" || prop === \"size\" || prop === \"creation_time\" || prop === \"modification_time\") continue;\n            else if (BoxParser.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(prop) > -1) continue;\n            else {\n                if (box_a[prop] !== box_b[prop]) return false;\n            }\n        }\n    }\n    return true;\n};\nBoxParser.boxEqual = function(box_a, box_b) {\n    if (!BoxParser.boxEqualFields(box_a, box_b)) return false;\n    for(var j = 0; j < BoxParser.DIFF_BOXES_PROP_NAMES.length; j++){\n        var name = BoxParser.DIFF_BOXES_PROP_NAMES[j];\n        if (box_a[name] && box_b[name]) {\n            if (!BoxParser.boxEqual(box_a[name], box_b[name])) return false;\n        }\n    }\n    return true;\n} // file:src/text-mp4.js\n;\n/* \n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ var VTTin4Parser = function() {};\nVTTin4Parser.prototype.parseSample = function(data) {\n    var cues, cue;\n    var stream = new MP4BoxStream(data.buffer);\n    cues = [];\n    while(!stream.isEos()){\n        cue = BoxParser.parseOneBox(stream, false);\n        if (cue.code === BoxParser.OK && cue.box.type === \"vttc\") cues.push(cue.box);\n    }\n    return cues;\n};\nVTTin4Parser.prototype.getText = function(startTime, endTime, data) {\n    function pad(n, width, z) {\n        z = z || '0';\n        n = n + '';\n        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n    }\n    function secToTimestamp(insec) {\n        var h = Math.floor(insec / 3600);\n        var m = Math.floor((insec - h * 3600) / 60);\n        var s = Math.floor(insec - h * 3600 - m * 60);\n        var ms = Math.floor((insec - h * 3600 - m * 60 - s) * 1000);\n        return \"\" + pad(h, 2) + \":\" + pad(m, 2) + \":\" + pad(s, 2) + \".\" + pad(ms, 3);\n    }\n    var cues = this.parseSample(data);\n    var string = \"\";\n    for(var i1 = 0; i1 < cues.length; i1++){\n        var cueIn4 = cues[i1];\n        string += secToTimestamp(startTime) + \" --> \" + secToTimestamp(endTime) + \"\\r\\n\";\n        string += cueIn4.payl.text;\n    }\n    return string;\n};\nvar XMLSubtitlein4Parser = function() {};\nXMLSubtitlein4Parser.prototype.parseSample = function(sample) {\n    var res = {};\n    var i1;\n    res.resources = [];\n    var stream = new MP4BoxStream(sample.data.buffer);\n    if (!sample.subsamples || sample.subsamples.length === 0) res.documentString = stream.readString(sample.data.length);\n    else {\n        res.documentString = stream.readString(sample.subsamples[0].size);\n        if (sample.subsamples.length > 1) for(i1 = 1; i1 < sample.subsamples.length; i1++)res.resources[i1] = stream.readUint8Array(sample.subsamples[i1].size);\n    }\n    if (typeof DOMParser !== \"undefined\") res.document = new DOMParser().parseFromString(res.documentString, \"application/xml\");\n    return res;\n};\nvar Textin4Parser = function() {};\nTextin4Parser.prototype.parseSample = function(sample) {\n    var textString;\n    var stream = new MP4BoxStream(sample.data.buffer);\n    textString = stream.readString(sample.data.length);\n    return textString;\n};\nTextin4Parser.prototype.parseConfig = function(data) {\n    var textString;\n    var stream = new MP4BoxStream(data.buffer);\n    stream.readUint32(); // version & flags\n    textString = stream.readCString();\n    return textString;\n};\nexports.XMLSubtitlein4Parser = XMLSubtitlein4Parser;\nexports.Textin4Parser = Textin4Parser;\n// file:src/isofile.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ var ISOFile = function(stream) {\n    /* MutiBufferStream object used to parse boxes */ this.stream = stream || new MultiBufferStream();\n    /* Array of all boxes (in order) found in the file */ this.boxes = [];\n    /* Array of all mdats */ this.mdats = [];\n    /* Array of all moofs */ this.moofs = [];\n    /* Boolean indicating if the file is compatible with progressive parsing (moov first) */ this.isProgressive = false;\n    /* Boolean used to fire moov start event only once */ this.moovStartFound = false;\n    /* Callback called when the moov parsing starts */ this.onMoovStart = null;\n    /* Boolean keeping track of the call to onMoovStart, to avoid double calls */ this.moovStartSent = false;\n    /* Callback called when the moov is entirely parsed */ this.onReady = null;\n    /* Boolean keeping track of the call to onReady, to avoid double calls */ this.readySent = false;\n    /* Callback to call when segments are ready */ this.onSegment = null;\n    /* Callback to call when samples are ready */ this.onSamples = null;\n    /* Callback to call when there is an error in the parsing or processing of samples */ this.onError = null;\n    /* Boolean indicating if the moov box run-length encoded tables of sample information have been processed */ this.sampleListBuilt = false;\n    /* Array of Track objects for which fragmentation of samples is requested */ this.fragmentedTracks = [];\n    /* Array of Track objects for which extraction of samples is requested */ this.extractedTracks = [];\n    /* Boolean indicating that fragmention is ready */ this.isFragmentationInitialized = false;\n    /* Boolean indicating that fragmented has started */ this.sampleProcessingStarted = false;\n    /* Number of the next 'moof' to generate when fragmenting */ this.nextMoofNumber = 0;\n    /* Boolean indicating if the initial list of items has been produced */ this.itemListBuilt = false;\n    /* Callback called when the sidx box is entirely parsed */ this.onSidx = null;\n    /* Boolean keeping track of the call to onSidx, to avoid double calls */ this.sidxSent = false;\n};\nISOFile.prototype.setSegmentOptions = function(id, user, options) {\n    var trak = this.getTrackById(id);\n    if (trak) {\n        var fragTrack = {};\n        this.fragmentedTracks.push(fragTrack);\n        fragTrack.id = id;\n        fragTrack.user = user;\n        fragTrack.trak = trak;\n        trak.nextSample = 0;\n        fragTrack.segmentStream = null;\n        fragTrack.nb_samples = 1000;\n        fragTrack.rapAlignement = true;\n        if (options) {\n            if (options.nbSamples) fragTrack.nb_samples = options.nbSamples;\n            if (options.rapAlignement) fragTrack.rapAlignement = options.rapAlignement;\n        }\n    }\n};\nISOFile.prototype.unsetSegmentOptions = function(id) {\n    var index = -1;\n    for(var i1 = 0; i1 < this.fragmentedTracks.length; i1++){\n        var fragTrack = this.fragmentedTracks[i1];\n        if (fragTrack.id == id) index = i1;\n    }\n    if (index > -1) this.fragmentedTracks.splice(index, 1);\n};\nISOFile.prototype.setExtractionOptions = function(id, user, options) {\n    var trak = this.getTrackById(id);\n    if (trak) {\n        var extractTrack = {};\n        this.extractedTracks.push(extractTrack);\n        extractTrack.id = id;\n        extractTrack.user = user;\n        extractTrack.trak = trak;\n        trak.nextSample = 0;\n        extractTrack.nb_samples = 1000;\n        extractTrack.samples = [];\n        if (options) {\n            if (options.nbSamples) extractTrack.nb_samples = options.nbSamples;\n        }\n    }\n};\nISOFile.prototype.unsetExtractionOptions = function(id) {\n    var index = -1;\n    for(var i1 = 0; i1 < this.extractedTracks.length; i1++){\n        var extractTrack = this.extractedTracks[i1];\n        if (extractTrack.id == id) index = i1;\n    }\n    if (index > -1) this.extractedTracks.splice(index, 1);\n};\nISOFile.prototype.parse = function() {\n    var found;\n    var ret1;\n    var box1;\n    var parseBoxHeadersOnly = false;\n    if (this.restoreParsePosition) {\n        if (!this.restoreParsePosition()) return;\n    }\n    while(true)if (this.hasIncompleteMdat && this.hasIncompleteMdat()) {\n        if (this.processIncompleteMdat()) continue;\n        else return;\n    } else {\n        if (this.saveParsePosition) this.saveParsePosition();\n        ret1 = BoxParser.parseOneBox(this.stream, parseBoxHeadersOnly);\n        if (ret1.code === BoxParser.ERR_NOT_ENOUGH_DATA) {\n            if (this.processIncompleteBox) {\n                if (this.processIncompleteBox(ret1)) continue;\n                else return;\n            } else return;\n        } else {\n            var box_type;\n            /* the box is entirely parsed */ box1 = ret1.box;\n            box_type = box1.type !== \"uuid\" ? box1.type : box1.uuid;\n            /* store the box in the 'boxes' array to preserve box order (for file rewrite if needed)  */ this.boxes.push(box1);\n            /* but also store box in a property for more direct access */ switch(box_type){\n                case \"mdat\":\n                    this.mdats.push(box1);\n                    break;\n                case \"moof\":\n                    this.moofs.push(box1);\n                    break;\n                case \"moov\":\n                    this.moovStartFound = true;\n                    if (this.mdats.length === 0) this.isProgressive = true;\n                /* no break */ /* falls through */ default:\n                    if (this[box_type] !== undefined) Log.warn(\"ISOFile\", \"Duplicate Box of type: \" + box_type + \", overriding previous occurrence\");\n                    this[box_type] = box1;\n                    break;\n            }\n            if (this.updateUsedBytes) this.updateUsedBytes(box1, ret1);\n        }\n    }\n};\nISOFile.prototype.checkBuffer = function(ab) {\n    if (ab === null || ab === undefined) throw \"Buffer must be defined and non empty\";\n    if (ab.fileStart === undefined) throw \"Buffer must have a fileStart property\";\n    if (ab.byteLength === 0) {\n        Log.warn(\"ISOFile\", \"Ignoring empty buffer (fileStart: \" + ab.fileStart + \")\");\n        this.stream.logBufferLevel();\n        return false;\n    }\n    Log.info(\"ISOFile\", \"Processing buffer (fileStart: \" + ab.fileStart + \")\");\n    /* mark the bytes in the buffer as not being used yet */ ab.usedBytes = 0;\n    this.stream.insertBuffer(ab);\n    this.stream.logBufferLevel();\n    if (!this.stream.initialized()) {\n        Log.warn(\"ISOFile\", \"Not ready to start parsing\");\n        return false;\n    }\n    return true;\n};\n/* Processes a new ArrayBuffer (with a fileStart property)\n   Returns the next expected file position, or undefined if not ready to parse */ ISOFile.prototype.appendBuffer = function(ab, last) {\n    var nextFileStart;\n    if (!this.checkBuffer(ab)) return;\n    /* Parse whatever is in the existing buffers */ this.parse();\n    /* Check if the moovStart callback needs to be called */ if (this.moovStartFound && !this.moovStartSent) {\n        this.moovStartSent = true;\n        if (this.onMoovStart) this.onMoovStart();\n    }\n    if (this.moov) {\n        /* A moov box has been entirely parsed */ /* if this is the first call after the moov is found we initialize the list of samples (may be empty in fragmented files) */ if (!this.sampleListBuilt) {\n            this.buildSampleLists();\n            this.sampleListBuilt = true;\n        }\n        /* We update the sample information if there are any new moof boxes */ this.updateSampleLists();\n        /* If the application needs to be informed that the 'moov' has been found,\n\t\t   we create the information object and callback the application */ if (this.onReady && !this.readySent) {\n            this.readySent = true;\n            this.onReady(this.getInfo());\n        }\n        /* See if any sample extraction or segment creation needs to be done with the available samples */ this.processSamples(last);\n        /* Inform about the best range to fetch next */ if (this.nextSeekPosition) {\n            nextFileStart = this.nextSeekPosition;\n            this.nextSeekPosition = undefined;\n        } else nextFileStart = this.nextParsePosition;\n        if (this.stream.getEndFilePositionAfter) nextFileStart = this.stream.getEndFilePositionAfter(nextFileStart);\n    } else if (this.nextParsePosition) /* moov has not been parsed but the first buffer was received,\n\t\t\t   the next fetch should probably be the next box start */ nextFileStart = this.nextParsePosition;\n    else /* No valid buffer has been parsed yet, we cannot know what to parse next */ nextFileStart = 0;\n    if (this.sidx) {\n        if (this.onSidx && !this.sidxSent) {\n            this.onSidx(this.sidx);\n            this.sidxSent = true;\n        }\n    }\n    if (this.meta) {\n        if (this.flattenItemInfo && !this.itemListBuilt) {\n            this.flattenItemInfo();\n            this.itemListBuilt = true;\n        }\n        if (this.processItems) this.processItems(this.onItem);\n    }\n    if (this.stream.cleanBuffers) {\n        Log.info(\"ISOFile\", \"Done processing buffer (fileStart: \" + ab.fileStart + \") - next buffer to fetch should have a fileStart position of \" + nextFileStart);\n        this.stream.logBufferLevel();\n        this.stream.cleanBuffers();\n        this.stream.logBufferLevel(true);\n        Log.info(\"ISOFile\", \"Sample data size in memory: \" + this.getAllocatedSampleDataSize());\n    }\n    return nextFileStart;\n};\nISOFile.prototype.getInfo = function() {\n    var i1, j;\n    var movie = {};\n    var trak;\n    var track;\n    var ref;\n    var sample_desc;\n    var _1904 = new Date('1904-01-01T00:00:00Z').getTime();\n    if (this.moov) {\n        movie.hasMoov = true;\n        movie.duration = this.moov.mvhd.duration;\n        movie.timescale = this.moov.mvhd.timescale;\n        movie.isFragmented = this.moov.mvex != null;\n        if (movie.isFragmented && this.moov.mvex.mehd) movie.fragment_duration = this.moov.mvex.mehd.fragment_duration;\n        movie.isProgressive = this.isProgressive;\n        movie.hasIOD = this.moov.iods != null;\n        movie.brands = [];\n        movie.brands.push(this.ftyp.major_brand);\n        movie.brands = movie.brands.concat(this.ftyp.compatible_brands);\n        movie.created = new Date(_1904 + this.moov.mvhd.creation_time * 1000);\n        movie.modified = new Date(_1904 + this.moov.mvhd.modification_time * 1000);\n        movie.tracks = [];\n        movie.audioTracks = [];\n        movie.videoTracks = [];\n        movie.subtitleTracks = [];\n        movie.metadataTracks = [];\n        movie.hintTracks = [];\n        movie.otherTracks = [];\n        for(i1 = 0; i1 < this.moov.traks.length; i1++){\n            trak = this.moov.traks[i1];\n            sample_desc = trak.mdia.minf.stbl.stsd.entries[0];\n            track = {};\n            movie.tracks.push(track);\n            track.id = trak.tkhd.track_id;\n            track.name = trak.mdia.hdlr.name;\n            track.references = [];\n            if (trak.tref) for(j = 0; j < trak.tref.boxes.length; j++){\n                ref = {};\n                track.references.push(ref);\n                ref.type = trak.tref.boxes[j].type;\n                ref.track_ids = trak.tref.boxes[j].track_ids;\n            }\n            if (trak.edts) track.edits = trak.edts.elst.entries;\n            track.created = new Date(_1904 + trak.tkhd.creation_time * 1000);\n            track.modified = new Date(_1904 + trak.tkhd.modification_time * 1000);\n            track.movie_duration = trak.tkhd.duration;\n            track.movie_timescale = movie.timescale;\n            track.layer = trak.tkhd.layer;\n            track.alternate_group = trak.tkhd.alternate_group;\n            track.volume = trak.tkhd.volume;\n            track.matrix = trak.tkhd.matrix;\n            track.track_width = trak.tkhd.width / 65536;\n            track.track_height = trak.tkhd.height / 65536;\n            track.timescale = trak.mdia.mdhd.timescale;\n            track.cts_shift = trak.mdia.minf.stbl.cslg;\n            track.duration = trak.mdia.mdhd.duration;\n            track.samples_duration = trak.samples_duration;\n            track.codec = sample_desc.getCodec();\n            track.kind = trak.udta && trak.udta.kinds.length ? trak.udta.kinds[0] : {\n                schemeURI: \"\",\n                value: \"\"\n            };\n            track.language = trak.mdia.elng ? trak.mdia.elng.extended_language : trak.mdia.mdhd.languageString;\n            track.nb_samples = trak.samples.length;\n            track.size = trak.samples_size;\n            track.bitrate = track.size * 8 * track.timescale / track.samples_duration;\n            if (sample_desc.isAudio()) {\n                track.type = \"audio\";\n                movie.audioTracks.push(track);\n                track.audio = {};\n                track.audio.sample_rate = sample_desc.getSampleRate();\n                track.audio.channel_count = sample_desc.getChannelCount();\n                track.audio.sample_size = sample_desc.getSampleSize();\n            } else if (sample_desc.isVideo()) {\n                track.type = \"video\";\n                movie.videoTracks.push(track);\n                track.video = {};\n                track.video.width = sample_desc.getWidth();\n                track.video.height = sample_desc.getHeight();\n            } else if (sample_desc.isSubtitle()) {\n                track.type = \"subtitles\";\n                movie.subtitleTracks.push(track);\n            } else if (sample_desc.isHint()) {\n                track.type = \"metadata\";\n                movie.hintTracks.push(track);\n            } else if (sample_desc.isMetadata()) {\n                track.type = \"metadata\";\n                movie.metadataTracks.push(track);\n            } else {\n                track.type = \"metadata\";\n                movie.otherTracks.push(track);\n            }\n        }\n    } else movie.hasMoov = false;\n    movie.mime = \"\";\n    if (movie.hasMoov && movie.tracks) {\n        if (movie.videoTracks && movie.videoTracks.length > 0) movie.mime += 'video/mp4; codecs=\\\"';\n        else if (movie.audioTracks && movie.audioTracks.length > 0) movie.mime += 'audio/mp4; codecs=\\\"';\n        else movie.mime += 'application/mp4; codecs=\\\"';\n        for(i1 = 0; i1 < movie.tracks.length; i1++){\n            if (i1 !== 0) movie.mime += ',';\n            movie.mime += movie.tracks[i1].codec;\n        }\n        movie.mime += '\\\"; profiles=\\\"';\n        movie.mime += this.ftyp.compatible_brands.join();\n        movie.mime += '\\\"';\n    }\n    return movie;\n};\nISOFile.prototype.setNextSeekPositionFromSample = function(sample) {\n    if (!sample) return;\n    if (this.nextSeekPosition) this.nextSeekPosition = Math.min(sample.offset + sample.alreadyRead, this.nextSeekPosition);\n    else this.nextSeekPosition = sample.offset + sample.alreadyRead;\n};\nISOFile.prototype.processSamples = function(last) {\n    var i1;\n    var trak;\n    if (!this.sampleProcessingStarted) return;\n    /* For each track marked for fragmentation,\n\t   check if the next sample is there (i.e. if the sample information is known (i.e. moof has arrived) and if it has been downloaded)\n\t   and create a fragment with it */ if (this.isFragmentationInitialized && this.onSegment !== null) for(i1 = 0; i1 < this.fragmentedTracks.length; i1++){\n        var fragTrak = this.fragmentedTracks[i1];\n        trak = fragTrak.trak;\n        while(trak.nextSample < trak.samples.length && this.sampleProcessingStarted){\n            /* The sample information is there (either because the file is not fragmented and this is not the last sample,\n\t\t\t\tor because the file is fragmented and the moof for that sample has been received */ Log.debug(\"ISOFile\", \"Creating media fragment on track #\" + fragTrak.id + \" for sample \" + trak.nextSample);\n            var result = this.createFragment(fragTrak.id, trak.nextSample, fragTrak.segmentStream);\n            if (result) {\n                fragTrak.segmentStream = result;\n                trak.nextSample++;\n            } else break;\n            /* A fragment is created by sample, but the segment is the accumulation in the buffer of these fragments.\n\t\t\t\t   It is flushed only as requested by the application (nb_samples) to avoid too many callbacks */ if (trak.nextSample % fragTrak.nb_samples === 0 || last || trak.nextSample >= trak.samples.length) {\n                Log.info(\"ISOFile\", \"Sending fragmented data on track #\" + fragTrak.id + \" for samples [\" + Math.max(0, trak.nextSample - fragTrak.nb_samples) + \",\" + (trak.nextSample - 1) + \"]\");\n                Log.info(\"ISOFile\", \"Sample data size in memory: \" + this.getAllocatedSampleDataSize());\n                if (this.onSegment) this.onSegment(fragTrak.id, fragTrak.user, fragTrak.segmentStream.buffer, trak.nextSample, last || trak.nextSample >= trak.samples.length);\n                /* force the creation of a new buffer */ fragTrak.segmentStream = null;\n                if (fragTrak !== this.fragmentedTracks[i1]) break;\n            }\n        }\n    }\n    if (this.onSamples !== null) /* For each track marked for data export,\n\t\t   check if the next sample is there (i.e. has been downloaded) and send it */ for(i1 = 0; i1 < this.extractedTracks.length; i1++){\n        var extractTrak = this.extractedTracks[i1];\n        trak = extractTrak.trak;\n        while(trak.nextSample < trak.samples.length && this.sampleProcessingStarted){\n            Log.debug(\"ISOFile\", \"Exporting on track #\" + extractTrak.id + \" sample #\" + trak.nextSample);\n            var sample = this.getSample(trak, trak.nextSample);\n            if (sample) {\n                trak.nextSample++;\n                extractTrak.samples.push(sample);\n            } else {\n                this.setNextSeekPositionFromSample(trak.samples[trak.nextSample]);\n                break;\n            }\n            if (trak.nextSample % extractTrak.nb_samples === 0 || trak.nextSample >= trak.samples.length) {\n                Log.debug(\"ISOFile\", \"Sending samples on track #\" + extractTrak.id + \" for sample \" + trak.nextSample);\n                if (this.onSamples) this.onSamples(extractTrak.id, extractTrak.user, extractTrak.samples);\n                extractTrak.samples = [];\n                if (extractTrak !== this.extractedTracks[i1]) break;\n            }\n        }\n    }\n};\n/* Find and return specific boxes using recursion and early return */ ISOFile.prototype.getBox = function(type) {\n    var result = this.getBoxes(type, true);\n    return result.length ? result[0] : null;\n};\nISOFile.prototype.getBoxes = function(type, returnEarly) {\n    var result = [];\n    ISOFile._sweep.call(this, type, result, returnEarly);\n    return result;\n};\nISOFile._sweep = function(type, result, returnEarly) {\n    if (this.type && this.type == type) result.push(this);\n    for(var box1 in this.boxes){\n        if (result.length && returnEarly) return;\n        ISOFile._sweep.call(this.boxes[box1], type, result, returnEarly);\n    }\n};\nISOFile.prototype.getTrackSamplesInfo = function(track_id) {\n    var track = this.getTrackById(track_id);\n    if (track) return track.samples;\n    else return;\n};\nISOFile.prototype.getTrackSample = function(track_id, number) {\n    var track = this.getTrackById(track_id);\n    var sample = this.getSample(track, number);\n    return sample;\n};\n/* Called by the application to release the resources associated to samples already forwarded to the application */ ISOFile.prototype.releaseUsedSamples = function(id, sampleNum) {\n    var size = 0;\n    var trak = this.getTrackById(id);\n    if (!trak.lastValidSample) trak.lastValidSample = 0;\n    for(var i1 = trak.lastValidSample; i1 < sampleNum; i1++)size += this.releaseSample(trak, i1);\n    Log.info(\"ISOFile\", \"Track #\" + id + \" released samples up to \" + sampleNum + \" (released size: \" + size + \", remaining: \" + this.samplesDataSize + \")\");\n    trak.lastValidSample = sampleNum;\n};\nISOFile.prototype.start = function() {\n    this.sampleProcessingStarted = true;\n    this.processSamples(false);\n};\nISOFile.prototype.stop = function() {\n    this.sampleProcessingStarted = false;\n};\n/* Called by the application to flush the remaining samples (e.g. once the download is finished or when no more samples will be added) */ ISOFile.prototype.flush = function() {\n    Log.info(\"ISOFile\", \"Flushing remaining samples\");\n    this.updateSampleLists();\n    this.processSamples(true);\n    this.stream.cleanBuffers();\n    this.stream.logBufferLevel(true);\n};\n/* Finds the byte offset for a given time on a given track\n   also returns the time of the previous rap */ ISOFile.prototype.seekTrack = function(time, useRap, trak) {\n    var j;\n    var sample;\n    var seek_offset = Infinity;\n    var rap_seek_sample_num = 0;\n    var seek_sample_num = 0;\n    var timescale;\n    if (trak.samples.length === 0) {\n        Log.info(\"ISOFile\", \"No sample in track, cannot seek! Using time \" + Log.getDurationString(0, 1) + \" and offset: \" + 0);\n        return {\n            offset: 0,\n            time: 0\n        };\n    }\n    for(j = 0; j < trak.samples.length; j++){\n        sample = trak.samples[j];\n        if (j === 0) {\n            seek_sample_num = 0;\n            timescale = sample.timescale;\n        } else if (sample.cts > time * sample.timescale) {\n            seek_sample_num = j - 1;\n            break;\n        }\n        if (useRap && sample.is_sync) rap_seek_sample_num = j;\n    }\n    if (useRap) seek_sample_num = rap_seek_sample_num;\n    time = trak.samples[seek_sample_num].cts;\n    trak.nextSample = seek_sample_num;\n    while(trak.samples[seek_sample_num].alreadyRead === trak.samples[seek_sample_num].size){\n        // No remaining samples to look for, all are downloaded.\n        if (!trak.samples[seek_sample_num + 1]) break;\n        seek_sample_num++;\n    }\n    seek_offset = trak.samples[seek_sample_num].offset + trak.samples[seek_sample_num].alreadyRead;\n    Log.info(\"ISOFile\", \"Seeking to \" + (useRap ? \"RAP\" : \"\") + \" sample #\" + trak.nextSample + \" on track \" + trak.tkhd.track_id + \", time \" + Log.getDurationString(time, timescale) + \" and offset: \" + seek_offset);\n    return {\n        offset: seek_offset,\n        time: time / timescale\n    };\n};\nISOFile.prototype.getTrackDuration = function(trak) {\n    var sample;\n    if (!trak.samples) return Infinity;\n    sample = trak.samples[trak.samples.length - 1];\n    return (sample.cts + sample.duration) / sample.timescale;\n};\n/* Finds the byte offset in the file corresponding to the given time or to the time of the previous RAP */ ISOFile.prototype.seek = function(time, useRap) {\n    var moov = this.moov;\n    var trak;\n    var trak_seek_info;\n    var i1;\n    var seek_info = {\n        offset: Infinity,\n        time: Infinity\n    };\n    if (!this.moov) throw \"Cannot seek: moov not received!\";\n    else {\n        for(i1 = 0; i1 < moov.traks.length; i1++){\n            trak = moov.traks[i1];\n            if (time > this.getTrackDuration(trak)) continue;\n            trak_seek_info = this.seekTrack(time, useRap, trak);\n            if (trak_seek_info.offset < seek_info.offset) seek_info.offset = trak_seek_info.offset;\n            if (trak_seek_info.time < seek_info.time) seek_info.time = trak_seek_info.time;\n        }\n        Log.info(\"ISOFile\", \"Seeking at time \" + Log.getDurationString(seek_info.time, 1) + \" needs a buffer with a fileStart position of \" + seek_info.offset);\n        if (seek_info.offset === Infinity) /* No sample info, in all tracks, cannot seek */ seek_info = {\n            offset: this.nextParsePosition,\n            time: 0\n        };\n        else /* check if the seek position is already in some buffer and\n\t\t\t in that case return the end of that buffer (or of the last contiguous buffer) */ /* TODO: Should wait until append operations are done */ seek_info.offset = this.stream.getEndFilePositionAfter(seek_info.offset);\n        Log.info(\"ISOFile\", \"Adjusted seek position (after checking data already in buffer): \" + seek_info.offset);\n        return seek_info;\n    }\n};\nISOFile.prototype.equal = function(b) {\n    var box_index = 0;\n    while(box_index < this.boxes.length && box_index < b.boxes.length){\n        var a_box = this.boxes[box_index];\n        var b_box = b.boxes[box_index];\n        if (!BoxParser.boxEqual(a_box, b_box)) return false;\n        box_index++;\n    }\n    return true;\n};\nexports.ISOFile = ISOFile;\n// file:src/isofile-advanced-parsing.js\n/* position in the current buffer of the beginning of the last box parsed */ ISOFile.prototype.lastBoxStartPosition = 0;\n/* indicator if the parsing is stuck in the middle of an mdat box */ ISOFile.prototype.parsingMdat = null;\n/* next file position that the parser needs:\n    - 0 until the first buffer (i.e. fileStart ===0) has been received \n    - otherwise, the next box start until the moov box has been parsed\n    - otherwise, the position of the next sample to fetch\n */ ISOFile.prototype.nextParsePosition = 0;\n/* keep mdat data */ ISOFile.prototype.discardMdatData = false;\nISOFile.prototype.processIncompleteBox = function(ret1) {\n    var box1;\n    var merged;\n    var found;\n    /* we did not have enough bytes in the current buffer to parse the entire box */ if (ret1.type === \"mdat\") {\n        /* we had enough bytes to get its type and size and it's an 'mdat' */ /* special handling for mdat boxes, since we don't actually need to parse it linearly \n\t\t   we create the box */ box1 = new BoxParser[ret1.type + \"Box\"](ret1.size);\n        this.parsingMdat = box1;\n        this.boxes.push(box1);\n        this.mdats.push(box1);\n        box1.start = ret1.start;\n        box1.hdr_size = ret1.hdr_size;\n        this.stream.addUsedBytes(box1.hdr_size);\n        /* indicate that the parsing should start from the end of the box */ this.lastBoxStartPosition = box1.start + box1.size;\n        /* let's see if we have the end of the box in the other buffers */ found = this.stream.seek(box1.start + box1.size, false, this.discardMdatData);\n        if (found) {\n            /* found the end of the box */ this.parsingMdat = null;\n            /* let's see if we can parse more in this buffer */ return true;\n        } else {\n            /* 'mdat' end not found in the existing buffers */ /* determine the next position in the file to start parsing from */ if (!this.moovStartFound) /* moov not find yet, \n\t\t\t\t   the file probably has 'mdat' at the beginning, and 'moov' at the end, \n\t\t\t\t   indicate that the downloader should not try to download those bytes now */ this.nextParsePosition = box1.start + box1.size;\n            else /* we have the start of the moov box, \n\t\t\t\t   the next bytes should try to complete the current 'mdat' */ this.nextParsePosition = this.stream.findEndContiguousBuf();\n            /* not much we can do, wait for more buffers to arrive */ return false;\n        }\n    } else {\n        /* box is incomplete, we may not even know its type */ if (ret1.type === \"moov\") {\n            /* the incomplete box is a 'moov' box */ this.moovStartFound = true;\n            if (this.mdats.length === 0) this.isProgressive = true;\n        }\n        /* either it's not an mdat box (and we need to parse it, we cannot skip it)\n\t\t   (TODO: we could skip 'free' boxes ...)\n\t\t\t   or we did not have enough data to parse the type and size of the box, \n\t\t   we try to concatenate the current buffer with the next buffer to restart parsing */ merged = this.stream.mergeNextBuffer ? this.stream.mergeNextBuffer() : false;\n        if (merged) {\n            /* The next buffer was contiguous, the merging succeeded,\n\t\t\t   we can now continue parsing, \n\t\t\t   the next best position to parse is at the end of this new buffer */ this.nextParsePosition = this.stream.getEndPosition();\n            return true;\n        } else {\n            /* we cannot concatenate existing buffers because they are not contiguous or because there is no additional buffer */ /* The next best position to parse is still at the end of this old buffer */ if (!ret1.type) /* There were not enough bytes in the buffer to parse the box type and length,\n\t\t\t\t   the next fetch should retrieve those missing bytes, i.e. the next bytes after this buffer */ this.nextParsePosition = this.stream.getEndPosition();\n            else /* we had enough bytes to parse size and type of the incomplete box\n\t\t\t\t   if we haven't found yet the moov box, skip this one and try the next one \n\t\t\t\t   if we have found the moov box, let's continue linear parsing */ if (this.moovStartFound) this.nextParsePosition = this.stream.getEndPosition();\n            else this.nextParsePosition = this.stream.getPosition() + ret1.size;\n            return false;\n        }\n    }\n};\nISOFile.prototype.hasIncompleteMdat = function() {\n    return this.parsingMdat !== null;\n};\nISOFile.prototype.processIncompleteMdat = function() {\n    var box1;\n    var found;\n    /* we are in the parsing of an incomplete mdat box */ box1 = this.parsingMdat;\n    found = this.stream.seek(box1.start + box1.size, false, this.discardMdatData);\n    if (found) {\n        Log.debug(\"ISOFile\", \"Found 'mdat' end in buffered data\");\n        /* the end of the mdat has been found */ this.parsingMdat = null;\n        /* we can parse more in this buffer */ return true;\n    } else {\n        /* we don't have the end of this mdat yet, \n\t\t   indicate that the next byte to fetch is the end of the buffers we have so far, \n\t\t   return and wait for more buffer to come */ this.nextParsePosition = this.stream.findEndContiguousBuf();\n        return false;\n    }\n};\nISOFile.prototype.restoreParsePosition = function() {\n    /* Reposition at the start position of the previous box not entirely parsed */ return this.stream.seek(this.lastBoxStartPosition, true, this.discardMdatData);\n};\nISOFile.prototype.saveParsePosition = function() {\n    /* remember the position of the box start in case we need to roll back (if the box is incomplete) */ this.lastBoxStartPosition = this.stream.getPosition();\n};\nISOFile.prototype.updateUsedBytes = function(box1, ret1) {\n    if (this.stream.addUsedBytes) {\n        if (box1.type === \"mdat\") {\n            /* for an mdat box, only its header is considered used, other bytes will be used when sample data is requested */ this.stream.addUsedBytes(box1.hdr_size);\n            if (this.discardMdatData) this.stream.addUsedBytes(box1.size - box1.hdr_size);\n        } else /* for all other boxes, the entire box data is considered used */ this.stream.addUsedBytes(box1.size);\n    }\n};\n// file:src/isofile-advanced-creation.js\nISOFile.prototype.add = BoxParser.Box.prototype.add;\nISOFile.prototype.addBox = BoxParser.Box.prototype.addBox;\nISOFile.prototype.init = function(_options) {\n    var options = _options || {};\n    var ftyp = this.add(\"ftyp\").set(\"major_brand\", options.brands && options.brands[0] || \"iso4\").set(\"minor_version\", 0).set(\"compatible_brands\", options.brands || [\n        \"iso4\"\n    ]);\n    var moov = this.add(\"moov\");\n    moov.add(\"mvhd\").set(\"timescale\", options.timescale || 600).set(\"rate\", options.rate || 65536).set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"duration\", options.duration || 0).set(\"volume\", options.width ? 0 : 0x0100).set(\"matrix\", [\n        65536,\n        0,\n        0,\n        0,\n        65536,\n        0,\n        0,\n        0,\n        0x40000000\n    ]).set(\"next_track_id\", 1);\n    moov.add(\"mvex\");\n    return this;\n};\nISOFile.prototype.addTrack = function(_options) {\n    if (!this.moov) this.init(_options);\n    var options = _options || {};\n    options.width = options.width || 320;\n    options.height = options.height || 320;\n    options.id = options.id || this.moov.mvhd.next_track_id;\n    options.type = options.type || \"avc1\";\n    var trak = this.moov.add(\"trak\");\n    this.moov.mvhd.next_track_id = options.id + 1;\n    trak.add(\"tkhd\").set(\"flags\", BoxParser.TKHD_FLAG_ENABLED | BoxParser.TKHD_FLAG_IN_MOVIE | BoxParser.TKHD_FLAG_IN_PREVIEW).set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"track_id\", options.id).set(\"duration\", options.duration || 0).set(\"layer\", options.layer || 0).set(\"alternate_group\", 0).set(\"volume\", 1).set(\"matrix\", [\n        65536,\n        0,\n        0,\n        0,\n        65536,\n        0,\n        0,\n        0,\n        0x40000000\n    ]).set(\"width\", options.width << 16).set(\"height\", options.height << 16);\n    var mdia = trak.add(\"mdia\");\n    mdia.add(\"mdhd\").set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"timescale\", options.timescale || 1).set(\"duration\", options.media_duration || 0).set(\"language\", options.language || \"und\");\n    mdia.add(\"hdlr\").set(\"handler\", options.hdlr || \"vide\").set(\"name\", options.name || \"Track created with MP4Box.js\");\n    mdia.add(\"elng\").set(\"extended_language\", options.language || \"fr-FR\");\n    var minf = mdia.add(\"minf\");\n    if (BoxParser[options.type + \"SampleEntry\"] === undefined) return;\n    var sample_description_entry = new BoxParser[options.type + \"SampleEntry\"]();\n    sample_description_entry.data_reference_index = 1;\n    var media_type = \"\";\n    for(var mediaType in BoxParser.sampleEntryCodes){\n        var codes = BoxParser.sampleEntryCodes[mediaType];\n        for(var i1 = 0; i1 < codes.length; i1++)if (codes.indexOf(options.type) > -1) {\n            media_type = mediaType;\n            break;\n        }\n    }\n    switch(media_type){\n        case \"Visual\":\n            minf.add(\"vmhd\").set(\"graphicsmode\", 0).set(\"opcolor\", [\n                0,\n                0,\n                0\n            ]);\n            sample_description_entry.set(\"width\", options.width).set(\"height\", options.height).set(\"horizresolution\", 4718592).set(\"vertresolution\", 4718592).set(\"frame_count\", 1).set(\"compressorname\", options.type + \" Compressor\").set(\"depth\", 0x18);\n            if (options.avcDecoderConfigRecord) {\n                var avcC = new BoxParser.avcCBox();\n                avcC.parse(new MP4BoxStream(options.avcDecoderConfigRecord));\n                sample_description_entry.addBox(avcC);\n            } else if (options.hevcDecoderConfigRecord) {\n                var hvcC = new BoxParser.hvcCBox();\n                hvcC.parse(new MP4BoxStream(options.hevcDecoderConfigRecord));\n                sample_description_entry.addBox(hvcC);\n            }\n            break;\n        case \"Audio\":\n            minf.add(\"smhd\").set(\"balance\", options.balance || 0);\n            sample_description_entry.set(\"channel_count\", options.channel_count || 2).set(\"samplesize\", options.samplesize || 16).set(\"samplerate\", options.samplerate || 65536);\n            break;\n        case \"Hint\":\n            minf.add(\"hmhd\"); // TODO: add properties\n            break;\n        case \"Subtitle\":\n            minf.add(\"sthd\");\n            switch(options.type){\n                case \"stpp\":\n                    sample_description_entry.set(\"namespace\", options.namespace || \"nonamespace\").set(\"schema_location\", options.schema_location || \"\").set(\"auxiliary_mime_types\", options.auxiliary_mime_types || \"\");\n                    break;\n            }\n            break;\n        case \"Metadata\":\n            minf.add(\"nmhd\");\n            break;\n        case \"System\":\n            minf.add(\"nmhd\");\n            break;\n        default:\n            minf.add(\"nmhd\");\n            break;\n    }\n    if (options.description) sample_description_entry.addBox(options.description);\n    if (options.description_boxes) options.description_boxes.forEach(function(b) {\n        sample_description_entry.addBox(b);\n    });\n    minf.add(\"dinf\").add(\"dref\").addEntry(new BoxParser[\"url Box\"]().set(\"flags\", 0x1));\n    var stbl = minf.add(\"stbl\");\n    stbl.add(\"stsd\").addEntry(sample_description_entry);\n    stbl.add(\"stts\").set(\"sample_counts\", []).set(\"sample_deltas\", []);\n    stbl.add(\"stsc\").set(\"first_chunk\", []).set(\"samples_per_chunk\", []).set(\"sample_description_index\", []);\n    stbl.add(\"stco\").set(\"chunk_offsets\", []);\n    stbl.add(\"stsz\").set(\"sample_sizes\", []);\n    this.moov.mvex.add(\"trex\").set(\"track_id\", options.id).set(\"default_sample_description_index\", options.default_sample_description_index || 1).set(\"default_sample_duration\", options.default_sample_duration || 0).set(\"default_sample_size\", options.default_sample_size || 0).set(\"default_sample_flags\", options.default_sample_flags || 0);\n    this.buildTrakSampleLists(trak);\n    return options.id;\n};\nBoxParser.Box.prototype.computeSize = function(stream_) {\n    var stream = stream_ || new DataStream();\n    stream.endianness = DataStream.BIG_ENDIAN;\n    this.write(stream);\n};\nISOFile.prototype.addSample = function(track_id, data, _options) {\n    var options = _options || {};\n    var sample = {};\n    var trak = this.getTrackById(track_id);\n    if (trak === null) return;\n    sample.number = trak.samples.length;\n    sample.track_id = trak.tkhd.track_id;\n    sample.timescale = trak.mdia.mdhd.timescale;\n    sample.description_index = options.sample_description_index ? options.sample_description_index - 1 : 0;\n    sample.description = trak.mdia.minf.stbl.stsd.entries[sample.description_index];\n    sample.data = data;\n    sample.size = data.byteLength;\n    sample.alreadyRead = sample.size;\n    sample.duration = options.duration || 1;\n    sample.cts = options.cts || 0;\n    sample.dts = options.dts || 0;\n    sample.is_sync = options.is_sync || false;\n    sample.is_leading = options.is_leading || 0;\n    sample.depends_on = options.depends_on || 0;\n    sample.is_depended_on = options.is_depended_on || 0;\n    sample.has_redundancy = options.has_redundancy || 0;\n    sample.degradation_priority = options.degradation_priority || 0;\n    sample.offset = 0;\n    sample.subsamples = options.subsamples;\n    trak.samples.push(sample);\n    trak.samples_size += sample.size;\n    trak.samples_duration += sample.duration;\n    if (trak.first_dts === undefined) trak.first_dts = options.dts;\n    this.processSamples();\n    var moof = this.createSingleSampleMoof(sample);\n    this.addBox(moof);\n    moof.computeSize();\n    /* adjusting the data_offset now that the moof size is known*/ moof.trafs[0].truns[0].data_offset = moof.size + 8; //8 is mdat header\n    this.add(\"mdat\").data = new Uint8Array(data);\n    return sample;\n};\nISOFile.prototype.createSingleSampleMoof = function(sample) {\n    var sample_flags = 0;\n    if (sample.is_sync) sample_flags = 33554432; // sample_depends_on_none (I picture)\n    else sample_flags = 65536; // non-sync\n    var moof = new BoxParser.moofBox();\n    moof.add(\"mfhd\").set(\"sequence_number\", this.nextMoofNumber);\n    this.nextMoofNumber++;\n    var traf = moof.add(\"traf\");\n    var trak = this.getTrackById(sample.track_id);\n    traf.add(\"tfhd\").set(\"track_id\", sample.track_id).set(\"flags\", BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF);\n    traf.add(\"tfdt\").set(\"baseMediaDecodeTime\", sample.dts - (trak.first_dts || 0));\n    traf.add(\"trun\").set(\"flags\", BoxParser.TRUN_FLAGS_DATA_OFFSET | BoxParser.TRUN_FLAGS_DURATION | BoxParser.TRUN_FLAGS_SIZE | BoxParser.TRUN_FLAGS_FLAGS | BoxParser.TRUN_FLAGS_CTS_OFFSET).set(\"data_offset\", 0).set(\"first_sample_flags\", 0).set(\"sample_count\", 1).set(\"sample_duration\", [\n        sample.duration\n    ]).set(\"sample_size\", [\n        sample.size\n    ]).set(\"sample_flags\", [\n        sample_flags\n    ]).set(\"sample_composition_time_offset\", [\n        sample.cts - sample.dts\n    ]);\n    return moof;\n};\n// file:src/isofile-sample-processing.js\n/* Index of the last moof box received */ ISOFile.prototype.lastMoofIndex = 0;\n/* size of the buffers allocated for samples */ ISOFile.prototype.samplesDataSize = 0;\n/* Resets all sample tables */ ISOFile.prototype.resetTables = function() {\n    var i1;\n    var trak, stco, stsc, stsz, stts, ctts, stss;\n    this.initial_duration = this.moov.mvhd.duration;\n    this.moov.mvhd.duration = 0;\n    for(i1 = 0; i1 < this.moov.traks.length; i1++){\n        trak = this.moov.traks[i1];\n        trak.tkhd.duration = 0;\n        trak.mdia.mdhd.duration = 0;\n        stco = trak.mdia.minf.stbl.stco || trak.mdia.minf.stbl.co64;\n        stco.chunk_offsets = [];\n        stsc = trak.mdia.minf.stbl.stsc;\n        stsc.first_chunk = [];\n        stsc.samples_per_chunk = [];\n        stsc.sample_description_index = [];\n        stsz = trak.mdia.minf.stbl.stsz || trak.mdia.minf.stbl.stz2;\n        stsz.sample_sizes = [];\n        stts = trak.mdia.minf.stbl.stts;\n        stts.sample_counts = [];\n        stts.sample_deltas = [];\n        ctts = trak.mdia.minf.stbl.ctts;\n        if (ctts) {\n            ctts.sample_counts = [];\n            ctts.sample_offsets = [];\n        }\n        stss = trak.mdia.minf.stbl.stss;\n        var k = trak.mdia.minf.stbl.boxes.indexOf(stss);\n        if (k != -1) trak.mdia.minf.stbl.boxes[k] = null;\n    }\n};\nISOFile.initSampleGroups = function(trak, traf, sbgps, trak_sgpds, traf_sgpds) {\n    var l;\n    var k;\n    var sample_groups_info;\n    var sample_group_info;\n    var sample_group_key;\n    function SampleGroupInfo(_type, _parameter, _sbgp) {\n        this.grouping_type = _type;\n        this.grouping_type_parameter = _parameter;\n        this.sbgp = _sbgp;\n        this.last_sample_in_run = -1;\n        this.entry_index = -1;\n    }\n    if (traf) traf.sample_groups_info = [];\n    if (!trak.sample_groups_info) trak.sample_groups_info = [];\n    for(k = 0; k < sbgps.length; k++){\n        sample_group_key = sbgps[k].grouping_type + \"/\" + sbgps[k].grouping_type_parameter;\n        sample_group_info = new SampleGroupInfo(sbgps[k].grouping_type, sbgps[k].grouping_type_parameter, sbgps[k]);\n        if (traf) traf.sample_groups_info[sample_group_key] = sample_group_info;\n        if (!trak.sample_groups_info[sample_group_key]) trak.sample_groups_info[sample_group_key] = sample_group_info;\n        for(l = 0; l < trak_sgpds.length; l++)if (trak_sgpds[l].grouping_type === sbgps[k].grouping_type) {\n            sample_group_info.description = trak_sgpds[l];\n            sample_group_info.description.used = true;\n        }\n        if (traf_sgpds) {\n            for(l = 0; l < traf_sgpds.length; l++)if (traf_sgpds[l].grouping_type === sbgps[k].grouping_type) {\n                sample_group_info.fragment_description = traf_sgpds[l];\n                sample_group_info.fragment_description.used = true;\n                sample_group_info.is_fragment = true;\n            }\n        }\n    }\n    if (!traf) {\n        for(k = 0; k < trak_sgpds.length; k++)if (!trak_sgpds[k].used && trak_sgpds[k].version >= 2) {\n            sample_group_key = trak_sgpds[k].grouping_type + \"/0\";\n            sample_group_info = new SampleGroupInfo(trak_sgpds[k].grouping_type, 0);\n            if (!trak.sample_groups_info[sample_group_key]) trak.sample_groups_info[sample_group_key] = sample_group_info;\n        }\n    } else if (traf_sgpds) {\n        for(k = 0; k < traf_sgpds.length; k++)if (!traf_sgpds[k].used && traf_sgpds[k].version >= 2) {\n            sample_group_key = traf_sgpds[k].grouping_type + \"/0\";\n            sample_group_info = new SampleGroupInfo(traf_sgpds[k].grouping_type, 0);\n            sample_group_info.is_fragment = true;\n            if (!traf.sample_groups_info[sample_group_key]) traf.sample_groups_info[sample_group_key] = sample_group_info;\n        }\n    }\n};\nISOFile.setSampleGroupProperties = function(trak, sample, sample_number, sample_groups_info) {\n    var k;\n    var index;\n    sample.sample_groups = [];\n    for(k in sample_groups_info){\n        sample.sample_groups[k] = {};\n        sample.sample_groups[k].grouping_type = sample_groups_info[k].grouping_type;\n        sample.sample_groups[k].grouping_type_parameter = sample_groups_info[k].grouping_type_parameter;\n        if (sample_number >= sample_groups_info[k].last_sample_in_run) {\n            if (sample_groups_info[k].last_sample_in_run < 0) sample_groups_info[k].last_sample_in_run = 0;\n            sample_groups_info[k].entry_index++;\n            if (sample_groups_info[k].entry_index <= sample_groups_info[k].sbgp.entries.length - 1) sample_groups_info[k].last_sample_in_run += sample_groups_info[k].sbgp.entries[sample_groups_info[k].entry_index].sample_count;\n        }\n        if (sample_groups_info[k].entry_index <= sample_groups_info[k].sbgp.entries.length - 1) sample.sample_groups[k].group_description_index = sample_groups_info[k].sbgp.entries[sample_groups_info[k].entry_index].group_description_index;\n        else sample.sample_groups[k].group_description_index = -1; // special value for not defined\n        if (sample.sample_groups[k].group_description_index !== 0) {\n            var description;\n            if (sample_groups_info[k].fragment_description) description = sample_groups_info[k].fragment_description;\n            else description = sample_groups_info[k].description;\n            if (sample.sample_groups[k].group_description_index > 0) {\n                if (sample.sample_groups[k].group_description_index > 65535) index = (sample.sample_groups[k].group_description_index >> 16) - 1;\n                else index = sample.sample_groups[k].group_description_index - 1;\n                if (description && index >= 0) sample.sample_groups[k].description = description.entries[index];\n            } else {\n                if (description && description.version >= 2) {\n                    if (description.default_group_description_index > 0) sample.sample_groups[k].description = description.entries[description.default_group_description_index - 1];\n                }\n            }\n        }\n    }\n};\nISOFile.process_sdtp = function(sdtp, sample, number) {\n    if (!sample) return;\n    if (sdtp) {\n        sample.is_leading = sdtp.is_leading[number];\n        sample.depends_on = sdtp.sample_depends_on[number];\n        sample.is_depended_on = sdtp.sample_is_depended_on[number];\n        sample.has_redundancy = sdtp.sample_has_redundancy[number];\n    } else {\n        sample.is_leading = 0;\n        sample.depends_on = 0;\n        sample.is_depended_on = 0;\n        sample.has_redundancy = 0;\n    }\n};\n/* Build initial sample list from  sample tables */ ISOFile.prototype.buildSampleLists = function() {\n    var i1;\n    var trak;\n    for(i1 = 0; i1 < this.moov.traks.length; i1++){\n        trak = this.moov.traks[i1];\n        this.buildTrakSampleLists(trak);\n    }\n};\nISOFile.prototype.buildTrakSampleLists = function(trak) {\n    var j, k;\n    var stco, stsc, stsz, stts, ctts, stss, stsd, subs, sbgps, sgpds, stdp;\n    var chunk_run_index, chunk_index, last_chunk_in_run, offset_in_chunk, last_sample_in_chunk;\n    var last_sample_in_stts_run, stts_run_index, last_sample_in_ctts_run, ctts_run_index, last_stss_index, last_subs_index, subs_entry_index, last_subs_sample_index;\n    trak.samples = [];\n    trak.samples_duration = 0;\n    trak.samples_size = 0;\n    stco = trak.mdia.minf.stbl.stco || trak.mdia.minf.stbl.co64;\n    stsc = trak.mdia.minf.stbl.stsc;\n    stsz = trak.mdia.minf.stbl.stsz || trak.mdia.minf.stbl.stz2;\n    stts = trak.mdia.minf.stbl.stts;\n    ctts = trak.mdia.minf.stbl.ctts;\n    stss = trak.mdia.minf.stbl.stss;\n    stsd = trak.mdia.minf.stbl.stsd;\n    subs = trak.mdia.minf.stbl.subs;\n    stdp = trak.mdia.minf.stbl.stdp;\n    sbgps = trak.mdia.minf.stbl.sbgps;\n    sgpds = trak.mdia.minf.stbl.sgpds;\n    last_sample_in_stts_run = -1;\n    stts_run_index = -1;\n    last_sample_in_ctts_run = -1;\n    ctts_run_index = -1;\n    last_stss_index = 0;\n    subs_entry_index = 0;\n    last_subs_sample_index = 0;\n    ISOFile.initSampleGroups(trak, null, sbgps, sgpds);\n    if (typeof stsz === \"undefined\") return;\n    /* we build the samples one by one and compute their properties */ for(j = 0; j < stsz.sample_sizes.length; j++){\n        var sample = {};\n        sample.number = j;\n        sample.track_id = trak.tkhd.track_id;\n        sample.timescale = trak.mdia.mdhd.timescale;\n        sample.alreadyRead = 0;\n        trak.samples[j] = sample;\n        /* size can be known directly */ sample.size = stsz.sample_sizes[j];\n        trak.samples_size += sample.size;\n        /* computing chunk-based properties (offset, sample description index)*/ if (j === 0) {\n            chunk_index = 1; /* the first sample is in the first chunk (chunk indexes are 1-based) */ \n            chunk_run_index = 0; /* the first chunk is the first entry in the first_chunk table */ \n            sample.chunk_index = chunk_index;\n            sample.chunk_run_index = chunk_run_index;\n            last_sample_in_chunk = stsc.samples_per_chunk[chunk_run_index];\n            offset_in_chunk = 0;\n            /* Is there another entry in the first_chunk table ? */ if (chunk_run_index + 1 < stsc.first_chunk.length) /* The last chunk in the run is the chunk before the next first chunk */ last_chunk_in_run = stsc.first_chunk[chunk_run_index + 1] - 1;\n            else /* There is only one entry in the table, it is valid for all future chunks*/ last_chunk_in_run = Infinity;\n        } else if (j < last_sample_in_chunk) {\n            /* the sample is still in the current chunk */ sample.chunk_index = chunk_index;\n            sample.chunk_run_index = chunk_run_index;\n        } else {\n            /* the sample is in the next chunk */ chunk_index++;\n            sample.chunk_index = chunk_index;\n            /* reset the accumulated offset in the chunk */ offset_in_chunk = 0;\n            if (chunk_index <= last_chunk_in_run) ;\n            else {\n                chunk_run_index++;\n                /* Is there another entry in the first_chunk table ? */ if (chunk_run_index + 1 < stsc.first_chunk.length) /* The last chunk in the run is the chunk before the next first chunk */ last_chunk_in_run = stsc.first_chunk[chunk_run_index + 1] - 1;\n                else /* There is only one entry in the table, it is valid for all future chunks*/ last_chunk_in_run = Infinity;\n            }\n            sample.chunk_run_index = chunk_run_index;\n            last_sample_in_chunk += stsc.samples_per_chunk[chunk_run_index];\n        }\n        sample.description_index = stsc.sample_description_index[sample.chunk_run_index] - 1;\n        sample.description = stsd.entries[sample.description_index];\n        sample.offset = stco.chunk_offsets[sample.chunk_index - 1] + offset_in_chunk; /* chunk indexes are 1-based */ \n        offset_in_chunk += sample.size;\n        /* setting dts, cts, duration and rap flags */ if (j > last_sample_in_stts_run) {\n            stts_run_index++;\n            if (last_sample_in_stts_run < 0) last_sample_in_stts_run = 0;\n            last_sample_in_stts_run += stts.sample_counts[stts_run_index];\n        }\n        if (j > 0) {\n            trak.samples[j - 1].duration = stts.sample_deltas[stts_run_index];\n            trak.samples_duration += trak.samples[j - 1].duration;\n            sample.dts = trak.samples[j - 1].dts + trak.samples[j - 1].duration;\n        } else sample.dts = 0;\n        if (ctts) {\n            if (j >= last_sample_in_ctts_run) {\n                ctts_run_index++;\n                if (last_sample_in_ctts_run < 0) last_sample_in_ctts_run = 0;\n                last_sample_in_ctts_run += ctts.sample_counts[ctts_run_index];\n            }\n            sample.cts = trak.samples[j].dts + ctts.sample_offsets[ctts_run_index];\n        } else sample.cts = sample.dts;\n        if (stss) {\n            if (j == stss.sample_numbers[last_stss_index] - 1) {\n                sample.is_sync = true;\n                last_stss_index++;\n            } else {\n                sample.is_sync = false;\n                sample.degradation_priority = 0;\n            }\n            if (subs) {\n                if (subs.entries[subs_entry_index].sample_delta + last_subs_sample_index == j + 1) {\n                    sample.subsamples = subs.entries[subs_entry_index].subsamples;\n                    last_subs_sample_index += subs.entries[subs_entry_index].sample_delta;\n                    subs_entry_index++;\n                }\n            }\n        } else sample.is_sync = true;\n        ISOFile.process_sdtp(trak.mdia.minf.stbl.sdtp, sample, sample.number);\n        if (stdp) sample.degradation_priority = stdp.priority[j];\n        else sample.degradation_priority = 0;\n        if (subs) {\n            if (subs.entries[subs_entry_index].sample_delta + last_subs_sample_index == j) {\n                sample.subsamples = subs.entries[subs_entry_index].subsamples;\n                last_subs_sample_index += subs.entries[subs_entry_index].sample_delta;\n            }\n        }\n        if (sbgps.length > 0 || sgpds.length > 0) ISOFile.setSampleGroupProperties(trak, sample, j, trak.sample_groups_info);\n    }\n    if (j > 0) {\n        trak.samples[j - 1].duration = Math.max(trak.mdia.mdhd.duration - trak.samples[j - 1].dts, 0);\n        trak.samples_duration += trak.samples[j - 1].duration;\n    }\n};\n/* Update sample list when new 'moof' boxes are received */ ISOFile.prototype.updateSampleLists = function() {\n    var i1, j, k;\n    var default_sample_description_index, default_sample_duration, default_sample_size, default_sample_flags;\n    var last_run_position;\n    var box1, moof, traf, trak, trex;\n    var sample;\n    var sample_flags;\n    if (this.moov === undefined) return;\n    /* if the input file is fragmented and fetched in multiple downloads, we need to update the list of samples */ while(this.lastMoofIndex < this.moofs.length){\n        box1 = this.moofs[this.lastMoofIndex];\n        this.lastMoofIndex++;\n        if (box1.type == \"moof\") {\n            moof = box1;\n            for(i1 = 0; i1 < moof.trafs.length; i1++){\n                traf = moof.trafs[i1];\n                trak = this.getTrackById(traf.tfhd.track_id);\n                if (trak.samples == null) trak.samples = [];\n                trex = this.getTrexById(traf.tfhd.track_id);\n                if (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) default_sample_description_index = traf.tfhd.default_sample_description_index;\n                else default_sample_description_index = trex ? trex.default_sample_description_index : 1;\n                if (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) default_sample_duration = traf.tfhd.default_sample_duration;\n                else default_sample_duration = trex ? trex.default_sample_duration : 0;\n                if (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) default_sample_size = traf.tfhd.default_sample_size;\n                else default_sample_size = trex ? trex.default_sample_size : 0;\n                if (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) default_sample_flags = traf.tfhd.default_sample_flags;\n                else default_sample_flags = trex ? trex.default_sample_flags : 0;\n                traf.sample_number = 0;\n                /* process sample groups */ if (traf.sbgps.length > 0) ISOFile.initSampleGroups(trak, traf, traf.sbgps, trak.mdia.minf.stbl.sgpds, traf.sgpds);\n                for(j = 0; j < traf.truns.length; j++){\n                    var trun = traf.truns[j];\n                    for(k = 0; k < trun.sample_count; k++){\n                        sample = {};\n                        sample.moof_number = this.lastMoofIndex;\n                        sample.number_in_traf = traf.sample_number;\n                        traf.sample_number++;\n                        sample.number = trak.samples.length;\n                        traf.first_sample_index = trak.samples.length;\n                        trak.samples.push(sample);\n                        sample.track_id = trak.tkhd.track_id;\n                        sample.timescale = trak.mdia.mdhd.timescale;\n                        sample.description_index = default_sample_description_index - 1;\n                        sample.description = trak.mdia.minf.stbl.stsd.entries[sample.description_index];\n                        sample.size = default_sample_size;\n                        if (trun.flags & BoxParser.TRUN_FLAGS_SIZE) sample.size = trun.sample_size[k];\n                        trak.samples_size += sample.size;\n                        sample.duration = default_sample_duration;\n                        if (trun.flags & BoxParser.TRUN_FLAGS_DURATION) sample.duration = trun.sample_duration[k];\n                        trak.samples_duration += sample.duration;\n                        if (trak.first_traf_merged || k > 0) sample.dts = trak.samples[trak.samples.length - 2].dts + trak.samples[trak.samples.length - 2].duration;\n                        else {\n                            if (traf.tfdt) sample.dts = traf.tfdt.baseMediaDecodeTime;\n                            else sample.dts = 0;\n                            trak.first_traf_merged = true;\n                        }\n                        sample.cts = sample.dts;\n                        if (trun.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) sample.cts = sample.dts + trun.sample_composition_time_offset[k];\n                        sample_flags = default_sample_flags;\n                        if (trun.flags & BoxParser.TRUN_FLAGS_FLAGS) sample_flags = trun.sample_flags[k];\n                        else if (k === 0 && trun.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) sample_flags = trun.first_sample_flags;\n                        sample.is_sync = sample_flags >> 16 & 0x1 ? false : true;\n                        sample.is_leading = sample_flags >> 26 & 0x3;\n                        sample.depends_on = sample_flags >> 24 & 0x3;\n                        sample.is_depended_on = sample_flags >> 22 & 0x3;\n                        sample.has_redundancy = sample_flags >> 20 & 0x3;\n                        sample.degradation_priority = sample_flags & 0xFFFF;\n                        //ISOFile.process_sdtp(traf.sdtp, sample, sample.number_in_traf);\n                        var bdop = traf.tfhd.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET ? true : false;\n                        var dbim = traf.tfhd.flags & BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF ? true : false;\n                        var dop = trun.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET ? true : false;\n                        var bdo = 0;\n                        if (!bdop) {\n                            if (!dbim) {\n                                if (j === 0) bdo = moof.start; // the position of the first byte of the enclosing Movie Fragment Box\n                                else bdo = last_run_position; // end of the data defined by the preceding *track* (irrespective of the track id) fragment in the moof\n                            } else bdo = moof.start;\n                        } else bdo = traf.tfhd.base_data_offset;\n                        if (j === 0 && k === 0) {\n                            if (dop) sample.offset = bdo + trun.data_offset; // If the data-offset is present, it is relative to the base-data-offset established in the track fragment header\n                            else sample.offset = bdo; // the data for this run starts the base-data-offset defined by the track fragment header\n                        } else sample.offset = last_run_position; // this run starts immediately after the data of the previous run\n                        last_run_position = sample.offset + sample.size;\n                        if (traf.sbgps.length > 0 || traf.sgpds.length > 0 || trak.mdia.minf.stbl.sbgps.length > 0 || trak.mdia.minf.stbl.sgpds.length > 0) ISOFile.setSampleGroupProperties(trak, sample, sample.number_in_traf, traf.sample_groups_info);\n                    }\n                }\n                if (traf.subs) {\n                    trak.has_fragment_subsamples = true;\n                    var sample_index = traf.first_sample_index;\n                    for(j = 0; j < traf.subs.entries.length; j++){\n                        sample_index += traf.subs.entries[j].sample_delta;\n                        sample = trak.samples[sample_index - 1];\n                        sample.subsamples = traf.subs.entries[j].subsamples;\n                    }\n                }\n            }\n        }\n    }\n};\n/* Try to get sample data for a given sample:\n   returns null if not found\n   returns the same sample if already requested\n */ ISOFile.prototype.getSample = function(trak, sampleNum) {\n    var buffer;\n    var sample = trak.samples[sampleNum];\n    if (!this.moov) return null;\n    if (!sample.data) {\n        /* Not yet fetched */ sample.data = new Uint8Array(sample.size);\n        sample.alreadyRead = 0;\n        this.samplesDataSize += sample.size;\n        Log.debug(\"ISOFile\", \"Allocating sample #\" + sampleNum + \" on track #\" + trak.tkhd.track_id + \" of size \" + sample.size + \" (total: \" + this.samplesDataSize + \")\");\n    } else if (sample.alreadyRead == sample.size) /* Already fetched entirely */ return sample;\n    /* The sample has only been partially fetched, we need to check in all buffers */ while(true){\n        var index = this.stream.findPosition(true, sample.offset + sample.alreadyRead, false);\n        if (index > -1) {\n            buffer = this.stream.buffers[index];\n            var lengthAfterStart = buffer.byteLength - (sample.offset + sample.alreadyRead - buffer.fileStart);\n            if (sample.size - sample.alreadyRead <= lengthAfterStart) {\n                /* the (rest of the) sample is entirely contained in this buffer */ Log.debug(\"ISOFile\", \"Getting sample #\" + sampleNum + \" data (alreadyRead: \" + sample.alreadyRead + \" offset: \" + (sample.offset + sample.alreadyRead - buffer.fileStart) + \" read size: \" + (sample.size - sample.alreadyRead) + \" full size: \" + sample.size + \")\");\n                DataStream.memcpy(sample.data.buffer, sample.alreadyRead, buffer, sample.offset + sample.alreadyRead - buffer.fileStart, sample.size - sample.alreadyRead);\n                /* update the number of bytes used in this buffer and check if it needs to be removed */ buffer.usedBytes += sample.size - sample.alreadyRead;\n                this.stream.logBufferLevel();\n                sample.alreadyRead = sample.size;\n                return sample;\n            } else {\n                /* the sample does not end in this buffer */ if (lengthAfterStart === 0) return null;\n                Log.debug(\"ISOFile\", \"Getting sample #\" + sampleNum + \" partial data (alreadyRead: \" + sample.alreadyRead + \" offset: \" + (sample.offset + sample.alreadyRead - buffer.fileStart) + \" read size: \" + lengthAfterStart + \" full size: \" + sample.size + \")\");\n                DataStream.memcpy(sample.data.buffer, sample.alreadyRead, buffer, sample.offset + sample.alreadyRead - buffer.fileStart, lengthAfterStart);\n                sample.alreadyRead += lengthAfterStart;\n                /* update the number of bytes used in this buffer and check if it needs to be removed */ buffer.usedBytes += lengthAfterStart;\n                this.stream.logBufferLevel();\n            /* keep looking in the next buffer */ }\n        } else return null;\n    }\n};\n/* Release the memory used to store the data of the sample */ ISOFile.prototype.releaseSample = function(trak, sampleNum) {\n    var sample = trak.samples[sampleNum];\n    if (sample.data) {\n        this.samplesDataSize -= sample.size;\n        sample.data = null;\n        sample.alreadyRead = 0;\n        return sample.size;\n    } else return 0;\n};\nISOFile.prototype.getAllocatedSampleDataSize = function() {\n    return this.samplesDataSize;\n};\n/* Builds the MIME Type 'codecs' sub-parameters for the whole file */ ISOFile.prototype.getCodecs = function() {\n    var i1;\n    var codecs = \"\";\n    for(i1 = 0; i1 < this.moov.traks.length; i1++){\n        var trak = this.moov.traks[i1];\n        if (i1 > 0) codecs += \",\";\n        codecs += trak.mdia.minf.stbl.stsd.entries[0].getCodec();\n    }\n    return codecs;\n};\n/* Helper function */ ISOFile.prototype.getTrexById = function(id) {\n    var i1;\n    if (!this.moov || !this.moov.mvex) return null;\n    for(i1 = 0; i1 < this.moov.mvex.trexs.length; i1++){\n        var trex = this.moov.mvex.trexs[i1];\n        if (trex.track_id == id) return trex;\n    }\n    return null;\n};\n/* Helper function */ ISOFile.prototype.getTrackById = function(id) {\n    if (this.moov === undefined) return null;\n    for(var j = 0; j < this.moov.traks.length; j++){\n        var trak = this.moov.traks[j];\n        if (trak.tkhd.track_id == id) return trak;\n    }\n    return null;\n};\n// file:src/isofile-item-processing.js\nISOFile.prototype.items = [];\nISOFile.prototype.entity_groups = [];\n/* size of the buffers allocated for samples */ ISOFile.prototype.itemsDataSize = 0;\nISOFile.prototype.flattenItemInfo = function() {\n    var items = this.items;\n    var entity_groups = this.entity_groups;\n    var i1, j;\n    var item;\n    var meta = this.meta;\n    if (meta === null || meta === undefined) return;\n    if (meta.hdlr === undefined) return;\n    if (meta.iinf === undefined) return;\n    for(i1 = 0; i1 < meta.iinf.item_infos.length; i1++){\n        item = {};\n        item.id = meta.iinf.item_infos[i1].item_ID;\n        items[item.id] = item;\n        item.ref_to = [];\n        item.name = meta.iinf.item_infos[i1].item_name;\n        if (meta.iinf.item_infos[i1].protection_index > 0) item.protection = meta.ipro.protections[meta.iinf.item_infos[i1].protection_index - 1];\n        if (meta.iinf.item_infos[i1].item_type) item.type = meta.iinf.item_infos[i1].item_type;\n        else item.type = \"mime\";\n        item.content_type = meta.iinf.item_infos[i1].content_type;\n        item.content_encoding = meta.iinf.item_infos[i1].content_encoding;\n    }\n    if (meta.grpl) for(i1 = 0; i1 < meta.grpl.boxes.length; i1++){\n        entity_group = {};\n        entity_group.id = meta.grpl.boxes[i1].group_id;\n        entity_group.entity_ids = meta.grpl.boxes[i1].entity_ids;\n        entity_group.type = meta.grpl.boxes[i1].type;\n        entity_groups[entity_group.id] = entity_group;\n    }\n    if (meta.iloc) for(i1 = 0; i1 < meta.iloc.items.length; i1++){\n        var offset;\n        var itemloc = meta.iloc.items[i1];\n        item = items[itemloc.item_ID];\n        if (itemloc.data_reference_index !== 0) {\n            Log.warn(\"Item storage with reference to other files: not supported\");\n            item.source = meta.dinf.boxes[itemloc.data_reference_index - 1];\n        }\n        switch(itemloc.construction_method){\n            case 0:\n                break;\n            case 1:\n                Log.warn(\"Item storage with construction_method : not supported\");\n                break;\n            case 2:\n                Log.warn(\"Item storage with construction_method : not supported\");\n                break;\n        }\n        item.extents = [];\n        item.size = 0;\n        for(j = 0; j < itemloc.extents.length; j++){\n            item.extents[j] = {};\n            item.extents[j].offset = itemloc.extents[j].extent_offset + itemloc.base_offset;\n            item.extents[j].length = itemloc.extents[j].extent_length;\n            item.extents[j].alreadyRead = 0;\n            item.size += item.extents[j].length;\n        }\n    }\n    if (meta.pitm) items[meta.pitm.item_id].primary = true;\n    if (meta.iref) for(i1 = 0; i1 < meta.iref.references.length; i1++){\n        var ref = meta.iref.references[i1];\n        for(j = 0; j < ref.references.length; j++)items[ref.from_item_ID].ref_to.push({\n            type: ref.type,\n            id: ref.references[j]\n        });\n    }\n    if (meta.iprp) for(var k = 0; k < meta.iprp.ipmas.length; k++){\n        var ipma = meta.iprp.ipmas[k];\n        for(i1 = 0; i1 < ipma.associations.length; i1++){\n            var association = ipma.associations[i1];\n            item = items[association.id];\n            if (!item) item = entity_groups[association.id];\n            if (item) {\n                if (item.properties === undefined) {\n                    item.properties = {};\n                    item.properties.boxes = [];\n                }\n                for(j = 0; j < association.props.length; j++){\n                    var propEntry = association.props[j];\n                    if (propEntry.property_index > 0 && propEntry.property_index - 1 < meta.iprp.ipco.boxes.length) {\n                        var propbox = meta.iprp.ipco.boxes[propEntry.property_index - 1];\n                        item.properties[propbox.type] = propbox;\n                        item.properties.boxes.push(propbox);\n                    }\n                }\n            }\n        }\n    }\n};\nISOFile.prototype.getItem = function(item_id) {\n    var buffer;\n    var item;\n    if (!this.meta) return null;\n    item = this.items[item_id];\n    if (!item.data && item.size) {\n        /* Not yet fetched */ item.data = new Uint8Array(item.size);\n        item.alreadyRead = 0;\n        this.itemsDataSize += item.size;\n        Log.debug(\"ISOFile\", \"Allocating item #\" + item_id + \" of size \" + item.size + \" (total: \" + this.itemsDataSize + \")\");\n    } else if (item.alreadyRead === item.size) /* Already fetched entirely */ return item;\n    /* The item has only been partially fetched, we need to check in all buffers to find the remaining extents*/ for(var i1 = 0; i1 < item.extents.length; i1++){\n        var extent = item.extents[i1];\n        if (extent.alreadyRead === extent.length) continue;\n        else {\n            var index = this.stream.findPosition(true, extent.offset + extent.alreadyRead, false);\n            if (index > -1) {\n                buffer = this.stream.buffers[index];\n                var lengthAfterStart = buffer.byteLength - (extent.offset + extent.alreadyRead - buffer.fileStart);\n                if (extent.length - extent.alreadyRead <= lengthAfterStart) {\n                    /* the (rest of the) extent is entirely contained in this buffer */ Log.debug(\"ISOFile\", \"Getting item #\" + item_id + \" extent #\" + i1 + \" data (alreadyRead: \" + extent.alreadyRead + \" offset: \" + (extent.offset + extent.alreadyRead - buffer.fileStart) + \" read size: \" + (extent.length - extent.alreadyRead) + \" full extent size: \" + extent.length + \" full item size: \" + item.size + \")\");\n                    DataStream.memcpy(item.data.buffer, item.alreadyRead, buffer, extent.offset + extent.alreadyRead - buffer.fileStart, extent.length - extent.alreadyRead);\n                    /* update the number of bytes used in this buffer and check if it needs to be removed */ buffer.usedBytes += extent.length - extent.alreadyRead;\n                    this.stream.logBufferLevel();\n                    item.alreadyRead += extent.length - extent.alreadyRead;\n                    extent.alreadyRead = extent.length;\n                } else {\n                    /* the sample does not end in this buffer */ Log.debug(\"ISOFile\", \"Getting item #\" + item_id + \" extent #\" + i1 + \" partial data (alreadyRead: \" + extent.alreadyRead + \" offset: \" + (extent.offset + extent.alreadyRead - buffer.fileStart) + \" read size: \" + lengthAfterStart + \" full extent size: \" + extent.length + \" full item size: \" + item.size + \")\");\n                    DataStream.memcpy(item.data.buffer, item.alreadyRead, buffer, extent.offset + extent.alreadyRead - buffer.fileStart, lengthAfterStart);\n                    extent.alreadyRead += lengthAfterStart;\n                    item.alreadyRead += lengthAfterStart;\n                    /* update the number of bytes used in this buffer and check if it needs to be removed */ buffer.usedBytes += lengthAfterStart;\n                    this.stream.logBufferLevel();\n                    return null;\n                }\n            } else return null;\n        }\n    }\n    if (item.alreadyRead === item.size) /* fetched entirely */ return item;\n    else return null;\n};\n/* Release the memory used to store the data of the item */ ISOFile.prototype.releaseItem = function(item_id) {\n    var item = this.items[item_id];\n    if (item.data) {\n        this.itemsDataSize -= item.size;\n        item.data = null;\n        item.alreadyRead = 0;\n        for(var i1 = 0; i1 < item.extents.length; i1++){\n            var extent = item.extents[i1];\n            extent.alreadyRead = 0;\n        }\n        return item.size;\n    } else return 0;\n};\nISOFile.prototype.processItems = function(callback) {\n    for(var i1 in this.items){\n        var item = this.items[i1];\n        this.getItem(item.id);\n        if (callback && !item.sent) {\n            callback(item);\n            item.sent = true;\n            item.data = null;\n        }\n    }\n};\nISOFile.prototype.hasItem = function(name) {\n    for(var i1 in this.items){\n        var item = this.items[i1];\n        if (item.name === name) return item.id;\n    }\n    return -1;\n};\nISOFile.prototype.getMetaHandler = function() {\n    if (!this.meta) return null;\n    else return this.meta.hdlr.handler;\n};\nISOFile.prototype.getPrimaryItem = function() {\n    if (!this.meta || !this.meta.pitm) return null;\n    else return this.getItem(this.meta.pitm.item_id);\n};\nISOFile.prototype.itemToFragmentedTrackFile = function(_options) {\n    var options = _options || {};\n    var item = null;\n    if (options.itemId) item = this.getItem(options.itemId);\n    else item = this.getPrimaryItem();\n    if (item == null) return null;\n    var file = new ISOFile();\n    file.discardMdatData = false;\n    // assuming the track type is the same as the item type\n    var trackOptions = {\n        type: item.type,\n        description_boxes: item.properties.boxes\n    };\n    if (item.properties.ispe) {\n        trackOptions.width = item.properties.ispe.image_width;\n        trackOptions.height = item.properties.ispe.image_height;\n    }\n    var trackId = file.addTrack(trackOptions);\n    if (trackId) {\n        file.addSample(trackId, item.data);\n        return file;\n    } else return null;\n};\n// file:src/isofile-write.js\n/* Rewrite the entire file */ ISOFile.prototype.write = function(outstream) {\n    for(var i1 = 0; i1 < this.boxes.length; i1++)this.boxes[i1].write(outstream);\n};\nISOFile.prototype.createFragment = function(track_id, sampleNumber, stream_) {\n    var trak = this.getTrackById(track_id);\n    var sample = this.getSample(trak, sampleNumber);\n    if (sample == null) {\n        this.setNextSeekPositionFromSample(trak.samples[sampleNumber]);\n        return null;\n    }\n    var stream = stream_ || new DataStream();\n    stream.endianness = DataStream.BIG_ENDIAN;\n    var moof = this.createSingleSampleMoof(sample);\n    moof.write(stream);\n    /* adjusting the data_offset now that the moof size is known*/ moof.trafs[0].truns[0].data_offset = moof.size + 8; //8 is mdat header\n    Log.debug(\"MP4Box\", \"Adjusting data_offset with new value \" + moof.trafs[0].truns[0].data_offset);\n    stream.adjustUint32(moof.trafs[0].truns[0].data_offset_position, moof.trafs[0].truns[0].data_offset);\n    var mdat = new BoxParser.mdatBox();\n    mdat.data = sample.data;\n    mdat.write(stream);\n    return stream;\n};\n/* Modify the file and create the initialization segment */ ISOFile.writeInitializationSegment = function(ftyp, moov, total_duration, sample_duration) {\n    var i1;\n    var index;\n    var mehd;\n    var trex;\n    var box1;\n    Log.debug(\"ISOFile\", \"Generating initialization segment\");\n    var stream = new DataStream();\n    stream.endianness = DataStream.BIG_ENDIAN;\n    ftyp.write(stream);\n    /* we can now create the new mvex box */ var mvex = moov.add(\"mvex\");\n    if (total_duration) mvex.add(\"mehd\").set(\"fragment_duration\", total_duration);\n    for(i1 = 0; i1 < moov.traks.length; i1++)mvex.add(\"trex\").set(\"track_id\", moov.traks[i1].tkhd.track_id).set(\"default_sample_description_index\", 1).set(\"default_sample_duration\", sample_duration).set(\"default_sample_size\", 0).set(\"default_sample_flags\", 65536);\n    moov.write(stream);\n    return stream.buffer;\n};\nISOFile.prototype.save = function(name) {\n    var stream = new DataStream();\n    stream.endianness = DataStream.BIG_ENDIAN;\n    this.write(stream);\n    stream.save(name);\n};\nISOFile.prototype.getBuffer = function() {\n    var stream = new DataStream();\n    stream.endianness = DataStream.BIG_ENDIAN;\n    this.write(stream);\n    return stream.buffer;\n};\nISOFile.prototype.initializeSegmentation = function() {\n    var i1;\n    var j;\n    var box1;\n    var initSegs;\n    var trak;\n    var seg;\n    if (this.onSegment === null) Log.warn(\"MP4Box\", \"No segmentation callback set!\");\n    if (!this.isFragmentationInitialized) {\n        this.isFragmentationInitialized = true;\n        this.nextMoofNumber = 0;\n        this.resetTables();\n    }\n    initSegs = [];\n    for(i1 = 0; i1 < this.fragmentedTracks.length; i1++){\n        var moov = new BoxParser.moovBox();\n        moov.mvhd = this.moov.mvhd;\n        moov.boxes.push(moov.mvhd);\n        trak = this.getTrackById(this.fragmentedTracks[i1].id);\n        moov.boxes.push(trak);\n        moov.traks.push(trak);\n        seg = {};\n        seg.id = trak.tkhd.track_id;\n        seg.user = this.fragmentedTracks[i1].user;\n        seg.buffer = ISOFile.writeInitializationSegment(this.ftyp, moov, this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration : undefined, this.moov.traks[i1].samples.length > 0 ? this.moov.traks[i1].samples[0].duration : 0);\n        initSegs.push(seg);\n    }\n    return initSegs;\n};\n// file:src/box-print.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ BoxParser.Box.prototype.printHeader = function(output) {\n    this.size += 8;\n    if (this.size > MAX_SIZE) this.size += 8;\n    if (this.type === \"uuid\") this.size += 16;\n    output.log(output.indent + \"size:\" + this.size);\n    output.log(output.indent + \"type:\" + this.type);\n};\nBoxParser.FullBox.prototype.printHeader = function(output) {\n    this.size += 4;\n    BoxParser.Box.prototype.printHeader.call(this, output);\n    output.log(output.indent + \"version:\" + this.version);\n    output.log(output.indent + \"flags:\" + this.flags);\n};\nBoxParser.Box.prototype.print = function(output) {\n    this.printHeader(output);\n};\nBoxParser.ContainerBox.prototype.print = function(output) {\n    this.printHeader(output);\n    for(var i1 = 0; i1 < this.boxes.length; i1++)if (this.boxes[i1]) {\n        var prev_indent = output.indent;\n        output.indent += \" \";\n        this.boxes[i1].print(output);\n        output.indent = prev_indent;\n    }\n};\nISOFile.prototype.print = function(output) {\n    output.indent = \"\";\n    for(var i1 = 0; i1 < this.boxes.length; i1++)if (this.boxes[i1]) this.boxes[i1].print(output);\n};\nBoxParser.mvhdBox.prototype.print = function(output) {\n    BoxParser.FullBox.prototype.printHeader.call(this, output);\n    output.log(output.indent + \"creation_time: \" + this.creation_time);\n    output.log(output.indent + \"modification_time: \" + this.modification_time);\n    output.log(output.indent + \"timescale: \" + this.timescale);\n    output.log(output.indent + \"duration: \" + this.duration);\n    output.log(output.indent + \"rate: \" + this.rate);\n    output.log(output.indent + \"volume: \" + (this.volume >> 8));\n    output.log(output.indent + \"matrix: \" + this.matrix.join(\", \"));\n    output.log(output.indent + \"next_track_id: \" + this.next_track_id);\n};\nBoxParser.tkhdBox.prototype.print = function(output) {\n    BoxParser.FullBox.prototype.printHeader.call(this, output);\n    output.log(output.indent + \"creation_time: \" + this.creation_time);\n    output.log(output.indent + \"modification_time: \" + this.modification_time);\n    output.log(output.indent + \"track_id: \" + this.track_id);\n    output.log(output.indent + \"duration: \" + this.duration);\n    output.log(output.indent + \"volume: \" + (this.volume >> 8));\n    output.log(output.indent + \"matrix: \" + this.matrix.join(\", \"));\n    output.log(output.indent + \"layer: \" + this.layer);\n    output.log(output.indent + \"alternate_group: \" + this.alternate_group);\n    output.log(output.indent + \"width: \" + this.width);\n    output.log(output.indent + \"height: \" + this.height);\n} // file:src/mp4box.js\n;\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */ var MP4Box = {};\nMP4Box.createFile = function(_keepMdatData, _stream) {\n    /* Boolean indicating if bytes containing media data should be kept in memory */ var keepMdatData = _keepMdatData !== undefined ? _keepMdatData : true;\n    var file = new ISOFile(_stream);\n    file.discardMdatData = keepMdatData ? false : true;\n    return file;\n};\nexports.createFile = MP4Box.createFile;\n\n},{}],\"d6vtv\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"EventTool\", ()=>H);\nparcelHelpers.export(exports, \"Log\", ()=>S);\nparcelHelpers.export(exports, \"autoReadStream\", ()=>ae);\nparcelHelpers.export(exports, \"file2stream\", ()=>ce);\nparcelHelpers.export(exports, \"recodemux\", ()=>ie);\nparcelHelpers.export(exports, \"workerTimer\", ()=>q);\nvar _mp4BoxJs = require(\"@webav/mp4box.js\");\nvar _mp4BoxJsDefault = parcelHelpers.interopDefault(_mp4BoxJs);\nvar N = Object.defineProperty;\nvar E = (e)=>{\n    throw TypeError(e);\n};\nvar P = (e, t, n)=>t in e ? N(e, t, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value: n\n    }) : e[t] = n;\nvar R = (e, t, n)=>P(e, typeof t != \"symbol\" ? t + \"\" : t, n), Q = (e, t, n)=>t.has(e) || E(\"Cannot \" + n);\nvar z = (e, t, n)=>(Q(e, t, \"read from private field\"), n ? n.call(e) : t.get(e)), M = (e, t, n)=>t.has(e) ? E(\"Cannot add the same private member more than once\") : t instanceof WeakSet ? t.add(e) : t.set(e, n);\nvar A;\nclass H {\n    constructor(){\n        M(this, A, /* @__PURE__ */ new Map());\n        /**\n     * 监听 EventType 中定义的事件\n     */ R(this, \"on\", (t, n)=>{\n            const r = z(this, A).get(t) ?? /* @__PURE__ */ new Set();\n            return r.add(n), z(this, A).has(t) || z(this, A).set(t, r), ()=>{\n                r.delete(n), r.size === 0 && z(this, A).delete(t);\n            };\n        });\n        /**\n     * 监听事件，首次触发后自动移除监听\n     *\n     * 期望回调一次的事件，使用 once; 期望多次回调使用 on\n     */ R(this, \"once\", (t, n)=>{\n            const r = this.on(t, (...o)=>{\n                r(), n(...o);\n            });\n            return r;\n        });\n        /**\n     * 触发事件\n     * @param type\n     * @param args\n     * @returns\n     */ R(this, \"emit\", (t, ...n)=>{\n            const r = z(this, A).get(t);\n            r != null && r.forEach((o)=>o(...n));\n        });\n    }\n    /**\n   * 在两个 EventTool 实例间转发消息\n   * @param from\n   * @param to\n   * @param evtTypes 需转发的消息类型\n   *\n   * @example\n   * EventTool.forwardEvent(from, to, ['evtName']),\n   */ static forwardEvent(t, n, r) {\n        const o = r.map((s)=>{\n            const [a, i] = Array.isArray(s) ? s : [\n                s,\n                s\n            ];\n            return t.on(a, (...d)=>{\n                n.emit(i, ...d);\n            });\n        });\n        return ()=>{\n            o.forEach((s)=>s());\n        };\n    }\n    destroy() {\n        z(this, A).clear();\n    }\n}\nA = new WeakMap();\nconst J = ()=>{\n    let e, t = 16.6;\n    self.onmessage = (n)=>{\n        n.data.event === \"start\" && (self.clearInterval(e), e = self.setInterval(()=>{\n            self.postMessage({});\n        }, t)), n.data.event === \"stop\" && self.clearInterval(e);\n    };\n}, j = ()=>{\n    const e = new Blob([\n        `(${J.toString()})()`\n    ]), t = URL.createObjectURL(e);\n    return new Worker(t);\n}, k = /* @__PURE__ */ new Map();\nlet I = 1, B = null;\nglobalThis.Worker != null && (B = j(), B.onmessage = ()=>{\n    I += 1;\n    for (const [e, t] of k)if (I % e === 0) for (const n of t)n();\n});\nconst q = (e, t)=>{\n    const n = Math.round(t / 16.6), r = k.get(n) ?? /* @__PURE__ */ new Set();\n    return r.add(e), k.set(n, r), k.size === 1 && r.size === 1 && (B == null || B.postMessage({\n        event: \"start\"\n    })), ()=>{\n        r.delete(e), r.size === 0 && k.delete(n), k.size === 0 && (I = 0, B == null || B.postMessage({\n            event: \"stop\"\n        }));\n    };\n};\nfunction ae(e, t) {\n    let n = !1;\n    async function r() {\n        const o = e.getReader();\n        for(; !n;){\n            const { value: s, done: a } = await o.read();\n            if (a) {\n                t.onDone();\n                return;\n            }\n            await t.onChunk(s);\n        }\n        o.releaseLock(), await e.cancel();\n    }\n    return r().catch(console.error), ()=>{\n        n = !0;\n    };\n}\nfunction ce(e, t, n) {\n    let r = 0, o = 0;\n    const s = e.boxes;\n    let a = !1;\n    const i = ()=>{\n        var m;\n        if (!a) {\n            if (s.find((y)=>y.type === \"moof\") != null) a = !0;\n            else return null;\n        }\n        if (o >= s.length) return null;\n        const l = new (0, _mp4BoxJsDefault.default).DataStream();\n        l.endianness = (0, _mp4BoxJsDefault.default).DataStream.BIG_ENDIAN;\n        let h = o;\n        try {\n            for(; h < s.length;)s[h].write(l), delete s[h], h += 1;\n        } catch (y) {\n            const x = s[h];\n            throw y instanceof Error && x != null ? Error(`${y.message} | deltaBuf( boxType: ${x.type}, boxSize: ${x.size}, boxDataLen: ${((m = x.data) == null ? void 0 : m.length) ?? -1})`) : y;\n        }\n        return W(e), o = s.length, new Uint8Array(l.buffer);\n    };\n    let d = !1, c = !1, u = null;\n    return {\n        stream: new ReadableStream({\n            start (l) {\n                r = self.setInterval(()=>{\n                    const h = i();\n                    h != null && !c && l.enqueue(h);\n                }, t), u = (h)=>{\n                    if (clearInterval(r), e.flush(), h != null) {\n                        l.error(h);\n                        return;\n                    }\n                    const m = i();\n                    m != null && !c && l.enqueue(m), c || l.close();\n                }, d && u();\n            },\n            cancel () {\n                c = !0, clearInterval(r), n == null || n();\n            }\n        }),\n        stop: (l)=>{\n            d || (d = !0, u == null || u(l));\n        }\n    };\n}\nfunction W(e) {\n    if (e.moov != null) {\n        for(var t = 0; t < e.moov.traks.length; t++)e.moov.traks[t].samples = [];\n        e.mdats = [], e.moofs = [];\n    }\n}\nconst U = (e, t)=>{\n    const n = new Uint8Array(8);\n    new DataView(n.buffer).setUint32(0, t);\n    for(let o = 0; o < 4; o++)n[4 + o] = e.charCodeAt(o);\n    return n;\n}, F = ()=>{\n    const e = new TextEncoder(), t = e.encode(\"mdta\"), n = e.encode(\"mp4 handler\"), r = 32 + n.byteLength + 1, o = new Uint8Array(r), s = new DataView(o.buffer);\n    return o.set(U(\"hdlr\", r), 0), s.setUint32(8, 0), o.set(t, 16), o.set(n, 32), o;\n}, G = (e)=>{\n    const t = new TextEncoder(), n = t.encode(\"mdta\"), r = e.map((c)=>{\n        const u = t.encode(c), g = 8 + u.byteLength, l = new Uint8Array(g);\n        return new DataView(l.buffer).setUint32(0, g), l.set(n, 4), l.set(u, 4 + n.byteLength), l;\n    }), s = 16 + r.reduce((c, u)=>c + u.byteLength, 0), a = new Uint8Array(s), i = new DataView(a.buffer);\n    a.set(U(\"keys\", s), 0), i.setUint32(8, 0), i.setUint32(12, e.length);\n    let d = 16;\n    for (const c of r)a.set(c, d), d += c.byteLength;\n    return a;\n}, K = (e)=>{\n    const t = new TextEncoder(), n = t.encode(\"data\"), r = Object.entries(e).map(([d, c], u)=>{\n        const g = u + 1, l = t.encode(c), h = 24 + l.byteLength, m = new Uint8Array(h), y = new DataView(m.buffer);\n        return y.setUint32(0, h), y.setUint32(4, g), y.setUint32(8, 16 + l.byteLength), m.set(n, 12), y.setUint32(16, 1), m.set(l, 24), m;\n    }), s = 8 + r.reduce((d, c)=>d + c.byteLength, 0), a = new Uint8Array(s);\n    a.set(U(\"ilst\", s), 0);\n    let i = 8;\n    for (const d of r)a.set(d, i), i += d.byteLength;\n    return a;\n}, X = (e)=>{\n    const t = F(), n = G(Object.keys(e)), r = K(e), o = t.length + n.length + r.length, s = new Uint8Array(o);\n    return s.set(t, 0), s.set(n, t.length), s.set(r, t.length + n.length), s;\n};\nfunction Y(e) {\n    return e instanceof Error ? String(e) : typeof e == \"object\" ? JSON.stringify(e, (t, n)=>n instanceof Error ? String(n) : n) : String(e);\n}\nfunction Z() {\n    const e = /* @__PURE__ */ new Date();\n    return `${e.getHours()}:${e.getMinutes()}:${e.getSeconds()}.${e.getMilliseconds()}`;\n}\nlet C = 1;\nconst O = [], V = [\n    \"debug\",\n    \"info\",\n    \"warn\",\n    \"error\"\n].reduce((e, t, n)=>Object.assign(e, {\n        [t]: (...r)=>{\n            C <= n && (console[t](...r), O.push({\n                lvName: t,\n                timeStr: Z(),\n                args: r\n            }));\n        }\n    }), {}), $ = /* @__PURE__ */ new Map(), S = {\n    /**\n   * 设置记录日志的级别\n   *\n   * @example\n   * Log.setLogLevel(Log.warn) // 记录 warn，error 日志\n   */ setLogLevel: (e)=>{\n        C = $.get(e) ?? 1;\n    },\n    ...V,\n    /**\n   * 生成一个 log 实例，所有输出前都会附加 tag\n   *\n   * @example\n   * const log = Log.create('<prefix>')\n   * log.info('xxx') // '<prefix> xxx'\n   */ create: (e)=>Object.fromEntries(Object.entries(V).map(([t, n])=>[\n                t,\n                (...r)=>n(e, ...r)\n            ])),\n    /**\n   * 将所有日志导出为一个字符串\n   *\n   * @example\n   * Log.dump() // => [level][time]  内容...\n   *\n   */ async dump () {\n        return O.reduce((e, { lvName: t, timeStr: n, args: r })=>e + `[${t}][${n}]  ${r.map((o)=>Y(o)).join(\" \")}\n`, \"\");\n    }\n};\n$.set(S.debug, 0);\n$.set(S.info, 1);\n$.set(S.warn, 2);\n$.set(S.error, 3);\n(async function() {\n    await Promise.resolve(), !(globalThis.navigator == null || globalThis.document == null) && (S.info(`@webav version: 1.1.0, date: ${/* @__PURE__ */ new Date().toLocaleDateString()}`), S.info(globalThis.navigator.userAgent), document.addEventListener(\"visibilitychange\", ()=>{\n        S.info(`visibilitychange: ${document.visibilityState}`);\n    }), \"PressureObserver\" in globalThis && new PressureObserver((n)=>{\n        S.info(`cpu state change: ${JSON.stringify(n.map((r)=>r.state))}`);\n    }).observe(\"cpu\"));\n})();\nfunction ie(e) {\n    S.info(\"recodemux opts:\", e);\n    const t = (0, _mp4BoxJsDefault.default).createFile(), n = new H(), r = (d, c)=>{\n        const g = d.add(\"udta\").add(\"meta\");\n        g.data = X(c), g.size = g.data.byteLength;\n    };\n    let o = !1;\n    const s = ()=>{\n        t.moov == null || o || (o = !0, e.metaDataTags != null && r(t.moov, e.metaDataTags), e.duration != null && (t.moov.mvhd.duration = e.duration));\n    };\n    n.once(\"VideoReady\", s), n.once(\"AudioReady\", s);\n    let a = e.video != null ? ee(e.video, t, n) : null, i = e.audio != null ? ne(e.audio, t, n) : null;\n    return e.video == null && n.emit(\"VideoReady\"), e.audio == null && n.emit(\"AudioReady\"), {\n        encodeVideo: (d, c)=>{\n            a == null || a.encode(d, c), d.close();\n        },\n        encodeAudio: (d)=>{\n            if (i != null) try {\n                i.encode(d), d.close();\n            } catch (c) {\n                const u = `encode audio chunk error: ${c.message}, state: ${JSON.stringify({\n                    qSize: i.encodeQueueSize,\n                    state: i.state\n                })}`;\n                throw S.error(u), Error(u);\n            }\n        },\n        getEncodeQueueSize: ()=>(a == null ? void 0 : a.encodeQueueSize) ?? (i == null ? void 0 : i.encodeQueueSize) ?? 0,\n        flush: async ()=>{\n            await Promise.all([\n                a == null ? void 0 : a.flush(),\n                (i == null ? void 0 : i.state) === \"configured\" ? i.flush() : null\n            ]);\n        },\n        close: ()=>{\n            n.destroy(), a == null || a.close(), (i == null ? void 0 : i.state) === \"configured\" && i.close();\n        },\n        mp4file: t\n    };\n}\nfunction ee(e, t, n) {\n    const r = {\n        // 微秒\n        timescale: 1e6,\n        width: e.width,\n        height: e.height,\n        brands: [\n            \"isom\",\n            \"iso2\",\n            \"avc1\",\n            \"mp42\",\n            \"mp41\"\n        ],\n        avcDecoderConfigRecord: null,\n        name: \"Track created with WebAV\"\n    };\n    let o = -1, s = !1;\n    n.once(\"AudioReady\", ()=>{\n        s = !0;\n    });\n    const a = {\n        encoder0: [],\n        encoder1: []\n    }, i = (w, b, p)=>{\n        var f;\n        if (o === -1 && p != null) {\n            const v = (f = p.decoderConfig) == null ? void 0 : f.description;\n            te(v), r.avcDecoderConfigRecord = v, o = t.addTrack(r), n.emit(\"VideoReady\"), S.info(\"VideoEncoder, video track ready, trackId:\", o);\n        }\n        a[w].push(L(b));\n    };\n    let d = \"encoder1\", c = 0;\n    const u = Math.floor(1e3 / e.expectFPS * 1e3);\n    function g() {\n        if (!s) return;\n        const w = d === \"encoder1\" ? \"encoder0\" : \"encoder1\", b = a[d], p = a[w];\n        if (b.length === 0 && p.length === 0) return;\n        let f = b[0];\n        if (f != null && (!f.is_sync || f.cts - c < u)) {\n            const D = l(b);\n            D > c && (c = D);\n        }\n        const v = p[0];\n        if (v != null && v.is_sync && v.cts - c < u) {\n            d = w, g();\n            return;\n        }\n        if (f != null && f.is_sync && v != null && v.is_sync) {\n            if (f.cts <= v.cts) {\n                const D = l(b);\n                D > c && (c = D);\n            } else {\n                d = w, g();\n                return;\n            }\n        }\n    }\n    function l(w) {\n        let b = -1, p = 0;\n        for(; p < w.length; p++){\n            const f = w[p];\n            if (p > 0 && f.is_sync) break;\n            t.addSample(o, f.data, f), b = f.cts + f.duration;\n        }\n        return w.splice(0, p), b;\n    }\n    const h = q(g, 15), m = _(e, (w, b)=>i(\"encoder0\", w, b)), y = _(e, (w, b)=>i(\"encoder1\", w, b));\n    let x = 0;\n    return {\n        get encodeQueueSize () {\n            return m.encodeQueueSize + y.encodeQueueSize;\n        },\n        encode: (w, b)=>{\n            try {\n                b.keyFrame && (x += 1), (x % 2 === 0 ? m : y).encode(w, b);\n            } catch (p) {\n                const f = `encode video frame error: ${p.message}, state: ${JSON.stringify({\n                    ts: w.timestamp,\n                    keyFrame: b.keyFrame,\n                    duration: w.duration,\n                    gopId: x\n                })}`;\n                throw S.error(f), Error(f);\n            }\n        },\n        flush: async ()=>{\n            await Promise.all([\n                m.state === \"configured\" ? await m.flush() : null,\n                y.state === \"configured\" ? await y.flush() : null\n            ]), h(), g();\n        },\n        close: ()=>{\n            m.state === \"configured\" && m.close(), y.state === \"configured\" && y.close();\n        }\n    };\n}\nfunction te(e) {\n    const t = new Uint8Array(e);\n    t[2].toString(2).slice(-2).includes(\"1\") && (t[2] = 0);\n}\nfunction _(e, t) {\n    const n = {\n        codec: e.codec,\n        framerate: e.expectFPS,\n        hardwareAcceleration: e.__unsafe_hardwareAcceleration__,\n        // 码率\n        bitrate: e.bitrate,\n        width: e.width,\n        height: e.height,\n        // H264 不支持背景透明度\n        alpha: \"discard\",\n        // macos 自带播放器只支持avc\n        avc: {\n            format: \"avc\"\n        }\n    }, r = new VideoEncoder({\n        error: (o)=>{\n            const s = `VideoEncoder error: ${o.message}, config: ${JSON.stringify(n)}, state: ${JSON.stringify({\n                qSize: r.encodeQueueSize,\n                state: r.state\n            })}`;\n            throw S.error(s), Error(s);\n        },\n        output: t\n    });\n    return r.configure(n), r;\n}\nfunction ne(e, t, n) {\n    const r = {\n        timescale: 1e6,\n        samplerate: e.sampleRate,\n        channel_count: e.channelCount,\n        hdlr: \"soun\",\n        type: e.codec === \"aac\" ? \"mp4a\" : \"Opus\",\n        name: \"Track created with WebAV\"\n    };\n    let o = -1, s = [], a = !1;\n    n.once(\"VideoReady\", ()=>{\n        a = !0, s.forEach((c)=>{\n            const u = L(c);\n            t.addSample(o, u.data, u);\n        }), s = [];\n    });\n    const i = {\n        codec: e.codec === \"aac\" ? \"mp4a.40.2\" : \"opus\",\n        sampleRate: e.sampleRate,\n        numberOfChannels: e.channelCount,\n        bitrate: 128e3\n    }, d = new AudioEncoder({\n        error: (c)=>{\n            const u = `AudioEncoder error: ${c.message}, config: ${JSON.stringify(i)}, state: ${JSON.stringify({\n                qSize: d.encodeQueueSize,\n                state: d.state\n            })}`;\n            throw S.error(u), Error(u);\n        },\n        output: (c, u)=>{\n            var g;\n            if (o === -1) {\n                const l = (g = u.decoderConfig) == null ? void 0 : g.description;\n                o = t.addTrack({\n                    ...r,\n                    description: l == null ? void 0 : re(l)\n                }), n.emit(\"AudioReady\"), S.info(\"AudioEncoder, audio track ready, trackId:\", o);\n            }\n            if (a) {\n                const l = L(c);\n                t.addSample(o, l.data, l);\n            } else s.push(c);\n        }\n    });\n    return d.configure(i), d;\n}\nfunction re(e) {\n    const t = e.byteLength, n = new Uint8Array([\n        0,\n        // version 0\n        0,\n        0,\n        0,\n        // flags\n        3,\n        // descriptor_type\n        23 + t,\n        // length\n        0,\n        // 0x01, // es_id\n        2,\n        // es_id\n        0,\n        // stream_priority\n        4,\n        // descriptor_type\n        18 + t,\n        // length\n        64,\n        // codec : mpeg4_audio\n        21,\n        // stream_type\n        0,\n        0,\n        0,\n        // buffer_size\n        0,\n        0,\n        0,\n        0,\n        // maxBitrate\n        0,\n        0,\n        0,\n        0,\n        // avgBitrate\n        5,\n        // descriptor_type\n        t,\n        ...new Uint8Array(e instanceof ArrayBuffer ? e : e.buffer),\n        6,\n        1,\n        2\n    ]), r = new (0, _mp4BoxJsDefault.default).BoxParser.esdsBox(n.byteLength);\n    return r.hdr_size = 0, r.parse(new (0, _mp4BoxJsDefault.default).DataStream(n, 0, (0, _mp4BoxJsDefault.default).DataStream.BIG_ENDIAN)), r;\n}\nfunction L(e) {\n    const t = new ArrayBuffer(e.byteLength);\n    e.copyTo(t);\n    const n = e.timestamp;\n    return {\n        duration: e.duration ?? 0,\n        dts: n,\n        cts: n,\n        is_sync: e.type === \"key\",\n        data: t\n    };\n}\n\n},{\"@webav/mp4box.js\":\"g0QYf\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"5lQoW\":[function(require,module,exports,__globalThis) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, '__esModule', {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"511Cz\":[function(require,module,exports,__globalThis) {\n/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */ /**\r\n * @fileoverview The resample function.\r\n * @see https://github.com/rochars/wave-resampler\r\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/**\r\n * Change the sample rate of the samples to a new sample rate.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {number} oldSampleRate The original sample rate.\r\n * @param {number} sampleRate The target sample rate.\r\n * @param {?Object} details The extra configuration, if needed.\r\n * @return {!Float64Array} the new samples.\r\n */ parcelHelpers.export(exports, \"resample\", ()=>resample);\nvar _interpolator = require(\"./lib/interpolator\");\nvar _firLpf = require(\"./lib/fir-lpf\");\nvar _butterworthLpf = require(\"./lib/butterworth-lpf\");\n/**\r\n * Configures wich resampling method uses LPF by default.\r\n * @private\r\n */ const DEFAULT_LPF_USE = {\n    'point': false,\n    'linear': false,\n    'cubic': true,\n    'sinc': true\n};\n/**\r\n * The default orders for the LPF types.\r\n * @private\r\n */ const DEFAULT_LPF_ORDER = {\n    'IIR': 16,\n    'FIR': 71\n};\n/**\r\n * The classes to use with each LPF type.\r\n * @private\r\n */ const DEFAULT_LPF = {\n    'IIR': (0, _butterworthLpf.ButterworthLPF),\n    'FIR': (0, _firLpf.FIRLPF)\n};\nfunction resample(samples, oldSampleRate, sampleRate, details = {}) {\n    // Make the new sample container\n    let rate = (sampleRate - oldSampleRate) / oldSampleRate + 1;\n    let newSamples = new Float64Array(samples.length * rate);\n    // Create the interpolator\n    details.method = details.method || 'cubic';\n    let interpolator = new (0, _interpolator.Interpolator)(samples.length, newSamples.length, {\n        method: details.method,\n        tension: details.tension || 0,\n        sincFilterSize: details.sincFilterSize || 6,\n        sincWindow: details.sincWindow || undefined\n    });\n    // Resample + LPF\n    if (details.LPF === undefined) details.LPF = DEFAULT_LPF_USE[details.method];\n    if (details.LPF) {\n        details.LPFType = details.LPFType || 'IIR';\n        const LPF = DEFAULT_LPF[details.LPFType];\n        // Upsampling\n        if (sampleRate > oldSampleRate) {\n            let filter = new LPF(details.LPFOrder || DEFAULT_LPF_ORDER[details.LPFType], sampleRate, oldSampleRate / 2);\n            upsample_(samples, newSamples, interpolator, filter);\n        // Downsampling\n        } else {\n            let filter = new LPF(details.LPFOrder || DEFAULT_LPF_ORDER[details.LPFType], oldSampleRate, sampleRate / 2);\n            downsample_(samples, newSamples, interpolator, filter);\n        }\n    // Resample, no LPF\n    } else resample_(samples, newSamples, interpolator);\n    return newSamples;\n}\n/**\r\n * Resample.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @private\r\n */ function resample_(samples, newSamples, interpolator) {\n    // Resample\n    for(let i = 0, len = newSamples.length; i < len; i++)newSamples[i] = interpolator.interpolate(i, samples);\n}\n/**\r\n * Upsample with LPF.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */ function upsample_(samples, newSamples, interpolator, filter) {\n    // Resample and filter\n    for(let i = 0, len = newSamples.length; i < len; i++)newSamples[i] = filter.filter(interpolator.interpolate(i, samples));\n    // Reverse filter\n    filter.reset();\n    for(let i = newSamples.length - 1; i >= 0; i--)newSamples[i] = filter.filter(newSamples[i]);\n}\n/**\r\n * Downsample with LPF.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */ function downsample_(samples, newSamples, interpolator, filter) {\n    // Filter\n    for(let i = 0, len = samples.length; i < len; i++)samples[i] = filter.filter(samples[i]);\n    // Reverse filter\n    filter.reset();\n    for(let i = samples.length - 1; i >= 0; i--)samples[i] = filter.filter(samples[i]);\n    // Resample\n    resample_(samples, newSamples, interpolator);\n}\n\n},{\"./lib/interpolator\":\"9rmiW\",\"./lib/fir-lpf\":\"hfYpd\",\"./lib/butterworth-lpf\":\"cB7ID\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"9rmiW\":[function(require,module,exports,__globalThis) {\n/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright 2012 Spencer Cohen\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */ /**\r\n * @fileoverview The Interpolator class. Based on Smooth.js by Spencer Cohen.\r\n * @see https://github.com/rochars/wave-resampler\r\n * @see https://github.com/osuushi/Smooth.js\r\n */ /**\r\n * A class to get scaled values out of arrays.\r\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"Interpolator\", ()=>Interpolator);\nclass Interpolator {\n    /**\r\n   * @param {number} scaleFrom the length of the original array.\r\n   * @param {number} scaleTo The length of the new array.\r\n   * @param {?Object} details The extra configuration, if needed.\r\n   */ constructor(scaleFrom, scaleTo, details){\n        /**\r\n     * The length of the original array.\r\n     * @type {number}\r\n     */ this.length_ = scaleFrom;\n        /**\r\n     * The scaling factor.\r\n     * @type {number}\r\n     */ this.scaleFactor_ = (scaleFrom - 1) / scaleTo;\n        /**\r\n     * The interpolation function.\r\n     * @type {Function}\r\n     */ this.interpolate = this.cubic;\n        if (details.method === 'point') this.interpolate = this.point;\n        else if (details.method === 'linear') this.interpolate = this.linear;\n        else if (details.method === 'sinc') this.interpolate = this.sinc;\n        /**\r\n     * The tanget factor for cubic interpolation.\r\n     * @type {number}\r\n     */ this.tangentFactor_ = 1 - Math.max(0, Math.min(1, details.tension || 0));\n        // Configure the kernel for sinc\n        /**\r\n     * The sinc filter size.\r\n     * @type {number}\r\n     */ this.sincFilterSize_ = details.sincFilterSize || 1;\n        /**\r\n     * The sinc kernel.\r\n     * @type {Function}\r\n     */ this.kernel_ = sincKernel_(details.sincWindow || window_);\n    }\n    /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */ point(t, samples) {\n        return this.getClippedInput_(Math.round(this.scaleFactor_ * t), samples);\n    }\n    /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */ linear(t, samples) {\n        t = this.scaleFactor_ * t;\n        let k = Math.floor(t);\n        t -= k;\n        return (1 - t) * this.getClippedInput_(k, samples) + t * this.getClippedInput_(k + 1, samples);\n    }\n    /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */ cubic(t, samples) {\n        t = this.scaleFactor_ * t;\n        let k = Math.floor(t);\n        let m = [\n            this.getTangent_(k, samples),\n            this.getTangent_(k + 1, samples)\n        ];\n        let p = [\n            this.getClippedInput_(k, samples),\n            this.getClippedInput_(k + 1, samples)\n        ];\n        t -= k;\n        let t2 = t * t;\n        let t3 = t * t2;\n        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];\n    }\n    /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */ sinc(t, samples) {\n        t = this.scaleFactor_ * t;\n        let k = Math.floor(t);\n        let ref = k - this.sincFilterSize_ + 1;\n        let ref1 = k + this.sincFilterSize_;\n        let sum = 0;\n        for(let n = ref; n <= ref1; n++)sum += this.kernel_(t - n) * this.getClippedInput_(n, samples);\n        return sum;\n    }\n    /**\r\n   * @param {number} k The scaled index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The tangent.\r\n   * @private\r\n   */ getTangent_(k, samples) {\n        return this.tangentFactor_ * (this.getClippedInput_(k + 1, samples) - this.getClippedInput_(k - 1, samples)) / 2;\n    }\n    /**\r\n   * @param {number} t The scaled index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   * @private\r\n   */ getClippedInput_(t, samples) {\n        if (0 <= t && t < this.length_) return samples[t];\n        return 0;\n    }\n}\n// Sinc functions\n/**\r\n * The default window function.\r\n * @param {number} x The sinc signal.\r\n * @return {number}\r\n * @private\r\n */ function window_(x) {\n    return Math.exp(-x / 2 * x / 2);\n}\n/**\r\n * @param {Function} window The window function.\r\n * @return {Function}\r\n * @private\r\n */ function sincKernel_(window) {\n    return function(x) {\n        return sinc_(x) * window(x);\n    };\n}\n/**\r\n * @param {number} x The sinc signal.\r\n * @return {number}\r\n * @private\r\n */ function sinc_(x) {\n    if (x === 0) return 1;\n    return Math.sin(Math.PI * x) / (Math.PI * x);\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"hfYpd\":[function(require,module,exports,__globalThis) {\n/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2014 Florian Markert\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */ /**\r\n * @fileoverview FIR LPF. Based on the FIR LPF from Fili by Florian Markert.\r\n * @see https://github.com/rochars/wave-resampler\r\n * @see https://github.com/markert/fili.js\r\n */ /**\r\n * A FIR low pass filter.\r\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"FIRLPF\", ()=>FIRLPF);\nclass FIRLPF {\n    /**\r\n   * @param {number} order The order of the filter.\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} cutOff The cut off frequency.\r\n   */ constructor(order, sampleRate, cutOff){\n        let omega = 2 * Math.PI * cutOff / sampleRate;\n        let dc = 0;\n        this.filters = [];\n        for(let i = 0; i <= order; i++){\n            if (i - order / 2 === 0) this.filters[i] = omega;\n            else {\n                this.filters[i] = Math.sin(omega * (i - order / 2)) / (i - order / 2);\n                // Hamming window\n                this.filters[i] *= 0.54 - 0.46 * Math.cos(2 * Math.PI * i / order);\n            }\n            dc = dc + this.filters[i];\n        }\n        // normalize\n        for(let i = 0; i <= order; i++)this.filters[i] /= dc;\n        this.z = this.initZ_();\n    }\n    /**\r\n   * @param {number} sample A sample of a sequence.\r\n   * @return {number}\r\n   */ filter(sample) {\n        this.z.buf[this.z.pointer] = sample;\n        let out = 0;\n        for(let i = 0, len = this.z.buf.length; i < len; i++)out += this.filters[i] * this.z.buf[(this.z.pointer + i) % this.z.buf.length];\n        this.z.pointer = (this.z.pointer + 1) % this.z.buf.length;\n        return out;\n    }\n    /**\r\n   * Reset the filter.\r\n   */ reset() {\n        this.z = this.initZ_();\n    }\n    /**\r\n   * Return the default value for z.\r\n   * @private\r\n   */ initZ_() {\n        let r = [];\n        for(let i = 0; i < this.filters.length - 1; i++)r.push(0);\n        return {\n            buf: r,\n            pointer: 0\n        };\n    }\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"cB7ID\":[function(require,module,exports,__globalThis) {\n/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2014 Florian Markert\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */ /**\r\n * @fileoverview Butterworth LPF. Based on the Butterworth LPF from Fili.js.\r\n * @see https://github.com/rochars/wave-resampler\r\n * @see https://github.com/markert/fili.js\r\n */ /**\r\n * Butterworth LPF.\r\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"ButterworthLPF\", ()=>ButterworthLPF);\nclass ButterworthLPF {\n    /**\r\n   * @param {number} order The order of the filter.\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} cutOff The cut off frequency.\r\n   */ constructor(order, sampleRate, cutOff){\n        let filters = [];\n        for(let i = 0; i < order; i++)filters.push(this.getCoeffs_({\n            Fs: sampleRate,\n            Fc: cutOff,\n            Q: 0.5 / Math.sin(Math.PI / (order * 2) * (i + 0.5))\n        }));\n        this.stages = [];\n        for(let i = 0; i < filters.length; i++)this.stages[i] = {\n            b0: filters[i].b[0],\n            b1: filters[i].b[1],\n            b2: filters[i].b[2],\n            a1: filters[i].a[0],\n            a2: filters[i].a[1],\n            k: filters[i].k,\n            z: [\n                0,\n                0\n            ]\n        };\n    }\n    /**\r\n   * @param {number} sample A sample of a sequence.\r\n   * @return {number}\r\n   */ filter(sample) {\n        let out = sample;\n        for(let i = 0, len = this.stages.length; i < len; i++)out = this.runStage_(i, out);\n        return out;\n    }\n    getCoeffs_(params) {\n        let coeffs = {};\n        coeffs.z = [\n            0,\n            0\n        ];\n        coeffs.a = [];\n        coeffs.b = [];\n        let p = this.preCalc_(params, coeffs);\n        coeffs.k = 1;\n        coeffs.b.push((1 - p.cw) / (2 * p.a0));\n        coeffs.b.push(2 * coeffs.b[0]);\n        coeffs.b.push(coeffs.b[0]);\n        return coeffs;\n    }\n    preCalc_(params, coeffs) {\n        let pre = {};\n        let w = 2 * Math.PI * params.Fc / params.Fs;\n        pre.alpha = Math.sin(w) / (2 * params.Q);\n        pre.cw = Math.cos(w);\n        pre.a0 = 1 + pre.alpha;\n        coeffs.a0 = pre.a0;\n        coeffs.a.push(-2 * pre.cw / pre.a0);\n        coeffs.k = 1;\n        coeffs.a.push((1 - pre.alpha) / pre.a0);\n        return pre;\n    }\n    runStage_(i, input) {\n        let temp = input * this.stages[i].k - this.stages[i].a1 * this.stages[i].z[0] - this.stages[i].a2 * this.stages[i].z[1];\n        let out = this.stages[i].b0 * temp + this.stages[i].b1 * this.stages[i].z[0] + this.stages[i].b2 * this.stages[i].z[1];\n        this.stages[i].z[1] = this.stages[i].z[0];\n        this.stages[i].z[0] = temp;\n        return out;\n    }\n    /**\r\n   * Reset the filter.\r\n   */ reset() {\n        for(let i = 0; i < this.stages.length; i++)this.stages[i].z = [\n            0,\n            0\n        ];\n    }\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"ga02n\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"dir\", ()=>b);\nparcelHelpers.export(exports, \"file\", ()=>y);\nparcelHelpers.export(exports, \"rollfile\", ()=>ae);\nparcelHelpers.export(exports, \"tmpfile\", ()=>re);\nparcelHelpers.export(exports, \"write\", ()=>J);\nvar U = (r)=>{\n    throw TypeError(r);\n};\nvar O = (r, e, t)=>e.has(r) || U(\"Cannot \" + t);\nvar s = (r, e, t)=>(O(r, e, \"read from private field\"), t ? t.call(r) : e.get(r)), o = (r, e, t)=>e.has(r) ? U(\"Cannot add the same private member more than once\") : e instanceof WeakSet ? e.add(r) : e.set(r, t), l = (r, e, t, a)=>(O(r, e, \"write to private field\"), a ? a.call(r, t) : e.set(r, t), t);\nconst K = \"KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHUobil7aWYobj09PSIvIilyZXR1cm57cGFyZW50Om51bGwsbmFtZToiIn07Y29uc3QgZT1uLnNwbGl0KCIvIikuZmlsdGVyKGk9PmkubGVuZ3RoPjApO2lmKGUubGVuZ3RoPT09MCl0aHJvdyBFcnJvcigiSW52YWxpZCBwYXRoIik7Y29uc3QgYT1lW2UubGVuZ3RoLTFdLHI9Ii8iK2Uuc2xpY2UoMCwtMSkuam9pbigiLyIpO3JldHVybntuYW1lOmEscGFyZW50OnJ9fWFzeW5jIGZ1bmN0aW9uIHcobixlKXtjb25zdHtwYXJlbnQ6YSxuYW1lOnJ9PXUobik7aWYoYT09bnVsbClyZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7Y29uc3QgaT1hLnNwbGl0KCIvIikuZmlsdGVyKHQ9PnQubGVuZ3RoPjApO3RyeXtsZXQgdD1hd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtmb3IoY29uc3QgcyBvZiBpKXQ9YXdhaXQgdC5nZXREaXJlY3RvcnlIYW5kbGUocyx7Y3JlYXRlOmUuY3JlYXRlfSk7aWYoZS5pc0ZpbGUpcmV0dXJuIGF3YWl0IHQuZ2V0RmlsZUhhbmRsZShyLHtjcmVhdGU6ZS5jcmVhdGV9KX1jYXRjaCh0KXtpZih0Lm5hbWU9PT0iTm90Rm91bmRFcnJvciIpcmV0dXJuIG51bGw7dGhyb3cgdH19Y29uc3QgZj17fTtzZWxmLm9ubWVzc2FnZT1hc3luYyBuPT57dmFyIGk7Y29uc3R7ZXZ0VHlwZTplLGFyZ3M6YX09bi5kYXRhO2xldCByPWZbYS5maWxlSWRdO3RyeXtsZXQgdDtjb25zdCBzPVtdO2lmKGU9PT0icmVnaXN0ZXIiKXtjb25zdCBsPWF3YWl0IHcoYS5maWxlUGF0aCx7Y3JlYXRlOiEwLGlzRmlsZTohMH0pO2lmKGw9PW51bGwpdGhyb3cgRXJyb3IoYG5vdCBmb3VuZCBmaWxlOiAke2EuZmlsZUlkfWApO3I9YXdhaXQgbC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKHttb2RlOmEubW9kZX0pLGZbYS5maWxlSWRdPXJ9ZWxzZSBpZihlPT09ImNsb3NlIilhd2FpdCByLmNsb3NlKCksZGVsZXRlIGZbYS5maWxlSWRdO2Vsc2UgaWYoZT09PSJ0cnVuY2F0ZSIpYXdhaXQgci50cnVuY2F0ZShhLm5ld1NpemUpO2Vsc2UgaWYoZT09PSJ3cml0ZSIpe2NvbnN0e2RhdGE6bCxvcHRzOm99PW4uZGF0YS5hcmdzO3Q9YXdhaXQgci53cml0ZShsLG8pfWVsc2UgaWYoZT09PSJyZWFkIil7Y29uc3R7b2Zmc2V0Omwsc2l6ZTpvfT1uLmRhdGEuYXJncyxnPW5ldyBVaW50OEFycmF5KG8pLGQ9YXdhaXQgci5yZWFkKGcse2F0Omx9KSxjPWcuYnVmZmVyO3Q9ZD09PW8/YzooKGk9Yy50cmFuc2Zlcik9PW51bGw/dm9pZCAwOmkuY2FsbChjLGQpKT8/Yy5zbGljZSgwLGQpLHMucHVzaCh0KX1lbHNlIGU9PT0iZ2V0U2l6ZSI/dD1hd2FpdCByLmdldFNpemUoKTplPT09ImZsdXNoIiYmYXdhaXQgci5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2V2dFR5cGU6ImNhbGxiYWNrIixjYklkOm4uZGF0YS5jYklkLHJldHVyblZhbDp0fSxzKX1jYXRjaCh0KXtjb25zdCBzPXQ7c2VsZi5wb3N0TWVzc2FnZSh7ZXZ0VHlwZToidGhyb3dFcnJvciIsY2JJZDpuLmRhdGEuY2JJZCxlcnJNc2c6cy5uYW1lKyI6ICIrcy5tZXNzYWdlK2AKYCtKU09OLnN0cmluZ2lmeShuLmRhdGEpfSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZnMtd29ya2VyLUY0UldscWNfLmpzLm1hcAo=\", Q = (r)=>Uint8Array.from(atob(r), (e)=>e.charCodeAt(0)), C = typeof self < \"u\" && self.Blob && new Blob([\n    Q(K)\n], {\n    type: \"text/javascript;charset=utf-8\"\n});\nfunction D(r) {\n    let e;\n    try {\n        if (e = C && (self.URL || self.webkitURL).createObjectURL(C), !e) throw \"\";\n        const t = new Worker(e, {\n            name: r == null ? void 0 : r.name\n        });\n        return t.addEventListener(\"error\", ()=>{\n            (self.URL || self.webkitURL).revokeObjectURL(e);\n        }), t;\n    } catch  {\n        return new Worker(\"data:text/javascript;base64,\" + K, {\n            name: r == null ? void 0 : r.name\n        });\n    } finally{\n        e && (self.URL || self.webkitURL).revokeObjectURL(e);\n    }\n}\nasync function M(r, e, t) {\n    const a = _();\n    return await a(\"register\", {\n        fileId: r,\n        filePath: e,\n        mode: t\n    }), {\n        read: async (i, n)=>await a(\"read\", {\n                fileId: r,\n                offset: i,\n                size: n\n            }),\n        write: async (i, n)=>await a(\"write\", {\n                fileId: r,\n                data: i,\n                opts: n\n            }, [\n                ArrayBuffer.isView(i) ? i.buffer : i\n            ]),\n        close: async ()=>await a(\"close\", {\n                fileId: r\n            }),\n        truncate: async (i)=>await a(\"truncate\", {\n                fileId: r,\n                newSize: i\n            }),\n        getSize: async ()=>await a(\"getSize\", {\n                fileId: r\n            }),\n        flush: async ()=>await a(\"flush\", {\n                fileId: r\n            })\n    };\n}\nconst I = [];\nlet k = 0;\nfunction _() {\n    if (I.length < 3) {\n        const e = r();\n        return I.push(e), e;\n    } else {\n        const e = I[k];\n        return k = (k + 1) % I.length, e;\n    }\n    function r() {\n        const e = new D();\n        let t = 0, a = {};\n        return e.onmessage = ({ data: i })=>{\n            var n, c;\n            i.evtType === \"callback\" ? (n = a[i.cbId]) == null || n.resolve(i.returnVal) : i.evtType === \"throwError\" && ((c = a[i.cbId]) == null || c.reject(Error(i.errMsg))), delete a[i.cbId];\n        }, async function(n, c, u = []) {\n            t += 1;\n            const h = new Promise((p, V)=>{\n                a[t] = {\n                    resolve: p,\n                    reject: V\n                };\n            });\n            return e.postMessage({\n                cbId: t,\n                evtType: n,\n                args: c\n            }, u), h;\n        };\n    }\n}\nfunction T(r) {\n    if (r === \"/\") return {\n        parent: null,\n        name: \"\"\n    };\n    const e = r.split(\"/\").filter((i)=>i.length > 0);\n    if (e.length === 0) throw Error(\"Invalid path\");\n    const t = e[e.length - 1], a = \"/\" + e.slice(0, -1).join(\"/\");\n    return {\n        name: t,\n        parent: a\n    };\n}\nasync function d(r, e) {\n    const { parent: t, name: a } = T(r);\n    if (t == null) return await navigator.storage.getDirectory();\n    const i = t.split(\"/\").filter((n)=>n.length > 0);\n    try {\n        let n = await navigator.storage.getDirectory();\n        for (const c of i)n = await n.getDirectoryHandle(c, {\n            create: e.create\n        });\n        return e.isFile ? await n.getFileHandle(a, {\n            create: e.create\n        }) : await n.getDirectoryHandle(a, {\n            create: e.create\n        });\n    } catch (n) {\n        if (n.name === \"NotFoundError\") return null;\n        throw n;\n    }\n}\nasync function N(r) {\n    const { parent: e, name: t } = T(r);\n    if (e == null) {\n        const i = await navigator.storage.getDirectory();\n        for await (const n of i.keys())await i.removeEntry(n, {\n            recursive: !0\n        });\n        return;\n    }\n    const a = await d(e, {\n        create: !1,\n        isFile: !1\n    });\n    if (a != null) try {\n        await a.removeEntry(t, {\n            recursive: !0\n        });\n    } catch (i) {\n        if (i.name === \"NotFoundError\") return;\n        throw i;\n    }\n}\nfunction x(r, e) {\n    return `${r}/${e}`.replace(\"//\", \"/\");\n}\nfunction b(r) {\n    return new v(r);\n}\nvar w, S, g;\nconst P = class P {\n    constructor(e){\n        o(this, w);\n        o(this, S);\n        o(this, g);\n        l(this, w, e);\n        const { parent: t, name: a } = T(e);\n        l(this, S, a), l(this, g, t);\n    }\n    get kind() {\n        return \"dir\";\n    }\n    get name() {\n        return s(this, S);\n    }\n    get path() {\n        return s(this, w);\n    }\n    get parent() {\n        return s(this, g) == null ? null : b(s(this, g));\n    }\n    /**\n   * Creates the directory.\n   * return A promise that resolves when the directory is created.\n   */ async create() {\n        return await d(s(this, w), {\n            create: !0,\n            isFile: !1\n        }), b(s(this, w));\n    }\n    /**\n   * Checks if the directory exists.\n   * return A promise that resolves to true if the directory exists, otherwise false.\n   */ async exists() {\n        return await d(s(this, w), {\n            create: !1,\n            isFile: !1\n        }) instanceof FileSystemDirectoryHandle;\n    }\n    /**\n   * Removes the directory.\n   * return A promise that resolves when the directory is removed.\n   */ async remove() {\n        for (const e of (await this.children()))try {\n            await e.remove();\n        } catch (t) {\n            console.warn(t);\n        }\n        try {\n            await N(s(this, w));\n        } catch (e) {\n            console.warn(e);\n        }\n    }\n    /**\n   * Retrieves the children of the directory.\n   * return A promise that resolves to an array of objects representing the children.\n   */ async children() {\n        const e = await d(s(this, w), {\n            create: !1,\n            isFile: !1\n        });\n        if (e == null) return [];\n        const t = [];\n        for await (const a of e.values())t.push((a.kind === \"file\" ? y : b)(x(s(this, w), a.name)));\n        return t;\n    }\n    async copyTo(e) {\n        if (!await this.exists()) throw Error(`dir ${this.path} not exists`);\n        if (e instanceof P) {\n            const t = await e.exists() ? b(x(e.path, this.name)) : e;\n            return await t.create(), await Promise.all((await this.children()).map((a)=>a.copyTo(t))), t;\n        } else if (e instanceof FileSystemDirectoryHandle) return await Promise.all((await this.children()).map(async (t)=>{\n            t.kind === \"file\" ? await t.copyTo(await e.getFileHandle(t.name, {\n                create: !0\n            })) : await t.copyTo(await e.getDirectoryHandle(t.name, {\n                create: !0\n            }));\n        })), null;\n        throw Error(\"Illegal target type\");\n    }\n    /**\n   * move directory, copy then remove current\n   */ async moveTo(e) {\n        const t = await this.copyTo(e);\n        return await this.remove(), t;\n    }\n};\nw = new WeakMap(), S = new WeakMap(), g = new WeakMap();\nlet v = P;\nconst z = /* @__PURE__ */ new Map();\nfunction y(r, e = \"rw\") {\n    if (e === \"rw\") {\n        const t = z.get(r) ?? new F(r, e);\n        return z.set(r, t), t;\n    }\n    return new F(r, e);\n}\nasync function J(r, e, t = {\n    overwrite: !0\n}) {\n    if (e instanceof F) {\n        await J(r, await e.stream(), t);\n        return;\n    }\n    const a = await (r instanceof F ? r : y(r, \"rw\")).createWriter();\n    try {\n        if (t.overwrite && await a.truncate(0), e instanceof ReadableStream) {\n            const i = e.getReader();\n            for(;;){\n                const { done: n, value: c } = await i.read();\n                if (n) break;\n                await a.write(c);\n            }\n        } else await a.write(e);\n    } catch (i) {\n        throw i;\n    } finally{\n        await a.close();\n    }\n}\nlet A = 0;\nconst $ = ()=>++A;\nvar f, Z, G, Y, X, m, R, W;\nconst H = class H {\n    constructor(e, t){\n        o(this, f);\n        o(this, Z);\n        o(this, G);\n        o(this, Y);\n        o(this, X);\n        o(this, m, 0);\n        o(this, R, /* @__PURE__ */ (()=>{\n            let e = null;\n            return ()=>(l(this, m, s(this, m) + 1), e ?? (e = new Promise(async (t, a)=>{\n                    try {\n                        const i = await M(s(this, X), s(this, f), s(this, Y));\n                        t([\n                            i,\n                            async ()=>{\n                                l(this, m, s(this, m) - 1), !(s(this, m) > 0) && (e = null, await i.close());\n                            }\n                        ]);\n                    } catch (i) {\n                        a(i);\n                    }\n                })));\n        })());\n        o(this, W, !1);\n        l(this, X, $()), l(this, f, e), l(this, Y, {\n            r: \"read-only\",\n            rw: \"readwrite\",\n            \"rw-unsafe\": \"readwrite-unsafe\"\n        }[t]);\n        const { parent: a, name: i } = T(e);\n        if (a == null) throw Error(\"Invalid path\");\n        l(this, G, i), l(this, Z, a);\n    }\n    get kind() {\n        return \"file\";\n    }\n    get path() {\n        return s(this, f);\n    }\n    get name() {\n        return s(this, G);\n    }\n    get parent() {\n        return s(this, Z) == null ? null : b(s(this, Z));\n    }\n    /**\n   * Random write to file\n   */ async createWriter() {\n        if (s(this, Y) === \"read-only\") throw Error(\"file is read-only\");\n        if (s(this, W)) throw Error(\"Other writer have not been closed\");\n        l(this, W, !0);\n        const e = new TextEncoder(), [t, a] = await s(this, R).call(this);\n        let i = await t.getSize(), n = !1;\n        return {\n            write: async (c, u = {})=>{\n                if (n) throw Error(\"Writer is closed\");\n                const h = typeof c == \"string\" ? e.encode(c) : c, p = u.at ?? i, V = h.byteLength;\n                return i = p + V, await t.write(h, {\n                    at: p\n                });\n            },\n            truncate: async (c)=>{\n                if (n) throw Error(\"Writer is closed\");\n                await t.truncate(c), i > c && (i = c);\n            },\n            flush: async ()=>{\n                if (n) throw Error(\"Writer is closed\");\n                await t.flush();\n            },\n            close: async ()=>{\n                if (n) throw Error(\"Writer is closed\");\n                n = !0, l(this, W, !1), await a();\n            }\n        };\n    }\n    /**\n   * Random access to file\n   */ async createReader() {\n        const [e, t] = await s(this, R).call(this);\n        let a = !1, i = 0;\n        return {\n            read: async (n, c = {})=>{\n                if (a) throw Error(\"Reader is closed\");\n                const u = c.at ?? i, h = await e.read(u, n);\n                return i = u + h.byteLength, h;\n            },\n            getSize: async ()=>{\n                if (a) throw Error(\"Reader is closed\");\n                return await e.getSize();\n            },\n            close: async ()=>{\n                a || (a = !0, await t());\n            }\n        };\n    }\n    async text() {\n        return new TextDecoder().decode(await this.arrayBuffer());\n    }\n    async arrayBuffer() {\n        const e = await d(s(this, f), {\n            create: !1,\n            isFile: !0\n        });\n        return e == null ? new ArrayBuffer(0) : (await e.getFile()).arrayBuffer();\n    }\n    async stream() {\n        const e = await this.getOriginFile();\n        return e == null ? new ReadableStream({\n            pull: (t)=>{\n                t.close();\n            }\n        }) : e.stream();\n    }\n    async getOriginFile() {\n        var e;\n        return (e = await d(s(this, f), {\n            create: !1,\n            isFile: !0\n        })) == null ? void 0 : e.getFile();\n    }\n    async getSize() {\n        const e = await d(s(this, f), {\n            create: !1,\n            isFile: !0\n        });\n        return e == null ? 0 : (await e.getFile()).size;\n    }\n    async exists() {\n        return await d(s(this, f), {\n            create: !1,\n            isFile: !0\n        }) instanceof FileSystemFileHandle;\n    }\n    async remove() {\n        if (s(this, m)) throw Error(\"exists unclosed reader/writer\");\n        await N(s(this, f));\n    }\n    async copyTo(e) {\n        if (e instanceof H) return e.path === this.path ? this : (await J(e.path, this), y(e.path));\n        if (e instanceof v) {\n            if (!await this.exists()) throw Error(`file ${this.path} not exists`);\n            return await this.copyTo(y(x(e.path, this.name)));\n        } else if (e instanceof FileSystemFileHandle) return await (await this.stream()).pipeTo(await e.createWritable()), null;\n        throw Error(\"Illegal target type\");\n    }\n    /**\n   * move file, copy then remove current\n   */ async moveTo(e) {\n        const t = await this.copyTo(e);\n        return await this.remove(), t;\n    }\n};\nf = new WeakMap(), Z = new WeakMap(), G = new WeakMap(), Y = new WeakMap(), X = new WeakMap(), m = new WeakMap(), R = new WeakMap(), W = new WeakMap();\nlet F = H;\nconst E = \"/.opfs-tools-temp-dir\";\nasync function B(r) {\n    try {\n        if (r.kind === \"file\") {\n            if (!await r.exists()) return !0;\n            const e = await r.createWriter();\n            await e.truncate(0), await e.close(), await r.remove();\n        } else await r.remove();\n        return !0;\n    } catch (e) {\n        return console.warn(e), !1;\n    }\n}\nfunction q() {\n    setInterval(async ()=>{\n        for (const e of (await b(E).children())){\n            const t = /^\\d+-(\\d+)$/.exec(e.name);\n            (t == null || Date.now() - Number(t[1]) > 2592e5) && await B(e);\n        }\n    }, 60000);\n}\nconst L = [];\nlet j = !1;\nasync function ee() {\n    if (globalThis.localStorage == null) return;\n    const r = \"OPFS_TOOLS_EXPIRES_TMP_FILES\";\n    j || (j = !0, globalThis.addEventListener(\"unload\", ()=>{\n        L.length !== 0 && localStorage.setItem(r, `${localStorage.getItem(r) ?? \"\"},${L.join(\",\")}`);\n    }));\n    let e = localStorage.getItem(r) ?? \"\";\n    for (const t of e.split(\",\"))t.length !== 0 && await B(y(`${E}/${t}`)) && (e = e.replace(t, \"\"));\n    localStorage.setItem(r, e.replace(/,{2,}/g, \",\"));\n}\n(async function() {\n    var e;\n    globalThis.__opfs_tools_tmpfile_init__ !== !0 && (globalThis.__opfs_tools_tmpfile_init__ = !0, !(globalThis.FileSystemDirectoryHandle == null || globalThis.FileSystemFileHandle == null || ((e = globalThis.navigator) == null ? void 0 : e.storage.getDirectory) == null) && (q(), await ee()));\n})();\nfunction re() {\n    const r = `${Math.random().toString().slice(2)}-${Date.now()}`;\n    return L.push(r), y(`${E}/${r}`);\n}\nfunction ae(r, e) {\n    let t = y(r), a = 0, i = t.createWriter(), n = t.createReader();\n    const c = async (u)=>{\n        const p = await (await n).read(a, {\n            at: Math.round(a * 0.3)\n        });\n        a = await u.write(p, {\n            at: 0\n        }), await u.truncate(a);\n    };\n    return {\n        append: async (u)=>{\n            const h = await i;\n            a += await h.write(u), a >= e && await c(h);\n        },\n        text: t.text.bind(t),\n        remove: async ()=>{\n            await (await n).close(), await (await i).close(), await t.remove();\n        },\n        getSize: async ()=>a\n    };\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}]},[\"3MqzM\"], \"3MqzM\", \"parcelRequire4dc0\", {})\nlet {default: _default, } = parcelRequire4dc0(\"3MqzM\");\nexport {_default as default, };\n\n//# sourceMappingURL=index.js.map\n","import { MP4Clip, Combinator } from '@webav/av-cliper';\n\nexport default function artplayerProxyWebAV(opt = {}) {\n    return (art) => {\n        const { option, constructor } = art;\n        const { createElement, def } = constructor.utils;\n\n        const canvas = createElement('canvas');\n        const ctx = canvas.getContext('2d');\n\n        let audioCtx;\n        let gainNode;\n\n        let clip = null;\n        let audioSource = null;\n        let intervalId = null;\n        let seekTarget = null;\n        let lastSeekTime = 0;\n\n        const state = {\n            playing: false,\n            duration: 0,\n            videoWidth: 0,\n            videoHeight: 0,\n            currentTime: 0,\n            playbackRate: 1,\n            paused: true,\n            ended: false,\n            readyState: 0,\n            buffered: 0,\n            muted: option.muted,\n            volume: option.volume,\n            autoplay: option.autoplay,\n        };\n\n        function reset() {\n            Object.assign(state, {\n                playing: false,\n                duration: 0,\n                videoWidth: 0,\n                videoHeight: 0,\n                currentTime: 0,\n                playbackRate: 1,\n                paused: true,\n                ended: false,\n                readyState: 0,\n                buffered: 0,\n                muted: option.muted,\n                volume: option.volume,\n                autoplay: option.autoplay,\n            });\n        }\n\n        function stop() {\n            if (intervalId) {\n                clearInterval(intervalId);\n                intervalId = null;\n            }\n            if (audioSource) {\n                audioSource.stop();\n                audioSource = null;\n            }\n        }\n\n        function updateVolume() {\n            if (gainNode) {\n                const effectiveVolume = state.muted ? 0 : state.volume;\n                gainNode.gain.setValueAtTime(effectiveVolume, audioCtx.currentTime);\n            }\n        }\n\n        async function play() {\n            if (!audioCtx) {\n                audioCtx = new AudioContext();\n                gainNode = audioCtx.createGain();\n                gainNode.connect(audioCtx.destination);\n            }\n\n            let curTime = state.currentTime * 1e6;\n            let startAt = 0;\n            let first = true;\n            let lastFrameTime = performance.now();\n\n            stop();\n            updateVolume();\n\n            async function frameHandler() {\n                if (!state.playing) return;\n\n                const currentFrameTime = performance.now();\n                const deltaTime = currentFrameTime - lastFrameTime;\n                lastFrameTime = currentFrameTime;\n\n                if (seekTarget !== null) {\n                    curTime = seekTarget * 1e6;\n                    seekTarget = null;\n                    first = true;\n                } else {\n                    curTime += deltaTime * 1000 * state.playbackRate;\n                }\n\n                state.currentTime = curTime / 1e6;\n\n                const { state: clipState, video, audio } = await clip.tick(Math.round(curTime));\n\n                art.emit('video:timeupdate', { type: 'timeupdate' });\n\n                if (clipState === 'done') {\n                    stop();\n                    state.ended = true;\n                    state.playing = false;\n                    state.paused = true;\n                    art.emit('video:ended', { type: 'ended' });\n                    return;\n                }\n\n                if (video && clipState === 'success') {\n                    ctx.clearRect(0, 0, state.videoWidth, state.videoHeight);\n                    ctx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);\n                    video.close();\n                }\n\n                if (first) {\n                    first = false;\n                } else if (audio?.[0]?.length) {\n                    const buf = audioCtx.createBuffer(2, audio[0].length, 48000);\n                    buf.copyToChannel(audio[0], 0);\n                    buf.copyToChannel(audio[1], 1);\n                    audioSource = audioCtx.createBufferSource();\n                    audioSource.buffer = buf;\n                    audioSource.connect(gainNode);\n                    audioSource.playbackRate.setValueAtTime(state.playbackRate, audioCtx.currentTime);\n                    startAt = Math.max(audioCtx.currentTime, startAt);\n                    audioSource.start(startAt);\n                    startAt += buf.duration / state.playbackRate;\n                }\n            }\n\n            state.playing = true;\n            state.paused = false;\n            intervalId = setInterval(frameHandler, 1000 / 60); // 约60fps\n        }\n\n        async function preview(time) {\n            const { video } = await clip.tick(time * 1e6);\n            if (video) {\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n                video.close();\n            }\n        }\n\n        function resize() {\n            const player = art.template?.$player;\n            if (!player || option.autoSize) return;\n\n            const aspectRatio = canvas.videoWidth / canvas.videoHeight;\n            const containerWidth = player.clientWidth;\n            const containerHeight = player.clientHeight;\n            const containerRatio = containerWidth / containerHeight;\n\n            let paddingLeft = 0;\n            let paddingTop = 0;\n\n            if (containerRatio > aspectRatio) {\n                const canvasWidth = containerHeight * aspectRatio;\n                paddingLeft = (containerWidth - canvasWidth) / 2;\n            } else {\n                const canvasHeight = containerWidth / aspectRatio;\n                paddingTop = (containerHeight - canvasHeight) / 2;\n            }\n\n            Object.assign(canvas.style, {\n                padding: `${paddingTop}px ${paddingLeft}px`,\n            });\n        }\n\n        async function init() {\n            const isSupported = await Combinator.isSupported();\n\n            if (!isSupported) {\n                art.notice.show = 'WebAV is not supported';\n                throw new Error('WebAV is not supported');\n            }\n\n            stop();\n            reset();\n\n            if (clip) {\n                clip.destroy();\n                art.emit('video:abort', { type: 'abort' });\n                art.emit('video:emptied', { type: 'emptied' });\n            }\n\n            try {\n                await Promise.resolve();\n                state.readyState = 1;\n                art.emit('video:loadstart', { type: 'loadstart' });\n                const response = await fetch(option.url);\n\n                if (!response.body) {\n                    throw new Error('No response body');\n                }\n\n                clip = new MP4Clip(response.body, opt);\n            } catch (error) {\n                state.readyState = 0;\n                art.emit('video:error', error);\n                throw error;\n            }\n\n            const info = await clip.ready;\n\n            Object.assign(state, {\n                readyState: 4,\n                duration: Math.round(info.duration / 1e6),\n                videoWidth: info.width,\n                videoHeight: info.height,\n            });\n\n            canvas.width = state.videoWidth;\n            canvas.height = state.videoHeight;\n            await preview(0.1);\n            resize();\n\n            art.emit('video:loadedmetadata', { type: 'loadedmetadata' });\n            art.emit('video:durationchange', { type: 'durationchange' });\n            art.emit('video:loadeddata', { type: 'loadeddata' });\n            art.emit('video:canplay', { type: 'canplay' });\n            art.emit('video:canplaythrough', { type: 'canplaythrough' });\n        }\n\n        def(canvas, 'duration', {\n            get: () => state.duration,\n        });\n\n        def(canvas, 'videoWidth', {\n            get: () => state.videoWidth,\n        });\n\n        def(canvas, 'videoHeight', {\n            get: () => state.videoHeight,\n        });\n\n        def(canvas, 'volume', {\n            get: () => state.volume,\n            set: (val) => {\n                state.volume = Math.max(0, Math.min(1, val));\n                updateVolume();\n                art.emit('video:volumechange', { type: 'volumechange' });\n            },\n        });\n\n        def(canvas, 'currentTime', {\n            get: () => state.currentTime,\n            set: (val) => {\n                if (state.readyState < 4) return;\n                const newTime = Math.max(0, Math.min(val, state.duration));\n                const now = performance.now();\n                if (now - lastSeekTime > 16) {\n                    lastSeekTime = now;\n                    seekTarget = newTime;\n                    state.currentTime = newTime;\n                    if (!state.playing) {\n                        preview(newTime);\n                    }\n                    art.emit('video:timeupdate', { type: 'timeupdate' });\n                }\n            },\n        });\n\n        def(canvas, 'autoplay', {\n            get: () => state.autoplay,\n            set: (val) => {\n                state.autoplay = val;\n                if (val && state.readyState >= 4) {\n                    canvas.play();\n                }\n            },\n        });\n\n        def(canvas, 'src', {\n            get: () => option.url,\n            set: (val) => {\n                option.url = val;\n                init().then(() => {\n                    if (option.autoplay) {\n                        canvas.play();\n                    }\n                });\n            },\n        });\n\n        def(canvas, 'playbackRate', {\n            get: () => state.playbackRate,\n            set: (val) => {\n                state.playbackRate = Math.max(0.25, Math.min(2, val));\n                if (audioSource) {\n                    audioSource.playbackRate.setValueAtTime(state.playbackRate, audioCtx.currentTime);\n                }\n                art.emit('video:ratechange', { type: 'ratechange' });\n            },\n        });\n\n        def(canvas, 'playing', {\n            get: () => state.playing,\n        });\n\n        def(canvas, 'paused', {\n            get: () => state.paused,\n        });\n\n        def(canvas, 'ended', {\n            get: () => state.ended,\n        });\n\n        def(canvas, 'readyState', {\n            get: () => state.readyState,\n        });\n\n        def(canvas, 'muted', {\n            get: () => state.muted,\n            set: (val) => {\n                state.muted = val;\n                updateVolume();\n                art.emit('video:volumechange', { type: 'volumechange' });\n            },\n        });\n\n        def(canvas, 'buffered', {\n            get: () => ({\n                start: () => 0,\n                end: () => state.buffered,\n                length: 1,\n            }),\n        });\n\n        def(canvas, 'play', {\n            value: async () => {\n                if (state.readyState < 4) return false;\n                await play();\n                art.emit('video:play', { type: 'play' });\n                art.emit('video:playing', { type: 'playing' });\n                return true;\n            },\n        });\n\n        def(canvas, 'pause', {\n            value: () => {\n                stop();\n                state.playing = false;\n                state.paused = true;\n                art.emit('video:pause', { type: 'pause' });\n            },\n        });\n\n        art.on('destroy', () => {\n            stop();\n            if (clip) {\n                clip.destroy();\n            }\n        });\n\n        art.on('resize', resize);\n\n        return canvas;\n    };\n}\n\nif (typeof window !== 'undefined') {\n    window['artplayerProxyWebAV'] = artplayerProxyWebAV;\n}\n","var vi = Object.defineProperty;\nvar Je = (s) => {\n  throw TypeError(s);\n};\nvar Si = (s, t, e) => t in s ? vi(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar S = (s, t, e) => Si(s, typeof t != \"symbol\" ? t + \"\" : t, e), Fe = (s, t, e) => t.has(s) || Je(\"Cannot \" + e);\nvar n = (s, t, e) => (Fe(s, t, \"read from private field\"), e ? e.call(s) : t.get(s)), d = (s, t, e) => t.has(s) ? Je(\"Cannot add the same private member more than once\") : t instanceof WeakSet ? t.add(s) : t.set(s, e), h = (s, t, e, i) => (Fe(s, t, \"write to private field\"), i ? i.call(s, e) : t.set(s, e), e), B = (s, t, e) => (Fe(s, t, \"access private method\"), e);\nimport wt from \"@webav/mp4box.js\";\nimport { workerTimer as Ti, Log as A, autoReadStream as ze, file2stream as oi, EventTool as Ve, recodemux as Ai } from \"@webav/internal-utils\";\nimport { Log as Bn } from \"@webav/internal-utils\";\nimport * as ki from \"wave-resampler\";\nimport { tmpfile as Ee, write as Pe } from \"opfs-tools\";\nfunction Ii(s) {\n  return document.createElement(s);\n}\nfunction Fi(s, t) {\n  const e = Ii(\"pre\");\n  e.style.cssText = `margin: 0; ${t}; visibility: hidden; position: fixed;`, e.textContent = s, document.body.appendChild(e);\n  const { width: i, height: r } = e.getBoundingClientRect();\n  e.remove(), e.style.visibility = \"visible\";\n  const a = new Image();\n  a.width = i, a.height = r;\n  const o = `\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${i}\" height=\"${r}\">\n    <foreignObject width=\"100%\" height=\"100%\">\n        <div xmlns=\"http://www.w3.org/1999/xhtml\">${e.outerHTML}</div>\n    </foreignObject>\n    </svg>\n  `.replace(/\\t/g, \"\").replace(/#/g, \"%23\");\n  return a.src = `data:image/svg+xml;charset=utf-8,${o}`, a;\n}\nasync function kn(s, t) {\n  const e = Fi(s, t);\n  await new Promise((a) => {\n    e.onload = a;\n  });\n  const i = new OffscreenCanvas(e.width, e.height), r = i.getContext(\"2d\");\n  return r == null || r.drawImage(e, 0, 0, e.width, e.height), await createImageBitmap(i);\n}\nfunction Ri(s) {\n  const t = new Float32Array(\n    s.map((i) => i.length).reduce((i, r) => i + r)\n  );\n  let e = 0;\n  for (const i of s)\n    t.set(i, e), e += i.length;\n  return t;\n}\nfunction Ei(s) {\n  const t = [];\n  for (let e = 0; e < s.length; e += 1)\n    for (let i = 0; i < s[e].length; i += 1)\n      t[i] == null && (t[i] = []), t[i].push(s[e][i]);\n  return t.map(Ri);\n}\nfunction ci(s) {\n  if (s.format === \"f32-planar\") {\n    const t = [];\n    for (let e = 0; e < s.numberOfChannels; e += 1) {\n      const i = s.allocationSize({ planeIndex: e }), r = new ArrayBuffer(i);\n      s.copyTo(r, { planeIndex: e }), t.push(new Float32Array(r));\n    }\n    return t;\n  } else if (s.format === \"f32\") {\n    const t = new ArrayBuffer(s.allocationSize({ planeIndex: 0 }));\n    return s.copyTo(t, { planeIndex: 0 }), Di(new Float32Array(t), s.numberOfChannels);\n  } else if (s.format === \"s16\") {\n    const t = new ArrayBuffer(s.allocationSize({ planeIndex: 0 }));\n    return s.copyTo(t, { planeIndex: 0 }), Pi(new Int16Array(t), s.numberOfChannels);\n  }\n  throw Error(\"Unsupported audio data format\");\n}\nfunction Pi(s, t) {\n  const e = s.length / t, i = Array.from(\n    { length: t },\n    () => new Float32Array(e)\n  );\n  for (let r = 0; r < e; r++)\n    for (let a = 0; a < t; a++) {\n      const o = s[r * t + a];\n      i[a][r] = o / 32768;\n    }\n  return i;\n}\nfunction Di(s, t) {\n  const e = s.length / t, i = Array.from(\n    { length: t },\n    () => new Float32Array(e)\n  );\n  for (let r = 0; r < e; r++)\n    for (let a = 0; a < t; a++)\n      i[a][r] = s[r * t + a];\n  return i;\n}\nfunction Le(s) {\n  return Array(s.numberOfChannels).fill(0).map((t, e) => s.getChannelData(e));\n}\nasync function Bi(s, t) {\n  var o;\n  const e = {\n    type: t,\n    data: s\n  }, i = new ImageDecoder(e);\n  await Promise.all([i.completed, i.tracks.ready]);\n  let r = ((o = i.tracks.selectedTrack) == null ? void 0 : o.frameCount) ?? 1;\n  const a = [];\n  for (let c = 0; c < r; c += 1)\n    a.push((await i.decode({ frameIndex: c })).image);\n  return a;\n}\nfunction Ye(s) {\n  var i, r;\n  const t = Math.max(...s.map((a) => {\n    var o;\n    return ((o = a[0]) == null ? void 0 : o.length) ?? 0;\n  })), e = new Float32Array(t * 2);\n  for (let a = 0; a < t; a++) {\n    let o = 0, c = 0;\n    for (let l = 0; l < s.length; l++) {\n      const m = ((i = s[l][0]) == null ? void 0 : i[a]) ?? 0, u = ((r = s[l][1]) == null ? void 0 : r[a]) ?? m;\n      o += m, c += u;\n    }\n    e[a] = o, e[a + t] = c;\n  }\n  return e;\n}\nasync function _i(s, t, e) {\n  const i = s.length, r = Array(e.chanCount).fill(0).map(() => new Float32Array(0));\n  if (i === 0) return r;\n  const a = Math.max(...s.map((m) => m.length));\n  if (a === 0) return r;\n  if (globalThis.OfflineAudioContext == null)\n    return s.map(\n      (m) => new Float32Array(\n        ki.resample(m, t, e.rate, {\n          method: \"sinc\",\n          LPF: !1\n        })\n      )\n    );\n  const o = new globalThis.OfflineAudioContext(\n    e.chanCount,\n    a * e.rate / t,\n    e.rate\n  ), c = o.createBufferSource(), l = o.createBuffer(i, a, t);\n  return s.forEach((m, u) => l.copyToChannel(m, u)), c.buffer = l, c.connect(o.destination), c.start(), Le(await o.startRendering());\n}\nfunction Ue(s) {\n  return new Promise((t) => {\n    const e = Ti(() => {\n      e(), t();\n    }, s);\n  });\n}\nfunction De(s, t, e) {\n  const i = e - t, r = new Float32Array(i);\n  let a = 0;\n  for (; a < i; )\n    r[a] = s[(t + a) % s.length], a += 1;\n  return r;\n}\nfunction li(s, t) {\n  const e = Math.floor(s.length / t), i = new Float32Array(e);\n  for (let r = 0; r < e; r++) {\n    const a = r * t, o = Math.floor(a), c = a - o;\n    o + 1 < s.length ? i[r] = s[o] * (1 - c) + s[o + 1] * c : i[r] = s[o];\n  }\n  return i;\n}\nconst T = {\n  sampleRate: 48e3,\n  channelCount: 2,\n  codec: \"mp4a.40.2\"\n};\nfunction Ne(s, t) {\n  const e = t.videoTracks[0], i = {};\n  if (e != null) {\n    const a = Oi(s.getTrackById(e.id)).buffer, { descKey: o, type: c } = e.codec.startsWith(\"avc1\") ? { descKey: \"avcDecoderConfigRecord\", type: \"avc1\" } : e.codec.startsWith(\"hvc1\") ? { descKey: \"hevcDecoderConfigRecord\", type: \"hvc1\" } : { descKey: \"\", type: \"\" };\n    o !== \"\" && (i.videoTrackConf = {\n      timescale: e.timescale,\n      duration: e.duration,\n      width: e.video.width,\n      height: e.video.height,\n      brands: t.brands,\n      type: c,\n      [o]: a\n    }), i.videoDecoderConf = {\n      codec: e.codec,\n      codedHeight: e.video.height,\n      codedWidth: e.video.width,\n      description: a\n    };\n  }\n  const r = t.audioTracks[0];\n  if (r != null) {\n    const a = je(s);\n    i.audioTrackConf = {\n      timescale: r.timescale,\n      samplerate: r.audio.sample_rate,\n      channel_count: r.audio.channel_count,\n      hdlr: \"soun\",\n      type: r.codec.startsWith(\"mp4a\") ? \"mp4a\" : r.codec,\n      description: je(s)\n    }, i.audioDecoderConf = {\n      codec: r.codec.startsWith(\"mp4a\") ? T.codec : r.codec,\n      numberOfChannels: r.audio.channel_count,\n      sampleRate: r.audio.sample_rate,\n      ...a == null ? {} : Mi(a)\n    };\n  }\n  return i;\n}\nfunction Oi(s) {\n  for (const t of s.mdia.minf.stbl.stsd.entries) {\n    const e = t.avcC ?? t.hvcC ?? t.av1C ?? t.vpcC;\n    if (e != null) {\n      const i = new wt.DataStream(\n        void 0,\n        0,\n        wt.DataStream.BIG_ENDIAN\n      );\n      return e.write(i), new Uint8Array(i.buffer.slice(8));\n    }\n  }\n  throw Error(\"avcC, hvcC, av1C or VPX not found\");\n}\nfunction je(s, t = \"mp4a\") {\n  var i;\n  const e = (i = s.moov) == null ? void 0 : i.traks.map((r) => r.mdia.minf.stbl.stsd.entries).flat().find(({ type: r }) => r === t);\n  return e == null ? void 0 : e.esds;\n}\nfunction Mi(s) {\n  var c;\n  const t = (c = s.esd.descs[0]) == null ? void 0 : c.descs[0];\n  if (t == null) return {};\n  const [e, i] = t.data, r = ((e & 7) << 1) + (i >> 7), a = (i & 127) >> 3;\n  return {\n    sampleRate: [\n      96e3,\n      88200,\n      64e3,\n      48e3,\n      44100,\n      32e3,\n      24e3,\n      22050,\n      16e3,\n      12e3,\n      11025,\n      8e3,\n      7350\n    ][r],\n    numberOfChannels: a\n  };\n}\nasync function zi(s, t, e) {\n  const i = wt.createFile(!1);\n  i.onReady = (a) => {\n    var l, m;\n    t({ mp4boxFile: i, info: a });\n    const o = (l = a.videoTracks[0]) == null ? void 0 : l.id;\n    o != null && i.setExtractionOptions(o, \"video\", { nbSamples: 100 });\n    const c = (m = a.audioTracks[0]) == null ? void 0 : m.id;\n    c != null && i.setExtractionOptions(c, \"audio\", { nbSamples: 100 }), i.start();\n  }, i.onSamples = e, await r();\n  async function r() {\n    let a = 0;\n    const o = 30 * 1024 * 1024;\n    for (; ; ) {\n      const c = await s.read(o, {\n        at: a\n      });\n      if (c.byteLength === 0) break;\n      c.fileStart = a;\n      const l = i.appendBuffer(c);\n      if (l == null) break;\n      a = l;\n    }\n    i.stop();\n  }\n}\nlet He = 0;\nfunction Re(s) {\n  return s.kind === \"file\" && s.createReader instanceof Function;\n}\nvar Ce, Jt, Yt, V, R, $, jt, L, rt, _t, bt, W, D, Ot;\nconst yt = class yt {\n  constructor(t, e = {}) {\n    d(this, Ce, He++);\n    d(this, Jt, A.create(`MP4Clip id:${n(this, Ce)},`));\n    S(this, \"ready\");\n    d(this, Yt, !1);\n    d(this, V, {\n      // 微秒\n      duration: 0,\n      width: 0,\n      height: 0,\n      audioSampleRate: 0,\n      audioChanCount: 0\n    });\n    d(this, R);\n    d(this, $, []);\n    d(this, jt, 1);\n    d(this, L, []);\n    d(this, rt, []);\n    d(this, _t, null);\n    d(this, bt, null);\n    d(this, W, {\n      video: null,\n      audio: null\n    });\n    d(this, D, { audio: !0 });\n    /**\n     * 拦截 {@link MP4Clip.tick} 方法返回的数据，用于对图像、音频数据二次处理\n     * @param time 调用 tick 的时间\n     * @param tickRet tick 返回的数据\n     *\n     * @see [移除视频绿幕背景](https://webav-tech.github.io/WebAV/demo/3_2-chromakey-video)\n     */\n    S(this, \"tickInterceptor\", async (t, e) => e);\n    d(this, Ot, new AbortController());\n    if (!(t instanceof ReadableStream) && !Re(t) && !Array.isArray(t.videoSamples))\n      throw Error(\"Illegal argument\");\n    h(this, D, { audio: !0, ...e }), h(this, jt, typeof e.audio == \"object\" && \"volume\" in e.audio ? e.audio.volume : 1);\n    const i = async (r) => (await Pe(n(this, R), r), n(this, R));\n    h(this, R, Re(t) ? t : \"localFile\" in t ? t.localFile : Ee()), this.ready = (t instanceof ReadableStream ? i(t).then(\n      (r) => Ke(r, n(this, D))\n    ) : Re(t) ? Ke(t, n(this, D)) : Promise.resolve(t)).then(\n      async ({ videoSamples: r, audioSamples: a, decoderConf: o, headerBoxPos: c }) => {\n        h(this, L, r), h(this, rt, a), h(this, W, o), h(this, $, c);\n        const { videoFrameFinder: l, audioFrameFinder: m } = Li(\n          {\n            video: o.video == null ? null : {\n              ...o.video,\n              hardwareAcceleration: n(this, D).__unsafe_hardwareAcceleration__\n            },\n            audio: o.audio\n          },\n          await n(this, R).createReader(),\n          r,\n          a,\n          n(this, D).audio !== !1 ? n(this, jt) : 0\n        );\n        return h(this, _t, l), h(this, bt, m), h(this, V, Vi(o, r, a)), n(this, Jt).info(\"MP4Clip meta:\", n(this, V)), { ...n(this, V) };\n      }\n    );\n  }\n  get meta() {\n    return { ...n(this, V) };\n  }\n  /**\n   * 提供视频头（box: ftyp, moov）的二进制数据\n   * 使用任意 mp4 demxer 解析即可获得详细的视频信息\n   * 单元测试包含使用 mp4box.js 解析示例代码\n   */\n  async getFileHeaderBinData() {\n    await this.ready;\n    const t = await n(this, R).getOriginFile();\n    if (t == null) throw Error(\"MP4Clip localFile is not origin file\");\n    return await new Blob(\n      n(this, $).map(\n        ({ start: e, size: i }) => t.slice(e, e + i)\n      )\n    ).arrayBuffer();\n  }\n  /**\n   * 获取素材指定时刻的图像帧、音频数据\n   * @param time 微秒\n   */\n  async tick(t) {\n    var r, a, o;\n    if (t >= n(this, V).duration)\n      return await this.tickInterceptor(t, {\n        audio: await ((r = n(this, bt)) == null ? void 0 : r.find(t)) ?? [],\n        state: \"done\"\n      });\n    const [e, i] = await Promise.all([\n      ((a = n(this, bt)) == null ? void 0 : a.find(t)) ?? [],\n      (o = n(this, _t)) == null ? void 0 : o.find(t)\n    ]);\n    return i == null ? await this.tickInterceptor(t, {\n      audio: e,\n      state: \"success\"\n    }) : await this.tickInterceptor(t, {\n      video: i,\n      audio: e,\n      state: \"success\"\n    });\n  }\n  /**\n   * 生成缩略图，默认每个关键帧生成一个 100px 宽度的缩略图。\n   *\n   * @param imgWidth 缩略图宽度，默认 100\n   * @param opts Partial<ThumbnailOpts>\n   * @returns Promise<Array<{ ts: number; img: Blob }>>\n   */\n  async thumbnails(t = 100, e) {\n    n(this, Ot).abort(), h(this, Ot, new AbortController());\n    const i = n(this, Ot).signal;\n    await this.ready;\n    const r = \"generate thumbnails aborted\";\n    if (i.aborted) throw Error(r);\n    const { width: a, height: o } = n(this, V), c = Wi(\n      t,\n      Math.round(o * (t / a)),\n      { quality: 0.1, type: \"image/png\" }\n    );\n    return new Promise(\n      async (l, m) => {\n        let u = [];\n        const w = n(this, W).video;\n        if (w == null || n(this, L).length === 0) {\n          p();\n          return;\n        }\n        i.addEventListener(\"abort\", () => {\n          m(Error(r));\n        });\n        async function p() {\n          i.aborted || l(\n            await Promise.all(\n              u.map(async (b) => ({\n                ts: b.ts,\n                img: await b.img\n              }))\n            )\n          );\n        }\n        function x(b) {\n          u.push({\n            ts: b.timestamp,\n            img: c(b)\n          });\n        }\n        const { start: f = 0, end: y = n(this, V).duration, step: g } = e ?? {};\n        if (g) {\n          let b = f;\n          const C = new hi(\n            await n(this, R).createReader(),\n            n(this, L),\n            {\n              ...w,\n              hardwareAcceleration: n(this, D).__unsafe_hardwareAcceleration__\n            }\n          );\n          for (; b <= y && !i.aborted; ) {\n            const v = await C.find(b);\n            v && x(v), b += g;\n          }\n          C.destroy(), p();\n        } else\n          await Yi(\n            n(this, L),\n            n(this, R),\n            w,\n            i,\n            { start: f, end: y },\n            (b, C) => {\n              b != null && x(b), C && p();\n            }\n          );\n      }\n    );\n  }\n  async split(t) {\n    if (await this.ready, t <= 0 || t >= n(this, V).duration)\n      throw Error('\"time\" out of bounds');\n    const [e, i] = Xi(\n      n(this, L),\n      t\n    ), [r, a] = Gi(\n      n(this, rt),\n      t\n    ), o = new yt(\n      {\n        localFile: n(this, R),\n        videoSamples: e ?? [],\n        audioSamples: r ?? [],\n        decoderConf: n(this, W),\n        headerBoxPos: n(this, $)\n      },\n      n(this, D)\n    ), c = new yt(\n      {\n        localFile: n(this, R),\n        videoSamples: i ?? [],\n        audioSamples: a ?? [],\n        decoderConf: n(this, W),\n        headerBoxPos: n(this, $)\n      },\n      n(this, D)\n    );\n    return await Promise.all([o.ready, c.ready]), [o, c];\n  }\n  async clone() {\n    await this.ready;\n    const t = new yt(\n      {\n        localFile: n(this, R),\n        videoSamples: [...n(this, L)],\n        audioSamples: [...n(this, rt)],\n        decoderConf: n(this, W),\n        headerBoxPos: n(this, $)\n      },\n      n(this, D)\n    );\n    return await t.ready, t.tickInterceptor = this.tickInterceptor, t;\n  }\n  /**\n   * 拆分 MP4Clip 为仅包含视频轨道和音频轨道的 MP4Clip\n   * @returns Mp4CLip[]\n   */\n  async splitTrack() {\n    await this.ready;\n    const t = [];\n    if (n(this, L).length > 0) {\n      const e = new yt(\n        {\n          localFile: n(this, R),\n          videoSamples: [...n(this, L)],\n          audioSamples: [],\n          decoderConf: {\n            video: n(this, W).video,\n            audio: null\n          },\n          headerBoxPos: n(this, $)\n        },\n        n(this, D)\n      );\n      await e.ready, e.tickInterceptor = this.tickInterceptor, t.push(e);\n    }\n    if (n(this, rt).length > 0) {\n      const e = new yt(\n        {\n          localFile: n(this, R),\n          videoSamples: [],\n          audioSamples: [...n(this, rt)],\n          decoderConf: {\n            audio: n(this, W).audio,\n            video: null\n          },\n          headerBoxPos: n(this, $)\n        },\n        n(this, D)\n      );\n      await e.ready, e.tickInterceptor = this.tickInterceptor, t.push(e);\n    }\n    return t;\n  }\n  destroy() {\n    var t, e;\n    n(this, Yt) || (n(this, Jt).info(\"MP4Clip destroy\"), h(this, Yt, !0), (t = n(this, _t)) == null || t.destroy(), (e = n(this, bt)) == null || e.destroy());\n  }\n};\nCe = new WeakMap(), Jt = new WeakMap(), Yt = new WeakMap(), V = new WeakMap(), R = new WeakMap(), $ = new WeakMap(), jt = new WeakMap(), L = new WeakMap(), rt = new WeakMap(), _t = new WeakMap(), bt = new WeakMap(), W = new WeakMap(), D = new WeakMap(), Ot = new WeakMap();\nlet Qe = yt;\nfunction Vi(s, t, e) {\n  const i = {\n    duration: 0,\n    width: 0,\n    height: 0,\n    audioSampleRate: 0,\n    audioChanCount: 0\n  };\n  s.video != null && t.length > 0 && (i.width = s.video.codedWidth ?? 0, i.height = s.video.codedHeight ?? 0), s.audio != null && e.length > 0 && (i.audioSampleRate = T.sampleRate, i.audioChanCount = T.channelCount);\n  let r = 0, a = 0;\n  if (t.length > 0)\n    for (let o = t.length - 1; o >= 0; o--) {\n      const c = t[o];\n      if (!c.deleted) {\n        r = c.cts + c.duration;\n        break;\n      }\n    }\n  if (e.length > 0) {\n    const o = e.at(-1);\n    a = o.cts + o.duration;\n  }\n  return i.duration = Math.max(r, a), i;\n}\nfunction Li(s, t, e, i, r) {\n  return {\n    audioFrameFinder: r === 0 || s.audio == null || i.length === 0 ? null : new Ni(\n      t,\n      i,\n      s.audio,\n      {\n        volume: r,\n        targetSampleRate: T.sampleRate\n      }\n    ),\n    videoFrameFinder: s.video == null || e.length === 0 ? null : new hi(\n      t,\n      e,\n      s.video\n    )\n  };\n}\nasync function Ke(s, t = {}) {\n  let e = null;\n  const i = { video: null, audio: null };\n  let r = [], a = [], o = [], c = -1, l = -1;\n  const m = await s.createReader();\n  await zi(\n    m,\n    (p) => {\n      e = p.info;\n      const x = p.mp4boxFile.ftyp;\n      o.push({ start: x.start, size: x.size });\n      const f = p.mp4boxFile.moov;\n      o.push({ start: f.start, size: f.size });\n      let { videoDecoderConf: y, audioDecoderConf: g } = Ne(\n        p.mp4boxFile,\n        p.info\n      );\n      i.video = y ?? null, i.audio = g ?? null, y == null && g == null && A.error(\"MP4Clip no video and audio track\"), A.info(\n        \"mp4BoxFile moov ready\",\n        {\n          ...p.info,\n          tracks: null,\n          videoTracks: null,\n          audioTracks: null\n        },\n        i\n      );\n    },\n    (p, x, f) => {\n      if (x === \"video\") {\n        c === -1 && (c = f[0].dts);\n        for (const y of f)\n          r.push(w(y, c, \"video\"));\n      } else if (x === \"audio\" && t.audio) {\n        l === -1 && (l = f[0].dts);\n        for (const y of f)\n          a.push(w(y, l, \"audio\"));\n      }\n    }\n  ), await m.close();\n  const u = r.at(-1) ?? a.at(-1);\n  if (e == null)\n    throw Error(\"MP4Clip stream is done, but not emit ready\");\n  if (u == null)\n    throw Error(\"MP4Clip stream not contain any sample\");\n  return _e(r), A.info(\"mp4 stream parsed\"), {\n    videoSamples: r,\n    audioSamples: a,\n    decoderConf: i,\n    headerBoxPos: o\n  };\n  function w(p, x = 0, f) {\n    const y = f === \"video\" && p.is_sync ? Ji(p.data, p.description.type) : -1;\n    let g = p.offset, b = p.size;\n    return y >= 0 && (g += y, b -= y), {\n      ...p,\n      is_idr: y >= 0,\n      offset: g,\n      size: b,\n      cts: (p.cts - x) / p.timescale * 1e6,\n      dts: (p.dts - x) / p.timescale * 1e6,\n      duration: p.duration / p.timescale * 1e6,\n      timescale: 1e6,\n      // 音频数据量可控，直接保存在内存中\n      data: f === \"video\" ? null : p.data\n    };\n  }\n}\nvar F, xt, Ct, Qt, vt, X, _, at, St, Mt, Kt, zt, ot, qt, Tt, Zt;\nclass hi {\n  constructor(t, e, i) {\n    d(this, F, null);\n    d(this, xt, 0);\n    d(this, Ct, { abort: !1, st: performance.now() });\n    S(this, \"find\", async (t) => {\n      (n(this, F) == null || n(this, F).state === \"closed\" || t <= n(this, xt) || t - n(this, xt) > 3e6) && n(this, Tt).call(this, t), n(this, Ct).abort = !0, h(this, xt, t), h(this, Ct, { abort: !1, st: performance.now() });\n      const e = await n(this, zt).call(this, t, n(this, F), n(this, Ct));\n      return h(this, Mt, 0), e;\n    });\n    // fix VideoFrame duration is null\n    d(this, Qt, 0);\n    d(this, vt, !1);\n    d(this, X, 0);\n    d(this, _, []);\n    d(this, at, 0);\n    d(this, St, 0);\n    d(this, Mt, 0);\n    d(this, Kt, !1);\n    d(this, zt, async (t, e, i) => {\n      if (e == null || e.state === \"closed\" || i.abort) return null;\n      if (n(this, _).length > 0) {\n        const r = n(this, _)[0];\n        return t < r.timestamp ? null : (n(this, _).shift(), t > r.timestamp + (r.duration ?? 0) ? (r.close(), await n(this, zt).call(this, t, e, i)) : (!n(this, Kt) && n(this, _).length < 10 && n(this, qt).call(this, e).catch((a) => {\n          throw h(this, Kt, !0), n(this, Tt).call(this, t), a;\n        }), r));\n      }\n      if (n(this, ot) || n(this, at) < n(this, St) && e.decodeQueueSize > 0) {\n        if (performance.now() - i.st > 6e3)\n          throw Error(\n            `MP4Clip.tick video timeout, ${JSON.stringify(n(this, Zt).call(this))}`\n          );\n        h(this, Mt, n(this, Mt) + 1), await Ue(15);\n      } else {\n        if (n(this, X) >= this.samples.length)\n          return null;\n        try {\n          await n(this, qt).call(this, e);\n        } catch (r) {\n          throw n(this, Tt).call(this, t), r;\n        }\n      }\n      return await n(this, zt).call(this, t, e, i);\n    });\n    d(this, ot, !1);\n    d(this, qt, async (t) => {\n      var r, a;\n      if (n(this, ot) || t.decodeQueueSize > 600) return;\n      let e = n(this, X) + 1;\n      if (e > this.samples.length) return;\n      h(this, ot, !0);\n      let i = !1;\n      for (; e < this.samples.length; e++) {\n        const o = this.samples[e];\n        if (!i && !o.deleted && (i = !0), o.is_idr) break;\n      }\n      if (i) {\n        const o = this.samples.slice(n(this, X), e);\n        if (((r = o[0]) == null ? void 0 : r.is_idr) !== !0)\n          A.warn(\"First sample not idr frame\");\n        else {\n          const c = performance.now(), l = await di(o, this.localFileReader), m = performance.now() - c;\n          if (m > 1e3) {\n            const u = o[0], w = o.at(-1), p = w.offset + w.size - u.offset;\n            A.warn(\n              `Read video samples time cost: ${Math.round(m)}ms, file chunk size: ${p}`\n            );\n          }\n          if (t.state === \"closed\") return;\n          h(this, Qt, ((a = l[0]) == null ? void 0 : a.duration) ?? 0), Be(t, l, {\n            onDecodingError: (u) => {\n              if (n(this, vt))\n                throw u;\n              n(this, at) === 0 && (h(this, vt, !0), A.warn(\"Downgrade to software decode\"), n(this, Tt).call(this));\n            }\n          }), h(this, St, n(this, St) + l.length);\n        }\n      }\n      h(this, X, e), h(this, ot, !1);\n    });\n    d(this, Tt, (t) => {\n      var i, r;\n      if (h(this, ot, !1), n(this, _).forEach((a) => a.close()), h(this, _, []), t == null || t === 0)\n        h(this, X, 0);\n      else {\n        let a = 0;\n        for (let o = 0; o < this.samples.length; o++) {\n          const c = this.samples[o];\n          if (c.is_idr && (a = o), !(c.cts < t)) {\n            h(this, X, a);\n            break;\n          }\n        }\n      }\n      h(this, St, 0), h(this, at, 0), ((i = n(this, F)) == null ? void 0 : i.state) !== \"closed\" && ((r = n(this, F)) == null || r.close());\n      const e = {\n        ...this.conf,\n        ...n(this, vt) ? { hardwareAcceleration: \"prefer-software\" } : {}\n      };\n      h(this, F, new VideoDecoder({\n        output: (a) => {\n          if (h(this, at, n(this, at) + 1), a.timestamp === -1) {\n            a.close();\n            return;\n          }\n          let o = a;\n          a.duration == null && (o = new VideoFrame(a, {\n            duration: n(this, Qt)\n          }), a.close()), n(this, _).push(o);\n        },\n        error: (a) => {\n          if (a.message.includes(\"Codec reclaimed due to inactivity\")) {\n            h(this, F, null), A.warn(a.message);\n            return;\n          }\n          const o = `VideoFinder VideoDecoder err: ${a.message}, config: ${JSON.stringify(e)}, state: ${JSON.stringify(n(this, Zt).call(this))}`;\n          throw A.error(o), Error(o);\n        }\n      })), n(this, F).configure(e);\n    });\n    d(this, Zt, () => {\n      var t, e;\n      return {\n        time: n(this, xt),\n        decState: (t = n(this, F)) == null ? void 0 : t.state,\n        decQSize: (e = n(this, F)) == null ? void 0 : e.decodeQueueSize,\n        decCusorIdx: n(this, X),\n        sampleLen: this.samples.length,\n        inputCnt: n(this, St),\n        outputCnt: n(this, at),\n        cacheFrameLen: n(this, _).length,\n        softDeocde: n(this, vt),\n        clipIdCnt: He,\n        sleepCnt: n(this, Mt),\n        memInfo: ui()\n      };\n    });\n    S(this, \"destroy\", () => {\n      var t, e;\n      ((t = n(this, F)) == null ? void 0 : t.state) !== \"closed\" && ((e = n(this, F)) == null || e.close()), h(this, F, null), n(this, Ct).abort = !0, n(this, _).forEach((i) => i.close()), h(this, _, []), this.localFileReader.close();\n    });\n    this.localFileReader = t, this.samples = e, this.conf = i;\n  }\n}\nF = new WeakMap(), xt = new WeakMap(), Ct = new WeakMap(), Qt = new WeakMap(), vt = new WeakMap(), X = new WeakMap(), _ = new WeakMap(), at = new WeakMap(), St = new WeakMap(), Mt = new WeakMap(), Kt = new WeakMap(), zt = new WeakMap(), ot = new WeakMap(), qt = new WeakMap(), Tt = new WeakMap(), Zt = new WeakMap();\nfunction Ui(s, t) {\n  for (let e = 0; e < t.length; e++) {\n    const i = t[e];\n    if (s >= i.cts && s < i.cts + i.duration)\n      return e;\n    if (i.cts > s) break;\n  }\n  return 0;\n}\nvar te, ee, U, At, G, et, M, Vt, ie, ne, ve, Se;\nclass Ni {\n  constructor(t, e, i, r) {\n    d(this, te, 1);\n    d(this, ee);\n    d(this, U, null);\n    d(this, At, { abort: !1, st: performance.now() });\n    S(this, \"find\", async (t) => {\n      const e = t <= n(this, G) || t - n(this, G) > 1e5;\n      (n(this, U) == null || n(this, U).state === \"closed\" || e) && n(this, ve).call(this), e && (h(this, G, t), h(this, et, Ui(t, this.samples))), n(this, At).abort = !0;\n      const i = t - n(this, G);\n      h(this, G, t), h(this, At, { abort: !1, st: performance.now() });\n      const r = await n(this, ie).call(this, Math.ceil(i * (n(this, ee) / 1e6)), n(this, U), n(this, At));\n      return h(this, Vt, 0), r;\n    });\n    d(this, G, 0);\n    d(this, et, 0);\n    d(this, M, {\n      frameCnt: 0,\n      data: []\n    });\n    d(this, Vt, 0);\n    d(this, ie, async (t, e = null, i) => {\n      if (e == null || i.abort || e.state === \"closed\" || t === 0)\n        return [];\n      const r = n(this, M).frameCnt - t;\n      if (r > 0)\n        return r < T.sampleRate / 10 && n(this, ne).call(this, e), qe(n(this, M), t);\n      if (e.decoding) {\n        if (performance.now() - i.st > 3e3)\n          throw i.abort = !0, Error(\n            `MP4Clip.tick audio timeout, ${JSON.stringify(n(this, Se).call(this))}`\n          );\n        h(this, Vt, n(this, Vt) + 1), await Ue(15);\n      } else {\n        if (n(this, et) >= this.samples.length - 1)\n          return qe(n(this, M), n(this, M).frameCnt);\n        n(this, ne).call(this, e);\n      }\n      return n(this, ie).call(this, t, e, i);\n    });\n    d(this, ne, (t) => {\n      if (t.decodeQueueSize > 10) return;\n      const i = [];\n      let r = n(this, et);\n      for (; r < this.samples.length; ) {\n        const a = this.samples[r];\n        if (r += 1, !a.deleted && (i.push(a), i.length >= 10))\n          break;\n      }\n      h(this, et, r), t.decode(\n        i.map(\n          (a) => new EncodedAudioChunk({\n            type: \"key\",\n            timestamp: a.cts,\n            duration: a.duration,\n            data: a.data\n          })\n        )\n      );\n    });\n    d(this, ve, () => {\n      var t;\n      h(this, G, 0), h(this, et, 0), h(this, M, {\n        frameCnt: 0,\n        data: []\n      }), (t = n(this, U)) == null || t.close(), h(this, U, Hi(\n        this.conf,\n        {\n          resampleRate: T.sampleRate,\n          volume: n(this, te)\n        },\n        (e) => {\n          n(this, M).data.push(e), n(this, M).frameCnt += e[0].length;\n        }\n      ));\n    });\n    d(this, Se, () => {\n      var t, e;\n      return {\n        time: n(this, G),\n        decState: (t = n(this, U)) == null ? void 0 : t.state,\n        decQSize: (e = n(this, U)) == null ? void 0 : e.decodeQueueSize,\n        decCusorIdx: n(this, et),\n        sampleLen: this.samples.length,\n        pcmLen: n(this, M).frameCnt,\n        clipIdCnt: He,\n        sleepCnt: n(this, Vt),\n        memInfo: ui()\n      };\n    });\n    S(this, \"destroy\", () => {\n      h(this, U, null), n(this, At).abort = !0, h(this, M, {\n        frameCnt: 0,\n        data: []\n      }), this.localFileReader.close();\n    });\n    this.localFileReader = t, this.samples = e, this.conf = i, h(this, te, r.volume), h(this, ee, r.targetSampleRate);\n  }\n}\nte = new WeakMap(), ee = new WeakMap(), U = new WeakMap(), At = new WeakMap(), G = new WeakMap(), et = new WeakMap(), M = new WeakMap(), Vt = new WeakMap(), ie = new WeakMap(), ne = new WeakMap(), ve = new WeakMap(), Se = new WeakMap();\nfunction Hi(s, t, e) {\n  let i = 0, r = 0;\n  const a = (u) => {\n    if (r += 1, u.length !== 0) {\n      if (t.volume !== 1)\n        for (const w of u)\n          for (let p = 0; p < w.length; p++) w[p] *= t.volume;\n      u.length === 1 && (u = [u[0], u[0]]), e(u);\n    }\n  }, o = $i(a), c = t.resampleRate !== s.sampleRate;\n  let l = new AudioDecoder({\n    output: (u) => {\n      const w = ci(u);\n      c ? o(\n        () => _i(w, u.sampleRate, {\n          rate: t.resampleRate,\n          chanCount: u.numberOfChannels\n        })\n      ) : a(w), u.close();\n    },\n    error: (u) => {\n      u.message.includes(\"Codec reclaimed due to inactivity\") || m(\"MP4Clip AudioDecoder err\", u);\n    }\n  });\n  l.configure(s);\n  function m(u, w) {\n    const p = `${u}: ${w.message}, state: ${JSON.stringify(\n      {\n        qSize: l.decodeQueueSize,\n        state: l.state,\n        inputCnt: i,\n        outputCnt: r\n      }\n    )}`;\n    throw A.error(p), Error(p);\n  }\n  return {\n    decode(u) {\n      i += u.length;\n      try {\n        for (const w of u) l.decode(w);\n      } catch (w) {\n        m(\"decode audio chunk error\", w);\n      }\n    },\n    close() {\n      l.state !== \"closed\" && l.close();\n    },\n    get decoding() {\n      return i > r && l.decodeQueueSize > 0;\n    },\n    get state() {\n      return l.state;\n    },\n    get decodeQueueSize() {\n      return l.decodeQueueSize;\n    }\n  };\n}\nfunction $i(s) {\n  const t = [];\n  let e = 0;\n  function i(o, c) {\n    t[c] = o, r();\n  }\n  function r() {\n    const o = t[e];\n    o != null && (s(o), e += 1, r());\n  }\n  let a = 0;\n  return (o) => {\n    const c = a;\n    a += 1, o().then((l) => i(l, c)).catch((l) => i(l, c));\n  };\n}\nfunction qe(s, t) {\n  const e = [new Float32Array(t), new Float32Array(t)];\n  let i = 0, r = 0;\n  for (; r < s.data.length; ) {\n    const [a, o] = s.data[r];\n    if (i + a.length > t) {\n      const c = t - i;\n      e[0].set(a.subarray(0, c), i), e[1].set(o.subarray(0, c), i), s.data[r][0] = a.subarray(c, a.length), s.data[r][1] = o.subarray(c, o.length);\n      break;\n    } else\n      e[0].set(a, i), e[1].set(o, i), i += a.length, r++;\n  }\n  return s.data = s.data.slice(r), s.frameCnt -= t, e;\n}\nasync function di(s, t) {\n  const e = s[0], i = s.at(-1);\n  if (i == null) return [];\n  const r = i.offset + i.size - e.offset;\n  if (r < 3e7) {\n    const a = new Uint8Array(\n      await t.read(r, { at: e.offset })\n    );\n    return s.map((o) => {\n      const c = o.offset - e.offset;\n      return new EncodedVideoChunk({\n        type: o.is_sync ? \"key\" : \"delta\",\n        timestamp: o.cts,\n        duration: o.duration,\n        data: a.subarray(c, c + o.size)\n      });\n    });\n  }\n  return await Promise.all(\n    s.map(async (a) => new EncodedVideoChunk({\n      type: a.is_sync ? \"key\" : \"delta\",\n      timestamp: a.cts,\n      duration: a.duration,\n      data: await t.read(a.size, {\n        at: a.offset\n      })\n    }))\n  );\n}\nfunction Wi(s, t, e) {\n  const i = new OffscreenCanvas(s, t), r = i.getContext(\"2d\");\n  return async (a) => (r.drawImage(a, 0, 0, s, t), a.close(), await i.convertToBlob(e));\n}\nfunction Xi(s, t) {\n  if (s.length === 0) return [];\n  let e = 0, i = 0, r = -1;\n  for (let l = 0; l < s.length; l++) {\n    const m = s[l];\n    if (r === -1 && t < m.cts && (r = l - 1), m.is_idr)\n      if (r === -1)\n        e = l;\n      else {\n        i = l;\n        break;\n      }\n  }\n  const a = s[r];\n  if (a == null) throw Error(\"Not found video sample by time\");\n  const o = s.slice(0, i === 0 ? s.length : i).map((l) => ({ ...l }));\n  for (let l = e; l < o.length; l++) {\n    const m = o[l];\n    t < m.cts && (m.deleted = !0, m.cts = -1);\n  }\n  _e(o);\n  const c = s.slice(a.is_idr ? r : e).map((l) => ({ ...l, cts: l.cts - t }));\n  for (const l of c)\n    l.cts < 0 && (l.deleted = !0, l.cts = -1);\n  return _e(c), [o, c];\n}\nfunction Gi(s, t) {\n  if (s.length === 0) return [];\n  let e = -1;\n  for (let a = 0; a < s.length; a++) {\n    const o = s[a];\n    if (!(t > o.cts)) {\n      e = a;\n      break;\n    }\n  }\n  if (e === -1) throw Error(\"Not found audio sample by time\");\n  const i = s.slice(0, e).map((a) => ({ ...a })), r = s.slice(e).map((a) => ({ ...a, cts: a.cts - t }));\n  return [i, r];\n}\nfunction Be(s, t, e) {\n  let i = 0;\n  if (s.state === \"configured\") {\n    for (; i < t.length; i++) s.decode(t[i]);\n    s.flush().catch((r) => {\n      if (!(r instanceof Error)) throw r;\n      if (r.message.includes(\"Decoding error\") && e.onDecodingError != null) {\n        e.onDecodingError(r);\n        return;\n      }\n      if (!r.message.includes(\"Aborted due to close\"))\n        throw r;\n    });\n  }\n}\nfunction Ji(s, t) {\n  if (t !== \"avc1\" && t !== \"hvc1\") return 0;\n  const e = new DataView(s.buffer);\n  let i = 0;\n  for (; i < s.byteLength - 4; ) {\n    if (t === \"avc1\" && (e.getUint8(i + 4) & 31) === 5)\n      return i;\n    if (t === \"hvc1\") {\n      const r = e.getUint8(i + 4) >> 1 & 63;\n      if (r === 19 || r === 20) return i;\n    }\n    i += e.getUint32(i) + 4;\n  }\n  return -1;\n}\nasync function Yi(s, t, e, i, r, a) {\n  const o = await t.createReader(), c = await di(\n    s.filter(\n      (u) => !u.deleted && u.is_sync && u.cts >= r.start && u.cts <= r.end\n    ),\n    o\n  );\n  if (c.length === 0 || i.aborted) return;\n  let l = 0;\n  Be(m(), c, {\n    onDecodingError: (u) => {\n      A.warn(\"thumbnailsByKeyFrame\", u), l === 0 ? Be(m(!0), c, {\n        onDecodingError: (w) => {\n          o.close(), A.error(\"thumbnailsByKeyFrame retry soft deocde\", w);\n        }\n      }) : (a(null, !0), o.close());\n    }\n  });\n  function m(u = !1) {\n    const w = {\n      ...e,\n      ...u ? { hardwareAcceleration: \"prefer-software\" } : {}\n    }, p = new VideoDecoder({\n      output: (x) => {\n        l += 1;\n        const f = l === c.length;\n        a(x, f), f && (o.close(), p.state !== \"closed\" && p.close());\n      },\n      error: (x) => {\n        const f = `thumbnails decoder error: ${x.message}, config: ${JSON.stringify(w)}, state: ${JSON.stringify(\n          {\n            qSize: p.decodeQueueSize,\n            state: p.state,\n            outputCnt: l,\n            inputCnt: c.length\n          }\n        )}`;\n        throw A.error(f), Error(f);\n      }\n    });\n    return i.addEventListener(\"abort\", () => {\n      o.close(), p.state !== \"closed\" && p.close();\n    }), p.configure(w), p;\n  }\n}\nfunction _e(s) {\n  let t = 0, e = null;\n  for (const i of s)\n    if (!i.deleted) {\n      if (i.is_sync && (t += 1), t >= 2) break;\n      (e == null || i.cts < e.cts) && (e = i);\n    }\n  e != null && e.cts < 2e5 && (e.duration += e.cts, e.cts = 0);\n}\nfunction ui() {\n  try {\n    const s = performance.memory;\n    return {\n      jsHeapSizeLimit: s.jsHeapSizeLimit,\n      totalJSHeapSize: s.totalJSHeapSize,\n      usedJSHeapSize: s.usedJSHeapSize,\n      percentUsed: (s.usedJSHeapSize / s.jsHeapSizeLimit).toFixed(3),\n      percentTotal: (s.totalJSHeapSize / s.jsHeapSizeLimit).toFixed(3)\n    };\n  } catch {\n    return {};\n  }\n}\nvar E, z, I, Te, fi;\nconst gt = class gt {\n  /**\n   * 静态图片可使用流、ImageBitmap 初始化\n   *\n   * 动图需要使用 VideoFrame[] 或提供图片类型\n   */\n  constructor(t) {\n    d(this, Te);\n    S(this, \"ready\");\n    d(this, E, {\n      // 微秒\n      duration: 0,\n      width: 0,\n      height: 0\n    });\n    d(this, z, null);\n    d(this, I, []);\n    S(this, \"tickInterceptor\", async (t, e) => e);\n    const e = (i) => (h(this, z, i), n(this, E).width = i.width, n(this, E).height = i.height, n(this, E).duration = 1 / 0, { ...n(this, E) });\n    if (t instanceof ReadableStream)\n      this.ready = new Response(t).blob().then((i) => createImageBitmap(i)).then(e);\n    else if (t instanceof ImageBitmap)\n      this.ready = Promise.resolve(e(t));\n    else if (Array.isArray(t) && t.every((i) => i instanceof VideoFrame)) {\n      h(this, I, t);\n      const i = n(this, I)[0];\n      if (i == null) throw Error(\"The frame count must be greater than 0\");\n      h(this, E, {\n        width: i.displayWidth,\n        height: i.displayHeight,\n        duration: n(this, I).reduce(\n          (r, a) => r + (a.duration ?? 0),\n          0\n        )\n      }), this.ready = Promise.resolve({ ...n(this, E), duration: 1 / 0 });\n    } else if (\"type\" in t)\n      this.ready = B(this, Te, fi).call(this, t.stream, t.type).then(() => ({\n        width: n(this, E).width,\n        height: n(this, E).height,\n        duration: 1 / 0\n      }));\n    else\n      throw Error(\"Illegal arguments\");\n  }\n  /**\n   * ⚠️ 静态图片的 duration 为 Infinity\n   *\n   * 使用 Sprite 包装时需要将它的 duration 设置为有限数\n   *\n   */\n  get meta() {\n    return { ...n(this, E) };\n  }\n  async tick(t) {\n    if (n(this, z) != null)\n      return await this.tickInterceptor(t, {\n        video: await createImageBitmap(n(this, z)),\n        state: \"success\"\n      });\n    const e = t % n(this, E).duration;\n    return await this.tickInterceptor(t, {\n      video: (n(this, I).find(\n        (i) => e >= i.timestamp && e <= i.timestamp + (i.duration ?? 0)\n      ) ?? n(this, I)[0]).clone(),\n      state: \"success\"\n    });\n  }\n  async split(t) {\n    if (await this.ready, n(this, z) != null)\n      return [\n        new gt(await createImageBitmap(n(this, z))),\n        new gt(await createImageBitmap(n(this, z)))\n      ];\n    let e = -1;\n    for (let a = 0; a < n(this, I).length; a++) {\n      const o = n(this, I)[a];\n      if (!(t > o.timestamp)) {\n        e = a;\n        break;\n      }\n    }\n    if (e === -1) throw Error(\"Not found frame by time\");\n    const i = n(this, I).slice(0, e).map((a) => new VideoFrame(a)), r = n(this, I).slice(e).map(\n      (a) => new VideoFrame(a, {\n        timestamp: a.timestamp - t\n      })\n    );\n    return [new gt(i), new gt(r)];\n  }\n  async clone() {\n    await this.ready;\n    const t = n(this, z) == null ? n(this, I).map((e) => e.clone()) : await createImageBitmap(n(this, z));\n    return new gt(t);\n  }\n  destroy() {\n    var t;\n    A.info(\"ImgClip destroy\"), (t = n(this, z)) == null || t.close(), n(this, I).forEach((e) => e.close());\n  }\n};\nE = new WeakMap(), z = new WeakMap(), I = new WeakMap(), Te = new WeakSet(), fi = async function(t, e) {\n  h(this, I, await Bi(t, e));\n  const i = n(this, I)[0];\n  if (i == null) throw Error(\"No frame available in gif\");\n  h(this, E, {\n    duration: n(this, I).reduce((r, a) => r + (a.duration ?? 0), 0),\n    width: i.codedWidth,\n    height: i.codedHeight\n  }), A.info(\"ImgClip ready:\", n(this, E));\n};\nlet Ze = gt;\nvar kt, it, ct, J, Ae, mi, lt, Y;\nconst tt = class tt {\n  /**\n   *\n   * @param dataSource 音频文件流\n   * @param opts 音频配置，控制音量、是否循环\n   */\n  constructor(t, e = {}) {\n    d(this, Ae);\n    S(this, \"ready\");\n    d(this, kt, {\n      // 微秒\n      duration: 0,\n      width: 0,\n      height: 0\n    });\n    d(this, it, new Float32Array());\n    d(this, ct, new Float32Array());\n    d(this, J);\n    /**\n     * 拦截 {@link AudioClip.tick} 方法返回的数据，用于对音频数据二次处理\n     * @param time 调用 tick 的时间\n     * @param tickRet tick 返回的数据\n     *\n     * @see [移除视频绿幕背景](https://webav-tech.github.io/WebAV/demo/3_2-chromakey-video)\n     */\n    S(this, \"tickInterceptor\", async (t, e) => e);\n    // 微秒\n    d(this, lt, 0);\n    d(this, Y, 0);\n    h(this, J, {\n      loop: !1,\n      volume: 1,\n      ...e\n    }), this.ready = B(this, Ae, mi).call(this, t).then(() => ({\n      // audio 没有宽高，无需绘制\n      width: 0,\n      height: 0,\n      duration: e.loop ? 1 / 0 : n(this, kt).duration\n    }));\n  }\n  /**\n   * 音频元信息\n   *\n   * ⚠️ 注意，这里是转换后（标准化）的元信息，非原始音频元信息\n   */\n  get meta() {\n    return {\n      ...n(this, kt),\n      sampleRate: T.sampleRate,\n      chanCount: 2\n    };\n  }\n  /**\n   * 获取音频素材完整的 PCM 数据\n   */\n  getPCMData() {\n    return [n(this, it), n(this, ct)];\n  }\n  /**\n   * 返回上次与当前时刻差对应的音频 PCM 数据；\n   *\n   * 若差值超过 3s 或当前时间小于上次时间，则重置状态\n   * @example\n   * tick(0) // => []\n   * tick(1e6) // => [leftChanPCM(1s), rightChanPCM(1s)]\n   *\n   */\n  async tick(t) {\n    if (!n(this, J).loop && t >= n(this, kt).duration)\n      return await this.tickInterceptor(t, { audio: [], state: \"done\" });\n    const e = t - n(this, lt);\n    if (t < n(this, lt) || e > 3e6)\n      return h(this, lt, t), h(this, Y, Math.ceil(\n        n(this, lt) / 1e6 * T.sampleRate\n      )), await this.tickInterceptor(t, {\n        audio: [new Float32Array(0), new Float32Array(0)],\n        state: \"success\"\n      });\n    h(this, lt, t);\n    const i = Math.ceil(\n      e / 1e6 * T.sampleRate\n    ), r = n(this, Y) + i, a = n(this, J).loop ? [\n      De(n(this, it), n(this, Y), r),\n      De(n(this, ct), n(this, Y), r)\n    ] : [\n      n(this, it).slice(n(this, Y), r),\n      n(this, ct).slice(n(this, Y), r)\n    ];\n    return h(this, Y, r), await this.tickInterceptor(t, { audio: a, state: \"success\" });\n  }\n  /**\n   * 按指定时间切割，返回前后两个音频素材\n   * @param time 时间，单位微秒\n   */\n  async split(t) {\n    await this.ready;\n    const e = Math.ceil(t / 1e6 * T.sampleRate), i = new tt(\n      this.getPCMData().map((a) => a.slice(0, e)),\n      n(this, J)\n    ), r = new tt(\n      this.getPCMData().map((a) => a.slice(e)),\n      n(this, J)\n    );\n    return [i, r];\n  }\n  async clone() {\n    await this.ready;\n    const t = new tt(this.getPCMData(), n(this, J));\n    return await t.ready, t;\n  }\n  /**\n   * 销毁实例，释放资源\n   */\n  destroy() {\n    h(this, it, new Float32Array(0)), h(this, ct, new Float32Array(0)), A.info(\"---- audioclip destroy ----\");\n  }\n};\nkt = new WeakMap(), it = new WeakMap(), ct = new WeakMap(), J = new WeakMap(), Ae = new WeakSet(), mi = async function(t) {\n  tt.ctx == null && (tt.ctx = new AudioContext({\n    sampleRate: T.sampleRate\n  }));\n  const e = performance.now(), i = t instanceof ReadableStream ? await ji(t, tt.ctx) : t;\n  A.info(\"Audio clip decoded complete:\", performance.now() - e);\n  const r = n(this, J).volume;\n  if (r !== 1)\n    for (const a of i)\n      for (let o = 0; o < a.length; o += 1) a[o] *= r;\n  n(this, kt).duration = i[0].length / T.sampleRate * 1e6, h(this, it, i[0]), h(this, ct, i[1] ?? n(this, it)), A.info(\n    \"Audio clip convert to AudioData, time:\",\n    performance.now() - e\n  );\n}, lt = new WeakMap(), Y = new WeakMap(), S(tt, \"ctx\", null);\nlet ti = tt;\nasync function ji(s, t) {\n  const e = await new Response(s).arrayBuffer();\n  return Le(await t.decodeAudioData(e));\n}\nvar It, se, Lt, Ut;\nconst ke = class ke {\n  constructor(t) {\n    S(this, \"ready\");\n    d(this, It, {\n      // 微秒\n      duration: 0,\n      width: 0,\n      height: 0\n    });\n    d(this, se, () => {\n    });\n    /**\n     * 实时流的音轨\n     */\n    S(this, \"audioTrack\");\n    d(this, Lt, null);\n    d(this, Ut);\n    h(this, Ut, t), this.audioTrack = t.getAudioTracks()[0] ?? null, n(this, It).duration = 1 / 0;\n    const e = t.getVideoTracks()[0];\n    e != null ? (e.contentHint = \"motion\", this.ready = new Promise((i) => {\n      h(this, se, Qi(e, (r) => {\n        n(this, It).width = r.width, n(this, It).height = r.height, h(this, Lt, r), i(this.meta);\n      }));\n    })) : this.ready = Promise.resolve(this.meta);\n  }\n  get meta() {\n    return {\n      ...n(this, It)\n    };\n  }\n  async tick() {\n    return {\n      video: n(this, Lt) == null ? null : await createImageBitmap(n(this, Lt)),\n      audio: [],\n      state: \"success\"\n    };\n  }\n  async split() {\n    return [await this.clone(), await this.clone()];\n  }\n  async clone() {\n    return new ke(n(this, Ut).clone());\n  }\n  destroy() {\n    n(this, Ut).getTracks().forEach((t) => t.stop()), n(this, se).call(this);\n  }\n};\nIt = new WeakMap(), se = new WeakMap(), Lt = new WeakMap(), Ut = new WeakMap(), S(ke, \"ctx\", null);\nlet ei = ke;\nfunction Qi(s, t) {\n  let e = !1, i;\n  return ze(\n    new MediaStreamTrackProcessor({\n      track: s\n    }).readable,\n    {\n      onChunk: async (r) => {\n        if (!e) {\n          const { displayHeight: a, displayWidth: o } = r, c = o ?? 0, l = a ?? 0, m = new OffscreenCanvas(c, l);\n          i = m.getContext(\"2d\"), t(m), e = !0;\n        }\n        i.drawImage(r, 0, 0), r.close();\n      },\n      onDone: async () => {\n      }\n    }\n  );\n}\nvar P, re, j, Q, K, O, nt, st, Ie, pi;\nconst Gt = class Gt {\n  constructor(t, e) {\n    d(this, Ie);\n    S(this, \"ready\");\n    d(this, P, []);\n    d(this, re, {\n      width: 0,\n      height: 0,\n      duration: 0\n    });\n    d(this, j, {\n      color: \"#FFF\",\n      textBgColor: null,\n      type: \"srt\",\n      fontSize: 30,\n      letterSpacing: null,\n      bottomOffset: 30,\n      fontFamily: \"Noto Sans SC\",\n      strokeStyle: \"#000\",\n      lineWidth: null,\n      lineCap: null,\n      lineJoin: null,\n      textShadow: {\n        offsetX: 2,\n        offsetY: 2,\n        blur: 4,\n        color: \"#000\"\n      },\n      videoWidth: 1280,\n      videoHeight: 720\n    });\n    d(this, Q);\n    d(this, K);\n    d(this, O, null);\n    d(this, nt, 0);\n    d(this, st, 0);\n    var l;\n    if (h(this, P, Array.isArray(t) ? t : Ki(t).map(({ start: m, end: u, text: w }) => ({\n      start: m * 1e6,\n      end: u * 1e6,\n      text: w\n    }))), n(this, P).length === 0) throw Error(\"No subtitles content\");\n    h(this, j, Object.assign(n(this, j), e)), h(this, st, e.textBgColor == null ? 0 : (e.fontSize ?? 50) * 0.2);\n    const { fontSize: i, fontFamily: r, videoWidth: a, videoHeight: o, letterSpacing: c } = n(this, j);\n    h(this, nt, i + n(this, st) * 2), h(this, Q, new OffscreenCanvas(a, o)), h(this, K, n(this, Q).getContext(\"2d\")), n(this, K).font = `${i}px ${r}`, n(this, K).textAlign = \"center\", n(this, K).textBaseline = \"top\", n(this, K).letterSpacing = c ?? \"0px\", h(this, re, {\n      width: a,\n      height: o,\n      duration: ((l = n(this, P).at(-1)) == null ? void 0 : l.end) ?? 0\n    }), this.ready = Promise.resolve(this.meta);\n  }\n  get meta() {\n    return { ...n(this, re) };\n  }\n  /**\n   * @see {@link IClip.tick}\n   */\n  async tick(t) {\n    var a, o;\n    if (n(this, O) != null && t >= n(this, O).timestamp && t <= n(this, O).timestamp + (n(this, O).duration ?? 0))\n      return { video: n(this, O).clone(), state: \"success\" };\n    let e = 0;\n    for (; e < n(this, P).length && !(t <= n(this, P)[e].end); e += 1)\n      ;\n    const i = n(this, P)[e] ?? n(this, P).at(-1);\n    if (t > i.end) return { state: \"done\" };\n    if (t < i.start) {\n      n(this, K).clearRect(0, 0, n(this, Q).width, n(this, Q).height);\n      const c = new VideoFrame(n(this, Q), {\n        timestamp: t,\n        // 直到下个字幕出现的时机\n        duration: i.start - t\n      });\n      return (a = n(this, O)) == null || a.close(), h(this, O, c), { video: c.clone(), state: \"success\" };\n    }\n    B(this, Ie, pi).call(this, i.text);\n    const r = new VideoFrame(n(this, Q), {\n      timestamp: t,\n      duration: i.end - t\n    });\n    return (o = n(this, O)) == null || o.close(), h(this, O, r), { video: r.clone(), state: \"success\" };\n  }\n  /**\n   * @see {@link IClip.split}\n   */\n  async split(t) {\n    await this.ready;\n    let e = -1;\n    for (let c = 0; c < n(this, P).length; c++) {\n      const l = n(this, P)[c];\n      if (!(t > l.start)) {\n        e = c;\n        break;\n      }\n    }\n    if (e === -1) throw Error(\"Not found subtitle by time\");\n    const i = n(this, P).slice(0, e).map((c) => ({ ...c }));\n    let r = i.at(-1), a = null;\n    r != null && r.end > t && (a = {\n      start: 0,\n      end: r.end - t,\n      text: r.text\n    }, r.end = t);\n    const o = n(this, P).slice(e).map((c) => ({ ...c, start: c.start - t, end: c.end - t }));\n    return a != null && o.unshift(a), [\n      new Gt(i, n(this, j)),\n      new Gt(o, n(this, j))\n    ];\n  }\n  /**\n   * @see {@link IClip.clone}\n   */\n  async clone() {\n    return new Gt(n(this, P).slice(0), n(this, j));\n  }\n  /**\n   * @see {@link IClip.destroy}\n   */\n  destroy() {\n    var t;\n    (t = n(this, O)) == null || t.close();\n  }\n};\nP = new WeakMap(), re = new WeakMap(), j = new WeakMap(), Q = new WeakMap(), K = new WeakMap(), O = new WeakMap(), nt = new WeakMap(), st = new WeakMap(), Ie = new WeakSet(), pi = function(t) {\n  const e = t.split(`\n`).reverse().map((g) => g.trim()), { width: i, height: r } = n(this, Q), {\n    color: a,\n    fontSize: o,\n    textBgColor: c,\n    textShadow: l,\n    strokeStyle: m,\n    lineWidth: u,\n    lineCap: w,\n    lineJoin: p,\n    bottomOffset: x\n  } = n(this, j), f = n(this, K);\n  f.clearRect(0, 0, i, r), f.globalAlpha = 0.6;\n  let y = x;\n  for (const g of e) {\n    const b = f.measureText(g), C = i / 2;\n    c != null && (f.shadowOffsetX = 0, f.shadowOffsetY = 0, f.shadowBlur = 0, f.fillStyle = c, f.globalAlpha = 0.5, f.fillRect(\n      C - b.actualBoundingBoxLeft - n(this, st),\n      r - y - n(this, nt),\n      b.width + n(this, st) * 2,\n      n(this, nt)\n    )), f.shadowColor = l.color, f.shadowOffsetX = l.offsetX, f.shadowOffsetY = l.offsetY, f.shadowBlur = l.blur, f.globalAlpha = 1, m != null && (f.lineWidth = u ?? o / 6, w != null && (f.lineCap = w), p != null && (f.lineJoin = p), f.strokeStyle = m, f.strokeText(\n      g,\n      C,\n      r - y - n(this, nt) + n(this, st)\n    )), f.fillStyle = a, f.fillText(\n      g,\n      C,\n      r - y - n(this, nt) + n(this, st)\n    ), y += n(this, nt) + o * 0.2;\n  }\n};\nlet ii = Gt;\nfunction ni(s) {\n  const t = s.match(/(\\d{2}):(\\d{2}):(\\d{2}),(\\d{3})/);\n  if (t == null) throw Error(`time format error: ${s}`);\n  const e = Number(t[1]), i = Number(t[2]), r = Number(t[3]), a = Number(t[4]);\n  return e * 60 * 60 + i * 60 + r + a / 1e3;\n}\nfunction Ki(s) {\n  return s.split(/\\r|\\n/).map((t) => t.trim()).filter((t) => t.length > 0).map((t) => ({\n    lineStr: t,\n    match: t.match(\n      /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})/\n    )\n  })).filter(\n    ({ lineStr: t }, e, i) => {\n      var r;\n      return !(/^\\d+$/.test(t) && ((r = i[e + 1]) == null ? void 0 : r.match) != null);\n    }\n  ).reduce(\n    (t, { lineStr: e, match: i }) => {\n      if (i == null) {\n        const r = t.at(-1);\n        if (r == null) return t;\n        r.text += r.text.length === 0 ? e : `\n${e}`;\n      } else\n        t.push({\n          start: ni(i[1]),\n          end: ni(i[2]),\n          text: \"\"\n        });\n      return t;\n    },\n    []\n  );\n}\nvar ae;\nclass wi {\n  constructor() {\n    S(this, \"readable\");\n    S(this, \"writable\");\n    d(this, ae, 0);\n    const t = wt.createFile();\n    let e = !1;\n    this.readable = new ReadableStream(\n      {\n        start: (i) => {\n          t.onReady = (a) => {\n            var l, m;\n            const o = (l = a.videoTracks[0]) == null ? void 0 : l.id;\n            o != null && t.setExtractionOptions(o, \"video\", { nbSamples: 100 });\n            const c = (m = a.audioTracks[0]) == null ? void 0 : m.id;\n            c != null && t.setExtractionOptions(c, \"audio\", { nbSamples: 100 }), i.enqueue({ chunkType: \"ready\", data: { info: a, file: t } }), t.start();\n          };\n          const r = {};\n          t.onSamples = (a, o, c) => {\n            i.enqueue({\n              chunkType: \"samples\",\n              data: { id: a, type: o, samples: c.map((l) => ({ ...l })) }\n            }), r[a] = (r[a] ?? 0) + c.length, t.releaseUsedSamples(a, r[a]);\n          }, t.onFlush = () => {\n            i.close();\n          };\n        },\n        cancel: () => {\n          t.stop(), e = !0;\n        }\n      },\n      {\n        // 每条消息 100 个 samples\n        highWaterMark: 50\n      }\n    ), this.writable = new WritableStream({\n      write: async (i) => {\n        if (e) {\n          this.writable.abort();\n          return;\n        }\n        const r = i.buffer;\n        r.fileStart = n(this, ae), h(this, ae, n(this, ae) + r.byteLength), t.appendBuffer(r);\n      },\n      close: () => {\n        var i;\n        t.flush(), t.stop(), (i = t.onFlush) == null || i.call(t);\n      }\n    });\n  }\n}\nae = new WeakMap();\nfunction qi(s) {\n  let t = 0;\n  const e = s.boxes, i = [];\n  let r = 0;\n  async function a() {\n    const f = x(e, t);\n    t = e.length, i.forEach(({ track: y, id: g }) => {\n      const b = y.samples.at(-1);\n      b != null && (r = Math.max(r, b.cts + b.duration)), s.releaseUsedSamples(g, y.samples.length), y.samples = [];\n    }), s.mdats = [], s.moofs = [], f != null && await (u == null ? void 0 : u.write(f));\n  }\n  let o = [];\n  function c() {\n    if (o.length > 0) return !0;\n    const f = e.findIndex((y) => y.type === \"moov\");\n    if (f === -1) return !1;\n    if (o = e.slice(0, f + 1), t = f + 1, i.length === 0)\n      for (let y = 1; ; y += 1) {\n        const g = s.getTrackById(y);\n        if (g == null) break;\n        i.push({ track: g, id: y });\n      }\n    return !0;\n  }\n  let l = 0;\n  const m = Ee();\n  let u = null;\n  const w = (async () => {\n    u = await m.createWriter(), l = self.setInterval(() => {\n      c() && a();\n    }, 100);\n  })();\n  let p = !1;\n  return async () => {\n    if (p) throw Error(\"File exported\");\n    if (p = !0, await w, clearInterval(l), !c() || u == null) return null;\n    s.flush(), await a(), await (u == null ? void 0 : u.close());\n    const f = o.find((b) => b.type === \"moov\");\n    if (f == null) return null;\n    f.mvhd.duration = r;\n    const y = Ee(), g = x(o, 0);\n    return await Pe(y, g), await Pe(y, m, { overwrite: !1 }), await y.stream();\n  };\n  function x(f, y) {\n    if (y >= f.length) return null;\n    const g = new wt.DataStream();\n    g.endianness = wt.DataStream.BIG_ENDIAN;\n    for (let b = y; b < f.length; b++)\n      f[b] !== null && (f[b].write(g), delete f[b]);\n    return new Uint8Array(g.buffer);\n  }\n}\nfunction Zi(s) {\n  const t = new ArrayBuffer(s.byteLength);\n  s.copyTo(t);\n  const e = s.timestamp;\n  return {\n    duration: s.duration ?? 0,\n    dts: e,\n    cts: e,\n    is_sync: s.type === \"key\",\n    data: t\n  };\n}\nasync function tn(s) {\n  const t = wt.createFile(), e = qi(t);\n  await en(s, t);\n  const i = await e();\n  if (i == null) throw Error(\"Can not generate file from streams\");\n  return i;\n}\nasync function en(s, t) {\n  let e = 0, i = 0, r = 0, a = 0, o = 0, c = 0, l = null, m = null;\n  for (const u of s)\n    await new Promise(async (w) => {\n      ze(u.pipeThrough(new wi()), {\n        onDone: w,\n        onChunk: async ({ chunkType: p, data: x }) => {\n          if (p === \"ready\") {\n            const { videoTrackConf: f, audioTrackConf: y } = Ne(\n              x.file,\n              x.info\n            );\n            e === 0 && f != null && (e = t.addTrack(f)), a === 0 && y != null && (a = t.addTrack(y));\n          } else if (p === \"samples\") {\n            const { type: f, samples: y } = x, g = f === \"video\" ? e : a, b = f === \"video\" ? i : o, C = f === \"video\" ? r : c;\n            y.forEach((k) => {\n              t.addSample(g, k.data, {\n                duration: k.duration,\n                dts: k.dts + b,\n                cts: k.cts + C,\n                is_sync: k.is_sync\n              });\n            });\n            const v = y.at(-1);\n            if (v == null) return;\n            f === \"video\" ? l = v : f === \"audio\" && (m = v);\n          }\n        }\n      });\n    }), l != null && (i += l.dts, r += l.cts), m != null && (o += m.dts, c += m.cts);\n}\nasync function In(s) {\n  return await tn([s]);\n}\nfunction nn(s) {\n  let t = [];\n  const e = new AudioDecoder({\n    output: (i) => {\n      t.push(i);\n    },\n    error: A.error\n  });\n  return e.configure(s), {\n    decode: async (i) => {\n      i.forEach((a) => {\n        e.decode(\n          new EncodedAudioChunk({\n            type: a.is_sync ? \"key\" : \"delta\",\n            timestamp: 1e6 * a.cts / a.timescale,\n            duration: 1e6 * a.duration / a.timescale,\n            data: a.data\n          })\n        );\n      }), await e.flush();\n      const r = t;\n      return t = [], r;\n    },\n    close: () => {\n      e.close();\n    }\n  };\n}\nfunction sn(s, t) {\n  const e = {\n    codec: s.codec,\n    sampleRate: s.sampleRate,\n    numberOfChannels: s.numberOfChannels\n  }, i = new AudioEncoder({\n    output: (o) => {\n      t(Zi(o));\n    },\n    error: (o) => {\n      A.error(\"AudioEncoder error:\", o, \", config:\", e);\n    }\n  });\n  i.configure(e);\n  let r = null;\n  function a(o, c) {\n    return new AudioData({\n      timestamp: c,\n      numberOfChannels: s.numberOfChannels,\n      numberOfFrames: o.length / s.numberOfChannels,\n      sampleRate: s.sampleRate,\n      format: \"f32-planar\",\n      data: o\n    });\n  }\n  return {\n    encode: async (o, c) => {\n      r != null && i.encode(a(r.data, r.ts)), r = { data: o, ts: c };\n    },\n    stop: async () => {\n      r != null && (rn(r.data, s.numberOfChannels, s.sampleRate), i.encode(a(r.data, r.ts)), r = null), await i.flush(), i.close();\n    }\n  };\n}\nfunction rn(s, t, e) {\n  const i = s.length - 1, r = Math.min(e / 2, i);\n  for (let a = 0; a < r; a++)\n    for (let o = 1; o <= t; o++)\n      s[Math.floor(i / o) - a] *= a / r;\n}\nfunction Fn(s, t) {\n  A.info(\"mixinMP4AndAudio, opts:\", {\n    volume: t.volume,\n    loop: t.loop\n  });\n  const e = wt.createFile(), { stream: i, stop: r } = oi(e, 500);\n  let a = null, o = null, c = [], l = 0, m = 0, u = 0, w = !0, p = T.sampleRate;\n  ze(s.pipeThrough(new wi()), {\n    onDone: async () => {\n      await (o == null ? void 0 : o.stop()), a == null || a.close(), r();\n    },\n    onChunk: async ({ chunkType: g, data: b }) => {\n      if (g === \"ready\") {\n        const { videoTrackConf: C, audioTrackConf: v, audioDecoderConf: k } = Ne(b.file, b.info);\n        l === 0 && C != null && (l = e.addTrack(C));\n        const H = v ?? {\n          timescale: 1e6,\n          samplerate: p,\n          channel_count: T.channelCount,\n          hdlr: \"soun\",\n          name: \"SoundHandler\",\n          type: \"mp4a\"\n        };\n        m === 0 && (m = e.addTrack(H), p = (v == null ? void 0 : v.samplerate) ?? p, w = v != null);\n        const Ci = new AudioContext({ sampleRate: p });\n        c = Le(\n          await Ci.decodeAudioData(\n            await new Response(t.stream).arrayBuffer()\n          )\n        ), k != null && (a = nn(k)), o = sn(\n          k ?? {\n            codec: H.type === \"mp4a\" ? T.codec : H.type,\n            numberOfChannels: H.channel_count,\n            sampleRate: H.samplerate\n          },\n          (Ge) => e.addSample(m, Ge.data, Ge)\n        );\n      } else if (g === \"samples\") {\n        const { id: C, type: v, samples: k } = b;\n        if (v === \"video\") {\n          k.forEach((H) => e.addSample(C, H.data, H)), w || await f(k);\n          return;\n        }\n        v === \"audio\" && await y(k);\n      }\n    }\n  });\n  function x(g) {\n    const b = c.map(\n      (C) => t.loop ? De(C, u, u + g) : C.slice(u, u + g)\n    );\n    if (u += g, t.volume !== 1)\n      for (const C of b)\n        for (let v = 0; v < C.length; v++) C[v] *= t.volume;\n    return b;\n  }\n  async function f(g) {\n    const b = g[0], C = g[g.length - 1], v = Math.floor(\n      (C.cts + C.duration - b.cts) / C.timescale * p\n    ), k = Ye([x(v)]);\n    k.length !== 0 && (o == null || o.encode(\n      k,\n      b.cts / b.timescale * 1e6\n    ));\n  }\n  async function y(g) {\n    if (a == null) return;\n    const b = (await a.decode(g)).map(\n      ci\n    ), C = Ei(b), v = x(C[0].length), k = g[0];\n    o == null || o.encode(\n      // 2. 混合输入的音频\n      Ye([C, v]),\n      k.cts / k.timescale * 1e6\n    );\n  }\n  return i;\n}\nconst an = `#version 300 es\n  layout (location = 0) in vec4 a_position;\n  layout (location = 1) in vec2 a_texCoord;\n  out vec2 v_texCoord;\n  void main () {\n    gl_Position = a_position;\n    v_texCoord = a_texCoord;\n  }\n`, on = `#version 300 es\nprecision mediump float;\nout vec4 FragColor;\nin vec2 v_texCoord;\n\nuniform sampler2D frameTexture;\nuniform vec3 keyColor;\n\n// 色度的相似度计算\nuniform float similarity;\n// 透明度的平滑度计算\nuniform float smoothness;\n// 降低绿幕饱和度，提高抠图准确度\nuniform float spill;\n\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\n\nvoid main() {\n  // 获取当前像素的rgba值\n  vec4 rgba = texture(frameTexture, v_texCoord);\n  // 计算当前像素与绿幕像素的色度差值\n  vec2 chromaVec = RGBtoUV(rgba.rgb) - RGBtoUV(keyColor);\n  // 计算当前像素与绿幕像素的色度距离（向量长度）, 越相像则色度距离越小\n  float chromaDist = sqrt(dot(chromaVec, chromaVec));\n  // 设置了一个相似度阈值，baseMask为负，则表明是绿幕，为正则表明不是绿幕\n  float baseMask = chromaDist - similarity;\n  // 如果baseMask为负数，fullMask等于0；baseMask为正数，越大，则透明度越低\n  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);\n  rgba.a = fullMask; // 设置透明度\n  // 如果baseMask为负数，spillVal等于0；baseMask为整数，越小，饱和度越低\n  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);\n  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.); // 计算当前像素的灰度值\n  rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);\n  FragColor = rgba;\n}\n`, cn = [-1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1], ln = [0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1];\nfunction hn(s, t, e) {\n  const i = si(s, s.VERTEX_SHADER, t), r = si(s, s.FRAGMENT_SHADER, e), a = s.createProgram();\n  if (s.attachShader(a, i), s.attachShader(a, r), s.linkProgram(a), !s.getProgramParameter(a, s.LINK_STATUS))\n    throw Error(\n      s.getProgramInfoLog(a) ?? \"Unable to initialize the shader program\"\n    );\n  return a;\n}\nfunction si(s, t, e) {\n  const i = s.createShader(t);\n  if (s.shaderSource(i, e), s.compileShader(i), !s.getShaderParameter(i, s.COMPILE_STATUS)) {\n    const r = s.getShaderInfoLog(i);\n    throw s.deleteShader(i), Error(r ?? \"An error occurred compiling the shaders\");\n  }\n  return i;\n}\nfunction dn(s, t, e) {\n  s.bindTexture(s.TEXTURE_2D, e), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, t), s.drawArrays(s.TRIANGLES, 0, 6);\n}\nfunction un(s) {\n  const t = s.createTexture();\n  if (t == null) throw Error(\"Create WebGL texture error\");\n  s.bindTexture(s.TEXTURE_2D, t);\n  const e = 0, i = s.RGBA, r = 1, a = 1, o = 0, c = s.RGBA, l = s.UNSIGNED_BYTE, m = new Uint8Array([0, 0, 255, 255]);\n  return s.texImage2D(\n    s.TEXTURE_2D,\n    e,\n    i,\n    r,\n    a,\n    o,\n    c,\n    l,\n    m\n  ), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), t;\n}\nfunction fn(s) {\n  const t = \"document\" in globalThis ? globalThis.document.createElement(\"canvas\") : new OffscreenCanvas(s.width, s.height);\n  t.width = s.width, t.height = s.height;\n  const e = t.getContext(\"webgl2\", {\n    premultipliedAlpha: !1,\n    alpha: !0\n  });\n  if (e == null) throw Error(\"Cant create gl context\");\n  const i = hn(e, an, on);\n  e.useProgram(i), e.uniform3fv(\n    e.getUniformLocation(i, \"keyColor\"),\n    s.keyColor.map((l) => l / 255)\n  ), e.uniform1f(\n    e.getUniformLocation(i, \"similarity\"),\n    s.similarity\n  ), e.uniform1f(\n    e.getUniformLocation(i, \"smoothness\"),\n    s.smoothness\n  ), e.uniform1f(e.getUniformLocation(i, \"spill\"), s.spill);\n  const r = e.createBuffer();\n  e.bindBuffer(e.ARRAY_BUFFER, r), e.bufferData(e.ARRAY_BUFFER, new Float32Array(cn), e.STATIC_DRAW);\n  const a = e.getAttribLocation(i, \"a_position\");\n  e.vertexAttribPointer(\n    a,\n    2,\n    e.FLOAT,\n    !1,\n    Float32Array.BYTES_PER_ELEMENT * 2,\n    0\n  ), e.enableVertexAttribArray(a);\n  const o = e.createBuffer();\n  e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(\n    e.ARRAY_BUFFER,\n    new Float32Array(ln),\n    e.STATIC_DRAW\n  );\n  const c = e.getAttribLocation(i, \"a_texCoord\");\n  return e.vertexAttribPointer(\n    c,\n    2,\n    e.FLOAT,\n    !1,\n    Float32Array.BYTES_PER_ELEMENT * 2,\n    0\n  ), e.enableVertexAttribArray(c), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, 1), { cvs: t, gl: e };\n}\nfunction mn(s) {\n  return s instanceof VideoFrame ? { width: s.codedWidth, height: s.codedHeight } : { width: s.width, height: s.height };\n}\nfunction pn(s) {\n  const e = new OffscreenCanvas(1, 1).getContext(\"2d\");\n  e.drawImage(s, 0, 0);\n  const {\n    data: [i, r, a]\n  } = e.getImageData(0, 0, 1, 1);\n  return [i, r, a];\n}\nconst Rn = (s) => {\n  let t = null, e = null, i = s.keyColor, r = null;\n  return async (a) => {\n    if ((t == null || e == null || r == null) && (i == null && (i = pn(a)), { cvs: t, gl: e } = fn({\n      ...mn(a),\n      keyColor: i,\n      ...s\n    }), r = un(e)), dn(e, a, r), globalThis.VideoFrame != null && a instanceof globalThis.VideoFrame) {\n      const o = new VideoFrame(t, {\n        alpha: \"keep\",\n        timestamp: a.timestamp,\n        duration: a.duration ?? void 0\n      });\n      return a.close(), o;\n    }\n    return createImageBitmap(t, {\n      imageOrientation: a instanceof ImageBitmap ? \"flipY\" : \"none\"\n    });\n  };\n};\nvar oe, ce, le, he, de, ue, ht, Bt, dt;\nconst $e = class $e {\n  constructor(t, e, i, r, a) {\n    d(this, ht);\n    d(this, oe, new Ve());\n    /**\n     * 监听属性变更事件\n     * @example\n     * rect.on('propsChange', (changedProps) => {})\n     */\n    S(this, \"on\", n(this, oe).on);\n    d(this, ce, 0);\n    d(this, le, 0);\n    d(this, he, 0);\n    d(this, de, 0);\n    d(this, ue, 0);\n    /**\n     * 如果当前实例是 Rect 控制点之一，`master` 将指向该 Rect\n     *\n     * 控制点的坐标是相对于它的 `master` 定位\n     */\n    d(this, dt, null);\n    /**\n     * 是否保持固定宽高比例，禁止变形缩放\n     *\n     * 值为 true 时，将缺少上下左右四个控制点\n     */\n    S(this, \"fixedAspectRatio\", !1);\n    /**\n     * 是否固定中心点进行缩放\n     * 值为 true 时，固定中心点不变进行缩放\n     * 值为 false 时，固定对角点不变进行缩放\n     */\n    S(this, \"fixedScaleCenter\", !1);\n    this.x = t ?? 0, this.y = e ?? 0, this.w = i ?? 0, this.h = r ?? 0, h(this, dt, a ?? null);\n  }\n  /**\n   * x 坐标\n   */\n  get x() {\n    return n(this, ce);\n  }\n  set x(t) {\n    B(this, ht, Bt).call(this, \"x\", t);\n  }\n  get y() {\n    return n(this, le);\n  }\n  /**\n   * y 坐标\n   */\n  set y(t) {\n    B(this, ht, Bt).call(this, \"y\", t);\n  }\n  /**\n   * 宽\n   */\n  get w() {\n    return n(this, he);\n  }\n  set w(t) {\n    B(this, ht, Bt).call(this, \"w\", t);\n  }\n  /**\n   * 高\n   */\n  get h() {\n    return n(this, de);\n  }\n  set h(t) {\n    B(this, ht, Bt).call(this, \"h\", t);\n  }\n  /**\n   * 旋转角度\n   * @see [MDN Canvas rotate](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/rotate)\n   */\n  get angle() {\n    return n(this, ue);\n  }\n  set angle(t) {\n    B(this, ht, Bt).call(this, \"angle\", t);\n  }\n  /**\n   * 根据坐标、宽高计算出来的矩形中心点\n   */\n  get center() {\n    const { x: t, y: e, w: i, h: r } = this;\n    return { x: t + i / 2, y: e + r / 2 };\n  }\n  clone() {\n    const { x: t, y: e, w: i, h: r } = this, a = new $e(t, e, i, r, n(this, dt));\n    return a.angle = this.angle, a.fixedAspectRatio = this.fixedAspectRatio, a.fixedScaleCenter = this.fixedScaleCenter, a;\n  }\n  /**\n   * 检测目标坐标是否命中当前实例\n   * @param tx 目标点 x 坐标\n   * @param ty 目标点 y 坐标\n   */\n  checkHit(t, e) {\n    var y, g;\n    let { angle: i, center: r, x: a, y: o, w: c, h: l } = this;\n    const m = ((y = n(this, dt)) == null ? void 0 : y.center) ?? r, u = ((g = n(this, dt)) == null ? void 0 : g.angle) ?? i;\n    n(this, dt) == null && (a = a - m.x, o = o - m.y);\n    const w = t - m.x, p = e - m.y;\n    let x = w, f = p;\n    return u !== 0 && (x = w * Math.cos(u) + p * Math.sin(u), f = p * Math.cos(u) - w * Math.sin(u)), !(x < a || x > a + c || f < o || f > o + l);\n  }\n};\noe = new WeakMap(), ce = new WeakMap(), le = new WeakMap(), he = new WeakMap(), de = new WeakMap(), ue = new WeakMap(), ht = new WeakSet(), Bt = function(t, e) {\n  const i = this[t] !== e;\n  switch (t) {\n    case \"x\":\n      h(this, ce, e);\n      break;\n    case \"y\":\n      h(this, le, e);\n      break;\n    case \"w\":\n      h(this, he, e);\n      break;\n    case \"h\":\n      h(this, de, e);\n      break;\n    case \"angle\":\n      h(this, ue, e);\n      break;\n  }\n  i && n(this, oe).emit(\"propsChange\", { [t]: e });\n}, dt = new WeakMap();\nlet Oe = $e;\nvar fe, Ft, Nt, ut, q;\nclass yi {\n  constructor() {\n    /**\n     * 控制素材在视频中的空间属性（坐标、旋转、缩放）\n     */\n    S(this, \"rect\", new Oe());\n    /**\n     * 控制素材在的时间偏移、时长、播放速率，常用于剪辑场景时间轴（轨道）模块\n     * duration 不能大于引用 {@link IClip} 的时长，单位 微秒\n     *\n     * playbackRate 控制当前素材的播放速率，1 表示正常播放；\n     * **注意**\n     *    1. 设置 playbackRate 时需要主动修正 duration\n     *    2. 音频使用最简单的插值算法来改变速率，所以改变速率后音调会产生变化，自定义算法请使用 {@link MP4Clip.tickInterceptor} 配合实现\n     *\n     */\n    d(this, fe, {\n      offset: 0,\n      duration: 0,\n      playbackRate: 1\n    });\n    d(this, Ft, new Ve());\n    /**\n     * 监听属性变更事件\n     * @example\n     * sprite.on('propsChange', (changedProps) => {})\n     */\n    S(this, \"on\", n(this, Ft).on);\n    d(this, Nt, 0);\n    /**\n     * 不透明度\n     */\n    S(this, \"opacity\", 1);\n    /**\n     * 水平或垂直方向翻转素材\n     */\n    S(this, \"flip\", null);\n    d(this, ut, null);\n    d(this, q, null);\n    /**\n     * @see {@link IClip.ready}\n     */\n    S(this, \"ready\", Promise.resolve());\n    this.rect.on(\"propsChange\", (t) => {\n      n(this, Ft).emit(\"propsChange\", { rect: t });\n    });\n  }\n  get time() {\n    return n(this, fe);\n  }\n  set time(t) {\n    Object.assign(n(this, fe), t);\n  }\n  get zIndex() {\n    return n(this, Nt);\n  }\n  /**\n   * 控制素材间的层级关系，zIndex 值较小的素材会被遮挡\n   */\n  set zIndex(t) {\n    const e = n(this, Nt) !== t;\n    h(this, Nt, t), e && n(this, Ft).emit(\"propsChange\", { zIndex: t });\n  }\n  _render(t) {\n    const {\n      rect: { center: e, angle: i }\n    } = this;\n    t.setTransform(\n      // 水平 缩放、倾斜\n      this.flip === \"horizontal\" ? -1 : 1,\n      0,\n      // 垂直 倾斜、缩放\n      0,\n      this.flip === \"vertical\" ? -1 : 1,\n      // 坐标原点偏移 x y\n      e.x,\n      e.y\n    ), t.rotate((this.flip == null ? 1 : -1) * i), t.globalAlpha = this.opacity;\n  }\n  /**\n   * 给素材添加动画，使用方法参考 css animation\n   *\n   * @example\n   * sprite.setAnimation(\n   *   {\n   *     '0%': { x: 0, y: 0 },\n   *     '25%': { x: 1200, y: 680 },\n   *     '50%': { x: 1200, y: 0 },\n   *     '75%': { x: 0, y: 680 },\n   *     '100%': { x: 0, y: 0 },\n   *   },\n   *   { duration: 4e6, iterCount: 1 },\n   * );\n   *\n   * @see [视频水印动画](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n   */\n  setAnimation(t, e) {\n    h(this, ut, Object.entries(t).map(([i, r]) => {\n      const a = { from: 0, to: 100 }[i] ?? Number(i.slice(0, -1));\n      if (isNaN(a) || a > 100 || a < 0)\n        throw Error(\"keyFrame must between 0~100\");\n      return [a / 100, r];\n    })), h(this, q, Object.assign({}, n(this, q), {\n      duration: e.duration,\n      delay: e.delay ?? 0,\n      iterCount: e.iterCount ?? 1 / 0\n    }));\n  }\n  /**\n   * 如果当前 sprite 已被设置动画，将 sprite 的动画属性设定到指定时间的状态\n   */\n  animate(t) {\n    if (n(this, ut) == null || n(this, q) == null || t < n(this, q).delay)\n      return;\n    const e = wn(\n      t,\n      n(this, ut),\n      n(this, q)\n    );\n    for (const i in e)\n      switch (i) {\n        case \"opacity\":\n          this.opacity = e[i];\n          break;\n        case \"x\":\n        case \"y\":\n        case \"w\":\n        case \"h\":\n        case \"angle\":\n          this.rect[i] = e[i];\n          break;\n      }\n  }\n  /**\n   * 将当前 sprite 的属性赋值到目标\n   *\n   * 用于 clone，或 {@link VisibleSprite} 与 {@link OffscreenSprite} 实例间的类型转换\n   */\n  copyStateTo(t) {\n    h(t, ut, n(this, ut)), h(t, q, n(this, q)), t.zIndex = this.zIndex, t.opacity = this.opacity, t.flip = this.flip, t.rect = this.rect.clone(), t.time = { ...this.time };\n  }\n  destroy() {\n    n(this, Ft).destroy();\n  }\n}\nfe = new WeakMap(), Ft = new WeakMap(), Nt = new WeakMap(), ut = new WeakMap(), q = new WeakMap();\nfunction wn(s, t, e) {\n  const i = s - e.delay;\n  if (i / e.duration >= e.iterCount) return {};\n  const r = i % e.duration, a = i === e.duration ? 1 : r / e.duration, o = t.findIndex((x) => x[0] >= a);\n  if (o === -1) return {};\n  const c = t[o - 1], l = t[o], m = l[1];\n  if (c == null) return m;\n  const u = c[1], w = {}, p = (a - c[0]) / (l[0] - c[0]);\n  for (const x in m) {\n    const f = x;\n    u[f] != null && (w[f] = (m[f] - u[f]) * p + u[f]);\n  }\n  return w;\n}\nvar Rt, ft, me;\nconst We = class We extends yi {\n  constructor(e) {\n    super();\n    d(this, Rt);\n    // 保持最近一帧，若 clip 在当前帧无数据，则绘制最近一帧\n    d(this, ft, null);\n    d(this, me, !1);\n    h(this, Rt, e), this.ready = e.ready.then(({ width: i, height: r, duration: a }) => {\n      this.rect.w = this.rect.w === 0 ? i : this.rect.w, this.rect.h = this.rect.h === 0 ? r : this.rect.h, this.time.duration = this.time.duration === 0 ? a : this.time.duration;\n    });\n  }\n  /**\n   * 绘制素材指定时刻的图像到 canvas 上下文，并返回对应的音频数据\n   * @param time 指定时刻，微秒\n   */\n  async offscreenRender(e, i) {\n    var p;\n    const r = i * this.time.playbackRate;\n    this.animate(r), super._render(e);\n    const { w: a, h: o } = this.rect, { video: c, audio: l, state: m } = await n(this, Rt).tick(r);\n    let u = l ?? [];\n    if (l != null && this.time.playbackRate !== 1 && (u = l.map(\n      (x) => li(x, this.time.playbackRate)\n    )), m === \"done\")\n      return {\n        audio: u,\n        done: !0\n      };\n    const w = c ?? n(this, ft);\n    return w != null && e.drawImage(w, -a / 2, -o / 2, a, o), c != null && ((p = n(this, ft)) == null || p.close(), h(this, ft, c)), {\n      audio: u,\n      done: !1\n    };\n  }\n  async clone() {\n    const e = new We(await n(this, Rt).clone());\n    return await e.ready, this.copyStateTo(e), e;\n  }\n  destroy() {\n    var e;\n    n(this, me) || (h(this, me, !0), A.info(\"OffscreenSprite destroy\"), super.destroy(), (e = n(this, ft)) == null || e.close(), h(this, ft, null), n(this, Rt).destroy());\n  }\n};\nRt = new WeakMap(), ft = new WeakMap(), me = new WeakMap();\nlet ri = We;\nvar Et, mt, Pt, Ht, pe, Me, we, ye;\nconst Xe = class Xe extends yi {\n  constructor(e) {\n    super();\n    d(this, pe);\n    d(this, Et);\n    /**\n     * 元素是否可见，用于不想删除，期望临时隐藏 Sprite 的场景\n     */\n    S(this, \"visible\", !0);\n    // 保持最近一帧，若 clip 在当前帧无数据，则绘制最近一帧\n    d(this, mt, null);\n    d(this, Pt, []);\n    d(this, Ht, !1);\n    d(this, we, -1);\n    d(this, ye, !1);\n    h(this, Et, e), this.ready = e.ready.then(({ width: i, height: r, duration: a }) => {\n      this.rect.w = this.rect.w === 0 ? i : this.rect.w, this.rect.h = this.rect.h === 0 ? r : this.rect.h, this.time.duration = this.time.duration === 0 ? a : this.time.duration;\n    });\n  }\n  getClip() {\n    return n(this, Et);\n  }\n  /**\n   * 提前准备指定 time 的帧\n   */\n  preFrame(e) {\n    B(this, pe, Me).call(this, e);\n  }\n  /**\n   * 绘制素材指定时刻的图像到 canvas 上下文，并返回对应的音频数据\n   * @param time 指定时刻，微秒\n   */\n  render(e, i) {\n    this.animate(i), super._render(e);\n    const { w: r, h: a } = this.rect;\n    n(this, we) !== i && B(this, pe, Me).call(this, i), h(this, we, i);\n    const o = n(this, Pt);\n    h(this, Pt, []);\n    const c = n(this, mt);\n    return c != null && e.drawImage(c, -r / 2, -a / 2, r, a), { audio: o };\n  }\n  copyStateTo(e) {\n    super.copyStateTo(e), e instanceof Xe && (e.visible = this.visible);\n  }\n  destroy() {\n    var e;\n    n(this, ye) || (h(this, ye, !0), A.info(\"VisibleSprite destroy\"), super.destroy(), (e = n(this, mt)) == null || e.close(), h(this, mt, null), n(this, Et).destroy());\n  }\n};\nEt = new WeakMap(), mt = new WeakMap(), Pt = new WeakMap(), Ht = new WeakMap(), pe = new WeakSet(), Me = function(e) {\n  n(this, Ht) || (h(this, Ht, !0), n(this, Et).tick(e * this.time.playbackRate).then(({ video: i, audio: r }) => {\n    var a;\n    i != null && ((a = n(this, mt)) == null || a.close(), h(this, mt, i ?? null)), h(this, Pt, r ?? []), r != null && this.time.playbackRate !== 1 && h(this, Pt, r.map(\n      (o) => li(o, this.time.playbackRate)\n    ));\n  }).finally(() => {\n    h(this, Ht, !1);\n  }));\n}, we = new WeakMap(), ye = new WeakMap();\nlet ai = Xe, yn = 0;\nasync function gi(s) {\n  s() > 50 && (await Ue(15), await gi(s));\n}\nvar Z, ge, N, $t, be, xe, Dt, Wt, pt, Xt, bi, xi;\nclass En {\n  /**\n   * 根据配置创建合成器实例\n   * @param opts ICombinatorOpts\n   */\n  constructor(t = {}) {\n    d(this, Xt);\n    d(this, Z, A.create(`id:${yn++},`));\n    d(this, ge, !1);\n    d(this, N, []);\n    d(this, $t);\n    d(this, be);\n    // 中断输出\n    d(this, xe, null);\n    d(this, Dt);\n    d(this, Wt);\n    d(this, pt, new Ve());\n    S(this, \"on\", n(this, pt).on);\n    const { width: e = 0, height: i = 0 } = t;\n    h(this, $t, new OffscreenCanvas(e, i));\n    const r = n(this, $t).getContext(\"2d\", { alpha: !1 });\n    if (r == null) throw Error(\"Can not create 2d offscreen context\");\n    h(this, be, r), h(this, Dt, Object.assign(\n      {\n        bgColor: \"#000\",\n        width: 0,\n        height: 0,\n        videoCodec: \"avc1.42E032\",\n        audio: !0,\n        bitrate: 5e6,\n        fps: 30,\n        metaDataTags: null\n      },\n      t\n    )), h(this, Wt, e * i > 0);\n  }\n  /**\n   * 检测当前环境的兼容性\n   * @param args.videoCodec 指定视频编码格式，默认 avc1.42E032\n   * @param args.width 指定视频宽度，默认 1920\n   * @param args.height 指定视频高度，默认 1080\n   * @param args.bitrate 指定视频比特率，默认 5e6\n   */\n  static async isSupported(t = {}) {\n    return (self.OffscreenCanvas != null && self.VideoEncoder != null && self.VideoDecoder != null && self.VideoFrame != null && self.AudioEncoder != null && self.AudioDecoder != null && self.AudioData != null && ((await self.VideoEncoder.isConfigSupported({\n      codec: t.videoCodec ?? \"avc1.42E032\",\n      width: t.width ?? 1920,\n      height: t.height ?? 1080,\n      bitrate: t.bitrate ?? 7e6\n    })).supported ?? !1) && (await self.AudioEncoder.isConfigSupported({\n      codec: T.codec,\n      sampleRate: T.sampleRate,\n      numberOfChannels: T.channelCount\n    })).supported) ?? !1;\n  }\n  /**\n   * 添加用于合成视频的 Sprite，视频时长默认取所有素材 duration 字段的最大值\n   * @param os Sprite\n   * @param opts.main 如果 main 为 true，视频时长为该素材的 duration 值\n   */\n  async addSprite(t, e = {}) {\n    const i = {\n      rect: Cn([\"x\", \"y\", \"w\", \"h\"], t.rect),\n      time: { ...t.time },\n      zIndex: t.zIndex\n    };\n    n(this, Z).info(\"Combinator add sprite\", i);\n    const r = await t.clone();\n    n(this, Z).info(\"Combinator add sprite ready\"), n(this, N).push(\n      Object.assign(r, {\n        main: e.main ?? !1,\n        expired: !1\n      })\n    ), n(this, N).sort((a, o) => a.zIndex - o.zIndex);\n  }\n  /**\n   * 输出视频文件二进制流\n   */\n  output() {\n    if (n(this, N).length === 0) throw Error(\"No sprite added\");\n    const t = n(this, N).find((l) => l.main), e = t != null ? t.time.offset + t.time.duration : Math.max(\n      ...n(this, N).map((l) => l.time.offset + l.time.duration)\n    );\n    if (e === 1 / 0)\n      throw Error(\n        \"Unable to determine the end time, please specify a main sprite, or limit the duration of ImgClip, AudioCli\"\n      );\n    e === -1 && n(this, Z).warn(\n      \"Unable to determine the end time, process value don't update\"\n    ), n(this, Z).info(`start combinate video, maxTime:${e}`);\n    const i = B(this, Xt, bi).call(this, e);\n    let r = performance.now();\n    const a = B(this, Xt, xi).call(this, i, e, {\n      onProgress: (l) => {\n        n(this, Z).debug(\"OutputProgress:\", l), n(this, pt).emit(\"OutputProgress\", l);\n      },\n      onEnded: async () => {\n        await i.flush(), n(this, Z).info(\n          \"===== output ended =====, cost:\",\n          performance.now() - r\n        ), n(this, pt).emit(\"OutputProgress\", 1), this.destroy();\n      },\n      onError: (l) => {\n        n(this, pt).emit(\"error\", l), c(l), this.destroy();\n      }\n    });\n    h(this, xe, () => {\n      a(), i.close(), c();\n    });\n    const { stream: o, stop: c } = oi(\n      i.mp4file,\n      500,\n      this.destroy\n    );\n    return o;\n  }\n  /**\n   * 销毁实例，释放资源\n   */\n  destroy() {\n    var t;\n    n(this, ge) || (h(this, ge, !0), (t = n(this, xe)) == null || t.call(this), n(this, pt).destroy());\n  }\n}\nZ = new WeakMap(), ge = new WeakMap(), N = new WeakMap(), $t = new WeakMap(), be = new WeakMap(), xe = new WeakMap(), Dt = new WeakMap(), Wt = new WeakMap(), pt = new WeakMap(), Xt = new WeakSet(), bi = function(t) {\n  const { fps: e, width: i, height: r, videoCodec: a, bitrate: o, audio: c, metaDataTags: l } = n(this, Dt);\n  return Ai({\n    video: n(this, Wt) ? {\n      width: i,\n      height: r,\n      expectFPS: e,\n      codec: a,\n      bitrate: o,\n      __unsafe_hardwareAcceleration__: n(this, Dt).__unsafe_hardwareAcceleration__\n    } : null,\n    audio: c === !1 ? null : {\n      codec: \"aac\",\n      sampleRate: T.sampleRate,\n      channelCount: T.channelCount\n    },\n    duration: t,\n    metaDataTags: l\n  });\n}, xi = function(t, e, {\n  onProgress: i,\n  onEnded: r,\n  onError: a\n}) {\n  let o = 0;\n  const c = { aborted: !1 };\n  let l = null;\n  (async () => {\n    const { fps: p, bgColor: x, audio: f } = n(this, Dt), y = Math.round(1e6 / p), g = n(this, be), b = gn({\n      ctx: g,\n      bgColor: x,\n      sprites: n(this, N),\n      aborter: c\n    }), C = bn({\n      remux: t,\n      ctx: g,\n      cvs: n(this, $t),\n      outputAudio: f,\n      hasVideoTrack: n(this, Wt),\n      timeSlice: y,\n      fps: p\n    });\n    let v = 0;\n    for (; ; ) {\n      if (l != null) return;\n      if (c.aborted || e !== -1 && v > e || n(this, N).length === 0) {\n        w(), await r();\n        return;\n      }\n      o = v / e;\n      const { audios: k, mainSprDone: H } = await b(v);\n      if (H) {\n        w(), await r();\n        return;\n      }\n      if (c.aborted) return;\n      C(v, k), v += y, await gi(t.getEncodeQueueSize);\n    }\n  })().catch((p) => {\n    l = p, n(this, Z).error(p), w(), a(p);\n  });\n  const u = setInterval(() => {\n    i(o);\n  }, 500), w = () => {\n    c.aborted || (c.aborted = !0, clearInterval(u), n(this, N).forEach((p) => p.destroy()));\n  };\n  return w;\n};\nfunction gn(s) {\n  const { ctx: t, bgColor: e, sprites: i, aborter: r } = s, { width: a, height: o } = t.canvas;\n  return async (c) => {\n    t.fillStyle = e, t.fillRect(0, 0, a, o);\n    const l = [];\n    let m = !1;\n    for (const u of i) {\n      if (r.aborted) break;\n      if (c < u.time.offset || u.expired) continue;\n      t.save();\n      const { audio: w, done: p } = await u.offscreenRender(t, c - u.time.offset);\n      l.push(w), t.restore(), (u.time.duration > 0 && c > u.time.offset + u.time.duration || p) && (u.main && (m = !0), u.destroy(), u.expired = !0);\n    }\n    return {\n      audios: l,\n      mainSprDone: m\n    };\n  };\n}\nfunction bn(s) {\n  const { ctx: t, cvs: e, outputAudio: i, remux: r, hasVideoTrack: a, timeSlice: o } = s, { width: c, height: l } = e;\n  let m = 0;\n  const u = Math.floor(3 * s.fps), w = xn(1024);\n  return (p, x) => {\n    if (i !== !1)\n      for (const f of w(p, x)) r.encodeAudio(f);\n    if (a) {\n      const f = new VideoFrame(e, {\n        duration: o,\n        timestamp: p\n      });\n      r.encodeVideo(f, {\n        keyFrame: m % u === 0\n      }), t.resetTransform(), t.clearRect(0, 0, c, l), m += 1;\n    }\n  };\n}\nfunction xn(s) {\n  const t = s * T.channelCount, e = new Float32Array(t * 3);\n  let i = 0, r = 0;\n  const a = s / T.sampleRate * 1e6, o = new Float32Array(t), c = (l) => {\n    let m = 0;\n    const u = Math.floor(i / t), w = [];\n    for (let p = 0; p < u; p++)\n      w.push(\n        new AudioData({\n          timestamp: r,\n          numberOfChannels: T.channelCount,\n          numberOfFrames: s,\n          sampleRate: T.sampleRate,\n          format: \"f32\",\n          data: e.subarray(m, m + t)\n        })\n      ), m += t, r += a;\n    for (e.set(e.subarray(m, i), 0), i -= m; l - r > a; )\n      w.push(\n        new AudioData({\n          timestamp: r,\n          numberOfChannels: T.channelCount,\n          numberOfFrames: s,\n          sampleRate: T.sampleRate,\n          format: \"f32\",\n          data: o\n        })\n      ), r += a;\n    return w;\n  };\n  return (l, m) => {\n    var w, p;\n    const u = Math.max(...m.map((x) => {\n      var f;\n      return ((f = x[0]) == null ? void 0 : f.length) ?? 0;\n    }));\n    for (let x = 0; x < u; x++) {\n      let f = 0, y = 0;\n      for (let g = 0; g < m.length; g++) {\n        const b = ((w = m[g][0]) == null ? void 0 : w[x]) ?? 0, C = ((p = m[g][1]) == null ? void 0 : p[x]) ?? b;\n        f += b, y += C;\n      }\n      e[i] = f, e[i + 1] = y, i += 2;\n    }\n    return c(l);\n  };\n}\nfunction Cn(s, t) {\n  return s.reduce(\n    (e, i) => (e[i] = t[i], e),\n    {}\n  );\n}\nexport {\n  ti as AudioClip,\n  En as Combinator,\n  ii as EmbedSubtitlesClip,\n  Ze as ImgClip,\n  Bn as Log,\n  Qe as MP4Clip,\n  ei as MediaStreamClip,\n  ri as OffscreenSprite,\n  Oe as Rect,\n  ai as VisibleSprite,\n  Rn as createChromakey,\n  tn as fastConcatMP4,\n  In as fixFMP4Duration,\n  Fn as mixinMP4AndAudio,\n  kn as renderTxt2ImgBitmap\n};\n//# sourceMappingURL=av-cliper.js.map\n","// 在主线程中执行的 工具函数\n\n/**\n * 创建一个新的 HTML 元素\n * @param tagName - 要创建的元素的标签名\n * @returns 新创建的 HTML 元素\n */\nexport function createEl(tagName: string): HTMLElement {\n  return document.createElement(tagName);\n}\n\n/**\n * 将文本渲染为图片\n * @param txt - 要渲染的文本\n * @param cssText - 应用于文本的 CSS 样式\n * @returns 渲染后的图片元素\n */\nexport function renderTxt2Img(txt: string, cssText: string): HTMLImageElement {\n  const div = createEl('pre');\n  div.style.cssText = `margin: 0; ${cssText}; visibility: hidden; position: fixed;`;\n  div.textContent = txt;\n  document.body.appendChild(div);\n\n  const { width, height } = div.getBoundingClientRect();\n  // 计算出 rect，立即从dom移除\n  div.remove();\n  div.style.visibility = 'visible';\n\n  const img = new Image();\n  img.width = width;\n  img.height = height;\n  const svgStr = `\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\">\n    <foreignObject width=\"100%\" height=\"100%\">\n        <div xmlns=\"http://www.w3.org/1999/xhtml\">${div.outerHTML}</div>\n    </foreignObject>\n    </svg>\n  `\n    .replace(/\\t/g, '')\n    .replace(/#/g, '%23');\n\n  img.src = `data:image/svg+xml;charset=utf-8,${svgStr}`;\n  return img;\n}\n\n/**\n * 将文本渲染为 {@link ImageBitmap}，用来创建 {@link ImgClip}\n * @param txt - 要渲染的文本\n * @param cssText - 应用于文本的 CSS 样式\n *\n * @example\n * new ImgClip(\n *   await renderTxt2ImgBitmap(\n *     '水印',\n *    `font-size:40px; color: white; text-shadow: 2px 2px 6px red;`,\n *   )\n * )\n */\nexport async function renderTxt2ImgBitmap(\n  txt: string,\n  cssText: string,\n): Promise<ImageBitmap> {\n  const imgEl = renderTxt2Img(txt, cssText);\n  await new Promise((resolve) => {\n    imgEl.onload = resolve;\n  });\n  const cvs = new OffscreenCanvas(imgEl.width, imgEl.height);\n  const ctx = cvs.getContext('2d');\n  ctx?.drawImage(imgEl, 0, 0, imgEl.width, imgEl.height);\n  return await createImageBitmap(cvs);\n}\n","// 能同时在 worker 和主线程中运行的工具函数\n\nimport { workerTimer } from '@webav/internal-utils';\nimport * as waveResampler from 'wave-resampler';\n\n/**\n * 合并（串联）多个 Float32Array，通常用于合并 PCM 数据\n */\nexport function concatFloat32Array(bufs: Float32Array[]): Float32Array {\n  const rs = new Float32Array(\n    bufs.map((buf) => buf.length).reduce((a, b) => a + b),\n  );\n\n  let offset = 0;\n  for (const buf of bufs) {\n    rs.set(buf, offset);\n    offset += buf.length;\n  }\n\n  return rs;\n}\n\n/**\n * 将小片段的 PCM 合并成一个大片段\n * @param fragments 小片段 PCM，子元素是不同声道的原始 PCM 数据\n */\nexport function concatPCMFragments(\n  fragments: Float32Array[][],\n): Float32Array[] {\n  // fragments: [[chan0, chan1], [chan0, chan1]...]\n  // chanListPCM: [[chan0, chan0...], [chan1, chan1...]]\n  const chanListPCM: Float32Array[][] = [];\n  for (let i = 0; i < fragments.length; i += 1) {\n    for (let j = 0; j < fragments[i].length; j += 1) {\n      if (chanListPCM[j] == null) chanListPCM[j] = [];\n      chanListPCM[j].push(fragments[i][j]);\n    }\n  }\n  // [bigChan0, bigChan1]\n  return chanListPCM.map(concatFloat32Array);\n}\n\n/**\n * 从 AudioData 中提取 PCM 数据的工具函数\n */\nexport function extractPCM4AudioData(ad: AudioData): Float32Array[] {\n  if (ad.format === 'f32-planar') {\n    const rs = [];\n    for (let idx = 0; idx < ad.numberOfChannels; idx += 1) {\n      const chanBufSize = ad.allocationSize({ planeIndex: idx });\n      const chanBuf = new ArrayBuffer(chanBufSize);\n      ad.copyTo(chanBuf, { planeIndex: idx });\n      rs.push(new Float32Array(chanBuf));\n    }\n    return rs;\n  } else if (ad.format === 'f32') {\n    const buf = new ArrayBuffer(ad.allocationSize({ planeIndex: 0 }));\n    ad.copyTo(buf, { planeIndex: 0 });\n    return convertF32ToPlanar(new Float32Array(buf), ad.numberOfChannels);\n  } else if (ad.format === 's16') {\n    const buf = new ArrayBuffer(ad.allocationSize({ planeIndex: 0 }));\n    ad.copyTo(buf, { planeIndex: 0 });\n    return convertS16ToF32Planar(new Int16Array(buf), ad.numberOfChannels);\n  }\n  throw Error('Unsupported audio data format');\n}\n\n/**\n * Convert s16 PCM to f32-planar\n * @param  pcmS16Data - The s16 PCM data.\n * @param  numChannels - Number of audio channels.\n * @returns An array of Float32Array, each containing the audio data for one channel.\n */\nfunction convertS16ToF32Planar(pcmS16Data: Int16Array, numChannels: number) {\n  const numSamples = pcmS16Data.length / numChannels;\n  const planarData = Array.from(\n    { length: numChannels },\n    () => new Float32Array(numSamples),\n  );\n\n  for (let i = 0; i < numSamples; i++) {\n    for (let channel = 0; channel < numChannels; channel++) {\n      const sample = pcmS16Data[i * numChannels + channel];\n      planarData[channel][i] = sample / 32768; // Normalize to range [-1.0, 1.0]\n    }\n  }\n\n  return planarData;\n}\n\nfunction convertF32ToPlanar(pcmF32Data: Float32Array, numChannels: number) {\n  const numSamples = pcmF32Data.length / numChannels;\n  const planarData = Array.from(\n    { length: numChannels },\n    () => new Float32Array(numSamples),\n  );\n\n  for (let i = 0; i < numSamples; i++) {\n    for (let channel = 0; channel < numChannels; channel++) {\n      planarData[channel][i] = pcmF32Data[i * numChannels + channel];\n    }\n  }\n\n  return planarData;\n}\n\n/**\n * 从 AudioBuffer 中提取 PCM\n */\nexport function extractPCM4AudioBuffer(ab: AudioBuffer): Float32Array[] {\n  return Array(ab.numberOfChannels)\n    .fill(0)\n    .map((_, idx) => {\n      return ab.getChannelData(idx);\n    });\n}\n\n/**\n * 调整音频数据的音量\n * @param ad - 要调整的音频对象\n * @param volume - 音量调整系数（0.0 - 1.0）\n * @returns 调整音量后的新音频数据\n */\nexport function adjustAudioDataVolume(ad: AudioData, volume: number) {\n  const data = new Float32Array(\n    concatFloat32Array(extractPCM4AudioData(ad)),\n  ).map((v) => v * volume);\n  const newAd = new AudioData({\n    sampleRate: ad.sampleRate,\n    numberOfChannels: ad.numberOfChannels,\n    timestamp: ad.timestamp,\n    format: ad.format,\n    numberOfFrames: ad.numberOfFrames,\n    data,\n  });\n  ad.close();\n  return newAd;\n}\n\n/**\n * 解码图像流，返回一个视频帧数组。\n *\n * @param stream - 包含图像数据的可读流。\n * @param type - 图像的 MIME 类型，例如 'image/jpeg'。\n *\n * @returns 返回一个 Promise，该 Promise 在解码完成后解析为 {@link VideoFrame} 数组。\n *\n * @see [解码动图](https://webav-tech.github.io/WebAV/demo/1_3-decode-image)\n *\n * @example\n *\n * const frames = await decodeImg(\n *   (await fetch('<gif url>')).body!,\n *   `image/gif`,\n * );\n */\nexport async function decodeImg(\n  stream: ReadableStream<Uint8Array>,\n  type: string,\n): Promise<VideoFrame[]> {\n  const init = {\n    type,\n    data: stream,\n  };\n  const imageDecoder = new ImageDecoder(init);\n\n  await Promise.all([imageDecoder.completed, imageDecoder.tracks.ready]);\n\n  let frameCnt = imageDecoder.tracks.selectedTrack?.frameCount ?? 1;\n\n  const rs: VideoFrame[] = [];\n  for (let i = 0; i < frameCnt; i += 1) {\n    rs.push((await imageDecoder.decode({ frameIndex: i })).image);\n  }\n  return rs;\n}\n\n/**\n * 混合双通道音轨的 PCM 数据，并将多声道并排成一个 Float32Array 输出\n * @param audios - 一个二维数组，每个元素是一个 Float32Array 数组，代表一个音频流的 PCM 数据。\n * 每个 Float32Array 数组的第一个元素是左声道数据，第二个元素（如果有）是右声道数据。\n * 如果只有左声道数据，则右声道将复用左声道数据。\n *\n * @returns 返回一个 Float32Array，返回结果是将这个一个音轨的左右声道并排成 Float32Array。\n *\n * @example\n *\n * const audios = [\n *   [new Float32Array([0.1, 0.2, 0.3]), new Float32Array([0.4, 0.5, 0.6])],\n *   [new Float32Array([0.7, 0.8, 0.9])],\n * ];\n * const mixed = mixinPCM(audios);\n */\nexport function mixinPCM(audios: Float32Array[][]): Float32Array {\n  const maxLen = Math.max(...audios.map((a) => a[0]?.length ?? 0));\n  const data = new Float32Array(maxLen * 2);\n\n  for (let bufIdx = 0; bufIdx < maxLen; bufIdx++) {\n    let chan0 = 0;\n    let chan1 = 0;\n    for (let trackIdx = 0; trackIdx < audios.length; trackIdx++) {\n      const _c0 = audios[trackIdx][0]?.[bufIdx] ?? 0;\n      // 如果是单声道 PCM，第二声道复用第一声道数据\n      const _c1 = audios[trackIdx][1]?.[bufIdx] ?? _c0;\n      chan0 += _c0;\n      chan1 += _c1;\n    }\n    data[bufIdx] = chan0;\n    data[bufIdx + maxLen] = chan1;\n  }\n\n  return data;\n}\n\n/**\n * 对 PCM 音频数据进行重采样。\n *\n * @param pcmData - 一个 Float32Array 数组，每个元素代表一个声道的 PCM 数据。\n * @param curRate - 当前的采样率。\n * @param target - 目标参数对象。\n * @param target.rate - 目标采样率。\n * @param target.chanCount - 目标声道数。\n *\n * @returns 返回一个 Promise，该 Promise 在重采样完成后解析为一个 Float32Array 数组，每个元素代表一个声道的 PCM 数据。\n *\n * @example\n *\n * const pcmData = [new Float32Array([0.1, 0.2, 0.3]), new Float32Array([0.4, 0.5, 0.6])];\n * const curRate = 44100;\n * const target = { rate: 48000, chanCount: 2 };\n * const resampled = await audioResample(pcmData, curRate, target);\n */\nexport async function audioResample(\n  pcmData: Float32Array[],\n  curRate: number,\n  target: {\n    rate: number;\n    chanCount: number;\n  },\n): Promise<Float32Array[]> {\n  const chanCnt = pcmData.length;\n  const emptyPCM = Array(target.chanCount)\n    .fill(0)\n    .map(() => new Float32Array(0));\n  if (chanCnt === 0) return emptyPCM;\n\n  const len = Math.max(...pcmData.map((c) => c.length));\n  if (len === 0) return emptyPCM;\n\n  // The Worker scope does not have access to OfflineAudioContext\n  if (globalThis.OfflineAudioContext == null) {\n    return pcmData.map(\n      (p) =>\n        new Float32Array(\n          waveResampler.resample(p, curRate, target.rate, {\n            method: 'sinc',\n            LPF: false,\n          }),\n        ),\n    );\n  }\n\n  const ctx = new globalThis.OfflineAudioContext(\n    target.chanCount,\n    (len * target.rate) / curRate,\n    target.rate,\n  );\n  const abSource = ctx.createBufferSource();\n  const ab = ctx.createBuffer(chanCnt, len, curRate);\n  pcmData.forEach((d, idx) => ab.copyToChannel(d, idx));\n\n  abSource.buffer = ab;\n  abSource.connect(ctx.destination);\n  abSource.start();\n\n  return extractPCM4AudioBuffer(await ctx.startRendering());\n}\n\n/**\n * 使当前执行环境暂停一段时间。\n * @param time - 暂停的时间，单位为毫秒。\n * @example\n * await sleep(1000);  // 暂停 1 秒\n */\nexport function sleep(time: number): Promise<void> {\n  return new Promise((resolve) => {\n    const stop = workerTimer(() => {\n      stop();\n      resolve();\n    }, time);\n  });\n}\n\n/**\n * 从给定的 Float32Array 中提取一个环形切片，超出边界从 0 开始循环\n *\n * 主要用于截取 PCM 实现循环播放\n *\n * @param data - 输入的 Float32Array。\n * @param start - 切片的开始索引。\n * @param end - 切片的结束索引。\n * @returns - 返回一个新的 Float32Array，包含从 start 到 end 的数据。\n *\n * @example\n * const data = new Float32Array([0, 1, 2, 3, 4, 5]);\n * ringSliceFloat32Array(data, 4, 6); // => Float32Array [4, 5, 0]\n */\nexport function ringSliceFloat32Array(\n  data: Float32Array,\n  start: number,\n  end: number,\n): Float32Array {\n  const cnt = end - start;\n  const rs = new Float32Array(cnt);\n  let i = 0;\n  while (i < cnt) {\n    rs[i] = data[(start + i) % data.length];\n    i += 1;\n  }\n  return rs;\n}\n\n/**\n * 函数节流\n */\nexport function throttle<F extends (...args: any[]) => any>(\n  func: F,\n  wait: number,\n): (...rest: Parameters<F>) => undefined | ReturnType<F> {\n  let lastTime: number;\n  return function (this: any, ...rest) {\n    if (lastTime == null || performance.now() - lastTime > wait) {\n      lastTime = performance.now();\n      return func.apply(this, rest);\n    }\n  };\n}\n\n/**\n * 改变 PCM 数据的播放速率，1 表示正常播放，0.5 表示播放速率减半，2 表示播放速率加倍\n */\nexport function changePCMPlaybackRate(\n  pcmData: Float32Array,\n  playbackRate: number,\n) {\n  // 计算新的采样率\n  const newLength = Math.floor(pcmData.length / playbackRate);\n  const newPcmData = new Float32Array(newLength);\n\n  // 线性插值\n  for (let i = 0; i < newLength; i++) {\n    // 原始数据中的位置\n    const originalIndex = i * playbackRate;\n    const intIndex = Math.floor(originalIndex);\n    const frac = originalIndex - intIndex;\n\n    // 边界检查\n    if (intIndex + 1 < pcmData.length) {\n      newPcmData[i] =\n        pcmData[intIndex] * (1 - frac) + pcmData[intIndex + 1] * frac;\n    } else {\n      newPcmData[i] = pcmData[intIndex]; // 最后一个样本\n    }\n  }\n\n  return newPcmData;\n}\n","interface IClipMeta {\n  width: number;\n  height: number;\n  duration: number;\n}\n\n/**\n * 所有素材需要实现的接口\n *\n * 素材（Clip）是不同数据类型的抽象，给其他模块提供数据\n *\n * WebAV 内置了 {@link MP4Clip}, {@link AudioClip}, {@link ImgClip}, {@link MediaStreamClip} 等常用素材，用于给 {@link Combinator} {@link AVCanvas} 提供数据\n *\n * 你只需实现该接口即可自定义素材，拥有最大的灵活度来生成视频内容，比如动画、转场效果等\n * @see [自定义素材](https://webav-tech.github.io/WebAV/demo/2_6-custom-clip)\n *\n */\nexport interface IClip {\n  /**\n   * 从素材中提取指定时间数据\n   * @param time 时间，单位 微秒\n   */\n  tick: (time: number) => Promise<{\n    video?: VideoFrame | ImageBitmap | null;\n    audio?: Float32Array[];\n    state: 'done' | 'success';\n  }>;\n\n  /**\n   * 当素材准备完成，ready 会切换到 resolved 状态\n   */\n  readonly ready: Promise<IClipMeta>;\n\n  /**\n   * 数据元数据\n   */\n  readonly meta: IClipMeta;\n\n  /**\n   * clone，返回一个新素材\n   */\n  clone: () => Promise<this>;\n\n  /**\n   * 按指定时间切割，返回该时刻前后两个新素材，常用于剪辑场景按时间分割素材\n   *\n   * 该方法不会破坏原素材的数据\n   *\n   * @param time 时间，微秒\n   * @returns\n   */\n  split?: (time: number) => Promise<[this, this]>;\n\n  /**\n   * 销毁实例，释放资源\n   */\n  destroy: () => void;\n}\n\n/**\n * 默认的音频设置，⚠️ 不要变更它的值 ⚠️\n */\nexport const DEFAULT_AUDIO_CONF = {\n  sampleRate: 48000,\n  channelCount: 2,\n  codec: 'mp4a.40.2',\n} as const;\n","import mp4box, {\n  AudioTrackOpts,\n  ESDSBoxParser,\n  MP4ABoxParser,\n  MP4ArrayBuffer,\n  MP4File,\n  MP4Info,\n  MP4Sample,\n  TrakBoxParser,\n  VideoTrackOpts,\n} from '@webav/mp4box.js';\nimport { DEFAULT_AUDIO_CONF } from '../clips';\nimport { file } from 'opfs-tools';\n\nexport function extractFileConfig(file: MP4File, info: MP4Info) {\n  const vTrack = info.videoTracks[0];\n  const rs: {\n    videoTrackConf?: VideoTrackOpts;\n    videoDecoderConf?: Parameters<VideoDecoder['configure']>[0];\n    audioTrackConf?: AudioTrackOpts;\n    audioDecoderConf?: Parameters<AudioDecoder['configure']>[0];\n  } = {};\n  if (vTrack != null) {\n    const videoDesc = parseVideoCodecDesc(file.getTrackById(vTrack.id)).buffer;\n    const { descKey, type } = vTrack.codec.startsWith('avc1')\n      ? { descKey: 'avcDecoderConfigRecord', type: 'avc1' }\n      : vTrack.codec.startsWith('hvc1')\n        ? { descKey: 'hevcDecoderConfigRecord', type: 'hvc1' }\n        : { descKey: '', type: '' };\n    if (descKey !== '') {\n      rs.videoTrackConf = {\n        timescale: vTrack.timescale,\n        duration: vTrack.duration,\n        width: vTrack.video.width,\n        height: vTrack.video.height,\n        brands: info.brands,\n        type,\n        [descKey]: videoDesc,\n      };\n    }\n\n    rs.videoDecoderConf = {\n      codec: vTrack.codec,\n      codedHeight: vTrack.video.height,\n      codedWidth: vTrack.video.width,\n      description: videoDesc,\n    };\n  }\n\n  const aTrack = info.audioTracks[0];\n  if (aTrack != null) {\n    const esdsBox = getESDSBoxFromMP4File(file);\n    rs.audioTrackConf = {\n      timescale: aTrack.timescale,\n      samplerate: aTrack.audio.sample_rate,\n      channel_count: aTrack.audio.channel_count,\n      hdlr: 'soun',\n      type: aTrack.codec.startsWith('mp4a') ? 'mp4a' : aTrack.codec,\n      description: getESDSBoxFromMP4File(file),\n    };\n    rs.audioDecoderConf = {\n      codec: aTrack.codec.startsWith('mp4a')\n        ? DEFAULT_AUDIO_CONF.codec\n        : aTrack.codec,\n      numberOfChannels: aTrack.audio.channel_count,\n      sampleRate: aTrack.audio.sample_rate,\n      ...(esdsBox == null ? {} : parseAudioInfo4ESDSBox(esdsBox)),\n    };\n  }\n  return rs;\n}\n\n// track is H.264, H.265 or VPX.\nfunction parseVideoCodecDesc(track: TrakBoxParser): Uint8Array {\n  for (const entry of track.mdia.minf.stbl.stsd.entries) {\n    // @ts-expect-error\n    const box = entry.avcC ?? entry.hvcC ?? entry.av1C ?? entry.vpcC;\n    if (box != null) {\n      const stream = new mp4box.DataStream(\n        undefined,\n        0,\n        mp4box.DataStream.BIG_ENDIAN,\n      );\n      box.write(stream);\n      return new Uint8Array(stream.buffer.slice(8)); // Remove the box header.\n    }\n  }\n  throw Error('avcC, hvcC, av1C or VPX not found');\n}\n\nfunction getESDSBoxFromMP4File(file: MP4File, codec = 'mp4a') {\n  const mp4aBox = file.moov?.traks\n    .map((t) => t.mdia.minf.stbl.stsd.entries)\n    .flat()\n    .find(({ type }) => type === codec) as MP4ABoxParser;\n\n  return mp4aBox?.esds;\n}\n\n// 解决封装层音频信息标识错误，导致解码异常\nfunction parseAudioInfo4ESDSBox(esds: ESDSBoxParser) {\n  const decoderConf = esds.esd.descs[0]?.descs[0];\n  if (decoderConf == null) return {};\n\n  const [byte1, byte2] = decoderConf.data;\n  // sampleRate 是第一字节后 3bit + 第二字节前 1bit\n  const sampleRateIdx = ((byte1 & 0x07) << 1) + (byte2 >> 7);\n  // numberOfChannels 是第二字节 [2, 5] 4bit\n  const numberOfChannels = (byte2 & 0x7f) >> 3;\n  const sampleRateEnum = [\n    96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025,\n    8000, 7350,\n  ] as const;\n  return {\n    sampleRate: sampleRateEnum[sampleRateIdx],\n    numberOfChannels,\n  };\n}\n\n/**\n * 快速解析 mp4 文件，如果是非 fMP4 格式，会优先解析 moov box（略过 mdat）避免占用过多内存\n */\nexport async function quickParseMP4File(\n  reader: Awaited<ReturnType<ReturnType<typeof file>['createReader']>>,\n  onReady: (data: { mp4boxFile: MP4File; info: MP4Info }) => void,\n  onSamples: (\n    id: number,\n    sampleType: 'video' | 'audio',\n    samples: MP4Sample[],\n  ) => void,\n) {\n  const mp4boxFile = mp4box.createFile(false);\n  mp4boxFile.onReady = (info) => {\n    onReady({ mp4boxFile, info });\n    const vTrackId = info.videoTracks[0]?.id;\n    if (vTrackId != null)\n      mp4boxFile.setExtractionOptions(vTrackId, 'video', { nbSamples: 100 });\n\n    const aTrackId = info.audioTracks[0]?.id;\n    if (aTrackId != null)\n      mp4boxFile.setExtractionOptions(aTrackId, 'audio', { nbSamples: 100 });\n\n    mp4boxFile.start();\n  };\n  mp4boxFile.onSamples = onSamples;\n\n  await parse();\n\n  async function parse() {\n    let cursor = 0;\n    const maxReadSize = 30 * 1024 * 1024;\n    while (true) {\n      const data = (await reader.read(maxReadSize, {\n        at: cursor,\n      })) as MP4ArrayBuffer;\n      if (data.byteLength === 0) break;\n      data.fileStart = cursor;\n      const nextPos = mp4boxFile.appendBuffer(data);\n      if (nextPos == null) break;\n      cursor = nextPos;\n    }\n\n    mp4boxFile.stop();\n  }\n}\n","import { MP4Info, MP4Sample } from '@webav/mp4box.js';\nimport { audioResample, extractPCM4AudioData, sleep } from '../av-utils';\nimport { Log } from '@webav/internal-utils';\nimport {\n  extractFileConfig,\n  quickParseMP4File,\n} from '../mp4-utils/mp4box-utils';\nimport { DEFAULT_AUDIO_CONF, IClip } from './iclip';\nimport { file, tmpfile, write } from 'opfs-tools';\n\nlet CLIP_ID = 0;\n\ntype OPFSToolFile = ReturnType<typeof file>;\nfunction isOTFile(obj: any): obj is OPFSToolFile {\n  return obj.kind === 'file' && obj.createReader instanceof Function;\n}\n\n// 用于内部创建 MP4Clip 实例\ntype MPClipCloneArgs = Awaited<ReturnType<typeof mp4FileToSamples>> & {\n  localFile: OPFSToolFile;\n};\n\ninterface MP4DecoderConf {\n  video: VideoDecoderConfig | null;\n  audio: AudioDecoderConfig | null;\n}\n\ninterface MP4ClipOpts {\n  audio?: boolean | { volume: number };\n  /**\n   * 不安全，随时可能废弃\n   */\n  __unsafe_hardwareAcceleration__?: HardwarePreference;\n}\n\ntype ExtMP4Sample = Omit<MP4Sample, 'data'> & {\n  is_idr: boolean;\n  deleted?: boolean;\n  data: null | Uint8Array;\n};\n\ntype LocalFileReader = Awaited<ReturnType<OPFSToolFile['createReader']>>;\n\ntype ThumbnailOpts = {\n  start: number;\n  end: number;\n  step: number;\n};\n\n/**\n * MP4 素材，解析 MP4 文件，使用 {@link MP4Clip.tick} 按需解码指定时间的图像帧\n *\n * 可用于实现视频抽帧、生成缩略图、视频编辑等功能\n *\n * @example\n * new MP4Clip((await fetch('<mp4 url>')).body)\n * new MP4Clip(mp4File.stream())\n *\n * @see {@link Combinator}\n * @see [AVCanvas](../../av-canvas/classes/AVCanvas.html)\n *\n * @see [解码播放视频](https://webav-tech.github.io/WebAV/demo/1_1-decode-video)\n */\nexport class MP4Clip implements IClip {\n  #insId = CLIP_ID++;\n\n  #log = Log.create(`MP4Clip id:${this.#insId},`);\n\n  ready: IClip['ready'];\n\n  #destroyed = false;\n\n  #meta = {\n    // 微秒\n    duration: 0,\n    width: 0,\n    height: 0,\n    audioSampleRate: 0,\n    audioChanCount: 0,\n  };\n\n  get meta() {\n    return { ...this.#meta };\n  }\n\n  #localFile: OPFSToolFile;\n\n  #headerBoxPos: Array<{ start: number; size: number }> = [];\n  /**\n   * 提供视频头（box: ftyp, moov）的二进制数据\n   * 使用任意 mp4 demxer 解析即可获得详细的视频信息\n   * 单元测试包含使用 mp4box.js 解析示例代码\n   */\n  async getFileHeaderBinData() {\n    await this.ready;\n    const oFile = await this.#localFile.getOriginFile();\n    if (oFile == null) throw Error('MP4Clip localFile is not origin file');\n\n    return await new Blob(\n      this.#headerBoxPos.map(({ start, size }) =>\n        oFile.slice(start, start + size),\n      ),\n    ).arrayBuffer();\n  }\n\n  #volume = 1;\n\n  #videoSamples: ExtMP4Sample[] = [];\n\n  #audioSamples: ExtMP4Sample[] = [];\n\n  #videoFrameFinder: VideoFrameFinder | null = null;\n  #audioFrameFinder: AudioFrameFinder | null = null;\n\n  #decoderConf: {\n    video: VideoDecoderConfig | null;\n    audio: AudioDecoderConfig | null;\n  } = {\n    video: null,\n    audio: null,\n  };\n\n  #opts: MP4ClipOpts = { audio: true };\n\n  constructor(\n    source: OPFSToolFile | ReadableStream<Uint8Array> | MPClipCloneArgs,\n    opts: MP4ClipOpts = {},\n  ) {\n    if (\n      !(source instanceof ReadableStream) &&\n      !isOTFile(source) &&\n      !Array.isArray(source.videoSamples)\n    ) {\n      throw Error('Illegal argument');\n    }\n\n    this.#opts = { audio: true, ...opts };\n    this.#volume =\n      typeof opts.audio === 'object' && 'volume' in opts.audio\n        ? opts.audio.volume\n        : 1;\n\n    const initByStream = async (s: ReadableStream) => {\n      await write(this.#localFile, s);\n      return this.#localFile;\n    };\n\n    this.#localFile = isOTFile(source)\n      ? source\n      : 'localFile' in source\n        ? source.localFile // from clone\n        : tmpfile();\n\n    this.ready = (\n      source instanceof ReadableStream\n        ? initByStream(source).then((otFile) =>\n            mp4FileToSamples(otFile, this.#opts),\n          )\n        : isOTFile(source)\n          ? mp4FileToSamples(source, this.#opts)\n          : Promise.resolve(source)\n    ).then(\n      async ({ videoSamples, audioSamples, decoderConf, headerBoxPos }) => {\n        this.#videoSamples = videoSamples;\n        this.#audioSamples = audioSamples;\n        this.#decoderConf = decoderConf;\n        this.#headerBoxPos = headerBoxPos;\n\n        const { videoFrameFinder, audioFrameFinder } = genDecoder(\n          {\n            video:\n              decoderConf.video == null\n                ? null\n                : {\n                    ...decoderConf.video,\n                    hardwareAcceleration:\n                      this.#opts.__unsafe_hardwareAcceleration__,\n                  },\n            audio: decoderConf.audio,\n          },\n          await this.#localFile.createReader(),\n          videoSamples,\n          audioSamples,\n          this.#opts.audio !== false ? this.#volume : 0,\n        );\n        this.#videoFrameFinder = videoFrameFinder;\n        this.#audioFrameFinder = audioFrameFinder;\n\n        this.#meta = genMeta(decoderConf, videoSamples, audioSamples);\n        this.#log.info('MP4Clip meta:', this.#meta);\n        return { ...this.#meta };\n      },\n    );\n  }\n\n  /**\n   * 拦截 {@link MP4Clip.tick} 方法返回的数据，用于对图像、音频数据二次处理\n   * @param time 调用 tick 的时间\n   * @param tickRet tick 返回的数据\n   *\n   * @see [移除视频绿幕背景](https://webav-tech.github.io/WebAV/demo/3_2-chromakey-video)\n   */\n  tickInterceptor: <T extends Awaited<ReturnType<MP4Clip['tick']>>>(\n    time: number,\n    tickRet: T,\n  ) => Promise<T> = async (_, tickRet) => tickRet;\n\n  /**\n   * 获取素材指定时刻的图像帧、音频数据\n   * @param time 微秒\n   */\n  async tick(time: number): Promise<{\n    video?: VideoFrame;\n    audio: Float32Array[];\n    state: 'success' | 'done';\n  }> {\n    if (time >= this.#meta.duration) {\n      return await this.tickInterceptor(time, {\n        audio: (await this.#audioFrameFinder?.find(time)) ?? [],\n        state: 'done',\n      });\n    }\n\n    const [audio, video] = await Promise.all([\n      this.#audioFrameFinder?.find(time) ?? [],\n      this.#videoFrameFinder?.find(time),\n    ]);\n\n    if (video == null) {\n      return await this.tickInterceptor(time, {\n        audio,\n        state: 'success',\n      });\n    }\n\n    return await this.tickInterceptor(time, {\n      video,\n      audio,\n      state: 'success',\n    });\n  }\n\n  #thumbAborter = new AbortController();\n  /**\n   * 生成缩略图，默认每个关键帧生成一个 100px 宽度的缩略图。\n   *\n   * @param imgWidth 缩略图宽度，默认 100\n   * @param opts Partial<ThumbnailOpts>\n   * @returns Promise<Array<{ ts: number; img: Blob }>>\n   */\n  async thumbnails(\n    imgWidth = 100,\n    opts?: Partial<ThumbnailOpts>,\n  ): Promise<Array<{ ts: number; img: Blob }>> {\n    this.#thumbAborter.abort();\n    this.#thumbAborter = new AbortController();\n    const aborterSignal = this.#thumbAborter.signal;\n\n    await this.ready;\n    const abortMsg = 'generate thumbnails aborted';\n    if (aborterSignal.aborted) throw Error(abortMsg);\n\n    const { width, height } = this.#meta;\n    const convtr = createVF2BlobConvtr(\n      imgWidth,\n      Math.round(height * (imgWidth / width)),\n      { quality: 0.1, type: 'image/png' },\n    );\n\n    return new Promise<Array<{ ts: number; img: Blob }>>(\n      async (resolve, reject) => {\n        let pngPromises: Array<{ ts: number; img: Promise<Blob> }> = [];\n        const vc = this.#decoderConf.video;\n        if (vc == null || this.#videoSamples.length === 0) {\n          resolver();\n          return;\n        }\n        aborterSignal.addEventListener('abort', () => {\n          reject(Error(abortMsg));\n        });\n\n        async function resolver() {\n          if (aborterSignal.aborted) return;\n          resolve(\n            await Promise.all(\n              pngPromises.map(async (it) => ({\n                ts: it.ts,\n                img: await it.img,\n              })),\n            ),\n          );\n        }\n\n        function pushPngPromise(vf: VideoFrame) {\n          pngPromises.push({\n            ts: vf.timestamp,\n            img: convtr(vf),\n          });\n        }\n\n        const { start = 0, end = this.#meta.duration, step } = opts ?? {};\n        if (step) {\n          let cur = start;\n          // 创建一个新的 VideoFrameFinder 实例，避免与 tick 方法共用而导致冲突\n          const videoFrameFinder = new VideoFrameFinder(\n            await this.#localFile.createReader(),\n            this.#videoSamples,\n            {\n              ...vc,\n              hardwareAcceleration: this.#opts.__unsafe_hardwareAcceleration__,\n            },\n          );\n          while (cur <= end && !aborterSignal.aborted) {\n            const vf = await videoFrameFinder.find(cur);\n            if (vf) pushPngPromise(vf);\n            cur += step;\n          }\n          videoFrameFinder.destroy();\n          resolver();\n        } else {\n          await thumbnailByKeyFrame(\n            this.#videoSamples,\n            this.#localFile,\n            vc,\n            aborterSignal,\n            { start, end },\n            (vf, done) => {\n              if (vf != null) pushPngPromise(vf);\n              if (done) resolver();\n            },\n          );\n        }\n      },\n    );\n  }\n\n  async split(time: number) {\n    await this.ready;\n\n    if (time <= 0 || time >= this.#meta.duration)\n      throw Error('\"time\" out of bounds');\n\n    const [preVideoSlice, postVideoSlice] = splitVideoSampleByTime(\n      this.#videoSamples,\n      time,\n    );\n    const [preAudioSlice, postAudioSlice] = splitAudioSampleByTime(\n      this.#audioSamples,\n      time,\n    );\n    const preClip = new MP4Clip(\n      {\n        localFile: this.#localFile,\n        videoSamples: preVideoSlice ?? [],\n        audioSamples: preAudioSlice ?? [],\n        decoderConf: this.#decoderConf,\n        headerBoxPos: this.#headerBoxPos,\n      },\n      this.#opts,\n    );\n    const postClip = new MP4Clip(\n      {\n        localFile: this.#localFile,\n        videoSamples: postVideoSlice ?? [],\n        audioSamples: postAudioSlice ?? [],\n        decoderConf: this.#decoderConf,\n        headerBoxPos: this.#headerBoxPos,\n      },\n      this.#opts,\n    );\n    await Promise.all([preClip.ready, postClip.ready]);\n\n    return [preClip, postClip] as [this, this];\n  }\n\n  async clone() {\n    await this.ready;\n    const clip = new MP4Clip(\n      {\n        localFile: this.#localFile,\n        videoSamples: [...this.#videoSamples],\n        audioSamples: [...this.#audioSamples],\n        decoderConf: this.#decoderConf,\n        headerBoxPos: this.#headerBoxPos,\n      },\n      this.#opts,\n    );\n    await clip.ready;\n    clip.tickInterceptor = this.tickInterceptor;\n    return clip as this;\n  }\n\n  /**\n   * 拆分 MP4Clip 为仅包含视频轨道和音频轨道的 MP4Clip\n   * @returns Mp4CLip[]\n   */\n  async splitTrack() {\n    await this.ready;\n    const clips: MP4Clip[] = [];\n    if (this.#videoSamples.length > 0) {\n      const videoClip = new MP4Clip(\n        {\n          localFile: this.#localFile,\n          videoSamples: [...this.#videoSamples],\n          audioSamples: [],\n          decoderConf: {\n            video: this.#decoderConf.video,\n            audio: null,\n          },\n          headerBoxPos: this.#headerBoxPos,\n        },\n        this.#opts,\n      );\n      await videoClip.ready;\n      videoClip.tickInterceptor = this.tickInterceptor;\n      clips.push(videoClip);\n    }\n    if (this.#audioSamples.length > 0) {\n      const audioClip = new MP4Clip(\n        {\n          localFile: this.#localFile,\n          videoSamples: [],\n          audioSamples: [...this.#audioSamples],\n          decoderConf: {\n            audio: this.#decoderConf.audio,\n            video: null,\n          },\n          headerBoxPos: this.#headerBoxPos,\n        },\n        this.#opts,\n      );\n      await audioClip.ready;\n      audioClip.tickInterceptor = this.tickInterceptor;\n      clips.push(audioClip);\n    }\n\n    return clips;\n  }\n\n  destroy(): void {\n    if (this.#destroyed) return;\n    this.#log.info('MP4Clip destroy');\n    this.#destroyed = true;\n\n    this.#videoFrameFinder?.destroy();\n    this.#audioFrameFinder?.destroy();\n  }\n}\n\nfunction genMeta(\n  decoderConf: MP4DecoderConf,\n  videoSamples: ExtMP4Sample[],\n  audioSamples: ExtMP4Sample[],\n) {\n  const meta = {\n    duration: 0,\n    width: 0,\n    height: 0,\n    audioSampleRate: 0,\n    audioChanCount: 0,\n  };\n  if (decoderConf.video != null && videoSamples.length > 0) {\n    meta.width = decoderConf.video.codedWidth ?? 0;\n    meta.height = decoderConf.video.codedHeight ?? 0;\n  }\n  if (decoderConf.audio != null && audioSamples.length > 0) {\n    meta.audioSampleRate = DEFAULT_AUDIO_CONF.sampleRate;\n    meta.audioChanCount = DEFAULT_AUDIO_CONF.channelCount;\n  }\n\n  let vDuration = 0;\n  let aDuration = 0;\n  if (videoSamples.length > 0) {\n    for (let i = videoSamples.length - 1; i >= 0; i--) {\n      const s = videoSamples[i];\n      if (s.deleted) continue;\n      vDuration = s.cts + s.duration;\n      break;\n    }\n  }\n  if (audioSamples.length > 0) {\n    const lastSampele = audioSamples.at(-1)!;\n    aDuration = lastSampele.cts + lastSampele.duration;\n  }\n  meta.duration = Math.max(vDuration, aDuration);\n\n  return meta;\n}\n\nfunction genDecoder(\n  decoderConf: MP4DecoderConf,\n  localFileReader: LocalFileReader,\n  videoSamples: ExtMP4Sample[],\n  audioSamples: ExtMP4Sample[],\n  volume: number,\n) {\n  return {\n    audioFrameFinder:\n      volume === 0 || decoderConf.audio == null || audioSamples.length === 0\n        ? null\n        : new AudioFrameFinder(\n            localFileReader,\n            audioSamples,\n            decoderConf.audio,\n            {\n              volume,\n              targetSampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n            },\n          ),\n    videoFrameFinder:\n      decoderConf.video == null || videoSamples.length === 0\n        ? null\n        : new VideoFrameFinder(\n            localFileReader,\n            videoSamples,\n            decoderConf.video,\n          ),\n  };\n}\n\nasync function mp4FileToSamples(otFile: OPFSToolFile, opts: MP4ClipOpts = {}) {\n  let mp4Info: MP4Info | null = null;\n  const decoderConf: MP4DecoderConf = { video: null, audio: null };\n  let videoSamples: ExtMP4Sample[] = [];\n  let audioSamples: ExtMP4Sample[] = [];\n  let headerBoxPos: Array<{ start: number; size: number }> = [];\n\n  let videoDeltaTS = -1;\n  let audioDeltaTS = -1;\n  const reader = await otFile.createReader();\n  await quickParseMP4File(\n    reader,\n    (data) => {\n      mp4Info = data.info;\n      const ftyp = data.mp4boxFile.ftyp!;\n      headerBoxPos.push({ start: ftyp.start, size: ftyp.size });\n      const moov = data.mp4boxFile.moov!;\n      headerBoxPos.push({ start: moov.start, size: moov.size });\n\n      let { videoDecoderConf: vc, audioDecoderConf: ac } = extractFileConfig(\n        data.mp4boxFile,\n        data.info,\n      );\n      decoderConf.video = vc ?? null;\n      decoderConf.audio = ac ?? null;\n      if (vc == null && ac == null) {\n        Log.error('MP4Clip no video and audio track');\n      }\n      Log.info(\n        'mp4BoxFile moov ready',\n        {\n          ...data.info,\n          tracks: null,\n          videoTracks: null,\n          audioTracks: null,\n        },\n        decoderConf,\n      );\n    },\n    (_, type, samples) => {\n      if (type === 'video') {\n        if (videoDeltaTS === -1) videoDeltaTS = samples[0].dts;\n        for (const s of samples) {\n          videoSamples.push(normalizeTimescale(s, videoDeltaTS, 'video'));\n        }\n      } else if (type === 'audio' && opts.audio) {\n        if (audioDeltaTS === -1) audioDeltaTS = samples[0].dts;\n        for (const s of samples) {\n          audioSamples.push(normalizeTimescale(s, audioDeltaTS, 'audio'));\n        }\n      }\n    },\n  );\n  await reader.close();\n\n  const lastSampele = videoSamples.at(-1) ?? audioSamples.at(-1);\n  if (mp4Info == null) {\n    throw Error('MP4Clip stream is done, but not emit ready');\n  } else if (lastSampele == null) {\n    throw Error('MP4Clip stream not contain any sample');\n  }\n  // 修复首帧黑帧\n  fixFirstBlackFrame(videoSamples);\n  Log.info('mp4 stream parsed');\n  return {\n    videoSamples,\n    audioSamples,\n    decoderConf,\n    headerBoxPos,\n  };\n\n  function normalizeTimescale(\n    s: MP4Sample,\n    delta = 0,\n    sampleType: 'video' | 'audio',\n  ) {\n    // todo: perf 丢弃多余字段，小尺寸对象性能更好\n    const idrOffset =\n      sampleType === 'video' && s.is_sync\n        ? idrNALUOffset(s.data, s.description.type)\n        : -1;\n    let offset = s.offset;\n    let size = s.size;\n    if (idrOffset >= 0) {\n      // 当 IDR 帧前面携带 SEI 数据可能导致解码失败\n      // 所以此处通过控制 offset、size 字段 跳过 SEI 数据\n      offset += idrOffset;\n      size -= idrOffset;\n    }\n    return {\n      ...s,\n      is_idr: idrOffset >= 0,\n      offset,\n      size,\n      cts: ((s.cts - delta) / s.timescale) * 1e6,\n      dts: ((s.dts - delta) / s.timescale) * 1e6,\n      duration: (s.duration / s.timescale) * 1e6,\n      timescale: 1e6,\n      // 音频数据量可控，直接保存在内存中\n      data: sampleType === 'video' ? null : s.data,\n    };\n  }\n}\n\nclass VideoFrameFinder {\n  #dec: VideoDecoder | null = null;\n  constructor(\n    public localFileReader: LocalFileReader,\n    public samples: ExtMP4Sample[],\n    public conf: VideoDecoderConfig,\n  ) {}\n\n  #ts = 0;\n  #curAborter = { abort: false, st: performance.now() };\n  find = async (time: number): Promise<VideoFrame | null> => {\n    if (\n      this.#dec == null ||\n      this.#dec.state === 'closed' ||\n      time <= this.#ts ||\n      time - this.#ts > 3e6\n    ) {\n      this.#reset(time);\n    }\n\n    this.#curAborter.abort = true;\n    this.#ts = time;\n\n    this.#curAborter = { abort: false, st: performance.now() };\n    const vf = await this.#parseFrame(time, this.#dec, this.#curAborter);\n    this.#sleepCnt = 0;\n    return vf;\n  };\n\n  // fix VideoFrame duration is null\n  #lastVfDur = 0;\n\n  #downgradeSoftDecode = false;\n  #videoDecCusorIdx = 0;\n  #videoFrames: VideoFrame[] = [];\n  #outputFrameCnt = 0;\n  #inputChunkCnt = 0;\n  #sleepCnt = 0;\n  #predecodeErr = false;\n  #parseFrame = async (\n    time: number,\n    dec: VideoDecoder | null,\n    aborter: { abort: boolean; st: number },\n  ): Promise<VideoFrame | null> => {\n    if (dec == null || dec.state === 'closed' || aborter.abort) return null;\n\n    if (this.#videoFrames.length > 0) {\n      const vf = this.#videoFrames[0];\n      if (time < vf.timestamp) return null;\n      // 弹出第一帧\n      this.#videoFrames.shift();\n      // 第一帧过期，找下一帧\n      if (time > vf.timestamp + (vf.duration ?? 0)) {\n        vf.close();\n        return await this.#parseFrame(time, dec, aborter);\n      }\n\n      if (!this.#predecodeErr && this.#videoFrames.length < 10) {\n        // 预解码 避免等待\n        this.#startDecode(dec).catch((err) => {\n          this.#predecodeErr = true;\n          this.#reset(time);\n          throw err;\n        });\n      }\n      // 符合期望\n      return vf;\n    }\n\n    // 缺少帧数据\n    if (\n      this.#decoding ||\n      (this.#outputFrameCnt < this.#inputChunkCnt && dec.decodeQueueSize > 0)\n    ) {\n      if (performance.now() - aborter.st > 6e3) {\n        throw Error(\n          `MP4Clip.tick video timeout, ${JSON.stringify(this.#getState())}`,\n        );\n      }\n      // 解码中，等待，然后重试\n      this.#sleepCnt += 1;\n      await sleep(15);\n    } else if (this.#videoDecCusorIdx >= this.samples.length) {\n      // decode completed\n      return null;\n    } else {\n      try {\n        await this.#startDecode(dec);\n      } catch (err) {\n        this.#reset(time);\n        throw err;\n      }\n    }\n    return await this.#parseFrame(time, dec, aborter);\n  };\n\n  #decoding = false;\n  #startDecode = async (dec: VideoDecoder) => {\n    if (this.#decoding || dec.decodeQueueSize > 600) return;\n\n    // 启动解码任务，然后重试\n    let endIdx = this.#videoDecCusorIdx + 1;\n    if (endIdx > this.samples.length) return;\n\n    this.#decoding = true;\n    // 该 GoP 时间区间有时间匹配，且未被删除的帧\n    let hasValidFrame = false;\n    for (; endIdx < this.samples.length; endIdx++) {\n      const s = this.samples[endIdx];\n      if (!hasValidFrame && !s.deleted) {\n        hasValidFrame = true;\n      }\n      // 找一个 GoP，所以是下一个 IDR 帧结束\n      if (s.is_idr) break;\n    }\n\n    if (hasValidFrame) {\n      const samples = this.samples.slice(this.#videoDecCusorIdx, endIdx);\n      if (samples[0]?.is_idr !== true) {\n        Log.warn('First sample not idr frame');\n      } else {\n        const readStarTime = performance.now();\n        const chunks = await videosamples2Chunks(samples, this.localFileReader);\n\n        const readCost = performance.now() - readStarTime;\n        if (readCost > 1000) {\n          const first = samples[0];\n          const last = samples.at(-1)!;\n          const rangSize = last.offset + last.size - first.offset;\n          Log.warn(\n            `Read video samples time cost: ${Math.round(readCost)}ms, file chunk size: ${rangSize}`,\n          );\n        }\n        // Wait for the previous asynchronous operation to complete, at which point the task may have already been terminated\n        if (dec.state === 'closed') return;\n\n        this.#lastVfDur = chunks[0]?.duration ?? 0;\n        decodeGoP(dec, chunks, {\n          onDecodingError: (err) => {\n            if (this.#downgradeSoftDecode) {\n              throw err;\n            } else if (this.#outputFrameCnt === 0) {\n              this.#downgradeSoftDecode = true;\n              Log.warn('Downgrade to software decode');\n              this.#reset();\n            }\n          },\n        });\n\n        this.#inputChunkCnt += chunks.length;\n      }\n    }\n    this.#videoDecCusorIdx = endIdx;\n    this.#decoding = false;\n  };\n\n  #reset = (time?: number) => {\n    this.#decoding = false;\n    this.#videoFrames.forEach((f) => f.close());\n    this.#videoFrames = [];\n    if (time == null || time === 0) {\n      this.#videoDecCusorIdx = 0;\n    } else {\n      let keyIdx = 0;\n      for (let i = 0; i < this.samples.length; i++) {\n        const s = this.samples[i];\n        if (s.is_idr) keyIdx = i;\n        if (s.cts < time) continue;\n        this.#videoDecCusorIdx = keyIdx;\n        break;\n      }\n    }\n    this.#inputChunkCnt = 0;\n    this.#outputFrameCnt = 0;\n    if (this.#dec?.state !== 'closed') this.#dec?.close();\n    const encoderConf = {\n      ...this.conf,\n      ...(this.#downgradeSoftDecode\n        ? { hardwareAcceleration: 'prefer-software' }\n        : {}),\n    } as VideoDecoderConfig;\n    this.#dec = new VideoDecoder({\n      output: (vf) => {\n        this.#outputFrameCnt += 1;\n        if (vf.timestamp === -1) {\n          vf.close();\n          return;\n        }\n        let rsVf = vf;\n        if (vf.duration == null) {\n          rsVf = new VideoFrame(vf, {\n            duration: this.#lastVfDur,\n          });\n          vf.close();\n        }\n        this.#videoFrames.push(rsVf);\n      },\n      error: (err) => {\n        if (err.message.includes('Codec reclaimed due to inactivity')) {\n          // todo:  因无活动被自动关闭的解码器，是否需要自动重启？\n          this.#dec = null;\n          Log.warn(err.message);\n          return;\n        }\n\n        const errMsg = `VideoFinder VideoDecoder err: ${err.message}, config: ${JSON.stringify(encoderConf)}, state: ${JSON.stringify(this.#getState())}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      },\n    });\n    this.#dec.configure(encoderConf);\n  };\n\n  #getState = () => ({\n    time: this.#ts,\n    decState: this.#dec?.state,\n    decQSize: this.#dec?.decodeQueueSize,\n    decCusorIdx: this.#videoDecCusorIdx,\n    sampleLen: this.samples.length,\n    inputCnt: this.#inputChunkCnt,\n    outputCnt: this.#outputFrameCnt,\n    cacheFrameLen: this.#videoFrames.length,\n    softDeocde: this.#downgradeSoftDecode,\n    clipIdCnt: CLIP_ID,\n    sleepCnt: this.#sleepCnt,\n    memInfo: memoryUsageInfo(),\n  });\n\n  destroy = () => {\n    if (this.#dec?.state !== 'closed') this.#dec?.close();\n    this.#dec = null;\n    this.#curAborter.abort = true;\n    this.#videoFrames.forEach((f) => f.close());\n    this.#videoFrames = [];\n    this.localFileReader.close();\n  };\n}\n\nfunction findIndexOfSamples(time: number, samples: ExtMP4Sample[]) {\n  for (let i = 0; i < samples.length; i++) {\n    const s = samples[i];\n    if (time >= s.cts && time < s.cts + s.duration) {\n      return i;\n    }\n    if (s.cts > time) break;\n  }\n  return 0;\n}\n\nclass AudioFrameFinder {\n  #volume = 1;\n  #sampleRate;\n  constructor(\n    public localFileReader: LocalFileReader,\n    public samples: ExtMP4Sample[],\n    public conf: AudioDecoderConfig,\n    opts: { volume: number; targetSampleRate: number },\n  ) {\n    this.#volume = opts.volume;\n    this.#sampleRate = opts.targetSampleRate;\n  }\n\n  #dec: ReturnType<typeof createAudioChunksDecoder> | null = null;\n  #curAborter = { abort: false, st: performance.now() };\n  find = async (time: number): Promise<Float32Array[]> => {\n    const needResetTime = time <= this.#ts || time - this.#ts > 0.1e6;\n    if (this.#dec == null || this.#dec.state === 'closed' || needResetTime) {\n      this.#reset();\n    }\n\n    if (needResetTime) {\n      // 前后获取音频数据差异不能超过 100ms(经验值)，否则视为 seek 操作，重置解码器\n      // seek 操作，重置时间\n      this.#ts = time;\n      this.#decCusorIdx = findIndexOfSamples(time, this.samples);\n    }\n\n    this.#curAborter.abort = true;\n    const deltaTime = time - this.#ts;\n    this.#ts = time;\n\n    this.#curAborter = { abort: false, st: performance.now() };\n\n    const pcmData = await this.#parseFrame(\n      Math.ceil(deltaTime * (this.#sampleRate / 1e6)),\n      this.#dec,\n      this.#curAborter,\n    );\n    this.#sleepCnt = 0;\n    return pcmData;\n  };\n\n  #ts = 0;\n  #decCusorIdx = 0;\n  #pcmData: {\n    frameCnt: number;\n    data: [Float32Array, Float32Array][];\n  } = {\n    frameCnt: 0,\n    data: [],\n  };\n  #sleepCnt = 0;\n  #parseFrame = async (\n    emitFrameCnt: number,\n    dec: ReturnType<typeof createAudioChunksDecoder> | null = null,\n    aborter: { abort: boolean; st: number },\n  ): Promise<Float32Array[]> => {\n    if (\n      dec == null ||\n      aborter.abort ||\n      dec.state === 'closed' ||\n      emitFrameCnt === 0\n    ) {\n      return [];\n    }\n\n    // 数据满足需要\n    const ramainFrameCnt = this.#pcmData.frameCnt - emitFrameCnt;\n    if (ramainFrameCnt > 0) {\n      // 剩余音频数据小于 100ms，预先解码\n      if (ramainFrameCnt < DEFAULT_AUDIO_CONF.sampleRate / 10) {\n        this.#startDecode(dec);\n      }\n      return emitAudioFrames(this.#pcmData, emitFrameCnt);\n    }\n\n    if (dec.decoding) {\n      if (performance.now() - aborter.st > 3e3) {\n        aborter.abort = true;\n        throw Error(\n          `MP4Clip.tick audio timeout, ${JSON.stringify(this.#getState())}`,\n        );\n      }\n      // 解码中，等待\n      this.#sleepCnt += 1;\n      await sleep(15);\n    } else if (this.#decCusorIdx >= this.samples.length - 1) {\n      // 最后片段，返回剩余数据\n      return emitAudioFrames(this.#pcmData, this.#pcmData.frameCnt);\n    } else {\n      this.#startDecode(dec);\n    }\n    return this.#parseFrame(emitFrameCnt, dec, aborter);\n  };\n\n  #startDecode = (dec: ReturnType<typeof createAudioChunksDecoder>) => {\n    const onceDecodeCnt = 10;\n    if (dec.decodeQueueSize > onceDecodeCnt) return;\n    // 启动解码任务\n    const samples = [];\n    let i = this.#decCusorIdx;\n    while (i < this.samples.length) {\n      const s = this.samples[i];\n      i += 1;\n      if (s.deleted) continue;\n      samples.push(s);\n      if (samples.length >= onceDecodeCnt) break;\n    }\n    this.#decCusorIdx = i;\n\n    dec.decode(\n      samples.map(\n        (s) =>\n          new EncodedAudioChunk({\n            type: 'key',\n            timestamp: s.cts,\n            duration: s.duration,\n            data: s.data!,\n          }),\n      ),\n    );\n  };\n\n  #reset = () => {\n    this.#ts = 0;\n    this.#decCusorIdx = 0;\n    this.#pcmData = {\n      frameCnt: 0,\n      data: [],\n    };\n    this.#dec?.close();\n    this.#dec = createAudioChunksDecoder(\n      this.conf,\n      {\n        resampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n        volume: this.#volume,\n      },\n      (pcmArr) => {\n        this.#pcmData.data.push(pcmArr as [Float32Array, Float32Array]);\n        this.#pcmData.frameCnt += pcmArr[0].length;\n      },\n    );\n  };\n\n  #getState = () => ({\n    time: this.#ts,\n    decState: this.#dec?.state,\n    decQSize: this.#dec?.decodeQueueSize,\n    decCusorIdx: this.#decCusorIdx,\n    sampleLen: this.samples.length,\n    pcmLen: this.#pcmData.frameCnt,\n    clipIdCnt: CLIP_ID,\n    sleepCnt: this.#sleepCnt,\n    memInfo: memoryUsageInfo(),\n  });\n\n  destroy = () => {\n    this.#dec = null;\n    this.#curAborter.abort = true;\n    this.#pcmData = {\n      frameCnt: 0,\n      data: [],\n    };\n    this.localFileReader.close();\n  };\n}\n\nfunction createAudioChunksDecoder(\n  decoderConf: AudioDecoderConfig,\n  opts: { resampleRate: number; volume: number },\n  outputCb: (pcm: Float32Array[]) => void,\n) {\n  let inputCnt = 0;\n  let outputCnt = 0;\n  const outputHandler = (pcmArr: Float32Array[]) => {\n    outputCnt += 1;\n    if (pcmArr.length === 0) return;\n    // 音量调节\n    if (opts.volume !== 1) {\n      for (const pcm of pcmArr)\n        for (let i = 0; i < pcm.length; i++) pcm[i] *= opts.volume;\n    }\n\n    // 补齐双声道\n    if (pcmArr.length === 1) pcmArr = [pcmArr[0], pcmArr[0]];\n\n    outputCb(pcmArr);\n  };\n  const resampleQ = createPromiseQueue<Float32Array[]>(outputHandler);\n\n  const needResample = opts.resampleRate !== decoderConf.sampleRate;\n  let adec = new AudioDecoder({\n    output: (ad) => {\n      const pcm = extractPCM4AudioData(ad);\n      if (needResample) {\n        resampleQ(() =>\n          audioResample(pcm, ad.sampleRate, {\n            rate: opts.resampleRate,\n            chanCount: ad.numberOfChannels,\n          }),\n        );\n      } else {\n        outputHandler(pcm);\n      }\n      ad.close();\n    },\n    error: (err) => {\n      if (err.message.includes('Codec reclaimed due to inactivity')) {\n        return;\n      }\n      handleDecodeError('MP4Clip AudioDecoder err', err as Error);\n    },\n  });\n  adec.configure(decoderConf);\n\n  function handleDecodeError(prefixStr: string, err: Error) {\n    const errMsg = `${prefixStr}: ${(err as Error).message}, state: ${JSON.stringify(\n      {\n        qSize: adec.decodeQueueSize,\n        state: adec.state,\n        inputCnt,\n        outputCnt,\n      },\n    )}`;\n    Log.error(errMsg);\n    throw Error(errMsg);\n  }\n\n  return {\n    decode(chunks: EncodedAudioChunk[]) {\n      inputCnt += chunks.length;\n      try {\n        for (const chunk of chunks) adec.decode(chunk);\n      } catch (err) {\n        handleDecodeError('decode audio chunk error', err as Error);\n      }\n    },\n    close() {\n      if (adec.state !== 'closed') adec.close();\n    },\n    get decoding() {\n      return inputCnt > outputCnt && adec.decodeQueueSize > 0;\n    },\n    get state() {\n      return adec.state;\n    },\n    get decodeQueueSize() {\n      return adec.decodeQueueSize;\n    },\n  };\n}\n\n// 并行执行任务，但按顺序emit结果\nfunction createPromiseQueue<T extends any>(onResult: (data: T) => void) {\n  const rsCache: T[] = [];\n  let waitingIdx = 0;\n\n  function updateRs(rs: T, emitIdx: number) {\n    rsCache[emitIdx] = rs;\n    emitRs();\n  }\n\n  function emitRs() {\n    const rs = rsCache[waitingIdx];\n    if (rs == null) return;\n    onResult(rs);\n\n    waitingIdx += 1;\n    emitRs();\n  }\n\n  let addIdx = 0;\n  return (task: () => Promise<T>) => {\n    const emitIdx = addIdx;\n    addIdx += 1;\n    task()\n      .then((rs) => updateRs(rs, emitIdx))\n      .catch((err) => updateRs(err, emitIdx));\n  };\n}\n\nfunction emitAudioFrames(\n  pcmData: { frameCnt: number; data: [Float32Array, Float32Array][] },\n  emitCnt: number,\n) {\n  // todo: perf 重复利用内存空间\n  const audio = [new Float32Array(emitCnt), new Float32Array(emitCnt)];\n  let offset = 0;\n  let i = 0;\n  for (; i < pcmData.data.length; ) {\n    const [chan0, chan1] = pcmData.data[i];\n    if (offset + chan0.length > emitCnt) {\n      const gapCnt = emitCnt - offset;\n      audio[0].set(chan0.subarray(0, gapCnt), offset);\n      audio[1].set(chan1.subarray(0, gapCnt), offset);\n      pcmData.data[i][0] = chan0.subarray(gapCnt, chan0.length);\n      pcmData.data[i][1] = chan1.subarray(gapCnt, chan1.length);\n      break;\n    } else {\n      audio[0].set(chan0, offset);\n      audio[1].set(chan1, offset);\n      offset += chan0.length;\n      i++;\n    }\n  }\n  pcmData.data = pcmData.data.slice(i);\n  pcmData.frameCnt -= emitCnt;\n  return audio;\n}\n\nasync function videosamples2Chunks(\n  samples: ExtMP4Sample[],\n  reader: Awaited<ReturnType<OPFSToolFile['createReader']>>,\n): Promise<EncodedVideoChunk[]> {\n  const first = samples[0];\n  const last = samples.at(-1);\n  if (last == null) return [];\n\n  const rangSize = last.offset + last.size - first.offset;\n  if (rangSize < 30e6) {\n    // 单次读取数据小于 30M，就一次性读取数据，降低 IO 频次\n    const data = new Uint8Array(\n      await reader.read(rangSize, { at: first.offset }),\n    );\n    return samples.map((s) => {\n      const offset = s.offset - first.offset;\n      return new EncodedVideoChunk({\n        type: s.is_sync ? 'key' : 'delta',\n        timestamp: s.cts,\n        duration: s.duration,\n        data: data.subarray(offset, offset + s.size),\n      });\n    });\n  }\n\n  return await Promise.all(\n    samples.map(async (s) => {\n      return new EncodedVideoChunk({\n        type: s.is_sync ? 'key' : 'delta',\n        timestamp: s.cts,\n        duration: s.duration,\n        data: await reader.read(s.size, {\n          at: s.offset,\n        }),\n      });\n    }),\n  );\n}\n\nfunction createVF2BlobConvtr(\n  width: number,\n  height: number,\n  opts?: ImageEncodeOptions,\n) {\n  const cvs = new OffscreenCanvas(width, height);\n  const ctx = cvs.getContext('2d')!;\n\n  return async (vf: VideoFrame) => {\n    ctx.drawImage(vf, 0, 0, width, height);\n    vf.close();\n    const blob = await cvs.convertToBlob(opts);\n    return blob;\n  };\n}\n\nfunction splitVideoSampleByTime(videoSamples: ExtMP4Sample[], time: number) {\n  if (videoSamples.length === 0) return [];\n  let gopStartIdx = 0;\n  let gopEndIdx = 0;\n  let hitIdx = -1;\n  for (let i = 0; i < videoSamples.length; i++) {\n    const s = videoSamples[i];\n    if (hitIdx === -1 && time < s.cts) hitIdx = i - 1;\n    if (s.is_idr) {\n      if (hitIdx === -1) {\n        gopStartIdx = i;\n      } else {\n        gopEndIdx = i;\n        break;\n      }\n    }\n  }\n\n  const hitSample = videoSamples[hitIdx];\n  if (hitSample == null) throw Error('Not found video sample by time');\n\n  const preSlice = videoSamples\n    .slice(0, gopEndIdx === 0 ? videoSamples.length : gopEndIdx)\n    .map((s) => ({ ...s }));\n  for (let i = gopStartIdx; i < preSlice.length; i++) {\n    const s = preSlice[i];\n    if (time < s.cts) {\n      s.deleted = true;\n      s.cts = -1;\n    }\n  }\n  fixFirstBlackFrame(preSlice);\n\n  const postSlice = videoSamples\n    .slice(hitSample.is_idr ? hitIdx : gopStartIdx)\n    .map((s) => ({ ...s, cts: s.cts - time }));\n\n  for (const s of postSlice) {\n    if (s.cts < 0) {\n      s.deleted = true;\n      s.cts = -1;\n    }\n  }\n  fixFirstBlackFrame(postSlice);\n\n  return [preSlice, postSlice];\n}\n\nfunction splitAudioSampleByTime(audioSamples: ExtMP4Sample[], time: number) {\n  if (audioSamples.length === 0) return [];\n  let hitIdx = -1;\n  for (let i = 0; i < audioSamples.length; i++) {\n    const s = audioSamples[i];\n    if (time > s.cts) continue;\n    hitIdx = i;\n    break;\n  }\n  if (hitIdx === -1) throw Error('Not found audio sample by time');\n  const preSlice = audioSamples.slice(0, hitIdx).map((s) => ({ ...s }));\n  const postSlice = audioSamples\n    .slice(hitIdx)\n    .map((s) => ({ ...s, cts: s.cts - time }));\n  return [preSlice, postSlice];\n}\n\n// 兼容解码错误\nfunction decodeGoP(\n  dec: VideoDecoder,\n  chunks: EncodedVideoChunk[],\n  opts: {\n    onDecodingError?: (err: Error) => void;\n  },\n) {\n  let i = 0;\n  if (dec.state !== 'configured') return;\n  for (; i < chunks.length; i++) dec.decode(chunks[i]);\n\n  // todo：flush 之后下一帧必须是 IDR 帧，是否可以根据情况再决定调用 flush？\n  // windows 某些设备 flush 可能不会被 resolved，所以不能 await flush\n  dec.flush().catch((err) => {\n    if (!(err instanceof Error)) throw err;\n    if (\n      err.message.includes('Decoding error') &&\n      opts.onDecodingError != null\n    ) {\n      opts.onDecodingError(err);\n      return;\n    }\n    // reset 中断解码器，预期会抛出 AbortedError\n    if (!err.message.includes('Aborted due to close')) {\n      throw err;\n    }\n  });\n}\n\nfunction idrNALUOffset(\n  u8Arr: Uint8Array,\n  type: MP4Sample['description']['type'],\n) {\n  if (type !== 'avc1' && type !== 'hvc1') return 0;\n\n  const dv = new DataView(u8Arr.buffer);\n  let i = 0;\n  for (; i < u8Arr.byteLength - 4; ) {\n    if (type === 'avc1' && (dv.getUint8(i + 4) & 0x1f) === 5) {\n      return i;\n    } else if (type === 'hvc1') {\n      const nalUnitType = (dv.getUint8(i + 4) >> 1) & 0x3f;\n      if (nalUnitType === 19 || nalUnitType === 20) return i;\n    }\n    // 跳至下一个 NALU 继续检查\n    i += dv.getUint32(i) + 4;\n  }\n  return -1;\n}\n\nasync function thumbnailByKeyFrame(\n  samples: ExtMP4Sample[],\n  localFile: OPFSToolFile,\n  decConf: VideoDecoderConfig,\n  abortSingl: AbortSignal,\n  time: { start: number; end: number },\n  onOutput: (vf: VideoFrame | null, done: boolean) => void,\n) {\n  const fileReader = await localFile.createReader();\n\n  const chunks = await videosamples2Chunks(\n    samples.filter(\n      (s) =>\n        !s.deleted && s.is_sync && s.cts >= time.start && s.cts <= time.end,\n    ),\n    fileReader,\n  );\n  if (chunks.length === 0 || abortSingl.aborted) return;\n\n  let outputCnt = 0;\n  decodeGoP(createVideoDec(), chunks, {\n    onDecodingError: (err) => {\n      Log.warn('thumbnailsByKeyFrame', err);\n      // 尝试降级一次\n      if (outputCnt === 0) {\n        decodeGoP(createVideoDec(true), chunks, {\n          onDecodingError: (err) => {\n            fileReader.close();\n            Log.error('thumbnailsByKeyFrame retry soft deocde', err);\n          },\n        });\n      } else {\n        onOutput(null, true);\n        fileReader.close();\n      }\n    },\n  });\n\n  function createVideoDec(downgrade = false) {\n    const encoderConf = {\n      ...decConf,\n      ...(downgrade ? { hardwareAcceleration: 'prefer-software' } : {}),\n    } as VideoDecoderConfig;\n    const dec = new VideoDecoder({\n      output: (vf) => {\n        outputCnt += 1;\n        const done = outputCnt === chunks.length;\n        onOutput(vf, done);\n        if (done) {\n          fileReader.close();\n          if (dec.state !== 'closed') dec.close();\n        }\n      },\n      error: (err) => {\n        const errMsg = `thumbnails decoder error: ${err.message}, config: ${JSON.stringify(encoderConf)}, state: ${JSON.stringify(\n          {\n            qSize: dec.decodeQueueSize,\n            state: dec.state,\n            outputCnt,\n            inputCnt: chunks.length,\n          },\n        )}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      },\n    });\n    abortSingl.addEventListener('abort', () => {\n      fileReader.close();\n      if (dec.state !== 'closed') dec.close();\n    });\n    dec.configure(encoderConf);\n    return dec;\n  }\n}\n\n// 如果第一帧出现的时间偏移较大，会导致第一帧为黑帧，这里尝试自动消除第一帧前的黑帧\nfunction fixFirstBlackFrame(samples: ExtMP4Sample[]) {\n  let iframeCnt = 0;\n  let minCtsSample: ExtMP4Sample | null = null;\n  // cts 最小表示视频的第一帧\n  for (const s of samples) {\n    if (s.deleted) continue;\n    // 最多检测两个 I 帧之间的帧\n    if (s.is_sync) iframeCnt += 1;\n    if (iframeCnt >= 2) break;\n\n    if (minCtsSample == null || s.cts < minCtsSample.cts) {\n      minCtsSample = s;\n    }\n  }\n  // 200ms 是经验值，自动消除 200ms 内的黑帧，超过则不处理\n  if (minCtsSample != null && minCtsSample.cts < 200e3) {\n    minCtsSample.duration += minCtsSample.cts;\n    minCtsSample.cts = 0;\n  }\n}\n\nfunction memoryUsageInfo() {\n  try {\n    // @ts-ignore\n    const mem = performance.memory;\n    return {\n      jsHeapSizeLimit: mem.jsHeapSizeLimit,\n      totalJSHeapSize: mem.totalJSHeapSize,\n      usedJSHeapSize: mem.usedJSHeapSize,\n      percentUsed: (mem.usedJSHeapSize / mem.jsHeapSizeLimit).toFixed(3),\n      percentTotal: (mem.totalJSHeapSize / mem.jsHeapSizeLimit).toFixed(3),\n    };\n  } catch (err) {\n    return {};\n  }\n}\n","import { decodeImg } from '../av-utils';\nimport { Log } from '@webav/internal-utils';\nimport { IClip } from './iclip';\n\ntype AnimateImgType = 'avif' | 'webp' | 'png' | 'gif';\n\n/**\n * 图像素材，支持动图\n *\n * 普通文字可通过 {@link renderTxt2ImgBitmap} 转换成图片素材\n *\n * @example\n * new ImgClip((await fetch('<img url>')).body);\n *\n * @example\n * new ImgClip(\n *   await renderTxt2ImgBitmap(\n *     '水印',\n *    `font-size:40px; color: white; text-shadow: 2px 2px 6px red;`,\n *   )\n * )\n *\n * @see [视频合成](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n */\nexport class ImgClip implements IClip {\n  ready: IClip['ready'];\n\n  #meta = {\n    // 微秒\n    duration: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /**\n   * ⚠️ 静态图片的 duration 为 Infinity\n   *\n   * 使用 Sprite 包装时需要将它的 duration 设置为有限数\n   *\n   */\n  get meta() {\n    return { ...this.#meta };\n  }\n\n  #img: ImageBitmap | null = null;\n\n  #frames: VideoFrame[] = [];\n\n  /**\n   * 静态图片可使用流、ImageBitmap 初始化\n   *\n   * 动图需要使用 VideoFrame[] 或提供图片类型\n   */\n  constructor(\n    dataSource:\n      | ReadableStream\n      | ImageBitmap\n      | VideoFrame[]\n      | { type: `image/${AnimateImgType}`; stream: ReadableStream },\n  ) {\n    const initWithImgBitmap = (imgBitmap: ImageBitmap) => {\n      this.#img = imgBitmap;\n      this.#meta.width = imgBitmap.width;\n      this.#meta.height = imgBitmap.height;\n      this.#meta.duration = Infinity;\n      return { ...this.#meta };\n    };\n\n    if (dataSource instanceof ReadableStream) {\n      this.ready = new Response(dataSource)\n        .blob()\n        .then((data) => createImageBitmap(data))\n        .then(initWithImgBitmap);\n    } else if (dataSource instanceof ImageBitmap) {\n      this.ready = Promise.resolve(initWithImgBitmap(dataSource));\n    } else if (\n      Array.isArray(dataSource) &&\n      dataSource.every((it) => it instanceof VideoFrame)\n    ) {\n      this.#frames = dataSource;\n      const frame = this.#frames[0];\n      if (frame == null) throw Error('The frame count must be greater than 0');\n      this.#meta = {\n        width: frame.displayWidth,\n        height: frame.displayHeight,\n        duration: this.#frames.reduce(\n          (acc, cur) => acc + (cur.duration ?? 0),\n          0,\n        ),\n      };\n      this.ready = Promise.resolve({ ...this.#meta, duration: Infinity });\n    } else if ('type' in dataSource) {\n      this.ready = this.#initAnimateImg(\n        dataSource.stream,\n        dataSource.type,\n      ).then(() => ({\n        width: this.#meta.width,\n        height: this.#meta.height,\n        duration: Infinity,\n      }));\n    } else {\n      throw Error('Illegal arguments');\n    }\n  }\n\n  async #initAnimateImg(\n    stream: ReadableStream,\n    type: `image/${AnimateImgType}`,\n  ) {\n    this.#frames = await decodeImg(stream, type);\n    const firstVf = this.#frames[0];\n    if (firstVf == null) throw Error('No frame available in gif');\n\n    this.#meta = {\n      duration: this.#frames.reduce((acc, cur) => acc + (cur.duration ?? 0), 0),\n      width: firstVf.codedWidth,\n      height: firstVf.codedHeight,\n    };\n    Log.info('ImgClip ready:', this.#meta);\n  }\n\n  tickInterceptor: <T extends Awaited<ReturnType<ImgClip['tick']>>>(\n    time: number,\n    tickRet: T,\n  ) => Promise<T> = async (_, tickRet) => tickRet;\n\n  async tick(time: number): Promise<{\n    video: ImageBitmap | VideoFrame;\n    state: 'success';\n  }> {\n    if (this.#img != null) {\n      return await this.tickInterceptor(time, {\n        video: await createImageBitmap(this.#img),\n        state: 'success',\n      });\n    }\n    const tt = time % this.#meta.duration;\n    return await this.tickInterceptor(time, {\n      video: (\n        this.#frames.find(\n          (f) => tt >= f.timestamp && tt <= f.timestamp + (f.duration ?? 0),\n        ) ?? this.#frames[0]\n      ).clone(),\n      state: 'success',\n    });\n  }\n\n  async split(time: number) {\n    await this.ready;\n    if (this.#img != null) {\n      return [\n        new ImgClip(await createImageBitmap(this.#img)),\n        new ImgClip(await createImageBitmap(this.#img)),\n      ] as [this, this];\n    }\n    let hitIdx = -1;\n    for (let i = 0; i < this.#frames.length; i++) {\n      const vf = this.#frames[i];\n      if (time > vf.timestamp) continue;\n      hitIdx = i;\n      break;\n    }\n    if (hitIdx === -1) throw Error('Not found frame by time');\n    const preSlice = this.#frames\n      .slice(0, hitIdx)\n      .map((vf) => new VideoFrame(vf));\n    const postSlice = this.#frames.slice(hitIdx).map(\n      (vf) =>\n        new VideoFrame(vf, {\n          timestamp: vf.timestamp - time,\n        }),\n    );\n    return [new ImgClip(preSlice), new ImgClip(postSlice)] as [this, this];\n  }\n\n  async clone() {\n    await this.ready;\n    const data =\n      this.#img == null\n        ? this.#frames.map((vf) => vf.clone())\n        : await createImageBitmap(this.#img);\n    return new ImgClip(data) as this;\n  }\n\n  destroy(): void {\n    Log.info('ImgClip destroy');\n    this.#img?.close();\n    this.#frames.forEach((f) => f.close());\n  }\n}\n","import {\n  concatPCMFragments,\n  extractPCM4AudioBuffer,\n  ringSliceFloat32Array,\n} from '../av-utils';\nimport { Log } from '@webav/internal-utils';\nimport { DEFAULT_AUDIO_CONF, IClip } from './iclip';\n\ninterface IAudioClipOpts {\n  loop?: boolean;\n  volume?: number;\n}\n\n/**\n * 音频素材，为创建、编辑音视频功能提供音频数据\n *\n * @example\n * new AudioClip((await fetch('<mp3 url>')).body, {\n *   loop: true,\n * }),\n */\nexport class AudioClip implements IClip {\n  static ctx: AudioContext | null = null;\n\n  ready: IClip['ready'];\n\n  #meta = {\n    // 微秒\n    duration: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /**\n   * 音频元信息\n   *\n   * ⚠️ 注意，这里是转换后（标准化）的元信息，非原始音频元信息\n   */\n  get meta() {\n    return {\n      ...this.#meta,\n      sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n      chanCount: 2,\n    };\n  }\n\n  #chan0Buf = new Float32Array();\n  #chan1Buf = new Float32Array();\n  /**\n   * 获取音频素材完整的 PCM 数据\n   */\n  getPCMData(): Float32Array[] {\n    return [this.#chan0Buf, this.#chan1Buf];\n  }\n\n  #opts;\n\n  /**\n   *\n   * @param dataSource 音频文件流\n   * @param opts 音频配置，控制音量、是否循环\n   */\n  constructor(\n    dataSource: ReadableStream<Uint8Array> | Float32Array[],\n    opts: IAudioClipOpts = {},\n  ) {\n    this.#opts = {\n      loop: false,\n      volume: 1,\n      ...opts,\n    };\n\n    this.ready = this.#init(dataSource).then(() => ({\n      // audio 没有宽高，无需绘制\n      width: 0,\n      height: 0,\n      duration: opts.loop ? Infinity : this.#meta.duration,\n    }));\n  }\n\n  async #init(\n    dataSource: ReadableStream<Uint8Array> | Float32Array[],\n  ): Promise<void> {\n    if (AudioClip.ctx == null) {\n      AudioClip.ctx = new AudioContext({\n        sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n      });\n    }\n\n    const tStart = performance.now();\n    const pcm =\n      dataSource instanceof ReadableStream\n        ? await parseStream2PCM(dataSource, AudioClip.ctx)\n        : dataSource;\n\n    Log.info('Audio clip decoded complete:', performance.now() - tStart);\n\n    const volume = this.#opts.volume;\n    if (volume !== 1) {\n      for (const chan of pcm)\n        for (let i = 0; i < chan.length; i += 1) chan[i] *= volume;\n    }\n\n    this.#meta.duration = (pcm[0].length / DEFAULT_AUDIO_CONF.sampleRate) * 1e6;\n\n    this.#chan0Buf = pcm[0];\n    // 单声道 转 立体声\n    this.#chan1Buf = pcm[1] ?? this.#chan0Buf;\n\n    Log.info(\n      'Audio clip convert to AudioData, time:',\n      performance.now() - tStart,\n    );\n  }\n\n  /**\n   * 拦截 {@link AudioClip.tick} 方法返回的数据，用于对音频数据二次处理\n   * @param time 调用 tick 的时间\n   * @param tickRet tick 返回的数据\n   *\n   * @see [移除视频绿幕背景](https://webav-tech.github.io/WebAV/demo/3_2-chromakey-video)\n   */\n  tickInterceptor: <T extends Awaited<ReturnType<AudioClip['tick']>>>(\n    time: number,\n    tickRet: T,\n  ) => Promise<T> = async (_, tickRet) => tickRet;\n\n  // 微秒\n  #ts = 0;\n  #frameOffset = 0;\n  /**\n   * 返回上次与当前时刻差对应的音频 PCM 数据；\n   *\n   * 若差值超过 3s 或当前时间小于上次时间，则重置状态\n   * @example\n   * tick(0) // => []\n   * tick(1e6) // => [leftChanPCM(1s), rightChanPCM(1s)]\n   *\n   */\n  async tick(time: number): Promise<{\n    audio: Float32Array[];\n    state: 'success' | 'done';\n  }> {\n    if (!this.#opts.loop && time >= this.#meta.duration) {\n      // 待观察：如果time跨度较大，返回done，理论上会丢失一些音频帧\n      return await this.tickInterceptor(time, { audio: [], state: 'done' });\n    }\n\n    const deltaTime = time - this.#ts;\n\n    // reset\n    if (time < this.#ts || deltaTime > 3e6) {\n      this.#ts = time;\n      this.#frameOffset = Math.ceil(\n        (this.#ts / 1e6) * DEFAULT_AUDIO_CONF.sampleRate,\n      );\n      return await this.tickInterceptor(time, {\n        audio: [new Float32Array(0), new Float32Array(0)],\n        state: 'success',\n      });\n    }\n\n    this.#ts = time;\n    const frameCnt = Math.ceil(\n      (deltaTime / 1e6) * DEFAULT_AUDIO_CONF.sampleRate,\n    );\n    const endIdx = this.#frameOffset + frameCnt;\n    const audio = this.#opts.loop\n      ? [\n          ringSliceFloat32Array(this.#chan0Buf, this.#frameOffset, endIdx),\n          ringSliceFloat32Array(this.#chan1Buf, this.#frameOffset, endIdx),\n        ]\n      : [\n          this.#chan0Buf.slice(this.#frameOffset, endIdx),\n          this.#chan1Buf.slice(this.#frameOffset, endIdx),\n        ];\n    this.#frameOffset = endIdx;\n\n    return await this.tickInterceptor(time, { audio, state: 'success' });\n  }\n\n  /**\n   * 按指定时间切割，返回前后两个音频素材\n   * @param time 时间，单位微秒\n   */\n  async split(time: number) {\n    await this.ready;\n    const frameCnt = Math.ceil((time / 1e6) * DEFAULT_AUDIO_CONF.sampleRate);\n    const preSlice = new AudioClip(\n      this.getPCMData().map((chan) => chan.slice(0, frameCnt)),\n      this.#opts,\n    );\n    const postSlice = new AudioClip(\n      this.getPCMData().map((chan) => chan.slice(frameCnt)),\n      this.#opts,\n    );\n    return [preSlice, postSlice] as [this, this];\n  }\n\n  async clone() {\n    await this.ready;\n    const clip = new AudioClip(this.getPCMData(), this.#opts) as this;\n    await clip.ready;\n    return clip;\n  }\n\n  /**\n   * 销毁实例，释放资源\n   */\n  destroy(): void {\n    this.#chan0Buf = new Float32Array(0);\n    this.#chan1Buf = new Float32Array(0);\n    Log.info('---- audioclip destroy ----');\n  }\n}\n\n/**\n * 拼接多个 AudioClip\n */\nexport async function concatAudioClip(\n  clips: AudioClip[],\n  opts?: IAudioClipOpts,\n) {\n  const bufs: Float32Array[][] = [];\n  for (const clip of clips) {\n    await clip.ready;\n    bufs.push(clip.getPCMData());\n  }\n  return new AudioClip(concatPCMFragments(bufs), opts);\n}\n\nasync function parseStream2PCM(\n  stream: ReadableStream<Uint8Array>,\n  ctx: AudioContext | OfflineAudioContext,\n): Promise<Float32Array[]> {\n  const buf = await new Response(stream).arrayBuffer();\n  return extractPCM4AudioBuffer(await ctx.decodeAudioData(buf));\n}\n","import { autoReadStream } from '@webav/internal-utils';\nimport { IClip } from './iclip';\n\n/**\n * 包装实时音视频流，仅用于 [AVCanvas](../../av-canvas/classes/AVCanvas.html)\n *\n * ⚠️ 不可用于 {@link Combinator} ，因为后台合成视频的速度是快于物理时间的，实时流无法提供非实时的数据\n *\n * @example\n * const spr = new VisibleSprite(\n *   new MediaStreamClip(\n *     await navigator.mediaDevices.getUserMedia({ video: true, audio: true, }),\n *   ),\n * );\n * await avCvs.addSprite(spr);\n */\nexport class MediaStreamClip implements IClip {\n  static ctx: AudioContext | null = null;\n\n  ready: IClip['ready'];\n\n  #meta = {\n    // 微秒\n    duration: 0,\n    width: 0,\n    height: 0,\n  };\n\n  get meta() {\n    return {\n      ...this.#meta,\n    };\n  }\n\n  #stopRenderCvs = () => {};\n\n  /**\n   * 实时流的音轨\n   */\n  readonly audioTrack: MediaStreamAudioTrack | null;\n\n  #cvs: OffscreenCanvas | null = null;\n\n  #ms: MediaStream;\n  constructor(ms: MediaStream) {\n    this.#ms = ms;\n    this.audioTrack = ms.getAudioTracks()[0] ?? null;\n    this.#meta.duration = Infinity;\n    const videoTrack = ms.getVideoTracks()[0];\n    if (videoTrack != null) {\n      videoTrack.contentHint = 'motion';\n      this.ready = new Promise((resolve) => {\n        this.#stopRenderCvs = renderVideoTrackToCvs(videoTrack, (cvs) => {\n          this.#meta.width = cvs.width;\n          this.#meta.height = cvs.height;\n          this.#cvs = cvs;\n          resolve(this.meta);\n        });\n      });\n    } else {\n      this.ready = Promise.resolve(this.meta);\n    }\n  }\n\n  async tick(): Promise<{\n    video: ImageBitmap | null;\n    audio: Float32Array[];\n    state: 'success';\n  }> {\n    return {\n      video: this.#cvs == null ? null : await createImageBitmap(this.#cvs),\n      audio: [],\n      state: 'success',\n    };\n  }\n\n  async split() {\n    return [await this.clone(), await this.clone()] as [this, this];\n  }\n\n  async clone() {\n    return new MediaStreamClip(this.#ms.clone()) as this;\n  }\n\n  destroy(): void {\n    this.#ms.getTracks().forEach((t) => t.stop());\n    this.#stopRenderCvs();\n  }\n}\n\nfunction renderVideoTrackToCvs(\n  track: MediaStreamVideoTrack,\n  onOffscreenCanvasReady: (cvs: OffscreenCanvas) => void,\n) {\n  let emitFF = false;\n  let cvsCtx: OffscreenCanvasRenderingContext2D;\n  return autoReadStream(\n    new MediaStreamTrackProcessor({\n      track,\n    }).readable,\n    {\n      onChunk: async (frame) => {\n        if (!emitFF) {\n          const { displayHeight, displayWidth } = frame;\n          const width = displayWidth ?? 0;\n          const height = displayHeight ?? 0;\n          const cvs = new OffscreenCanvas(width, height);\n          cvsCtx = cvs.getContext('2d')!;\n          onOffscreenCanvasReady(cvs);\n          emitFF = true;\n        }\n        cvsCtx.drawImage(frame, 0, 0);\n        frame.close();\n      },\n      onDone: async () => {},\n    },\n  );\n}\n","import { IClip } from './iclip';\n\ninterface IEmbedSubtitlesOpts {\n  color?: string;\n  textBgColor?: string | null;\n  type?: 'srt';\n  fontFamily?: string;\n  fontSize?: number;\n  letterSpacing?: string | null;\n  // 字幕偏离底部的距离\n  bottomOffset?: number;\n  strokeStyle?: string;\n  lineWidth?: number | null;\n  lineCap?: CanvasLineCap | null;\n  lineJoin?: CanvasLineJoin | null;\n  textShadow?: {\n    offsetX: number;\n    offsetY: number;\n    blur: number;\n    color: string;\n  };\n  videoWidth: number;\n  videoHeight: number;\n}\n\ndeclare global {\n  interface OffscreenCanvasRenderingContext2D {\n    letterSpacing: string;\n  }\n}\n\ninterface SubtitleStruct {\n  start: number;\n  end: number;\n  text: string;\n}\n\n/**\n * 嵌入式字幕，将字幕（目前仅支持 SRT 格式）嵌入视频画面中\n *\n * @example\n * const es = new EmbedSubtitlesClip(srtSubtitleStr, {\n *   videoWidth: 1280,\n *   videoHeight: 720,\n *   fontFamily: 'Noto Sans SC',\n *   color: 'white',\n * });\n */\nexport class EmbedSubtitlesClip implements IClip {\n  ready: IClip['ready'];\n\n  #subtitles: SubtitleStruct[] = [];\n\n  #meta = {\n    width: 0,\n    height: 0,\n    duration: 0,\n  };\n\n  get meta() {\n    return { ...this.#meta };\n  }\n\n  #opts: Required<IEmbedSubtitlesOpts> = {\n    color: '#FFF',\n    textBgColor: null,\n    type: 'srt',\n    fontSize: 30,\n    letterSpacing: null,\n    bottomOffset: 30,\n    fontFamily: 'Noto Sans SC',\n    strokeStyle: '#000',\n    lineWidth: null,\n    lineCap: null,\n    lineJoin: null,\n    textShadow: {\n      offsetX: 2,\n      offsetY: 2,\n      blur: 4,\n      color: '#000',\n    },\n    videoWidth: 1280,\n    videoHeight: 720,\n  };\n\n  #cvs: OffscreenCanvas;\n  #ctx: OffscreenCanvasRenderingContext2D;\n\n  #lastVF: VideoFrame | null = null;\n\n  #lineHeight = 0;\n  #linePadding = 0;\n\n  constructor(content: string | SubtitleStruct[], opts: IEmbedSubtitlesOpts) {\n    this.#subtitles = Array.isArray(content)\n      ? content\n      : parseSrt(content).map(({ start, end, text }) => ({\n          start: start * 1e6,\n          end: end * 1e6,\n          text,\n        }));\n    if (this.#subtitles.length === 0) throw Error('No subtitles content');\n\n    this.#opts = Object.assign(this.#opts, opts);\n    // 如果需要绘制背景，则需要给文字添加边距\n    this.#linePadding =\n      opts.textBgColor == null ? 0 : (opts.fontSize ?? 50) * 0.2;\n\n    const { fontSize, fontFamily, videoWidth, videoHeight, letterSpacing } =\n      this.#opts;\n    this.#lineHeight = fontSize + this.#linePadding * 2;\n    this.#cvs = new OffscreenCanvas(videoWidth, videoHeight);\n    this.#ctx = this.#cvs.getContext('2d')!;\n    this.#ctx.font = `${fontSize}px ${fontFamily}`;\n    this.#ctx.textAlign = 'center';\n    this.#ctx.textBaseline = 'top';\n    this.#ctx.letterSpacing = letterSpacing ?? '0px';\n\n    this.#meta = {\n      width: videoWidth,\n      height: videoHeight,\n      duration: this.#subtitles.at(-1)?.end ?? 0,\n    };\n    // 字幕的宽高 由视频画面内容决定\n    this.ready = Promise.resolve(this.meta);\n  }\n\n  #renderTxt(txt: string) {\n    const lines = txt\n      .split('\\n')\n      .reverse()\n      .map((t) => t.trim());\n\n    const { width, height } = this.#cvs;\n\n    const {\n      color,\n      fontSize,\n      textBgColor,\n      textShadow,\n      strokeStyle,\n      lineWidth,\n      lineCap,\n      lineJoin,\n      bottomOffset,\n    } = this.#opts;\n    const ctx = this.#ctx;\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalAlpha = 0.6;\n    // 测试canvas背景\n    // ctx.fillStyle = 'red'\n    // ctx.fillRect(0, 0, this.#cvs.width, this.#cvs.height)\n\n    let bottomDistance = bottomOffset;\n    for (const lineStr of lines) {\n      const txtMeas = ctx.measureText(lineStr);\n      const centerX = width / 2;\n      if (textBgColor != null) {\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.shadowBlur = 0;\n        // 字幕背景\n        ctx.fillStyle = textBgColor;\n        ctx.globalAlpha = 0.5;\n        ctx.fillRect(\n          centerX - txtMeas.actualBoundingBoxLeft - this.#linePadding,\n          height - bottomDistance - this.#lineHeight,\n          txtMeas.width + this.#linePadding * 2,\n          this.#lineHeight,\n        );\n      } else {\n      }\n\n      ctx.shadowColor = textShadow.color;\n      ctx.shadowOffsetX = textShadow.offsetX;\n      ctx.shadowOffsetY = textShadow.offsetY;\n      ctx.shadowBlur = textShadow.blur;\n\n      ctx.globalAlpha = 1;\n\n      if (strokeStyle != null) {\n        ctx.lineWidth = lineWidth ?? fontSize / 6;\n        if (lineCap != null) ctx.lineCap = lineCap;\n        if (lineJoin != null) ctx.lineJoin = lineJoin;\n        ctx.strokeStyle = strokeStyle;\n        ctx.strokeText(\n          lineStr,\n          centerX,\n          height - bottomDistance - this.#lineHeight + this.#linePadding,\n        );\n      }\n\n      ctx.fillStyle = color;\n      ctx.fillText(\n        lineStr,\n        centerX,\n        height - bottomDistance - this.#lineHeight + this.#linePadding,\n      );\n\n      // 多行，底部偏移距离叠加\n      bottomDistance += this.#lineHeight + fontSize * 0.2;\n    }\n  }\n\n  /**\n   * @see {@link IClip.tick}\n   */\n  async tick(time: number): Promise<{\n    video?: VideoFrame;\n    state: 'done' | 'success';\n  }> {\n    if (\n      this.#lastVF != null &&\n      time >= this.#lastVF.timestamp &&\n      time <= this.#lastVF.timestamp + (this.#lastVF.duration ?? 0)\n    ) {\n      return { video: this.#lastVF.clone(), state: 'success' };\n    }\n\n    let i = 0;\n    for (; i < this.#subtitles.length; i += 1) {\n      if (time <= this.#subtitles[i].end) break;\n    }\n\n    const it = this.#subtitles[i] ?? this.#subtitles.at(-1);\n    if (time > it.end) return { state: 'done' };\n    if (time < it.start) {\n      // 此时无字幕内容，清空画布\n      this.#ctx.clearRect(0, 0, this.#cvs.width, this.#cvs.height);\n      const vf = new VideoFrame(this.#cvs, {\n        timestamp: time,\n        // 直到下个字幕出现的时机\n        duration: it.start - time,\n      });\n      this.#lastVF?.close();\n      this.#lastVF = vf;\n\n      return { video: vf.clone(), state: 'success' };\n    }\n\n    this.#renderTxt(it.text);\n\n    const vf = new VideoFrame(this.#cvs, {\n      timestamp: time,\n      duration: it.end - time,\n    });\n    this.#lastVF?.close();\n    this.#lastVF = vf;\n\n    return { video: vf.clone(), state: 'success' };\n  }\n\n  /**\n   * @see {@link IClip.split}\n   */\n  async split(time: number) {\n    await this.ready;\n    let hitIdx = -1;\n    for (let i = 0; i < this.#subtitles.length; i++) {\n      const sub = this.#subtitles[i];\n      if (time > sub.start) continue;\n      hitIdx = i;\n      break;\n    }\n    if (hitIdx === -1) throw Error('Not found subtitle by time');\n    const preSlice = this.#subtitles.slice(0, hitIdx).map((s) => ({ ...s }));\n    let preLastIt = preSlice.at(-1);\n    let postFirstIt = null;\n    // 切割时间命中字幕区间，需要将当前字幕元素拆成前后两份\n    if (preLastIt != null && preLastIt.end > time) {\n      postFirstIt = {\n        start: 0,\n        end: preLastIt.end - time,\n        text: preLastIt.text,\n      };\n\n      preLastIt.end = time;\n    }\n    const postSlice = this.#subtitles\n      .slice(hitIdx)\n      .map((s) => ({ ...s, start: s.start - time, end: s.end - time }));\n    if (postFirstIt != null) postSlice.unshift(postFirstIt);\n    return [\n      new EmbedSubtitlesClip(preSlice, this.#opts),\n      new EmbedSubtitlesClip(postSlice, this.#opts),\n    ] as [this, this];\n  }\n\n  /**\n   * @see {@link IClip.clone}\n   */\n  async clone() {\n    return new EmbedSubtitlesClip(this.#subtitles.slice(0), this.#opts) as this;\n  }\n\n  /**\n   * @see {@link IClip.destroy}\n   */\n  destroy() {\n    this.#lastVF?.close();\n  }\n}\n\n// SRT字幕格式 https://www.cnblogs.com/tocy/p/subtitle-format-srt.html\nfunction srtTimeToSeconds(time: string) {\n  const match = time.match(/(\\d{2}):(\\d{2}):(\\d{2}),(\\d{3})/);\n  if (match == null) throw Error(`time format error: ${time}`);\n\n  const hours = Number(match[1]);\n  const minutes = Number(match[2]);\n  const seconds = Number(match[3]);\n  const milliseconds = Number(match[4]);\n\n  return hours * 60 * 60 + minutes * 60 + seconds + milliseconds / 1000;\n}\n\nfunction parseSrt(srt: string) {\n  return (\n    srt\n      .split(/\\r|\\n/)\n      .map((s) => s.trim())\n      .filter((str) => str.length > 0)\n      // 匹配时间戳标记行，匹配失败的为字幕内容\n      .map((s) => ({\n        lineStr: s,\n        match: s.match(\n          /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})/,\n        ),\n      }))\n      // 过滤掉时间上一行的数字标记\n      .filter(\n        ({ lineStr }, idx, source) =>\n          !(/^\\d+$/.test(lineStr) && source[idx + 1]?.match != null),\n      )\n      // 按时间标记行聚合，拼接字幕内容到 text 字段\n      .reduce(\n        (acc, { lineStr, match }) => {\n          if (match == null) {\n            const last = acc.at(-1);\n            if (last == null) return acc;\n\n            last.text += last.text.length === 0 ? lineStr : `\\n${lineStr}`;\n          } else {\n            acc.push({\n              start: srtTimeToSeconds(match[1]),\n              end: srtTimeToSeconds(match[2]),\n              text: '',\n            });\n          }\n\n          return acc;\n        },\n        [] as Array<{\n          start: number;\n          end: number;\n          text: string;\n        }>,\n      )\n  );\n}\n","import mp4box, {\n  MP4ArrayBuffer,\n  MP4File,\n  MP4Info,\n  MP4Sample,\n} from '@webav/mp4box.js';\n\n/**\n * 将原始字节流转换成 MP4Sample 流\n */\nexport class SampleTransform {\n  readable: ReadableStream<\n    | {\n        chunkType: 'ready';\n        data: { info: MP4Info; file: MP4File };\n      }\n    | {\n        chunkType: 'samples';\n        data: { id: number; type: 'video' | 'audio'; samples: MP4Sample[] };\n      }\n  >;\n\n  writable: WritableStream<Uint8Array>;\n\n  #inputBufOffset = 0;\n\n  constructor() {\n    const file = mp4box.createFile();\n    let streamCancelled = false;\n    this.readable = new ReadableStream(\n      {\n        start: (ctrl) => {\n          file.onReady = (info) => {\n            const vTrackId = info.videoTracks[0]?.id;\n            if (vTrackId != null)\n              file.setExtractionOptions(vTrackId, 'video', { nbSamples: 100 });\n\n            const aTrackId = info.audioTracks[0]?.id;\n            if (aTrackId != null)\n              file.setExtractionOptions(aTrackId, 'audio', { nbSamples: 100 });\n\n            ctrl.enqueue({ chunkType: 'ready', data: { info, file } });\n            file.start();\n          };\n\n          const releasedCnt: Record<number, number> = {};\n          file.onSamples = (id, type, samples) => {\n            ctrl.enqueue({\n              chunkType: 'samples',\n              data: { id, type, samples: samples.map((s) => ({ ...s })) },\n            });\n            releasedCnt[id] = (releasedCnt[id] ?? 0) + samples.length;\n            file.releaseUsedSamples(id, releasedCnt[id]);\n          };\n\n          file.onFlush = () => {\n            ctrl.close();\n          };\n        },\n        cancel: () => {\n          file.stop();\n          streamCancelled = true;\n        },\n      },\n      {\n        // 每条消息 100 个 samples\n        highWaterMark: 50,\n      },\n    );\n\n    this.writable = new WritableStream({\n      write: async (ui8Arr) => {\n        if (streamCancelled) {\n          this.writable.abort();\n          return;\n        }\n\n        const inputBuf = ui8Arr.buffer as MP4ArrayBuffer;\n        inputBuf.fileStart = this.#inputBufOffset;\n        this.#inputBufOffset += inputBuf.byteLength;\n        file.appendBuffer(inputBuf);\n      },\n      close: () => {\n        file.flush();\n        file.stop();\n        file.onFlush?.();\n      },\n    });\n  }\n}\n","import mp4box, {\n  MP4File,\n  MP4Sample,\n  SampleOpts,\n  TrakBoxParser,\n} from '@webav/mp4box.js';\nimport { autoReadStream, file2stream, Log } from '@webav/internal-utils';\nimport {\n  extractPCM4AudioData,\n  extractPCM4AudioBuffer,\n  mixinPCM,\n  ringSliceFloat32Array,\n  concatPCMFragments,\n} from '../av-utils';\nimport { DEFAULT_AUDIO_CONF } from '../clips';\nimport { SampleTransform } from './sample-transform';\nimport { extractFileConfig } from './mp4box-utils';\nimport { tmpfile, write } from 'opfs-tools';\n\nfunction fixMP4BoxFileDuration(\n  inMP4File: MP4File,\n): () => Promise<ReadableStream<Uint8Array> | null> {\n  let sendedBoxIdx = 0;\n  const boxes = inMP4File.boxes;\n  const tracks: Array<{ track: TrakBoxParser; id: number }> = [];\n  let totalDuration = 0;\n\n  async function write2TmpFile() {\n    const buf = box2Buf(boxes, sendedBoxIdx);\n    sendedBoxIdx = boxes.length;\n    // 释放引用，避免内存泄露\n    // todo: use unsafeReleaseMP4BoxFile\n    tracks.forEach(({ track, id }) => {\n      const s = track.samples.at(-1);\n      if (s != null)\n        totalDuration = Math.max(totalDuration, s.cts + s.duration);\n\n      inMP4File.releaseUsedSamples(id, track.samples.length);\n      track.samples = [];\n    });\n    inMP4File.mdats = [];\n    inMP4File.moofs = [];\n    if (buf != null) await tmpFileWriter?.write(buf);\n  }\n\n  let moovPrevBoxes: typeof boxes = [];\n  function moovBoxReady() {\n    if (moovPrevBoxes.length > 0) return true;\n\n    const moovIdx = boxes.findIndex((box) => box.type === 'moov');\n    if (moovIdx === -1) return false;\n\n    moovPrevBoxes = boxes.slice(0, moovIdx + 1);\n    sendedBoxIdx = moovIdx + 1;\n\n    if (tracks.length === 0) {\n      for (let i = 1; true; i += 1) {\n        const track = inMP4File.getTrackById(i);\n        if (track == null) break;\n        tracks.push({ track, id: i });\n      }\n    }\n\n    return true;\n  }\n\n  let timerId = 0;\n  // 把 moov 之外的 box 先写入临时文件，待更新 duration 之后再拼接临时文件\n  const postFile = tmpfile();\n  let tmpFileWriter: Awaited<\n    ReturnType<ReturnType<typeof tmpfile>['createWriter']>\n  > | null = null;\n\n  const initPromise = (async () => {\n    tmpFileWriter = await postFile.createWriter();\n\n    timerId = self.setInterval(() => {\n      if (!moovBoxReady()) return;\n      write2TmpFile();\n    }, 100);\n  })();\n\n  let stoped = false;\n  return async () => {\n    if (stoped) throw Error('File exported');\n    stoped = true;\n\n    await initPromise;\n    clearInterval(timerId);\n\n    if (!moovBoxReady() || tmpFileWriter == null) return null;\n    inMP4File.flush();\n    await write2TmpFile();\n    await tmpFileWriter?.close();\n\n    const moov = moovPrevBoxes.find((box) => box.type === 'moov') as\n      | typeof inMP4File.moov\n      | undefined;\n    if (moov == null) return null;\n\n    moov.mvhd.duration = totalDuration;\n\n    const rsFile = tmpfile();\n    const buf = box2Buf(moovPrevBoxes, 0)!;\n    await write(rsFile, buf);\n    await write(rsFile, postFile, { overwrite: false });\n\n    return await rsFile.stream();\n  };\n\n  function box2Buf(source: typeof boxes, startIdx: number): Uint8Array | null {\n    if (startIdx >= source.length) return null;\n\n    const ds = new mp4box.DataStream();\n    ds.endianness = mp4box.DataStream.BIG_ENDIAN;\n\n    for (let i = startIdx; i < source.length; i++) {\n      if (source[i] === null) continue;\n      source[i].write(ds);\n      delete source[i];\n    }\n    return new Uint8Array(ds.buffer);\n  }\n}\n\n/**\n * EncodedAudioChunk | EncodedVideoChunk 转换为 MP4 addSample 需要的参数\n */\nfunction chunk2MP4SampleOpts(\n  chunk: EncodedAudioChunk | EncodedVideoChunk,\n): SampleOpts & {\n  data: ArrayBuffer;\n} {\n  const buf = new ArrayBuffer(chunk.byteLength);\n  chunk.copyTo(buf);\n  const dts = chunk.timestamp;\n  return {\n    duration: chunk.duration ?? 0,\n    dts,\n    cts: dts,\n    is_sync: chunk.type === 'key',\n    data: buf,\n  };\n}\n\n/**\n * 快速拼接多个mp4 文件流，要求所有 mp4 的属性一致，\n * 属性包括（不限于）：音视频编码格式、分辨率、采样率\n *\n * @param streams 一个包含 Uint8Array 的可读流数组。\n * @returns 返回一个 Promise，该 Promise 在解析时返回一个包含合并后的 MP4 数据的可读流。\n * @throws 如果无法从流生成文件，将抛出错误。\n *\n * @example\n * const streams = [stream1, stream2, stream3];\n * const resultStream = await fastConcatMP4(streams);\n */\nexport async function fastConcatMP4(\n  streams: ReadableStream<Uint8Array>[],\n): Promise<ReadableStream<Uint8Array>> {\n  const outfile = mp4box.createFile();\n\n  const dumpFile = fixMP4BoxFileDuration(outfile);\n  await concatStreamsToMP4BoxFile(streams, outfile);\n  const outStream = await dumpFile();\n  if (outStream == null) throw Error('Can not generate file from streams');\n  return outStream;\n}\n\nasync function concatStreamsToMP4BoxFile(\n  streams: ReadableStream<Uint8Array>[],\n  outfile: MP4File,\n) {\n  let vTrackId = 0;\n  let vDTS = 0;\n  let vCTS = 0;\n  let aTrackId = 0;\n  let aDTS = 0;\n  let aCTS = 0;\n  // ts bug, 不能正确识别类型\n  let lastVSamp: any = null;\n  let lastASamp: any = null;\n  for (const stream of streams) {\n    await new Promise<void>(async (resolve) => {\n      autoReadStream(stream.pipeThrough(new SampleTransform()), {\n        onDone: resolve,\n        onChunk: async ({ chunkType, data }) => {\n          if (chunkType === 'ready') {\n            const { videoTrackConf, audioTrackConf } = extractFileConfig(\n              data.file,\n              data.info,\n            );\n            if (vTrackId === 0 && videoTrackConf != null) {\n              vTrackId = outfile.addTrack(videoTrackConf);\n            }\n            if (aTrackId === 0 && audioTrackConf != null) {\n              aTrackId = outfile.addTrack(audioTrackConf);\n            }\n          } else if (chunkType === 'samples') {\n            const { type, samples } = data;\n            const trackId = type === 'video' ? vTrackId : aTrackId;\n            const offsetDTS = type === 'video' ? vDTS : aDTS;\n            const offsetCTS = type === 'video' ? vCTS : aCTS;\n\n            samples.forEach((s) => {\n              outfile.addSample(trackId, s.data, {\n                duration: s.duration,\n                dts: s.dts + offsetDTS,\n                cts: s.cts + offsetCTS,\n                is_sync: s.is_sync,\n              });\n            });\n\n            const lastSamp = samples.at(-1);\n            if (lastSamp == null) return;\n            if (type === 'video') {\n              lastVSamp = lastSamp;\n            } else if (type === 'audio') {\n              lastASamp = lastSamp;\n            }\n          }\n        },\n      });\n    });\n    if (lastVSamp != null) {\n      vDTS += lastVSamp.dts;\n      vCTS += lastVSamp.cts;\n    }\n    if (lastASamp != null) {\n      aDTS += lastASamp.dts;\n      aCTS += lastASamp.cts;\n    }\n  }\n}\n\n/**\n * 为 WebAV 生成的 fmp4 文件设置正确的时长值\n */\nexport async function fixFMP4Duration(\n  stream: ReadableStream<Uint8Array>,\n): Promise<ReadableStream<Uint8Array>> {\n  return await fastConcatMP4([stream]);\n}\n\n/**\n * 创建 MP4 音频样本解码器。\n * @param adConf - 音频解码器配置参数 {@link AudioDecoderConfig}。\n * @returns 返回一个对象，包含 `decode` 和 `close` 方法。\n * - `decode` 方法用于解码 MP4 音频样本，返回解码后的音频数据数组。\n * - `close` 方法用于关闭音频解码器。\n */\nfunction createMP4AudioSampleDecoder(\n  adConf: Parameters<AudioDecoder['configure']>[0],\n) {\n  let cacheAD: AudioData[] = [];\n  const adDecoder = new AudioDecoder({\n    output: (ad) => {\n      cacheAD.push(ad);\n    },\n    error: Log.error,\n  });\n  adDecoder.configure(adConf);\n\n  return {\n    decode: async (ss: MP4Sample[]) => {\n      ss.forEach((s) => {\n        adDecoder.decode(\n          new EncodedAudioChunk({\n            type: s.is_sync ? 'key' : 'delta',\n            timestamp: (1e6 * s.cts) / s.timescale,\n            duration: (1e6 * s.duration) / s.timescale,\n            data: s.data,\n          }),\n        );\n      });\n\n      await adDecoder.flush();\n\n      const rs = cacheAD;\n      cacheAD = [];\n\n      return rs;\n    },\n    close: () => {\n      adDecoder.close();\n    },\n  };\n}\n\n// 音频编码与解码API有很大区别，\n// 是因为编码中途调用 AudioEncoder.flush ，会导致声音听起来卡顿\nfunction createMP4AudioSampleEncoder(\n  aeConf: Parameters<AudioEncoder['configure']>[0],\n  onOutput: (s: ReturnType<typeof chunk2MP4SampleOpts>) => void,\n) {\n  const encoderConf = {\n    codec: aeConf.codec,\n    sampleRate: aeConf.sampleRate,\n    numberOfChannels: aeConf.numberOfChannels,\n  } as const;\n\n  const adEncoder = new AudioEncoder({\n    output: (chunk) => {\n      onOutput(chunk2MP4SampleOpts(chunk));\n    },\n    error: (err) => {\n      Log.error('AudioEncoder error:', err, ', config:', encoderConf);\n    },\n  });\n\n  adEncoder.configure(encoderConf);\n\n  // 保留一个音频数据，用于最后做声音淡出\n  let lastData: { data: Float32Array; ts: number } | null = null;\n\n  function createAD(data: Float32Array, ts: number) {\n    return new AudioData({\n      timestamp: ts,\n      numberOfChannels: aeConf.numberOfChannels,\n      numberOfFrames: data.length / aeConf.numberOfChannels,\n      sampleRate: aeConf.sampleRate,\n      format: 'f32-planar',\n      data,\n    });\n  }\n  return {\n    encode: async (data: Float32Array, ts: number) => {\n      if (lastData != null) {\n        adEncoder.encode(createAD(lastData.data, lastData.ts));\n      }\n      lastData = { data, ts };\n    },\n    stop: async () => {\n      if (lastData != null) {\n        // 副作用修改数据\n        audioFade(lastData.data, aeConf.numberOfChannels, aeConf.sampleRate);\n        adEncoder.encode(createAD(lastData.data, lastData.ts));\n        lastData = null;\n      }\n      await adEncoder.flush();\n      adEncoder.close();\n    },\n  };\n}\n\n/**\n * 音频线性淡出，避免 POP 声\n * 副作用调整音量值\n */\nfunction audioFade(pcmData: Float32Array, chanCnt: number, sampleRate: number) {\n  const dataLen = pcmData.length - 1;\n  // 避免超出边界，最长 500ms 的淡出时间\n  const fadeLen = Math.min(sampleRate / 2, dataLen);\n  for (let i = 0; i < fadeLen; i++) {\n    for (let j = 1; j <= chanCnt; j++) {\n      // 从尾部开始，调整每个声道音量值\n      pcmData[Math.floor(dataLen / j) - i] *= i / fadeLen;\n    }\n  }\n}\n\n/**\n * 视频配音；混合 MP4 与音频文件，仅重编码音频，视频轨道不变\n * @param mp4Stream - MP4 流\n * @param audio - 音频信息\n * @param audio.stream - 音频数据流\n * @param audio.volume - 音频音量\n * @param audio.loop - 音频时长小于视频时，是否循环使用音频流\n * @returns 输出混合后的音频流\n */\nexport function mixinMP4AndAudio(\n  mp4Stream: ReadableStream<Uint8Array>,\n  audio: {\n    stream: ReadableStream<Uint8Array>;\n    volume: number;\n    loop: boolean;\n  },\n) {\n  Log.info('mixinMP4AndAudio, opts:', {\n    volume: audio.volume,\n    loop: audio.loop,\n  });\n\n  const outfile = mp4box.createFile();\n  const { stream: outStream, stop: stopOut } = file2stream(outfile, 500);\n\n  let audioSampleDecoder: ReturnType<\n    typeof createMP4AudioSampleDecoder\n  > | null = null;\n\n  let audioSampleEncoder: ReturnType<\n    typeof createMP4AudioSampleEncoder\n  > | null = null;\n\n  let inputAudioPCM: Float32Array[] = [];\n\n  let vTrackId = 0;\n  let aTrackId = 0;\n  let audioOffset = 0;\n  let mp4HasAudio = true;\n  let sampleRate = DEFAULT_AUDIO_CONF.sampleRate as number;\n  autoReadStream(mp4Stream.pipeThrough(new SampleTransform()), {\n    onDone: async () => {\n      await audioSampleEncoder?.stop();\n      audioSampleDecoder?.close();\n      stopOut();\n    },\n    onChunk: async ({ chunkType, data }) => {\n      if (chunkType === 'ready') {\n        const { videoTrackConf, audioTrackConf, audioDecoderConf } =\n          extractFileConfig(data.file, data.info);\n        if (vTrackId === 0 && videoTrackConf != null) {\n          vTrackId = outfile.addTrack(videoTrackConf);\n        }\n\n        const safeAudioTrackConf = audioTrackConf ?? {\n          timescale: 1e6,\n          samplerate: sampleRate,\n          channel_count: DEFAULT_AUDIO_CONF.channelCount,\n          hdlr: 'soun',\n          name: 'SoundHandler',\n          type: 'mp4a',\n        };\n        if (aTrackId === 0) {\n          aTrackId = outfile.addTrack(safeAudioTrackConf);\n          sampleRate = audioTrackConf?.samplerate ?? sampleRate;\n          mp4HasAudio = audioTrackConf == null ? false : true;\n        }\n        const audioCtx = new AudioContext({ sampleRate });\n        inputAudioPCM = extractPCM4AudioBuffer(\n          await audioCtx.decodeAudioData(\n            await new Response(audio.stream).arrayBuffer(),\n          ),\n        );\n\n        if (audioDecoderConf != null) {\n          audioSampleDecoder = createMP4AudioSampleDecoder(audioDecoderConf);\n        }\n        audioSampleEncoder = createMP4AudioSampleEncoder(\n          audioDecoderConf ?? {\n            codec:\n              safeAudioTrackConf.type === 'mp4a'\n                ? DEFAULT_AUDIO_CONF.codec\n                : safeAudioTrackConf.type,\n            numberOfChannels: safeAudioTrackConf.channel_count,\n            sampleRate: safeAudioTrackConf.samplerate,\n          },\n          (s) => outfile.addSample(aTrackId, s.data, s),\n        );\n      } else if (chunkType === 'samples') {\n        const { id, type, samples } = data;\n        if (type === 'video') {\n          samples.forEach((s) => outfile.addSample(id, s.data, s));\n\n          if (!mp4HasAudio) await addInputAudio2Track(samples);\n          return;\n        }\n\n        if (type === 'audio') await mixinAudioSampleAndInputPCM(samples);\n      }\n    },\n  });\n\n  function getInputAudioSlice(len: number) {\n    const rs = inputAudioPCM.map((chanBuf) =>\n      audio.loop\n        ? ringSliceFloat32Array(chanBuf, audioOffset, audioOffset + len)\n        : chanBuf.slice(audioOffset, audioOffset + len),\n    );\n    audioOffset += len;\n\n    if (audio.volume !== 1) {\n      for (const buf of rs)\n        for (let i = 0; i < buf.length; i++) buf[i] *= audio.volume;\n    }\n\n    return rs;\n  }\n\n  async function addInputAudio2Track(vdieoSamples: MP4Sample[]) {\n    const firstSamp = vdieoSamples[0];\n    const lastSamp = vdieoSamples[vdieoSamples.length - 1];\n    const pcmLength = Math.floor(\n      ((lastSamp.cts + lastSamp.duration - firstSamp.cts) /\n        lastSamp.timescale) *\n        sampleRate,\n    );\n    const audioDataBuf = mixinPCM([getInputAudioSlice(pcmLength)]);\n    if (audioDataBuf.length === 0) return;\n    audioSampleEncoder?.encode(\n      audioDataBuf,\n      (firstSamp.cts / firstSamp.timescale) * 1e6,\n    );\n  }\n\n  async function mixinAudioSampleAndInputPCM(samples: MP4Sample[]) {\n    if (audioSampleDecoder == null) return;\n\n    // 1. 先解码mp4音频\n    // [[chan0, chan1], [chan0, chan1]...]\n    const pcmFragments = (await audioSampleDecoder.decode(samples)).map(\n      extractPCM4AudioData,\n    );\n    // [chan0, chan1]\n    const mp4AudioPCM = concatPCMFragments(pcmFragments);\n    const inputAudioPCM = getInputAudioSlice(mp4AudioPCM[0].length);\n    const firstSamp = samples[0];\n\n    // 3. 重编码音频\n    audioSampleEncoder?.encode(\n      // 2. 混合输入的音频\n      mixinPCM([mp4AudioPCM, inputAudioPCM]),\n      (firstSamp.cts / firstSamp.timescale) * 1e6,\n    );\n  }\n\n  return outStream;\n}\n","// 改编自 https://jameshfisher.com/2020/08/11/production-ready-green-screen-in-the-browser/\nconst vertexShader = `#version 300 es\n  layout (location = 0) in vec4 a_position;\n  layout (location = 1) in vec2 a_texCoord;\n  out vec2 v_texCoord;\n  void main () {\n    gl_Position = a_position;\n    v_texCoord = a_texCoord;\n  }\n`;\n\nconst fragmentShader = `#version 300 es\nprecision mediump float;\nout vec4 FragColor;\nin vec2 v_texCoord;\n\nuniform sampler2D frameTexture;\nuniform vec3 keyColor;\n\n// 色度的相似度计算\nuniform float similarity;\n// 透明度的平滑度计算\nuniform float smoothness;\n// 降低绿幕饱和度，提高抠图准确度\nuniform float spill;\n\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\n\nvoid main() {\n  // 获取当前像素的rgba值\n  vec4 rgba = texture(frameTexture, v_texCoord);\n  // 计算当前像素与绿幕像素的色度差值\n  vec2 chromaVec = RGBtoUV(rgba.rgb) - RGBtoUV(keyColor);\n  // 计算当前像素与绿幕像素的色度距离（向量长度）, 越相像则色度距离越小\n  float chromaDist = sqrt(dot(chromaVec, chromaVec));\n  // 设置了一个相似度阈值，baseMask为负，则表明是绿幕，为正则表明不是绿幕\n  float baseMask = chromaDist - similarity;\n  // 如果baseMask为负数，fullMask等于0；baseMask为正数，越大，则透明度越低\n  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);\n  rgba.a = fullMask; // 设置透明度\n  // 如果baseMask为负数，spillVal等于0；baseMask为整数，越小，饱和度越低\n  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);\n  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.); // 计算当前像素的灰度值\n  rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);\n  FragColor = rgba;\n}\n`;\n\nconst POINT_POS = [-1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1];\nconst TEX_COORD_POS = [0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1];\n\n//  初始化着色器程序，让 WebGL 知道如何绘制我们的数据\nfunction initShaderProgram(\n  gl: WebGLRenderingContext,\n  vsSource: string,\n  fsSource: string,\n) {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource)!;\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource)!;\n\n  // 创建着色器程序\n  const shaderProgram = gl.createProgram()!;\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    throw Error(\n      gl.getProgramInfoLog(shaderProgram) ??\n        'Unable to initialize the shader program',\n    );\n  }\n\n  return shaderProgram;\n}\n\n// 创建指定类型的着色器，上传 source 源码并编译\nfunction loadShader(gl: WebGLRenderingContext, type: number, source: string) {\n  const shader = gl.createShader(type)!;\n\n  // Send the source to the shader object\n  gl.shaderSource(shader, source);\n\n  // Compile the shader program\n  gl.compileShader(shader);\n\n  // See if it compiled successfully\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const errMsg = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw Error(errMsg ?? 'An error occurred compiling the shaders');\n  }\n\n  return shader;\n}\n\nfunction updateTexture(\n  gl: WebGLRenderingContext,\n  img: TImgSource,\n  texture: WebGLTexture,\n) {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n  gl.drawArrays(gl.TRIANGLES, 0, 6);\n}\n\nfunction initTexture(gl: WebGLRenderingContext) {\n  const texture = gl.createTexture();\n  if (texture == null) throw Error('Create WebGL texture error');\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // put a single pixel in the texture so we can use it immediately.\n  const level = 0;\n  const internalFormat = gl.RGBA;\n  const width = 1;\n  const height = 1;\n  const border = 0;\n  const srcFormat = gl.RGBA;\n  const srcType = gl.UNSIGNED_BYTE;\n  const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    level,\n    internalFormat,\n    width,\n    height,\n    border,\n    srcFormat,\n    srcType,\n    pixel,\n  );\n\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n  return texture;\n}\n\ninterface IChromakeyOpts {\n  keyColor: [number, number, number];\n  similarity: number;\n  smoothness: number;\n  spill: number;\n}\n\nfunction initCvs(\n  opts: {\n    width: number;\n    height: number;\n  } & IChromakeyOpts,\n) {\n  const cvs =\n    'document' in globalThis\n      ? globalThis.document.createElement('canvas')\n      : new OffscreenCanvas(opts.width, opts.height);\n  cvs.width = opts.width;\n  cvs.height = opts.height;\n\n  const gl = cvs.getContext('webgl2', {\n    premultipliedAlpha: false,\n    alpha: true,\n  }) as WebGL2RenderingContext | null;\n\n  if (gl == null) throw Error('Cant create gl context');\n\n  const shaderProgram = initShaderProgram(gl, vertexShader, fragmentShader);\n  gl.useProgram(shaderProgram);\n\n  gl.uniform3fv(\n    gl.getUniformLocation(shaderProgram, 'keyColor'),\n    opts.keyColor.map((v) => v / 255),\n  );\n  gl.uniform1f(\n    gl.getUniformLocation(shaderProgram, 'similarity'),\n    opts.similarity,\n  );\n  gl.uniform1f(\n    gl.getUniformLocation(shaderProgram, 'smoothness'),\n    opts.smoothness,\n  );\n  gl.uniform1f(gl.getUniformLocation(shaderProgram, 'spill'), opts.spill);\n\n  const posBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(POINT_POS), gl.STATIC_DRAW);\n  const a_position = gl.getAttribLocation(shaderProgram, 'a_position');\n  gl.vertexAttribPointer(\n    a_position,\n    2,\n    gl.FLOAT,\n    false,\n    Float32Array.BYTES_PER_ELEMENT * 2,\n    0,\n  );\n  gl.enableVertexAttribArray(a_position);\n\n  const texCoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array(TEX_COORD_POS),\n    gl.STATIC_DRAW,\n  );\n  const a_texCoord = gl.getAttribLocation(shaderProgram, 'a_texCoord');\n  gl.vertexAttribPointer(\n    a_texCoord,\n    2,\n    gl.FLOAT,\n    false,\n    Float32Array.BYTES_PER_ELEMENT * 2,\n    0,\n  );\n  gl.enableVertexAttribArray(a_texCoord);\n\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n\n  return { cvs, gl };\n}\n\ntype TImgSource =\n  | HTMLVideoElement\n  | HTMLCanvasElement\n  | HTMLImageElement\n  | ImageBitmap\n  | OffscreenCanvas\n  | VideoFrame;\n\nfunction getSourceWH(imgSource: TImgSource) {\n  return imgSource instanceof VideoFrame\n    ? { width: imgSource.codedWidth, height: imgSource.codedHeight }\n    : { width: imgSource.width, height: imgSource.height };\n}\n\nfunction getKeyColor(imgSource: TImgSource) {\n  const cvs = new OffscreenCanvas(1, 1);\n  const ctx = cvs.getContext('2d')!;\n  ctx.drawImage(imgSource, 0, 0);\n  const {\n    data: [r, g, b],\n  } = ctx.getImageData(0, 0, 1, 1);\n  return [r, g, b] as [number, number, number];\n}\n\n/**\n * 绿幕抠图\n * keyColor 需要扣除的背景色，若不传则取第一个像素点\n * similarity 背景色相似度阈值，过小可能保留背景色，过大可能扣掉更多非背景像素点\n * smoothness 平滑度；过小可能出现锯齿，过大导致整体变透明\n * spill      饱和度；过小可能保留绿色混合，过大导致图片变灰度\n * @param opts: {\n *   keyColor?: [r, g, b]\n *   similarity: number\n *   smoothness: number\n *   spill: number\n * }\n */\nexport const createChromakey = (\n  opts: Omit<IChromakeyOpts, 'keyColor'> & {\n    keyColor?: [number, number, number];\n  },\n) => {\n  let cvs: HTMLCanvasElement | OffscreenCanvas | null = null;\n  let gl: WebGLRenderingContext | null = null;\n  let keyC = opts.keyColor;\n  let texture: WebGLTexture | null = null;\n\n  return async (imgSource: TImgSource) => {\n    if (cvs == null || gl == null || texture == null) {\n      if (keyC == null) keyC = getKeyColor(imgSource);\n      ({ cvs, gl } = initCvs({\n        ...getSourceWH(imgSource),\n        keyColor: keyC,\n        ...opts,\n      }));\n      texture = initTexture(gl);\n    }\n\n    updateTexture(gl, imgSource, texture);\n\n    if (\n      globalThis.VideoFrame != null &&\n      imgSource instanceof globalThis.VideoFrame\n    ) {\n      const rs = new VideoFrame(cvs, {\n        alpha: 'keep',\n        timestamp: imgSource.timestamp,\n        duration: imgSource.duration ?? undefined,\n      });\n      imgSource.close();\n      return rs;\n    }\n\n    return createImageBitmap(cvs, {\n      imageOrientation: imgSource instanceof ImageBitmap ? 'flipY' : 'none',\n    });\n  };\n};\n","import { EventTool } from '@webav/internal-utils';\n\ninterface IPoint {\n  x: number;\n  y: number;\n}\n\nexport interface IRectBaseProps {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n  angle: number;\n}\n\n/**\n * 用于记录素材在视频或画布中的空间属性：位置、大小、旋转\n *\n * 并提供控制点位置，支持用户在画布中缩放、旋转素材\n *\n * 一般由内部 WebAV SDK 内部创建维护\n *\n * @see {@link Combinator}, {@link OffscreenSprite}\n * @see [AVCanvas](../../av-canvas/classes/AVCanvas.html), {@link VisibleSprite}\n *\n * @see [视频剪辑](https://webav-tech.github.io/WebAV/demo/6_4-video-editor)\n */\nexport class Rect implements IRectBaseProps {\n  #evtTool = new EventTool<{\n    propsChange: (props: Partial<IRectBaseProps>) => void;\n  }>();\n  /**\n   * 监听属性变更事件\n   * @example\n   * rect.on('propsChange', (changedProps) => {})\n   */\n  on = this.#evtTool.on;\n\n  #x = 0;\n  /**\n   * x 坐标\n   */\n  get x() {\n    return this.#x;\n  }\n  set x(v) {\n    this.#setBaseProps('x', v);\n  }\n  #y = 0;\n  get y() {\n    return this.#y;\n  }\n  /**\n   * y 坐标\n   */\n  set y(v) {\n    this.#setBaseProps('y', v);\n  }\n  #w = 0;\n  /**\n   * 宽\n   */\n  get w() {\n    return this.#w;\n  }\n  set w(v) {\n    this.#setBaseProps('w', v);\n  }\n  #h = 0;\n  /**\n   * 高\n   */\n  get h() {\n    return this.#h;\n  }\n  set h(v) {\n    this.#setBaseProps('h', v);\n  }\n  #angle = 0;\n  /**\n   * 旋转角度\n   * @see [MDN Canvas rotate](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/rotate)\n   */\n  get angle() {\n    return this.#angle;\n  }\n  set angle(v) {\n    this.#setBaseProps('angle', v);\n  }\n\n  #setBaseProps(prop: keyof IRectBaseProps, v: number) {\n    const changed = this[prop] !== v;\n    switch (prop) {\n      case 'x':\n        this.#x = v;\n        break;\n      case 'y':\n        this.#y = v;\n        break;\n      case 'w':\n        this.#w = v;\n        break;\n      case 'h':\n        this.#h = v;\n        break;\n      case 'angle':\n        this.#angle = v;\n        break;\n    }\n    if (changed) this.#evtTool.emit('propsChange', { [prop]: v });\n  }\n\n  /**\n   * 如果当前实例是 Rect 控制点之一，`master` 将指向该 Rect\n   *\n   * 控制点的坐标是相对于它的 `master` 定位\n   */\n  #master: Rect | null = null;\n\n  constructor(\n    x?: number,\n    y?: number,\n    w?: number,\n    h?: number,\n    master?: Rect | null,\n  ) {\n    this.x = x ?? 0;\n    this.y = y ?? 0;\n    this.w = w ?? 0;\n    this.h = h ?? 0;\n    this.#master = master ?? null;\n  }\n\n  /**\n   * 根据坐标、宽高计算出来的矩形中心点\n   */\n  get center(): IPoint {\n    const { x, y, w, h } = this;\n    return { x: x + w / 2, y: y + h / 2 };\n  }\n\n  /**\n   * 是否保持固定宽高比例，禁止变形缩放\n   *\n   * 值为 true 时，将缺少上下左右四个控制点\n   */\n  fixedAspectRatio = false;\n\n  /**\n   * 是否固定中心点进行缩放\n   * 值为 true 时，固定中心点不变进行缩放\n   * 值为 false 时，固定对角点不变进行缩放\n   */\n  fixedScaleCenter = false;\n\n  clone(): Rect {\n    const { x, y, w, h } = this;\n    const rect = new Rect(x, y, w, h, this.#master);\n    rect.angle = this.angle;\n    rect.fixedAspectRatio = this.fixedAspectRatio;\n    rect.fixedScaleCenter = this.fixedScaleCenter;\n    return rect;\n  }\n\n  /**\n   * 检测目标坐标是否命中当前实例\n   * @param tx 目标点 x 坐标\n   * @param ty 目标点 y 坐标\n   */\n  checkHit(tx: number, ty: number): boolean {\n    let { angle, center, x, y, w, h } = this;\n    // ctrls 的中心点、旋转角度都取自于 master （sprite）\n    const cnt = this.#master?.center ?? center;\n    const agl = this.#master?.angle ?? angle;\n    // ctrl 初始化时其坐标就是相对于 master 的，参见 get ctrls()\n    // 所以此处不用转换\n    if (this.#master == null) {\n      x = x - cnt.x;\n      y = y - cnt.y;\n    }\n    // 鼠标点击坐标映射成以中点为原点的坐标\n    const tOX = tx - cnt.x;\n    const tOY = ty - cnt.y;\n    // 如果有旋转，映射成相对 sprite 原点，旋转前的坐标\n    let mx = tOX;\n    let my = tOY;\n    if (agl !== 0) {\n      // 推导公式 https://github.com/hughfenghen/hughfenghen.github.io/issues/96\n      mx = tOX * Math.cos(agl) + tOY * Math.sin(agl);\n      my = tOY * Math.cos(agl) - tOX * Math.sin(agl);\n    }\n\n    if (mx < x || mx > x + w || my < y || my > y + h) return false;\n\n    return true;\n  }\n}\n","import { EventTool } from '@webav/internal-utils';\nimport { IRectBaseProps, Rect } from './rect';\n\ninterface IAnimationOpts {\n  duration: number;\n  delay?: number;\n  iterCount?: number;\n}\n\ntype TAnimateProps = IRectBaseProps & { opacity: number };\n\nexport type TAnimationKeyFrame = Array<[number, Partial<TAnimateProps>]>;\n\ntype TKeyFrameOpts = Partial<\n  Record<`${number}%` | 'from' | 'to', Partial<TAnimateProps>>\n>;\n\n/**\n * Sprite 基类\n *\n * @see {@link OffscreenSprite}\n * @see {@link VisibleSprite}\n */\nexport abstract class BaseSprite {\n  /**\n   * 控制素材在视频中的空间属性（坐标、旋转、缩放）\n   */\n  rect = new Rect();\n\n  /**\n   * 控制素材在的时间偏移、时长、播放速率，常用于剪辑场景时间轴（轨道）模块\n   * duration 不能大于引用 {@link IClip} 的时长，单位 微秒\n   *\n   * playbackRate 控制当前素材的播放速率，1 表示正常播放；\n   * **注意**\n   *    1. 设置 playbackRate 时需要主动修正 duration\n   *    2. 音频使用最简单的插值算法来改变速率，所以改变速率后音调会产生变化，自定义算法请使用 {@link MP4Clip.tickInterceptor} 配合实现\n   *\n   */\n  #time = {\n    offset: 0,\n    duration: 0,\n    playbackRate: 1,\n  };\n  get time(): { offset: number; duration: number; playbackRate: number } {\n    return this.#time;\n  }\n  set time(v: { offset: number; duration: number; playbackRate?: number }) {\n    Object.assign(this.#time, v);\n  }\n\n  #evtTool = new EventTool<{\n    propsChange: (\n      value: Partial<{ rect: Partial<Rect>; zIndex: number }>,\n    ) => void;\n  }>();\n  /**\n   * 监听属性变更事件\n   * @example\n   * sprite.on('propsChange', (changedProps) => {})\n   */\n  on = this.#evtTool.on;\n\n  #zIndex = 0;\n  get zIndex(): number {\n    return this.#zIndex;\n  }\n\n  /**\n   * 控制素材间的层级关系，zIndex 值较小的素材会被遮挡\n   */\n  set zIndex(v: number) {\n    const changed = this.#zIndex !== v;\n    this.#zIndex = v;\n    if (changed) this.#evtTool.emit('propsChange', { zIndex: v });\n  }\n\n  /**\n   * 不透明度\n   */\n  opacity = 1;\n\n  /**\n   * 水平或垂直方向翻转素材\n   */\n  flip: 'horizontal' | 'vertical' | null = null;\n\n  #animatKeyFrame: TAnimationKeyFrame | null = null;\n\n  #animatOpts: Required<IAnimationOpts> | null = null;\n\n  /**\n   * @see {@link IClip.ready}\n   */\n  ready = Promise.resolve();\n\n  constructor() {\n    this.rect.on('propsChange', (props) => {\n      this.#evtTool.emit('propsChange', { rect: props });\n    });\n  }\n\n  protected _render(\n    ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  ): void {\n    const {\n      rect: { center, angle },\n    } = this;\n    ctx.setTransform(\n      // 水平 缩放、倾斜\n      this.flip === 'horizontal' ? -1 : 1,\n      0,\n      // 垂直 倾斜、缩放\n      0,\n      this.flip === 'vertical' ? -1 : 1,\n      // 坐标原点偏移 x y\n      center.x,\n      center.y,\n    );\n    // 任意方向翻转，旋转角度转为负值，才能与控制点同步\n    ctx.rotate((this.flip == null ? 1 : -1) * angle);\n\n    ctx.globalAlpha = this.opacity;\n  }\n\n  /**\n   * 给素材添加动画，使用方法参考 css animation\n   *\n   * @example\n   * sprite.setAnimation(\n   *   {\n   *     '0%': { x: 0, y: 0 },\n   *     '25%': { x: 1200, y: 680 },\n   *     '50%': { x: 1200, y: 0 },\n   *     '75%': { x: 0, y: 680 },\n   *     '100%': { x: 0, y: 0 },\n   *   },\n   *   { duration: 4e6, iterCount: 1 },\n   * );\n   *\n   * @see [视频水印动画](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n   */\n  setAnimation(keyFrame: TKeyFrameOpts, opts: IAnimationOpts): void {\n    this.#animatKeyFrame = Object.entries(keyFrame).map(([k, val]) => {\n      const numK = { from: 0, to: 100 }[k] ?? Number(k.slice(0, -1));\n      if (isNaN(numK) || numK > 100 || numK < 0) {\n        throw Error('keyFrame must between 0~100');\n      }\n      return [numK / 100, val];\n    }) as TAnimationKeyFrame;\n    this.#animatOpts = Object.assign({}, this.#animatOpts, {\n      duration: opts.duration,\n      delay: opts.delay ?? 0,\n      iterCount: opts.iterCount ?? Infinity,\n    });\n  }\n\n  /**\n   * 如果当前 sprite 已被设置动画，将 sprite 的动画属性设定到指定时间的状态\n   */\n  animate(time: number): void {\n    if (\n      this.#animatKeyFrame == null ||\n      this.#animatOpts == null ||\n      time < this.#animatOpts.delay\n    )\n      return;\n    const updateProps = linearTimeFn(\n      time,\n      this.#animatKeyFrame,\n      this.#animatOpts,\n    );\n    for (const k in updateProps) {\n      switch (k) {\n        case 'opacity':\n          this.opacity = updateProps[k] as number;\n          break;\n        case 'x':\n        case 'y':\n        case 'w':\n        case 'h':\n        case 'angle':\n          this.rect[k] = updateProps[k] as number;\n          break;\n      }\n    }\n  }\n\n  /**\n   * 将当前 sprite 的属性赋值到目标\n   *\n   * 用于 clone，或 {@link VisibleSprite} 与 {@link OffscreenSprite} 实例间的类型转换\n   */\n  copyStateTo<T extends BaseSprite>(target: T) {\n    target.#animatKeyFrame = this.#animatKeyFrame;\n    target.#animatOpts = this.#animatOpts;\n    target.zIndex = this.zIndex;\n    target.opacity = this.opacity;\n    target.flip = this.flip;\n    target.rect = this.rect.clone();\n    target.time = { ...this.time };\n  }\n\n  protected destroy() {\n    this.#evtTool.destroy();\n  }\n}\n\nexport function linearTimeFn(\n  time: number,\n  kf: TAnimationKeyFrame,\n  opts: Required<IAnimationOpts>,\n): Partial<TAnimateProps> {\n  const offsetTime = time - opts.delay;\n  if (offsetTime / opts.duration >= opts.iterCount) return {};\n\n  const t = offsetTime % opts.duration;\n\n  const process = offsetTime === opts.duration ? 1 : t / opts.duration;\n  const idx = kf.findIndex((it) => it[0] >= process);\n  if (idx === -1) return {};\n\n  const startState = kf[idx - 1];\n  const nextState = kf[idx];\n  const nextFrame = nextState[1];\n  if (startState == null) return nextFrame;\n  const startFrame = startState[1];\n\n  const rs: Partial<TAnimateProps> = {};\n  // 介于两个Frame状态间的进度\n  const stateProcess =\n    (process - startState[0]) / (nextState[0] - startState[0]);\n  for (const prop in nextFrame) {\n    const p = prop as keyof TAnimateProps;\n    if (startFrame[p] == null) continue;\n    // @ts-expect-error\n    // eslint-disable-next-line\n    rs[p] = (nextFrame[p] - startFrame[p]) * stateProcess + startFrame[p];\n  }\n\n  return rs;\n}\n","import { BaseSprite } from './base-sprite';\nimport { IClip } from '../clips';\nimport { Log } from '@webav/internal-utils';\nimport { changePCMPlaybackRate } from '../av-utils';\n\n/**\n * 包装 {@link IClip} 给素材扩展坐标、层级、透明度等信息，用于 {@link Combinator} 在后台合成视频\n *\n * 跟 {@link VisibleSprite} 非常相似，应用场景不同\n *\n * @example\n * const spr = new OffscreenSprite(\n *   new MP4Clip((await fetch('<mp4 url>')).body),\n * );\n * spr.opacity = 0.5 // 半透明\n * spr.rect.x = 100 // x 坐标偏移 100 像素\n * spr.time.offset = 10e6 // 视频第 10s 开始绘制该视频素材\n *\n * @see [视频合成](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n */\nexport class OffscreenSprite extends BaseSprite {\n  #clip: IClip;\n\n  // 保持最近一帧，若 clip 在当前帧无数据，则绘制最近一帧\n  #lastVf: VideoFrame | ImageBitmap | null = null;\n\n  #destroyed = false;\n\n  constructor(clip: IClip) {\n    super();\n    this.#clip = clip;\n    this.ready = clip.ready.then(({ width, height, duration }) => {\n      this.rect.w = this.rect.w === 0 ? width : this.rect.w;\n      this.rect.h = this.rect.h === 0 ? height : this.rect.h;\n      this.time.duration =\n        this.time.duration === 0 ? duration : this.time.duration;\n    });\n  }\n\n  /**\n   * 绘制素材指定时刻的图像到 canvas 上下文，并返回对应的音频数据\n   * @param time 指定时刻，微秒\n   */\n  async offscreenRender(\n    ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    time: number,\n  ): Promise<{\n    audio: Float32Array[];\n    done: boolean;\n  }> {\n    const ts = time * this.time.playbackRate;\n    this.animate(ts);\n    super._render(ctx);\n    const { w, h } = this.rect;\n    const { video, audio, state } = await this.#clip.tick(ts);\n    let outAudio = audio ?? [];\n    if (audio != null && this.time.playbackRate !== 1) {\n      outAudio = audio.map((pcm) =>\n        changePCMPlaybackRate(pcm, this.time.playbackRate),\n      );\n    }\n\n    if (state === 'done') {\n      return {\n        audio: outAudio,\n        done: true,\n      };\n    }\n\n    const imgSource = video ?? this.#lastVf;\n    if (imgSource != null) {\n      ctx.drawImage(imgSource, -w / 2, -h / 2, w, h);\n    }\n\n    if (video != null) {\n      this.#lastVf?.close();\n      this.#lastVf = video;\n    }\n\n    return {\n      audio: outAudio,\n      done: false,\n    };\n  }\n\n  async clone() {\n    const spr = new OffscreenSprite(await this.#clip.clone());\n    await spr.ready;\n    this.copyStateTo(spr);\n    return spr;\n  }\n\n  destroy(): void {\n    if (this.#destroyed) return;\n    this.#destroyed = true;\n\n    Log.info('OffscreenSprite destroy');\n    super.destroy();\n    this.#lastVf?.close();\n    this.#lastVf = null;\n    this.#clip.destroy();\n  }\n}\n","import { BaseSprite } from './base-sprite';\nimport { IClip } from '../clips';\nimport { Log } from '@webav/internal-utils';\nimport { changePCMPlaybackRate } from '../av-utils';\n\n/**\n * 包装 {@link IClip} 给素材扩展坐标、层级、透明度等信息，用于 {@link [AVCanvas](../../av-canvas/classes/AVCanvas.html)} 响应用户交互\n *\n * 跟 {@link OffscreenSprite} 非常相似，应用场景不同\n *\n * @example\n * const spr = new VisibleSprite(\n *   new MP4Clip((await fetch('<mp4 url>')).body),\n * );\n * spr.opacity = 0.5 // 半透明\n * spr.rect.x = 100 // x 坐标偏移 100 像素\n * spr.time.offset = 10e6 // 视频第 10s 开始绘制素材\n *\n * @see [视频剪辑](https://webav-tech.github.io/WebAV/demo/6_4-video-editor)\n *\n */\nexport class VisibleSprite extends BaseSprite {\n  #clip: IClip;\n  getClip() {\n    return this.#clip;\n  }\n\n  /**\n   * 元素是否可见，用于不想删除，期望临时隐藏 Sprite 的场景\n   */\n  visible = true;\n\n  constructor(clip: IClip) {\n    super();\n    this.#clip = clip;\n    this.ready = clip.ready.then(({ width, height, duration }) => {\n      this.rect.w = this.rect.w === 0 ? width : this.rect.w;\n      this.rect.h = this.rect.h === 0 ? height : this.rect.h;\n      this.time.duration =\n        this.time.duration === 0 ? duration : this.time.duration;\n    });\n  }\n\n  // 保持最近一帧，若 clip 在当前帧无数据，则绘制最近一帧\n  #lastVf: VideoFrame | ImageBitmap | null = null;\n  #lastAudio: Float32Array[] = [];\n  #ticking = false;\n  #update(time: number) {\n    if (this.#ticking) return;\n    this.#ticking = true;\n    this.#clip\n      .tick(time * this.time.playbackRate)\n      .then(({ video, audio }) => {\n        if (video != null) {\n          this.#lastVf?.close();\n          this.#lastVf = video ?? null;\n        }\n        this.#lastAudio = audio ?? [];\n        if (audio != null && this.time.playbackRate !== 1) {\n          this.#lastAudio = audio.map((pcm) =>\n            changePCMPlaybackRate(pcm, this.time.playbackRate),\n          );\n        }\n      })\n      .finally(() => {\n        this.#ticking = false;\n      });\n  }\n\n  /**\n   * 提前准备指定 time 的帧\n   */\n  preFrame(time: number) {\n    this.#update(time);\n  }\n\n  #lastTime = -1;\n  /**\n   * 绘制素材指定时刻的图像到 canvas 上下文，并返回对应的音频数据\n   * @param time 指定时刻，微秒\n   */\n  render(\n    ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    time: number,\n  ): { audio: Float32Array[] } {\n    this.animate(time);\n    super._render(ctx);\n    const { w, h } = this.rect;\n    if (this.#lastTime !== time) this.#update(time);\n    this.#lastTime = time;\n\n    const audio = this.#lastAudio;\n    this.#lastAudio = [];\n    const video = this.#lastVf;\n    if (video != null) ctx.drawImage(video, -w / 2, -h / 2, w, h);\n\n    return { audio };\n  }\n\n  copyStateTo<T extends BaseSprite>(target: T): void {\n    super.copyStateTo(target);\n    if (target instanceof VisibleSprite) {\n      target.visible = this.visible;\n    }\n  }\n\n  #destroyed = false;\n  destroy(): void {\n    if (this.#destroyed) return;\n    this.#destroyed = true;\n\n    Log.info('VisibleSprite destroy');\n    super.destroy();\n    this.#lastVf?.close();\n    this.#lastVf = null;\n    this.#clip.destroy();\n  }\n}\n","import { Log, EventTool, file2stream, recodemux } from '@webav/internal-utils';\nimport { OffscreenSprite } from './sprite/offscreen-sprite';\nimport { sleep } from './av-utils';\nimport { DEFAULT_AUDIO_CONF } from './clips';\n\nexport interface ICombinatorOpts {\n  width?: number;\n  height?: number;\n  bitrate?: number;\n  fps?: number;\n  bgColor?: string;\n  videoCodec?: string;\n  /**\n   * false 合成的视频文件中排除音轨\n   */\n  audio?: false;\n  /**\n   * 向输出的视频中写入 meta tags 数据\n   */\n  metaDataTags?: Record<string, string>;\n  /**\n   * 不安全，随时可能废弃\n   */\n  __unsafe_hardwareAcceleration__?: HardwarePreference;\n}\n\nlet COM_ID = 0;\n\n/**\n * 避免 VideoEncoder 队列中的 VideoFrame 过多，打爆显存\n */\nasync function letEncoderCalmDown(getQSize: () => number) {\n  if (getQSize() > 50) {\n    await sleep(15);\n    await letEncoderCalmDown(getQSize);\n  }\n}\n\n/**\n * 视频合成器；能添加多个 {@link OffscreenSprite}，根据它们位置、层级、时间偏移等信息，合成输出为视频文件\n * @see [视频合成](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n * @see [视频配音](https://webav-tech.github.io/WebAV/demo/2_2-video-add-audio)\n * @example\n * const spr1 = new OffscreenSprite(\n *   new MP4Clip((await fetch('<mp4 url>')).body),\n * );\n * const spr2 = new OffscreenSprite(\n *   new AudioClip((await fetch('<audio url>')).body),\n * );\n * const com = new Combinator({ width: 1280, height: 720, });\n\n * await com.addSprite(spr1);\n * await com.addSprite(spr2);\n\n * com.output(); // => ReadableStream\n *\n */\nexport class Combinator {\n  /**\n   * 检测当前环境的兼容性\n   * @param args.videoCodec 指定视频编码格式，默认 avc1.42E032\n   * @param args.width 指定视频宽度，默认 1920\n   * @param args.height 指定视频高度，默认 1080\n   * @param args.bitrate 指定视频比特率，默认 5e6\n   */\n  static async isSupported(\n    args: {\n      videoCodec?: string;\n      width?: number;\n      height?: number;\n      bitrate?: number;\n    } = {},\n  ): Promise<boolean> {\n    return (\n      (self.OffscreenCanvas != null &&\n        self.VideoEncoder != null &&\n        self.VideoDecoder != null &&\n        self.VideoFrame != null &&\n        self.AudioEncoder != null &&\n        self.AudioDecoder != null &&\n        self.AudioData != null &&\n        ((\n          await self.VideoEncoder.isConfigSupported({\n            codec: args.videoCodec ?? 'avc1.42E032',\n            width: args.width ?? 1920,\n            height: args.height ?? 1080,\n            bitrate: args.bitrate ?? 7e6,\n          })\n        ).supported ??\n          false) &&\n        (\n          await self.AudioEncoder.isConfigSupported({\n            codec: DEFAULT_AUDIO_CONF.codec,\n            sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n            numberOfChannels: DEFAULT_AUDIO_CONF.channelCount,\n          })\n        ).supported) ??\n      false\n    );\n  }\n\n  #log = Log.create(`id:${COM_ID++},`);\n\n  #destroyed = false;\n\n  #sprites: Array<OffscreenSprite & { main: boolean; expired: boolean }> = [];\n\n  #cvs;\n\n  #ctx;\n\n  // 中断输出\n  #stopOutput: (() => void) | null = null;\n\n  #opts: Required<ICombinatorOpts>;\n\n  #hasVideoTrack: boolean;\n\n  #evtTool = new EventTool<{\n    OutputProgress: (progress: number) => void;\n    error: (err: Error) => void;\n  }>();\n  on = this.#evtTool.on;\n\n  /**\n   * 根据配置创建合成器实例\n   * @param opts ICombinatorOpts\n   */\n  constructor(opts: ICombinatorOpts = {}) {\n    const { width = 0, height = 0 } = opts;\n    this.#cvs = new OffscreenCanvas(width, height);\n    // this.#cvs = document.querySelector('#canvas') as HTMLCanvasElement\n    const ctx = this.#cvs.getContext('2d', { alpha: false });\n    if (ctx == null) throw Error('Can not create 2d offscreen context');\n    this.#ctx = ctx;\n    this.#opts = Object.assign(\n      {\n        bgColor: '#000',\n        width: 0,\n        height: 0,\n        videoCodec: 'avc1.42E032',\n        audio: true,\n        bitrate: 5e6,\n        fps: 30,\n        metaDataTags: null,\n      },\n      opts,\n    );\n\n    this.#hasVideoTrack = width * height > 0;\n  }\n\n  /**\n   * 添加用于合成视频的 Sprite，视频时长默认取所有素材 duration 字段的最大值\n   * @param os Sprite\n   * @param opts.main 如果 main 为 true，视频时长为该素材的 duration 值\n   */\n  async addSprite(\n    os: OffscreenSprite,\n    opts: { main?: boolean } = {},\n  ): Promise<void> {\n    const logAttrs = {\n      rect: pick(['x', 'y', 'w', 'h'], os.rect),\n      time: { ...os.time },\n      zIndex: os.zIndex,\n    };\n    this.#log.info('Combinator add sprite', logAttrs);\n    const newOS = await os.clone();\n    this.#log.info('Combinator add sprite ready');\n    this.#sprites.push(\n      Object.assign(newOS, {\n        main: opts.main ?? false,\n        expired: false,\n      }),\n    );\n    this.#sprites.sort((a, b) => a.zIndex - b.zIndex);\n  }\n\n  #startRecodeMux(duration: number) {\n    const { fps, width, height, videoCodec, bitrate, audio, metaDataTags } =\n      this.#opts;\n    const recodeMuxer = recodemux({\n      video: this.#hasVideoTrack\n        ? {\n            width,\n            height,\n            expectFPS: fps,\n            codec: videoCodec,\n            bitrate,\n            __unsafe_hardwareAcceleration__:\n              this.#opts.__unsafe_hardwareAcceleration__,\n          }\n        : null,\n      audio:\n        audio === false\n          ? null\n          : {\n              codec: 'aac',\n              sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n              channelCount: DEFAULT_AUDIO_CONF.channelCount,\n            },\n      duration,\n      metaDataTags: metaDataTags,\n    });\n    return recodeMuxer;\n  }\n\n  /**\n   * 输出视频文件二进制流\n   */\n  output(): ReadableStream<Uint8Array> {\n    if (this.#sprites.length === 0) throw Error('No sprite added');\n\n    const mainSpr = this.#sprites.find((it) => it.main);\n    // 最大时间，优先取 main sprite，不存在则取最大值\n    const maxTime =\n      mainSpr != null\n        ? mainSpr.time.offset + mainSpr.time.duration\n        : Math.max(\n            ...this.#sprites.map((it) => it.time.offset + it.time.duration),\n          );\n    if (maxTime === Infinity) {\n      throw Error(\n        'Unable to determine the end time, please specify a main sprite, or limit the duration of ImgClip, AudioCli',\n      );\n    }\n    // 主视频（main）的 videoTrack duration 值为 0\n    if (maxTime === -1) {\n      this.#log.warn(\n        \"Unable to determine the end time, process value don't update\",\n      );\n    }\n\n    this.#log.info(`start combinate video, maxTime:${maxTime}`);\n    const remux = this.#startRecodeMux(maxTime);\n    let starTime = performance.now();\n    const stopReCodeMux = this.#run(remux, maxTime, {\n      onProgress: (prog) => {\n        this.#log.debug('OutputProgress:', prog);\n        this.#evtTool.emit('OutputProgress', prog);\n      },\n      onEnded: async () => {\n        await remux.flush();\n        this.#log.info(\n          '===== output ended =====, cost:',\n          performance.now() - starTime,\n        );\n        this.#evtTool.emit('OutputProgress', 1);\n        this.destroy();\n      },\n      onError: (err) => {\n        this.#evtTool.emit('error', err);\n        closeOutStream(err);\n        this.destroy();\n      },\n    });\n\n    this.#stopOutput = () => {\n      stopReCodeMux();\n      remux.close();\n      closeOutStream();\n    };\n    const { stream, stop: closeOutStream } = file2stream(\n      remux.mp4file,\n      500,\n      this.destroy,\n    );\n\n    return stream;\n  }\n\n  /**\n   * 销毁实例，释放资源\n   */\n  destroy() {\n    if (this.#destroyed) return;\n    this.#destroyed = true;\n\n    this.#stopOutput?.();\n    this.#evtTool.destroy();\n  }\n\n  #run(\n    remux: ReturnType<typeof recodemux>,\n    maxTime: number,\n    {\n      onProgress,\n      onEnded,\n      onError,\n    }: {\n      onProgress: (prog: number) => void;\n      onEnded: () => Promise<void>;\n      onError: (err: Error) => void;\n    },\n  ): () => void {\n    let progress = 0;\n    const aborter = { aborted: false };\n    let err: Error | null = null;\n\n    const _run = async () => {\n      const { fps, bgColor, audio: outputAudio } = this.#opts;\n      const timeSlice = Math.round(1e6 / fps);\n\n      const ctx = this.#ctx;\n      const sprRender = createSpritesRender({\n        ctx,\n        bgColor,\n        sprites: this.#sprites,\n        aborter,\n      });\n      const encodeData = createAVEncoder({\n        remux,\n        ctx,\n        cvs: this.#cvs,\n        outputAudio,\n        hasVideoTrack: this.#hasVideoTrack,\n        timeSlice,\n        fps,\n      });\n\n      let ts = 0;\n      while (true) {\n        if (err != null) return;\n        if (\n          aborter.aborted ||\n          (maxTime === -1 ? false : ts > maxTime) ||\n          this.#sprites.length === 0\n        ) {\n          exit();\n          await onEnded();\n          return;\n        }\n        progress = ts / maxTime;\n\n        const { audios, mainSprDone } = await sprRender(ts);\n        if (mainSprDone) {\n          exit();\n          await onEnded();\n          return;\n        }\n\n        if (aborter.aborted) return;\n\n        encodeData(ts, audios);\n\n        ts += timeSlice;\n\n        await letEncoderCalmDown(remux.getEncodeQueueSize);\n      }\n    };\n\n    _run().catch((e) => {\n      err = e;\n      this.#log.error(e);\n      exit();\n      onError(e);\n    });\n\n    const outProgTimer = setInterval(() => {\n      onProgress(progress);\n    }, 500);\n\n    const exit = () => {\n      if (aborter.aborted) return;\n      aborter.aborted = true;\n      clearInterval(outProgTimer);\n      this.#sprites.forEach((it) => it.destroy());\n    };\n\n    return exit;\n  }\n}\n\nfunction createSpritesRender(opts: {\n  ctx: OffscreenCanvasRenderingContext2D;\n  bgColor: string;\n  sprites: Array<OffscreenSprite & { main: boolean; expired: boolean }>;\n  aborter: { aborted: boolean };\n}) {\n  const { ctx, bgColor, sprites, aborter } = opts;\n  const { width, height } = ctx.canvas;\n  return async (ts: number) => {\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(0, 0, width, height);\n\n    const audios: Float32Array[][] = [];\n    let mainSprDone = false;\n    for (const s of sprites) {\n      if (aborter.aborted) break;\n      if (ts < s.time.offset || s.expired) continue;\n\n      ctx.save();\n      const { audio, done } = await s.offscreenRender(ctx, ts - s.time.offset);\n      audios.push(audio);\n      ctx.restore();\n\n      // 超过设定时间主动掐断，或资源结束\n      if (\n        (s.time.duration > 0 && ts > s.time.offset + s.time.duration) ||\n        done\n      ) {\n        if (s.main) mainSprDone = true;\n\n        s.destroy();\n        s.expired = true;\n      }\n    }\n    return {\n      audios,\n      mainSprDone,\n    };\n  };\n}\n\nfunction createAVEncoder(opts: {\n  remux: ReturnType<typeof recodemux>;\n  ctx: OffscreenCanvasRenderingContext2D;\n  cvs: OffscreenCanvas;\n  outputAudio?: boolean;\n  hasVideoTrack: boolean;\n  timeSlice: number;\n  fps: number;\n}) {\n  const { ctx, cvs, outputAudio, remux, hasVideoTrack, timeSlice } = opts;\n  const { width, height } = cvs;\n  let frameCnt = 0;\n  // 3s 一个 GOP\n  const gopSize = Math.floor(3 * opts.fps);\n\n  const audioTrackBuf = createAudioTrackBuf(1024);\n\n  return (ts: number, audios: Float32Array[][]) => {\n    if (outputAudio !== false) {\n      for (const ad of audioTrackBuf(ts, audios)) remux.encodeAudio(ad);\n    }\n\n    if (hasVideoTrack) {\n      const vf = new VideoFrame(cvs, {\n        duration: timeSlice,\n        timestamp: ts,\n      });\n\n      remux.encodeVideo(vf, {\n        keyFrame: frameCnt % gopSize === 0,\n      });\n      ctx.resetTransform();\n      ctx.clearRect(0, 0, width, height);\n\n      frameCnt += 1;\n    }\n  };\n}\n\n/**\n * 缓冲输入的数据，转换成固定帧数的 AudioData\n * @param adFrames 一个 AudioData 实例的音频帧数\n */\nexport function createAudioTrackBuf(adFrames: number) {\n  const adDataSize = adFrames * DEFAULT_AUDIO_CONF.channelCount;\n  // pcm 数据缓存区\n  const chanBuf = new Float32Array(adDataSize * 3);\n  let putOffset = 0;\n\n  let audioTs = 0;\n  const adDuration = (adFrames / DEFAULT_AUDIO_CONF.sampleRate) * 1e6;\n\n  // 缺少音频数据时占位\n  const placeholderData = new Float32Array(adDataSize);\n\n  const getAudioData = (ts: number) => {\n    let readOffset = 0;\n    const adCnt = Math.floor(putOffset / adDataSize);\n    const rs: AudioData[] = [];\n    // 从缓存区按指定帧数获取数据构造 AudioData\n    for (let i = 0; i < adCnt; i++) {\n      rs.push(\n        new AudioData({\n          timestamp: audioTs,\n          numberOfChannels: DEFAULT_AUDIO_CONF.channelCount,\n          numberOfFrames: adFrames,\n          sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n          format: 'f32',\n          data: chanBuf.subarray(readOffset, readOffset + adDataSize),\n        }),\n      );\n      readOffset += adDataSize;\n      audioTs += adDuration;\n    }\n    chanBuf.set(chanBuf.subarray(readOffset, putOffset), 0);\n    putOffset -= readOffset;\n\n    // 已有音频数据不足，使用占位数据填充\n    while (ts - audioTs > adDuration) {\n      rs.push(\n        new AudioData({\n          timestamp: audioTs,\n          numberOfChannels: DEFAULT_AUDIO_CONF.channelCount,\n          numberOfFrames: adFrames,\n          sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n          format: 'f32',\n          data: placeholderData,\n        }),\n      );\n      audioTs += adDuration;\n    }\n    return rs;\n  };\n\n  return (ts: number, trackAudios: Float32Array[][]) => {\n    const maxLen = Math.max(...trackAudios.map((a) => a[0]?.length ?? 0));\n    for (let bufIdx = 0; bufIdx < maxLen; bufIdx++) {\n      let chan0 = 0;\n      let chan1 = 0;\n      for (let trackIdx = 0; trackIdx < trackAudios.length; trackIdx++) {\n        const _c0 = trackAudios[trackIdx][0]?.[bufIdx] ?? 0;\n        // 如果是单声道 PCM，第二声道复用第一声道数据\n        const _c1 = trackAudios[trackIdx][1]?.[bufIdx] ?? _c0;\n        chan0 += _c0;\n        chan1 += _c1;\n      }\n      // 合成多个素材的音频数据写入缓存区\n      chanBuf[putOffset] = chan0;\n      chanBuf[putOffset + 1] = chan1;\n      putOffset += 2;\n    }\n    // 消费缓存区数据，生成 AudioData\n    return getAudioData(ts);\n  };\n}\n\nfunction pick<K extends keyof T, T extends object>(keys: K[], obj: T) {\n  return keys.reduce(\n    (acc, key) => {\n      acc[key] = obj[key];\n      return acc;\n    },\n    {} as Record<K, T[K]>,\n  );\n}\n","// file:src/log.js\n/* \n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar Log = (function (){\n\t\tvar start = new Date();\n\t\tvar LOG_LEVEL_ERROR \t= 4;\n\t\tvar LOG_LEVEL_WARNING \t= 3;\n\t\tvar LOG_LEVEL_INFO \t\t= 2;\n\t\tvar LOG_LEVEL_DEBUG\t\t= 1;\n\t\tvar log_level = LOG_LEVEL_ERROR;\n\t\tvar logObject = {\n\t\t\tsetLogLevel : function(level) {\n\t\t\t\tif (level == this.debug) log_level = LOG_LEVEL_DEBUG;\n\t\t\t\telse if (level == this.info) log_level = LOG_LEVEL_INFO;\n\t\t\t\telse if (level == this.warn) log_level = LOG_LEVEL_WARNING;\n\t\t\t\telse if (level == this.error) log_level = LOG_LEVEL_ERROR;\n\t\t\t\telse log_level = LOG_LEVEL_ERROR;\n\t\t\t},\n\t\t\tdebug : function(module, msg) {\n\t\t\t\tif (console.debug === undefined) {\n\t\t\t\t\tconsole.debug = console.log;\n\t\t\t\t}\n\t\t\t\tif (LOG_LEVEL_DEBUG >= log_level) {\n\t\t\t\t\tconsole.debug(\"[\"+Log.getDurationString(new Date()-start,1000)+\"]\",\"[\"+module+\"]\",msg);\n\t\t\t\t}\n\t\t\t},\n\t\t\tlog : function(module, msg) {\n\t\t\t\tthis.debug(module.msg)\n\t\t\t},\n\t\t\tinfo : function(module, msg) {\n\t\t\t\tif (LOG_LEVEL_INFO >= log_level) {\n\t\t\t\t\tconsole.info(\"[\"+Log.getDurationString(new Date()-start,1000)+\"]\",\"[\"+module+\"]\",msg);\n\t\t\t\t}\n\t\t\t},\n\t\t\twarn : function(module, msg) {\n\t\t\t\tif (LOG_LEVEL_WARNING >= log_level) {\n\t\t\t\t\tconsole.warn(\"[\"+Log.getDurationString(new Date()-start,1000)+\"]\",\"[\"+module+\"]\",msg);\n\t\t\t\t}\n\t\t\t},\n\t\t\terror : function(module, msg) {\n\t\t\t\tif (LOG_LEVEL_ERROR >= log_level) {\n\t\t\t\t\tconsole.error(\"[\"+Log.getDurationString(new Date()-start,1000)+\"]\",\"[\"+module+\"]\",msg);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn logObject;\n\t})();\n\t\n/* Helper function to print a duration value in the form H:MM:SS.MS */\nLog.getDurationString = function(duration, _timescale) {\n\tvar neg;\n\t/* Helper function to print a number on a fixed number of digits */\n\tfunction pad(number, length) {\n\t\tvar str = '' + number;\n\t\tvar a = str.split('.');\t\t\n\t\twhile (a[0].length < length) {\n\t\t\ta[0] = '0' + a[0];\n\t\t}\n\t\treturn a.join('.');\n\t}\n\tif (duration < 0) {\n\t\tneg = true;\n\t\tduration = -duration;\n\t} else {\n\t\tneg = false;\t\n\t}\n\tvar timescale = _timescale || 1;\n\tvar duration_sec = duration/timescale;\n\tvar hours = Math.floor(duration_sec/3600);\n\tduration_sec -= hours * 3600;\n\tvar minutes = Math.floor(duration_sec/60);\n\tduration_sec -= minutes * 60;\t\t\n\tvar msec = duration_sec*1000;\n\tduration_sec = Math.floor(duration_sec);\n\tmsec -= duration_sec*1000;\n\tmsec = Math.floor(msec);\n\treturn (neg ? \"-\": \"\")+hours+\":\"+pad(minutes,2)+\":\"+pad(duration_sec,2)+\".\"+pad(msec,3);\n}\n\t\n/* Helper function to stringify HTML5 TimeRanges objects */\t\nLog.printRanges = function(ranges) {\n\tvar length = ranges.length;\n\tif (length > 0) {\n\t\tvar str = \"\";\n\t\tfor (var i = 0; i < length; i++) {\n\t\t  if (i > 0) str += \",\";\n\t\t  str += \"[\"+Log.getDurationString(ranges.start(i))+ \",\"+Log.getDurationString(ranges.end(i))+\"]\";\n\t\t}\n\t\treturn str;\n\t} else {\n\t\treturn \"(empty)\";\n\t}\n}\n\nif (typeof exports !== 'undefined') {\n\texports.Log = Log;\n}\n// file:src/stream.js\nvar MP4BoxStream = function(arrayBuffer) {\n  if (arrayBuffer instanceof ArrayBuffer) {\n    this.buffer = arrayBuffer;\n    this.dataview = new DataView(arrayBuffer);\n  } else {\n    throw (\"Needs an array buffer\");\n  }\n  this.position = 0;\n};\n\n/*************************************************************************\n  Common API between MultiBufferStream and SimpleStream\n *************************************************************************/\nMP4BoxStream.prototype.getPosition = function() {\n  return this.position;\n}\n\nMP4BoxStream.prototype.getEndPosition = function() {\n  return this.buffer.byteLength;\n}\n\nMP4BoxStream.prototype.getLength = function() {\n  return this.buffer.byteLength;\n}\n\nMP4BoxStream.prototype.seek = function (pos) {\n  var npos = Math.max(0, Math.min(this.buffer.byteLength, pos));\n  this.position = (isNaN(npos) || !isFinite(npos)) ? 0 : npos;\n  return true;\n}\n\nMP4BoxStream.prototype.isEos = function () {\n  return this.getPosition() >= this.getEndPosition();\n}\n\n/*************************************************************************\n  Read methods, simimar to DataStream but simpler\n *************************************************************************/\nMP4BoxStream.prototype.readAnyInt = function(size, signed) {\n  var res = 0;\n  if (this.position + size <= this.buffer.byteLength) {\n    switch (size) {\n      case 1:\n        if (signed) {\n          res = this.dataview.getInt8(this.position);\n        } else {\n          res = this.dataview.getUint8(this.position);\n        }\n        break;\n      case 2:\n        if (signed) {\n          res = this.dataview.getInt16(this.position);\n        } else {\n          res = this.dataview.getUint16(this.position);\n        }\n        break;\n      case 3:\n        if (signed) {\n          throw (\"No method for reading signed 24 bits values\");\n        } else {\n          res = this.dataview.getUint8(this.position) << 16;\n          res |= this.dataview.getUint8(this.position+1) << 8;\n          res |= this.dataview.getUint8(this.position+2);\n        }\n        break;\n      case 4:\n        if (signed) {\n          res = this.dataview.getInt32(this.position);\n        } else {\n          res = this.dataview.getUint32(this.position);\n        }\n        break;\n      case 8:\n        if (signed) {\n          throw (\"No method for reading signed 64 bits values\");\n        } else {\n          res = this.dataview.getUint32(this.position) << 32;\n          res |= this.dataview.getUint32(this.position+4);\n        }\n        break;\n      default:\n        throw (\"readInt method not implemented for size: \"+size);\n    }\n    this.position+= size;\n    return res;\n  } else {\n    throw (\"Not enough bytes in buffer\");\n  }\n}\n\nMP4BoxStream.prototype.readUint8 = function() {\n  return this.readAnyInt(1, false);\n}\n\nMP4BoxStream.prototype.readUint16 = function() {\n  return this.readAnyInt(2, false);\n}\n\nMP4BoxStream.prototype.readUint24 = function() {\n  return this.readAnyInt(3, false);\n}\n\nMP4BoxStream.prototype.readUint32 = function() {\n  return this.readAnyInt(4, false);\n}\n\nMP4BoxStream.prototype.readUint64 = function() {\n  return this.readAnyInt(8, false);\n}\n\nMP4BoxStream.prototype.readString = function(length) {\n  if (this.position + length <= this.buffer.byteLength) {\n    var s = \"\";\n    for (var i = 0; i < length; i++) {\n      s += String.fromCharCode(this.readUint8());\n    }\n    return s;\n  } else {\n    throw (\"Not enough bytes in buffer\");\n  }\n}\n\nMP4BoxStream.prototype.readCString = function() {\n  var arr = [];\n  while(true) {\n    var b = this.readUint8();\n    if (b !== 0) {\n      arr.push(b);\n    } else {\n      break;\n    }\n  }\n  return String.fromCharCode.apply(null, arr); \n}\n\nMP4BoxStream.prototype.readInt8 = function() {\n  return this.readAnyInt(1, true);\n}\n\nMP4BoxStream.prototype.readInt16 = function() {\n  return this.readAnyInt(2, true);\n}\n\nMP4BoxStream.prototype.readInt32 = function() {\n  return this.readAnyInt(4, true);\n}\n\nMP4BoxStream.prototype.readInt64 = function() {\n  return this.readAnyInt(8, false);\n}\n\nMP4BoxStream.prototype.readUint8Array = function(length) {\n  var arr = new Uint8Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readUint8();\n  }\n  return arr;\n}\n\nMP4BoxStream.prototype.readInt16Array = function(length) {\n  var arr = new Int16Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readInt16();\n  }\n  return arr;\n}\n\nMP4BoxStream.prototype.readUint16Array = function(length) {\n  var arr = new Int16Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readUint16();\n  }\n  return arr;\n}\n\nMP4BoxStream.prototype.readUint32Array = function(length) {\n  var arr = new Uint32Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readUint32();\n  }\n  return arr;\n}\n\nMP4BoxStream.prototype.readInt32Array = function(length) {\n  var arr = new Int32Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readInt32();\n  }\n  return arr;\n}\n\nif (typeof exports !== 'undefined') {\n  exports.MP4BoxStream = MP4BoxStream;\n}// file:src/DataStream.js\n/**\n  DataStream reads scalars, arrays and structs of data from an ArrayBuffer.\n  It's like a file-like DataView on steroids.\n\n  @param {ArrayBuffer} arrayBuffer ArrayBuffer to read from.\n  @param {?Number} byteOffset Offset from arrayBuffer beginning for the DataStream.\n  @param {?Boolean} endianness DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN (the default).\n  */\nvar DataStream = function(arrayBuffer, byteOffset, endianness) {\n  this._byteOffset = byteOffset || 0;\n  if (arrayBuffer instanceof ArrayBuffer) {\n    this.buffer = arrayBuffer;\n  } else if (typeof arrayBuffer == \"object\") {\n    this.dataView = arrayBuffer;\n    if (byteOffset) {\n      this._byteOffset += byteOffset;\n    }\n  } else {\n    this.buffer = new ArrayBuffer(arrayBuffer || 0);\n  }\n  this.position = 0;\n  this.endianness = endianness == null ? DataStream.LITTLE_ENDIAN : endianness;\n};\nDataStream.prototype = {};\n\nDataStream.prototype.getPosition = function() {\n  return this.position;\n}\n\n/**\n  Internal function to resize the DataStream buffer when required.\n  @param {number} extra Number of bytes to add to the buffer allocation.\n  @return {null}\n  */\nDataStream.prototype._realloc = function(extra) {\n  if (!this._dynamicSize) {\n    return;\n  }\n  var req = this._byteOffset + this.position + extra;\n  var blen = this._buffer.byteLength;\n  if (req <= blen) {\n    if (req > this._byteLength) {\n      this._byteLength = req;\n    }\n    return;\n  }\n  if (blen < 1) {\n    blen = 1;\n  }\n  while (req > blen) {\n    blen *= 2;\n  }\n  var buf = new ArrayBuffer(blen);\n  var src = new Uint8Array(this._buffer);\n  var dst = new Uint8Array(buf, 0, src.length);\n  dst.set(src);\n  this.buffer = buf;\n  this._byteLength = req;\n};\n\n/**\n  Internal function to trim the DataStream buffer when required.\n  Used for stripping out the extra bytes from the backing buffer when\n  the virtual byteLength is smaller than the buffer byteLength (happens after\n  growing the buffer with writes and not filling the extra space completely).\n\n  @return {null}\n  */\nDataStream.prototype._trimAlloc = function() {\n  if (this._byteLength == this._buffer.byteLength) {\n    return;\n  }\n  var buf = new ArrayBuffer(this._byteLength);\n  var dst = new Uint8Array(buf);\n  var src = new Uint8Array(this._buffer, 0, dst.length);\n  dst.set(src);\n  this.buffer = buf;\n};\n\n\n/**\n  Big-endian const to use as default endianness.\n  @type {boolean}\n  */\nDataStream.BIG_ENDIAN = false;\n\n/**\n  Little-endian const to use as default endianness.\n  @type {boolean}\n  */\nDataStream.LITTLE_ENDIAN = true;\n\n/**\n  Virtual byte length of the DataStream backing buffer.\n  Updated to be max of original buffer size and last written size.\n  If dynamicSize is false is set to buffer size.\n  @type {number}\n  */\nDataStream.prototype._byteLength = 0;\n\n/**\n  Returns the byte length of the DataStream object.\n  @type {number}\n  */\nObject.defineProperty(DataStream.prototype, 'byteLength',\n  { get: function() {\n    return this._byteLength - this._byteOffset;\n  }});\n\n/**\n  Set/get the backing ArrayBuffer of the DataStream object.\n  The setter updates the DataView to point to the new buffer.\n  @type {Object}\n  */\nObject.defineProperty(DataStream.prototype, 'buffer',\n  { get: function() {\n      this._trimAlloc();\n      return this._buffer;\n    },\n    set: function(v) {\n      this._buffer = v;\n      this._dataView = new DataView(this._buffer, this._byteOffset);\n      this._byteLength = this._buffer.byteLength;\n    } });\n\n/**\n  Set/get the byteOffset of the DataStream object.\n  The setter updates the DataView to point to the new byteOffset.\n  @type {number}\n  */\nObject.defineProperty(DataStream.prototype, 'byteOffset',\n  { get: function() {\n      return this._byteOffset;\n    },\n    set: function(v) {\n      this._byteOffset = v;\n      this._dataView = new DataView(this._buffer, this._byteOffset);\n      this._byteLength = this._buffer.byteLength;\n    } });\n\n/**\n  Set/get the backing DataView of the DataStream object.\n  The setter updates the buffer and byteOffset to point to the DataView values.\n  @type {Object}\n  */\nObject.defineProperty(DataStream.prototype, 'dataView',\n  { get: function() {\n      return this._dataView;\n    },\n    set: function(v) {\n      this._byteOffset = v.byteOffset;\n      this._buffer = v.buffer;\n      this._dataView = new DataView(this._buffer, this._byteOffset);\n      this._byteLength = this._byteOffset + v.byteLength;\n    } });\n\n/**\n  Sets the DataStream read/write position to given position.\n  Clamps between 0 and DataStream length.\n\n  @param {number} pos Position to seek to.\n  @return {null}\n  */\nDataStream.prototype.seek = function(pos) {\n  var npos = Math.max(0, Math.min(this.byteLength, pos));\n  this.position = (isNaN(npos) || !isFinite(npos)) ? 0 : npos;\n};\n\n/**\n  Returns true if the DataStream seek pointer is at the end of buffer and\n  there's no more data to read.\n\n  @return {boolean} True if the seek pointer is at the end of the buffer.\n  */\nDataStream.prototype.isEof = function() {\n  return (this.position >= this._byteLength);\n};\n\n\n/**\n  Maps a Uint8Array into the DataStream buffer.\n\n  Nice for quickly reading in data.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint8Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapUint8Array = function(length) {\n  this._realloc(length * 1);\n  var arr = new Uint8Array(this._buffer, this.byteOffset+this.position, length);\n  this.position += length * 1;\n  return arr;\n};\n\n\n/**\n  Reads an Int32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int32Array.\n */\nDataStream.prototype.readInt32Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 4) : length;\n  var arr = new Int32Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads an Int16Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int16Array.\n */\nDataStream.prototype.readInt16Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 2) : length;\n  var arr = new Int16Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads an Int8Array of desired length from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int8Array.\n */\nDataStream.prototype.readInt8Array = function(length) {\n  length = length == null ? (this.byteLength-this.position) : length;\n  var arr = new Int8Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Uint32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint32Array.\n */\nDataStream.prototype.readUint32Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 4) : length;\n  var arr = new Uint32Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Uint16Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint16Array.\n */\nDataStream.prototype.readUint16Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 2) : length;\n  var arr = new Uint16Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Uint8Array of desired length from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint8Array.\n */\nDataStream.prototype.readUint8Array = function(length) {\n  length = length == null ? (this.byteLength-this.position) : length;\n  var arr = new Uint8Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Float64Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Float64Array.\n */\nDataStream.prototype.readFloat64Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 8) : length;\n  var arr = new Float64Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Float32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Float32Array.\n */\nDataStream.prototype.readFloat32Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 4) : length;\n  var arr = new Float32Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n\n/**\n  Reads a 32-bit int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readInt32 = function(e) {\n  var v = this._dataView.getInt32(this.position, e == null ? this.endianness : e);\n  this.position += 4;\n  return v;\n};\n\n/**\n  Reads a 16-bit int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readInt16 = function(e) {\n  var v = this._dataView.getInt16(this.position, e == null ? this.endianness : e);\n  this.position += 2;\n  return v;\n};\n\n/**\n  Reads an 8-bit int from the DataStream.\n\n  @return {number} The read number.\n */\nDataStream.prototype.readInt8 = function() {\n  var v = this._dataView.getInt8(this.position);\n  this.position += 1;\n  return v;\n};\n\n/**\n  Reads a 32-bit unsigned int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readUint32 = function(e) {\n  var v = this._dataView.getUint32(this.position, e == null ? this.endianness : e);\n  this.position += 4;\n  return v;\n};\n\n/**\n  Reads a 16-bit unsigned int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readUint16 = function(e) {\n  var v = this._dataView.getUint16(this.position, e == null ? this.endianness : e);\n  this.position += 2;\n  return v;\n};\n\n/**\n  Reads an 8-bit unsigned int from the DataStream.\n\n  @return {number} The read number.\n */\nDataStream.prototype.readUint8 = function() {\n  var v = this._dataView.getUint8(this.position);\n  this.position += 1;\n  return v;\n};\n\n/**\n  Reads a 32-bit float from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readFloat32 = function(e) {\n  var v = this._dataView.getFloat32(this.position, e == null ? this.endianness : e);\n  this.position += 4;\n  return v;\n};\n\n/**\n  Reads a 64-bit float from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readFloat64 = function(e) {\n  var v = this._dataView.getFloat64(this.position, e == null ? this.endianness : e);\n  this.position += 8;\n  return v;\n};\n\n/**\n  Native endianness. Either DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN\n  depending on the platform endianness.\n\n  @type {boolean}\n */\nDataStream.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n\n/**\n  Copies byteLength bytes from the src buffer at srcOffset to the\n  dst buffer at dstOffset.\n\n  @param {Object} dst Destination ArrayBuffer to write to.\n  @param {number} dstOffset Offset to the destination ArrayBuffer.\n  @param {Object} src Source ArrayBuffer to read from.\n  @param {number} srcOffset Offset to the source ArrayBuffer.\n  @param {number} byteLength Number of bytes to copy.\n */\nDataStream.memcpy = function(dst, dstOffset, src, srcOffset, byteLength) {\n  var dstU8 = new Uint8Array(dst, dstOffset, byteLength);\n  var srcU8 = new Uint8Array(src, srcOffset, byteLength);\n  dstU8.set(srcU8);\n};\n\n/**\n  Converts array to native endianness in-place.\n\n  @param {Object} array Typed array to convert.\n  @param {boolean} arrayIsLittleEndian True if the data in the array is\n                                       little-endian. Set false for big-endian.\n  @return {Object} The converted typed array.\n */\nDataStream.arrayToNative = function(array, arrayIsLittleEndian) {\n  if (arrayIsLittleEndian == this.endianness) {\n    return array;\n  } else {\n    return this.flipArrayEndianness(array);\n  }\n};\n\n/**\n  Converts native endianness array to desired endianness in-place.\n\n  @param {Object} array Typed array to convert.\n  @param {boolean} littleEndian True if the converted array should be\n                                little-endian. Set false for big-endian.\n  @return {Object} The converted typed array.\n */\nDataStream.nativeToEndian = function(array, littleEndian) {\n  if (this.endianness == littleEndian) {\n    return array;\n  } else {\n    return this.flipArrayEndianness(array);\n  }\n};\n\n/**\n  Flips typed array endianness in-place.\n\n  @param {Object} array Typed array to flip.\n  @return {Object} The converted typed array.\n */\nDataStream.flipArrayEndianness = function(array) {\n  var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n  for (var i=0; i<array.byteLength; i+=array.BYTES_PER_ELEMENT) {\n    for (var j=i+array.BYTES_PER_ELEMENT-1, k=i; j>k; j--, k++) {\n      var tmp = u8[k];\n      u8[k] = u8[j];\n      u8[j] = tmp;\n    }\n  }\n  return array;\n};\n\n/**\n  Seek position where DataStream#readStruct ran into a problem.\n  Useful for debugging struct parsing.\n\n  @type {number}\n */\nDataStream.prototype.failurePosition = 0;\n\nString.fromCharCodeUint8 = function(uint8arr) {\n    var arr = [];\n    for (var i = 0; i < uint8arr.length; i++) {\n      arr[i] = uint8arr[i];\n    }\n    return String.fromCharCode.apply(null, arr);\n}\n/**\n  Read a string of desired length and encoding from the DataStream.\n\n  @param {number} length The length of the string to read in bytes.\n  @param {?string} encoding The encoding of the string data in the DataStream.\n                            Defaults to ASCII.\n  @return {string} The read string.\n */\nDataStream.prototype.readString = function(length, encoding) {\n  if (encoding == null || encoding == \"ASCII\") {\n    return String.fromCharCodeUint8.apply(null, [this.mapUint8Array(length == null ? this.byteLength-this.position : length)]);\n  } else {\n    return (new TextDecoder(encoding)).decode(this.mapUint8Array(length));\n  }\n};\n\n/**\n  Read null-terminated string of desired length from the DataStream. Truncates\n  the returned string so that the null byte is not a part of it.\n\n  @param {?number} length The length of the string to read.\n  @return {string} The read string.\n */\nDataStream.prototype.readCString = function(length) {\n  var blen = this.byteLength-this.position;\n  var u8 = new Uint8Array(this._buffer, this._byteOffset + this.position);\n  var len = blen;\n  if (length != null) {\n    len = Math.min(length, blen);\n  }\n  for (var i = 0; i < len && u8[i] !== 0; i++); // find first zero byte\n  var s = String.fromCharCodeUint8.apply(null, [this.mapUint8Array(i)]);\n  if (length != null) {\n    this.position += len-i;\n  } else if (i != blen) {\n    this.position += 1; // trailing zero if not at end of buffer\n  }\n  return s;\n};\n\n/* \n   TODO: fix endianness for 24/64-bit fields\n   TODO: check range/support for 64-bits numbers in JavaScript\n*/\nvar MAX_SIZE = Math.pow(2, 32);\n\nDataStream.prototype.readInt64 = function () {\n  return (this.readInt32()*MAX_SIZE)+this.readUint32();\n}\nDataStream.prototype.readUint64 = function () {\n\treturn (this.readUint32()*MAX_SIZE)+this.readUint32();\n}\n\nDataStream.prototype.readInt64 = function () {\n  return (this.readUint32()*MAX_SIZE)+this.readUint32();\n}\n\nDataStream.prototype.readUint24 = function () {\n\treturn (this.readUint8()<<16)+(this.readUint8()<<8)+this.readUint8();\n}\n\nif (typeof exports !== 'undefined') {\n  exports.DataStream = DataStream;  \n}\n// file:src/DataStream-write.js\n/**\n  Saves the DataStream contents to the given filename.\n  Uses Chrome's anchor download property to initiate download.\n \n  @param {string} filename Filename to save as.\n  @return {null}\n  */\nDataStream.prototype.save = function(filename) {\n  var blob = new Blob([this.buffer]);\n  if (window.URL && URL.createObjectURL) {\n      var url = window.URL.createObjectURL(blob);\n      var a = document.createElement('a');\n      // Required in Firefox:\n      document.body.appendChild(a);\n      a.setAttribute('href', url);\n      a.setAttribute('download', filename);\n      // Required in Firefox:\n      a.setAttribute('target', '_self');\n      a.click();\n      window.URL.revokeObjectURL(url);\n  } else {\n      throw(\"DataStream.save: Can't create object URL.\");\n  }\n};\n\n/**\n  Whether to extend DataStream buffer when trying to write beyond its size.\n  If set, the buffer is reallocated to twice its current size until the\n  requested write fits the buffer.\n  @type {boolean}\n  */\nDataStream.prototype._dynamicSize = true;\nObject.defineProperty(DataStream.prototype, 'dynamicSize',\n  { get: function() {\n      return this._dynamicSize;\n    },\n    set: function(v) {\n      if (!v) {\n        this._trimAlloc();\n      }\n      this._dynamicSize = v;\n    } });\n\n/**\n  Internal function to trim the DataStream buffer when required.\n  Used for stripping out the first bytes when not needed anymore.\n\n  @return {null}\n  */\nDataStream.prototype.shift = function(offset) {\n  var buf = new ArrayBuffer(this._byteLength-offset);\n  var dst = new Uint8Array(buf);\n  var src = new Uint8Array(this._buffer, offset, dst.length);\n  dst.set(src);\n  this.buffer = buf;\n  this.position -= offset;\n};\n\n/**\n  Writes an Int32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeInt32Array = function(arr, e) {\n  this._realloc(arr.length * 4);\n  if (arr instanceof Int32Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapInt32Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeInt32(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes an Int16Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeInt16Array = function(arr, e) {\n  this._realloc(arr.length * 2);\n  if (arr instanceof Int16Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapInt16Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeInt16(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes an Int8Array to the DataStream.\n\n  @param {Object} arr The array to write.\n */\nDataStream.prototype.writeInt8Array = function(arr) {\n  this._realloc(arr.length * 1);\n  if (arr instanceof Int8Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapInt8Array(arr.length);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeInt8(arr[i]);\n    }\n  }\n};\n\n/**\n  Writes a Uint32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeUint32Array = function(arr, e) {\n  this._realloc(arr.length * 4);\n  if (arr instanceof Uint32Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapUint32Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeUint32(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes a Uint16Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeUint16Array = function(arr, e) {\n  this._realloc(arr.length * 2);\n  if (arr instanceof Uint16Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapUint16Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeUint16(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes a Uint8Array to the DataStream.\n\n  @param {Object} arr The array to write.\n */\nDataStream.prototype.writeUint8Array = function(arr) {\n  this._realloc(arr.length * 1);\n  if (arr instanceof Uint8Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapUint8Array(arr.length);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeUint8(arr[i]);\n    }\n  }\n};\n\n/**\n  Writes a Float64Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeFloat64Array = function(arr, e) {\n  this._realloc(arr.length * 8);\n  if (arr instanceof Float64Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapFloat64Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeFloat64(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes a Float32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeFloat32Array = function(arr, e) {\n  this._realloc(arr.length * 4);\n  if (arr instanceof Float32Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapFloat32Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeFloat32(arr[i], e);\n    }\n  }\n};\n\n\n/**\n  Writes a 32-bit int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeInt32 = function(v, e) {\n  this._realloc(4);\n  this._dataView.setInt32(this.position, v, e == null ? this.endianness : e);\n  this.position += 4;\n};\n\n/**\n  Writes a 16-bit int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeInt16 = function(v, e) {\n  this._realloc(2);\n  this._dataView.setInt16(this.position, v, e == null ? this.endianness : e);\n  this.position += 2;\n};\n\n/**\n  Writes an 8-bit int to the DataStream.\n\n  @param {number} v Number to write.\n */\nDataStream.prototype.writeInt8 = function(v) {\n  this._realloc(1);\n  this._dataView.setInt8(this.position, v);\n  this.position += 1;\n};\n\n/**\n  Writes a 32-bit unsigned int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeUint32 = function(v, e) {\n  this._realloc(4);\n  this._dataView.setUint32(this.position, v, e == null ? this.endianness : e);\n  this.position += 4;\n};\n\n/**\n  Writes a 16-bit unsigned int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeUint16 = function(v, e) {\n  this._realloc(2);\n  this._dataView.setUint16(this.position, v, e == null ? this.endianness : e);\n  this.position += 2;\n};\n\n/**\n  Writes an 8-bit unsigned  int to the DataStream.\n\n  @param {number} v Number to write.\n */\nDataStream.prototype.writeUint8 = function(v) {\n  this._realloc(1);\n  this._dataView.setUint8(this.position, v);\n  this.position += 1;\n};\n\n/**\n  Writes a 32-bit float to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeFloat32 = function(v, e) {\n  this._realloc(4);\n  this._dataView.setFloat32(this.position, v, e == null ? this.endianness : e);\n  this.position += 4;\n};\n\n/**\n  Writes a 64-bit float to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeFloat64 = function(v, e) {\n  this._realloc(8);\n  this._dataView.setFloat64(this.position, v, e == null ? this.endianness : e);\n  this.position += 8;\n};\n\n/**\n  Write a UCS-2 string of desired endianness to the DataStream. The\n  lengthOverride argument lets you define the number of characters to write.\n  If the string is shorter than lengthOverride, the extra space is padded with\n  zeroes.\n\n  @param {string} str The string to write.\n  @param {?boolean} endianness The endianness to use for the written string data.\n  @param {?number} lengthOverride The number of characters to write.\n */\nDataStream.prototype.writeUCS2String = function(str, endianness, lengthOverride) {\n  if (lengthOverride == null) {\n    lengthOverride = str.length;\n  }\n  for (var i = 0; i < str.length && i < lengthOverride; i++) {\n    this.writeUint16(str.charCodeAt(i), endianness);\n  }\n  for (; i<lengthOverride; i++) {\n    this.writeUint16(0);\n  }\n};\n\n/**\n  Writes a string of desired length and encoding to the DataStream.\n\n  @param {string} s The string to write.\n  @param {?string} encoding The encoding for the written string data.\n                            Defaults to ASCII.\n  @param {?number} length The number of characters to write.\n */\nDataStream.prototype.writeString = function(s, encoding, length) {\n  var i = 0;\n  if (encoding == null || encoding == \"ASCII\") {\n    if (length != null) {\n      var len = Math.min(s.length, length);\n      for (i=0; i<len; i++) {\n        this.writeUint8(s.charCodeAt(i));\n      }\n      for (; i<length; i++) {\n        this.writeUint8(0);\n      }\n    } else {\n      for (i=0; i<s.length; i++) {\n        this.writeUint8(s.charCodeAt(i));\n      }\n    }\n  } else {\n    this.writeUint8Array((new TextEncoder(encoding)).encode(s.substring(0, length)));\n  }\n};\n\n/**\n  Writes a null-terminated string to DataStream and zero-pads it to length\n  bytes. If length is not given, writes the string followed by a zero.\n  If string is longer than length, the written part of the string does not have\n  a trailing zero.\n\n  @param {string} s The string to write.\n  @param {?number} length The number of characters to write.\n */\nDataStream.prototype.writeCString = function(s, length) {\n  var i = 0;\n  if (length != null) {\n    var len = Math.min(s.length, length);\n    for (i=0; i<len; i++) {\n      this.writeUint8(s.charCodeAt(i));\n    }\n    for (; i<length; i++) {\n      this.writeUint8(0);\n    }\n  } else {\n    for (i=0; i<s.length; i++) {\n      this.writeUint8(s.charCodeAt(i));\n    }\n    this.writeUint8(0);\n  }\n};\n\n/**\n  Writes a struct to the DataStream. Takes a structDefinition that gives the\n  types and a struct object that gives the values. Refer to readStruct for the\n  structure of structDefinition.\n\n  @param {Object} structDefinition Type definition of the struct.\n  @param {Object} struct The struct data object.\n  */\nDataStream.prototype.writeStruct = function(structDefinition, struct) {\n  for (var i = 0; i < structDefinition.length; i+=2) {\n    var t = structDefinition[i+1];\n    this.writeType(t, struct[structDefinition[i]], struct);\n  }\n};\n\n/**\n  Writes object v of type t to the DataStream.\n\n  @param {Object} t Type of data to write.\n  @param {Object} v Value of data to write.\n  @param {Object} struct Struct to pass to write callback functions.\n  */\nDataStream.prototype.writeType = function(t, v, struct) {\n  var tp;\n  if (typeof t == \"function\") {\n    return t(this, v);\n  } else if (typeof t == \"object\" && !(t instanceof Array)) {\n    return t.set(this, v, struct);\n  }\n  var lengthOverride = null;\n  var charset = \"ASCII\";\n  var pos = this.position;\n  if (typeof(t) == 'string' && /:/.test(t)) {\n    tp = t.split(\":\");\n    t = tp[0];\n    lengthOverride = parseInt(tp[1]);\n  }\n  if (typeof t == 'string' && /,/.test(t)) {\n    tp = t.split(\",\");\n    t = tp[0];\n    charset = parseInt(tp[1]);\n  }\n\n  switch(t) {\n    case 'uint8':\n      this.writeUint8(v);\n      break;\n    case 'int8':\n      this.writeInt8(v);\n      break;\n\n    case 'uint16':\n      this.writeUint16(v, this.endianness);\n      break;\n    case 'int16':\n      this.writeInt16(v, this.endianness);\n      break;\n    case 'uint32':\n      this.writeUint32(v, this.endianness);\n      break;\n    case 'int32':\n      this.writeInt32(v, this.endianness);\n      break;\n    case 'float32':\n      this.writeFloat32(v, this.endianness);\n      break;\n    case 'float64':\n      this.writeFloat64(v, this.endianness);\n      break;\n\n    case 'uint16be':\n      this.writeUint16(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'int16be':\n      this.writeInt16(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'uint32be':\n      this.writeUint32(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'int32be':\n      this.writeInt32(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'float32be':\n      this.writeFloat32(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'float64be':\n      this.writeFloat64(v, DataStream.BIG_ENDIAN);\n      break;\n\n    case 'uint16le':\n      this.writeUint16(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'int16le':\n      this.writeInt16(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'uint32le':\n      this.writeUint32(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'int32le':\n      this.writeInt32(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'float32le':\n      this.writeFloat32(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'float64le':\n      this.writeFloat64(v, DataStream.LITTLE_ENDIAN);\n      break;\n\n    case 'cstring':\n      this.writeCString(v, lengthOverride);\n      break;\n\n    case 'string':\n      this.writeString(v, charset, lengthOverride);\n      break;\n\n    case 'u16string':\n      this.writeUCS2String(v, this.endianness, lengthOverride);\n      break;\n\n    case 'u16stringle':\n      this.writeUCS2String(v, DataStream.LITTLE_ENDIAN, lengthOverride);\n      break;\n\n    case 'u16stringbe':\n      this.writeUCS2String(v, DataStream.BIG_ENDIAN, lengthOverride);\n      break;\n\n    default:\n      if (t.length == 3) {\n        var ta = t[1];\n        for (var i=0; i<v.length; i++) {\n          this.writeType(ta, v[i]);\n        }\n        break;\n      } else {\n        this.writeStruct(t, v);\n        break;\n      }\n  }\n  if (lengthOverride != null) {\n    this.position = pos;\n    this._realloc(lengthOverride);\n    this.position = pos + lengthOverride;\n  }\n};\n\n\nDataStream.prototype.writeUint64 = function (v) {\n\tvar h = Math.floor(v / MAX_SIZE);\n\tthis.writeUint32(h);\n\tthis.writeUint32(v & 0xFFFFFFFF);\n}\n\nDataStream.prototype.writeUint24 = function (v) {\n\tthis.writeUint8((v & 0x00FF0000)>>16);\n\tthis.writeUint8((v & 0x0000FF00)>>8);\n\tthis.writeUint8((v & 0x000000FF));\n}\n\nDataStream.prototype.adjustUint32 = function(position, value) {\n\tvar pos = this.position;\n\tthis.seek(position);\n\tthis.writeUint32(value);\n\tthis.seek(pos);\n}\n// file:src/DataStream-map.js\n/**\n  Maps an Int32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int32Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapInt32Array = function(length, e) {\n  this._realloc(length * 4);\n  var arr = new Int32Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 4;\n  return arr;\n};\n\n/**\n  Maps an Int16Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int16Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapInt16Array = function(length, e) {\n  this._realloc(length * 2);\n  var arr = new Int16Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 2;\n  return arr;\n};\n\n/**\n  Maps an Int8Array into the DataStream buffer.\n\n  Nice for quickly reading in data.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int8Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapInt8Array = function(length) {\n  this._realloc(length * 1);\n  var arr = new Int8Array(this._buffer, this.byteOffset+this.position, length);\n  this.position += length * 1;\n  return arr;\n};\n\n/**\n  Maps a Uint32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint32Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapUint32Array = function(length, e) {\n  this._realloc(length * 4);\n  var arr = new Uint32Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 4;\n  return arr;\n};\n\n/**\n  Maps a Uint16Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint16Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapUint16Array = function(length, e) {\n  this._realloc(length * 2);\n  var arr = new Uint16Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 2;\n  return arr;\n};\n\n/**\n  Maps a Float64Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Float64Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapFloat64Array = function(length, e) {\n  this._realloc(length * 8);\n  var arr = new Float64Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 8;\n  return arr;\n};\n\n/**\n  Maps a Float32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Float32Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapFloat32Array = function(length, e) {\n  this._realloc(length * 4);\n  var arr = new Float32Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 4;\n  return arr;\n};\n// file:src/buffer.js\n/**\n * MultiBufferStream is a class that acts as a SimpleStream for parsing \n * It holds several, possibly non-contiguous ArrayBuffer objects, each with a fileStart property \n * containing the offset for the buffer data in an original/virtual file \n *\n * It inherits also from DataStream for all read/write/alloc operations\n */\n\n/**\n * Constructor\n */\nvar MultiBufferStream = function(buffer) {\n\t/* List of ArrayBuffers, with a fileStart property, sorted in fileStart order and non overlapping */\n\tthis.buffers = [];\t\n\tthis.bufferIndex = -1;\n\tif (buffer) {\n\t\tthis.insertBuffer(buffer);\n\t\tthis.bufferIndex = 0;\n\t}\n}\nMultiBufferStream.prototype = new DataStream(new ArrayBuffer(), 0, DataStream.BIG_ENDIAN);\n\n/************************************************************************************\n  Methods for the managnement of the buffers (insertion, removal, concatenation, ...)\n ***********************************************************************************/\n\nMultiBufferStream.prototype.initialized = function() {\n\tvar firstBuffer;\n\tif (this.bufferIndex > -1) {\n\t\treturn true;\n\t} else if (this.buffers.length > 0) {\n\t\tfirstBuffer = this.buffers[0];\n\t\tif (firstBuffer.fileStart === 0) {\n\t\t\tthis.buffer = firstBuffer;\n\t\t\tthis.bufferIndex = 0;\n\t\t\tLog.debug(\"MultiBufferStream\", \"Stream ready for parsing\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tLog.warn(\"MultiBufferStream\", \"The first buffer should have a fileStart of 0\");\n\t\t\tthis.logBufferLevel();\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tLog.warn(\"MultiBufferStream\", \"No buffer to start parsing from\");\n\t\tthis.logBufferLevel();\n\t\treturn false;\n\t}\t\t\t\n}\n\n/**\n * helper functions to concatenate two ArrayBuffer objects\n * @param  {ArrayBuffer} buffer1 \n * @param  {ArrayBuffer} buffer2 \n * @return {ArrayBuffer} the concatenation of buffer1 and buffer2 in that order\n */\nArrayBuffer.concat = function(buffer1, buffer2) {\n  Log.debug(\"ArrayBuffer\", \"Trying to create a new buffer of size: \"+(buffer1.byteLength + buffer2.byteLength));\n  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n};\n\n/**\n * Reduces the size of a given buffer, but taking the part between offset and offset+newlength\n * @param  {ArrayBuffer} buffer    \n * @param  {Number}      offset    the start of new buffer\n * @param  {Number}      newLength the length of the new buffer\n * @return {ArrayBuffer}           the new buffer\n */\nMultiBufferStream.prototype.reduceBuffer = function(buffer, offset, newLength) {\n\tvar smallB;\n\tsmallB = new Uint8Array(newLength);\n\tsmallB.set(new Uint8Array(buffer, offset, newLength));\n\tsmallB.buffer.fileStart = buffer.fileStart+offset;\n\tsmallB.buffer.usedBytes = 0;\n\treturn smallB.buffer;\t\n}\n\n/**\n * Inserts the new buffer in the sorted list of buffers,\n *  making sure, it is not overlapping with existing ones (possibly reducing its size).\n *  if the new buffer overrides/replaces the 0-th buffer (for instance because it is bigger), \n *  updates the DataStream buffer for parsing \n*/\nMultiBufferStream.prototype.insertBuffer = function(ab) {\t\n\tvar to_add = true;\n\t/* TODO: improve insertion if many buffers */\n\tfor (var i = 0; i < this.buffers.length; i++) {\n\t\tvar b = this.buffers[i];\n\t\tif (ab.fileStart <= b.fileStart) {\n\t\t\t/* the insertion position is found */\n\t\t\tif (ab.fileStart === b.fileStart) {\n\t\t\t\t/* The new buffer overlaps with an existing buffer */\n\t\t\t\tif (ab.byteLength >  b.byteLength) {\n\t\t\t\t\t/* the new buffer is bigger than the existing one\n\t\t\t\t\t   remove the existing buffer and try again to insert \n\t\t\t\t\t   the new buffer to check overlap with the next ones */\n\t\t\t\t\tthis.buffers.splice(i, 1);\n\t\t\t\t\ti--; \n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t/* the new buffer is smaller than the existing one, just drop it */\n\t\t\t\t\tLog.warn(\"MultiBufferStream\", \"Buffer (fileStart: \"+ab.fileStart+\" - Length: \"+ab.byteLength+\") already appended, ignoring\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* The beginning of the new buffer is not overlapping with an existing buffer\n\t\t\t\t   let's check the end of it */\n\t\t\t\tif (ab.fileStart + ab.byteLength <= b.fileStart) {\n\t\t\t\t\t/* no overlap, we can add it as is */\n\t\t\t\t} else {\n\t\t\t\t\t/* There is some overlap, cut the new buffer short, and add it*/\n\t\t\t\t\tab = this.reduceBuffer(ab, 0, b.fileStart - ab.fileStart);\n\t\t\t\t}\n\t\t\t\tLog.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \"+ab.fileStart+\" - Length: \"+ab.byteLength+\")\");\n\t\t\t\tthis.buffers.splice(i, 0, ab);\n\t\t\t\t/* if this new buffer is inserted in the first place in the list of the buffer, \n\t\t\t\t   and the DataStream is initialized, make it the buffer used for parsing */\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tthis.buffer = ab;\n\t\t\t\t}\n\t\t\t}\n\t\t\tto_add = false;\n\t\t\tbreak;\n\t\t} else if (ab.fileStart < b.fileStart + b.byteLength) {\n\t\t\t/* the new buffer overlaps its beginning with the end of the current buffer */\n\t\t\tvar offset = b.fileStart + b.byteLength - ab.fileStart;\n\t\t\tvar newLength = ab.byteLength - offset;\n\t\t\tif (newLength > 0) {\n\t\t\t\t/* the new buffer is bigger than the current overlap, drop the overlapping part and try again inserting the remaining buffer */\n\t\t\t\tab = this.reduceBuffer(ab, offset, newLength);\n\t\t\t} else {\n\t\t\t\t/* the content of the new buffer is entirely contained in the existing buffer, drop it entirely */\n\t\t\t\tto_add = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* if the buffer has not been added, we can add it at the end */\n\tif (to_add) {\n\t\tLog.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \"+ab.fileStart+\" - Length: \"+ab.byteLength+\")\");\n\t\tthis.buffers.push(ab);\n\t\t/* if this new buffer is inserted in the first place in the list of the buffer, \n\t\t   and the DataStream is initialized, make it the buffer used for parsing */\n\t\tif (i === 0) {\n\t\t\tthis.buffer = ab;\n\t\t}\n\t}\n}\n\n/**\n * Displays the status of the buffers (number and used bytes)\n * @param  {Object} info callback method for display\n */\nMultiBufferStream.prototype.logBufferLevel = function(info) {\n\tvar i;\n\tvar buffer;\n\tvar used, total;\n\tvar ranges = [];\n\tvar range;\n\tvar bufferedString = \"\";\n\tused = 0;\n\ttotal = 0;\n\tfor (i = 0; i < this.buffers.length; i++) {\n\t\tbuffer = this.buffers[i];\n\t\tif (i === 0) {\n\t\t\trange = {};\n\t\t\tranges.push(range);\n\t\t\trange.start = buffer.fileStart;\n\t\t\trange.end = buffer.fileStart+buffer.byteLength;\n\t\t\tbufferedString += \"[\"+range.start+\"-\";\n\t\t} else if (range.end === buffer.fileStart) {\n\t\t\trange.end = buffer.fileStart+buffer.byteLength;\n\t\t} else {\n\t\t\trange = {};\n\t\t\trange.start = buffer.fileStart;\n\t\t\tbufferedString += (ranges[ranges.length-1].end-1)+\"], [\"+range.start+\"-\";\n\t\t\trange.end = buffer.fileStart+buffer.byteLength;\n\t\t\tranges.push(range);\n\t\t}\n\t\tused += buffer.usedBytes;\n\t\ttotal += buffer.byteLength;\n\t}\n\tif (ranges.length > 0) {\n\t\tbufferedString += (range.end-1)+\"]\";\n\t}\n\tvar log = (info ? Log.info : Log.debug)\n\tif (this.buffers.length === 0) {\n\t\tlog(\"MultiBufferStream\", \"No more buffer in memory\");\n\t} else {\n\t\tlog(\"MultiBufferStream\", \"\"+this.buffers.length+\" stored buffer(s) (\"+used+\"/\"+total+\" bytes), continuous ranges: \"+bufferedString);\n\t}\n}\n\nMultiBufferStream.prototype.cleanBuffers = function () {\n\tvar i;\n\tvar buffer;\n\tfor (i = 0; i < this.buffers.length; i++) {\n\t\tbuffer = this.buffers[i];\n\t\tif (buffer.usedBytes === buffer.byteLength) {\n\t\t\tLog.debug(\"MultiBufferStream\", \"Removing buffer #\"+i);\n\t\t\tthis.buffers.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nMultiBufferStream.prototype.mergeNextBuffer = function() {\n\tvar next_buffer;\n\tif (this.bufferIndex+1 < this.buffers.length) {\n\t\tnext_buffer = this.buffers[this.bufferIndex+1];\n\t\tif (next_buffer.fileStart === this.buffer.fileStart + this.buffer.byteLength) {\n\t\t\tvar oldLength = this.buffer.byteLength;\n\t\t\tvar oldUsedBytes = this.buffer.usedBytes;\n\t\t\tvar oldFileStart = this.buffer.fileStart;\n\t\t\tthis.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, next_buffer);\n\t\t\tthis.buffer = this.buffers[this.bufferIndex];\n\t\t\tthis.buffers.splice(this.bufferIndex+1, 1);\n\t\t\tthis.buffer.usedBytes = oldUsedBytes; /* TODO: should it be += ? */\n\t\t\tthis.buffer.fileStart = oldFileStart;\n\t\t\tLog.debug(\"ISOFile\", \"Concatenating buffer for box parsing (length: \"+oldLength+\"->\"+this.buffer.byteLength+\")\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\n/*************************************************************************\n  Seek-related functions\n *************************************************************************/\n\n/**\n * Finds the buffer that holds the given file position\n * @param  {Boolean} fromStart    indicates if the search should start from the current buffer (false) \n *                                or from the first buffer (true)\n * @param  {Number}  filePosition position in the file to seek to\n * @param  {Boolean} markAsUsed   indicates if the bytes in between the current position and the seek position \n *                                should be marked as used for garbage collection\n * @return {Number}               the index of the buffer holding the seeked file position, -1 if not found.\n */\nMultiBufferStream.prototype.findPosition = function(fromStart, filePosition, markAsUsed) {\n\tvar i;\n\tvar abuffer = null;\n\tvar index = -1;\n\n\t/* find the buffer with the largest position smaller than the given position */\n\tif (fromStart === true) {\n\t   /* the reposition can be in the past, we need to check from the beginning of the list of buffers */\n\t\ti = 0;\n\t} else {\n\t\ti = this.bufferIndex;\n\t}\n\n\twhile (i < this.buffers.length) {\n\t\tabuffer = this.buffers[i];\n\t\tif (abuffer.fileStart <= filePosition) {\n\t\t\tindex = i;\n\t\t\tif (markAsUsed) {\n\t\t\t\tif (abuffer.fileStart + abuffer.byteLength <= filePosition) {\n\t\t\t\t\tabuffer.usedBytes = abuffer.byteLength;\t\n\t\t\t\t} else {\n\t\t\t\t\tabuffer.usedBytes = filePosition - abuffer.fileStart;\n\t\t\t\t}\t\t\n\t\t\t\tthis.logBufferLevel();\t\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (index !== -1) {\n\t\tabuffer = this.buffers[index];\n\t\tif (abuffer.fileStart + abuffer.byteLength >= filePosition) {\t\t\t\n\t\t\tLog.debug(\"MultiBufferStream\", \"Found position in existing buffer #\"+index);\n\t\t\treturn index;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n/**\n * Finds the largest file position contained in a buffer or in the next buffers if they are contiguous (no gap)\n * starting from the given buffer index or from the current buffer if the index is not given\n *\n * @param  {Number} inputindex Index of the buffer to start from\n * @return {Number}            The largest file position found in the buffers\n */\nMultiBufferStream.prototype.findEndContiguousBuf = function(inputindex) {\n\tvar i;\n\tvar currentBuf;\n\tvar nextBuf;\n\tvar index = (inputindex !== undefined ? inputindex : this.bufferIndex);\n\tcurrentBuf = this.buffers[index];\n\t/* find the end of the contiguous range of data */\n\tif (this.buffers.length > index+1) {\n\t\tfor (i = index+1; i < this.buffers.length; i++) {\n\t\t\tnextBuf = this.buffers[i];\n\t\t\tif (nextBuf.fileStart === currentBuf.fileStart + currentBuf.byteLength) {\n\t\t\t\tcurrentBuf = nextBuf;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* return the position of last byte in the file that we have */\n\treturn currentBuf.fileStart + currentBuf.byteLength;\n}\n\n/**\n * Returns the largest file position contained in the buffers, larger than the given position\n * @param  {Number} pos the file position to start from\n * @return {Number}     the largest position in the current buffer or in the buffer and the next contiguous \n *                      buffer that holds the given position\n */\nMultiBufferStream.prototype.getEndFilePositionAfter = function(pos) {\n\tvar index = this.findPosition(true, pos, false);\n\tif (index !== -1) {\n\t\treturn this.findEndContiguousBuf(index);\n\t} else {\n\t\treturn pos;\n\t}\n}\n\n/*************************************************************************\n  Garbage collection related functions\n *************************************************************************/\n\n/**\n * Marks a given number of bytes as used in the current buffer for garbage collection\n * @param {Number} nbBytes \n */\nMultiBufferStream.prototype.addUsedBytes = function(nbBytes) {\n\tthis.buffer.usedBytes += nbBytes;\n\tthis.logBufferLevel();\n}\n\n/**\n * Marks the entire current buffer as used, ready for garbage collection\n */\nMultiBufferStream.prototype.setAllUsedBytes = function() {\n\tthis.buffer.usedBytes = this.buffer.byteLength;\n\tthis.logBufferLevel();\n}\n\n/*************************************************************************\n  Common API between MultiBufferStream and SimpleStream\n *************************************************************************/\n\n/**\n * Tries to seek to a given file position\n * if possible, repositions the parsing from there and returns true \n * if not possible, does not change anything and returns false \n * @param  {Number}  filePosition position in the file to seek to\n * @param  {Boolean} fromStart    indicates if the search should start from the current buffer (false) \n *                                or from the first buffer (true)\n * @param  {Boolean} markAsUsed   indicates if the bytes in between the current position and the seek position \n *                                should be marked as used for garbage collection\n * @return {Boolean}              true if the seek succeeded, false otherwise\n */\nMultiBufferStream.prototype.seek = function(filePosition, fromStart, markAsUsed) {\n\tvar index;\n\tindex = this.findPosition(fromStart, filePosition, markAsUsed);\n\tif (index !== -1) {\n\t\tthis.buffer = this.buffers[index];\n\t\tthis.bufferIndex = index;\n\t\tthis.position = filePosition - this.buffer.fileStart;\n\t\tLog.debug(\"MultiBufferStream\", \"Repositioning parser at buffer position: \"+this.position);\n\t\treturn true;\n\t} else {\n\t\tLog.debug(\"MultiBufferStream\", \"Position \"+filePosition+\" not found in buffered data\");\n\t\treturn false;\n\t}\n}\n\n/**\n * Returns the current position in the file\n * @return {Number} the position in the file\n */\nMultiBufferStream.prototype.getPosition = function() {\n\tif (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null) {\n\t\tthrow \"Error accessing position in the MultiBufferStream\";\n\t}\n\treturn this.buffers[this.bufferIndex].fileStart+this.position;\n}\n\n/**\n * Returns the length of the current buffer\n * @return {Number} the length of the current buffer\n */\nMultiBufferStream.prototype.getLength = function() {\n\treturn this.byteLength;\n}\n\nMultiBufferStream.prototype.getEndPosition = function() {\n\tif (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null) {\n\t\tthrow \"Error accessing position in the MultiBufferStream\";\n\t}\n\treturn this.buffers[this.bufferIndex].fileStart+this.byteLength;\n}\n\nif (typeof exports !== 'undefined') {\n\texports.MultiBufferStream = MultiBufferStream;\n}// file:src/descriptor.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar MPEG4DescriptorParser = function () {\n\tvar ES_DescrTag \t\t\t= 0x03;\n\tvar DecoderConfigDescrTag \t= 0x04;\n\tvar DecSpecificInfoTag \t\t= 0x05;\n\tvar SLConfigDescrTag \t\t= 0x06;\n\n\tvar descTagToName = [];\n\tdescTagToName[ES_DescrTag] \t\t\t\t= \"ES_Descriptor\";\n\tdescTagToName[DecoderConfigDescrTag] \t= \"DecoderConfigDescriptor\";\n\tdescTagToName[DecSpecificInfoTag] \t\t= \"DecoderSpecificInfo\";\n\tdescTagToName[SLConfigDescrTag] \t\t= \"SLConfigDescriptor\";\n\n\tthis.getDescriptorName = function(tag) {\n\t\treturn descTagToName[tag];\n\t}\n\n\tvar that = this;\n\tvar classes = {};\n\n\tthis.parseOneDescriptor = function (stream) {\n\t\tvar hdrSize = 0;\n\t\tvar size = 0;\n\t\tvar tag;\n\t\tvar desc;\n\t\tvar byteRead;\n\t\ttag = stream.readUint8();\n\t\thdrSize++;\n\t\tbyteRead = stream.readUint8();\n\t\thdrSize++;\n\t\twhile (byteRead & 0x80) {\n\t\t\tsize = (byteRead & 0x7F)<<7;\n\t\t\tbyteRead = stream.readUint8();\n\t\t\thdrSize++;\n\t\t}\n\t\tsize += byteRead & 0x7F;\n\t\tLog.debug(\"MPEG4DescriptorParser\", \"Found \"+(descTagToName[tag] || \"Descriptor \"+tag)+\", size \"+size+\" at position \"+stream.getPosition());\n\t\tif (descTagToName[tag]) {\n\t\t\tdesc = new classes[descTagToName[tag]](size);\n\t\t} else {\n\t\t\tdesc = new classes.Descriptor(size);\n\t\t}\n\t\tdesc.parse(stream);\n\t\treturn desc;\n\t}\n\n\tclasses.Descriptor = function(_tag, _size) {\n\t\tthis.tag = _tag;\n\t\tthis.size = _size;\n\t\tthis.descs = [];\n\t}\n\n\tclasses.Descriptor.prototype.parse = function (stream) {\n\t\tthis.data = stream.readUint8Array(this.size);\n\t}\n\n\tclasses.Descriptor.prototype.findDescriptor = function (tag) {\n\t\tfor (var i = 0; i < this.descs.length; i++) {\n\t\t\tif (this.descs[i].tag == tag) {\n\t\t\t\treturn this.descs[i];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tclasses.Descriptor.prototype.parseRemainingDescriptors = function (stream) {\n\t\tvar start = stream.position;\n\t\twhile (stream.position < start+this.size) {\n\t\t\tvar desc = that.parseOneDescriptor(stream);\n\t\t\tthis.descs.push(desc);\n\t\t}\n\t}\n\n\tclasses.ES_Descriptor = function (size) {\n\t\tclasses.Descriptor.call(this, ES_DescrTag, size);\n\t}\n\n\tclasses.ES_Descriptor.prototype = new classes.Descriptor();\n\n\tclasses.ES_Descriptor.prototype.parse = function(stream) {\n\t\tthis.ES_ID = stream.readUint16();\n\t\tthis.flags = stream.readUint8();\n\t\tthis.size -= 3;\n\t\tif (this.flags & 0x80) {\n\t\t\tthis.dependsOn_ES_ID = stream.readUint16();\n\t\t\tthis.size -= 2;\n\t\t} else {\n\t\t\tthis.dependsOn_ES_ID = 0;\n\t\t}\n\t\tif (this.flags & 0x40) {\n\t\t\tvar l = stream.readUint8();\n\t\t\tthis.URL = stream.readString(l);\n\t\t\tthis.size -= l+1;\n\t\t} else {\n\t\t\tthis.URL = \"\";\n\t\t}\n\t\tif (this.flags & 0x20) {\n\t\t\tthis.OCR_ES_ID = stream.readUint16();\n\t\t\tthis.size -= 2;\n\t\t} else {\n\t\t\tthis.OCR_ES_ID = 0;\n\t\t}\n\t\tthis.parseRemainingDescriptors(stream);\n\t}\n\n\tclasses.ES_Descriptor.prototype.getOTI = function(stream) {\n\t\tvar dcd = this.findDescriptor(DecoderConfigDescrTag);\n\t\tif (dcd) {\n\t\t\treturn dcd.oti;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tclasses.ES_Descriptor.prototype.getAudioConfig = function(stream) {\n\t\tvar dcd = this.findDescriptor(DecoderConfigDescrTag);\n\t\tif (!dcd) return null;\n\t\tvar dsi = dcd.findDescriptor(DecSpecificInfoTag);\n\t\tif (dsi && dsi.data) {\n\t\t\tvar audioObjectType = (dsi.data[0]& 0xF8) >> 3;\n\t\t\tif (audioObjectType === 31 && dsi.data.length >= 2) {\n\t\t\t\taudioObjectType = 32 + ((dsi.data[0] & 0x7) << 3) + ((dsi.data[1] & 0xE0) >> 5);\n\t\t\t}\n\t\t\treturn audioObjectType;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclasses.DecoderConfigDescriptor = function (size) {\n\t\tclasses.Descriptor.call(this, DecoderConfigDescrTag, size);\n\t}\n\tclasses.DecoderConfigDescriptor.prototype = new classes.Descriptor();\n\n\tclasses.DecoderConfigDescriptor.prototype.parse = function(stream) {\n\t\tthis.oti = stream.readUint8();\n\t\tthis.streamType = stream.readUint8();\n\t\tthis.upStream = ((this.streamType >> 1) & 1) !== 0;\n\t\tthis.streamType = this.streamType >>> 2;\n\t\tthis.bufferSize = stream.readUint24();\n\t\tthis.maxBitrate = stream.readUint32();\n\t\tthis.avgBitrate = stream.readUint32();\n\t\tthis.size -= 13;\n\t\tthis.parseRemainingDescriptors(stream);\n\t}\n\n\tclasses.DecoderSpecificInfo = function (size) {\n\t\tclasses.Descriptor.call(this, DecSpecificInfoTag, size);\n\t}\n\tclasses.DecoderSpecificInfo.prototype = new classes.Descriptor();\n\n\tclasses.SLConfigDescriptor = function (size) {\n\t\tclasses.Descriptor.call(this, SLConfigDescrTag, size);\n\t}\n\tclasses.SLConfigDescriptor.prototype = new classes.Descriptor();\n\n\treturn this;\n}\n\nif (typeof exports !== 'undefined') {\n\texports.MPEG4DescriptorParser = MPEG4DescriptorParser;\n}\n// file:src/box.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar BoxParser = {\n\tERR_INVALID_DATA : -1,\n\tERR_NOT_ENOUGH_DATA : 0,\n\tOK : 1,\n\n\t// Boxes to be created with default parsing\n\tBASIC_BOXES: [ \"mdat\", \"idat\", \"free\", \"skip\", \"meco\", \"strk\" ],\n\tFULL_BOXES: [ \"hmhd\", \"nmhd\", \"iods\", \"xml \", \"bxml\", \"ipro\", \"mere\" ],\n\tCONTAINER_BOXES: [\n\t\t[ \"moov\", [ \"trak\", \"pssh\" ] ],\n\t\t[ \"trak\" ],\n\t\t[ \"edts\" ],\n\t\t[ \"mdia\" ],\n\t\t[ \"minf\" ],\n\t\t[ \"dinf\" ],\n\t\t[ \"stbl\", [ \"sgpd\", \"sbgp\" ] ],\n\t\t[ \"mvex\", [ \"trex\" ] ],\n\t\t[ \"moof\", [ \"traf\" ] ],\n\t\t[ \"traf\", [ \"trun\", \"sgpd\", \"sbgp\" ] ],\n\t\t[ \"vttc\" ],\n\t\t[ \"tref\" ],\n\t\t[ \"iref\" ],\n\t\t[ \"mfra\", [ \"tfra\" ] ],\n\t\t[ \"meco\" ],\n\t\t[ \"hnti\" ],\n\t\t[ \"hinf\" ],\n\t\t[ \"strk\" ],\n\t\t[ \"strd\" ],\n\t\t[ \"sinf\" ],\n\t\t[ \"rinf\" ],\n\t\t[ \"schi\" ],\n\t\t[ \"trgr\" ],\n\t\t[ \"udta\", [\"kind\"] ],\n\t\t[ \"iprp\", [\"ipma\"] ],\n\t\t[ \"ipco\" ],\n\t\t[ \"grpl\" ],\n\t\t[ \"j2kH\" ],\n\t\t[ \"etyp\", [ \"tyco\"] ]\n\t],\n\t// Boxes effectively created\n\tboxCodes : [],\n\tfullBoxCodes : [],\n\tcontainerBoxCodes : [],\n\tsampleEntryCodes : {},\n\tsampleGroupEntryCodes: [],\n\ttrackGroupTypes: [],\n\tUUIDBoxes: {},\n\tUUIDs: [],\n\tinitialize: function() {\n\t\tBoxParser.FullBox.prototype = new BoxParser.Box();\n\t\tBoxParser.ContainerBox.prototype = new BoxParser.Box();\n\t\tBoxParser.SampleEntry.prototype = new BoxParser.Box();\n\t\tBoxParser.TrackGroupTypeBox.prototype = new BoxParser.FullBox();\n\n\t\t/* creating constructors for simple boxes */\n\t\tBoxParser.BASIC_BOXES.forEach(function(type) {\n\t\t\tBoxParser.createBoxCtor(type)\n\t\t});\n\t\tBoxParser.FULL_BOXES.forEach(function(type) {\n\t\t\tBoxParser.createFullBoxCtor(type);\n\t\t});\n\t\tBoxParser.CONTAINER_BOXES.forEach(function(types) {\n\t\t\tBoxParser.createContainerBoxCtor(types[0], null, types[1]);\n\t\t});\n\t},\n\tBox: function(_type, _size, _uuid) {\n\t\tthis.type = _type;\n\t\tthis.size = _size;\n\t\tthis.uuid = _uuid;\n\t},\n\tFullBox: function(type, size, uuid) {\n\t\tBoxParser.Box.call(this, type, size, uuid);\n\t\tthis.flags = 0;\n\t\tthis.version = 0;\n\t},\n\tContainerBox: function(type, size, uuid) {\n\t\tBoxParser.Box.call(this, type, size, uuid);\n\t\tthis.boxes = [];\n\t},\n\tSampleEntry: function(type, size, hdr_size, start) {\n\t\tBoxParser.ContainerBox.call(this, type, size);\n\t\tthis.hdr_size = hdr_size;\n\t\tthis.start = start;\n\t},\n\tSampleGroupEntry: function(type) {\n\t\tthis.grouping_type = type;\n\t},\n\tTrackGroupTypeBox: function(type, size) {\n\t\tBoxParser.FullBox.call(this, type, size);\n\t},\n\tcreateBoxCtor: function(type, parseMethod){\n\t\tBoxParser.boxCodes.push(type);\n\t\tBoxParser[type+\"Box\"] = function(size) {\n\t\t\tBoxParser.Box.call(this, type, size);\n\t\t}\n\t\tBoxParser[type+\"Box\"].prototype = new BoxParser.Box();\n\t\tif (parseMethod) BoxParser[type+\"Box\"].prototype.parse = parseMethod;\n\t},\n\tcreateFullBoxCtor: function(type, parseMethod) {\n\t\t//BoxParser.fullBoxCodes.push(type);\n\t\tBoxParser[type+\"Box\"] = function(size) {\n\t\t\tBoxParser.FullBox.call(this, type, size);\n\t\t}\n\t\tBoxParser[type+\"Box\"].prototype = new BoxParser.FullBox();\n\t\tBoxParser[type+\"Box\"].prototype.parse = function(stream) {\n\t\t\tthis.parseFullHeader(stream);\n\t\t\tif (parseMethod) {\n\t\t\t\tparseMethod.call(this, stream);\n\t\t\t}\n\t\t};\n\t},\n\taddSubBoxArrays: function(subBoxNames) {\n\t\tif (subBoxNames) {\n\t\t\tthis.subBoxNames = subBoxNames;\n\t\t\tvar nbSubBoxes = subBoxNames.length;\n\t\t\tfor (var k = 0; k<nbSubBoxes; k++) {\n\t\t\t\tthis[subBoxNames[k]+\"s\"] = [];\n\t\t\t}\n\t\t}\n\t},\n\tcreateContainerBoxCtor: function(type, parseMethod, subBoxNames) {\n\t\t//BoxParser.containerBoxCodes.push(type);\n\t\tBoxParser[type+\"Box\"] = function(size) {\n\t\t\tBoxParser.ContainerBox.call(this, type, size);\n\t\t\tBoxParser.addSubBoxArrays.call(this, subBoxNames);\n\t\t}\n\t\tBoxParser[type+\"Box\"].prototype = new BoxParser.ContainerBox();\n\t\tif (parseMethod) BoxParser[type+\"Box\"].prototype.parse = parseMethod;\n\t},\n\tcreateMediaSampleEntryCtor: function(mediaType, parseMethod, subBoxNames) {\n\t\tBoxParser.sampleEntryCodes[mediaType] = [];\n\t\tBoxParser[mediaType+\"SampleEntry\"] = function(type, size) {\n\t\t\tBoxParser.SampleEntry.call(this, type, size);\n\t\t\tBoxParser.addSubBoxArrays.call(this, subBoxNames);\n\t\t};\n\t\tBoxParser[mediaType+\"SampleEntry\"].prototype = new BoxParser.SampleEntry();\n\t\tif (parseMethod) BoxParser[mediaType+\"SampleEntry\"].prototype .parse = parseMethod;\n\t},\n\tcreateSampleEntryCtor: function(mediaType, type, parseMethod, subBoxNames) {\n\t\tBoxParser.sampleEntryCodes[mediaType].push(type);\n\t\tBoxParser[type+\"SampleEntry\"] = function(size) {\n\t\t\tBoxParser[mediaType+\"SampleEntry\"].call(this, type, size);\n\t\t\tBoxParser.addSubBoxArrays.call(this, subBoxNames);\n\t\t};\n\t\tBoxParser[type+\"SampleEntry\"].prototype = new BoxParser[mediaType+\"SampleEntry\"]();\n\t\tif (parseMethod) BoxParser[type+\"SampleEntry\"].prototype.parse = parseMethod;\n\t},\n\tcreateEncryptedSampleEntryCtor: function(mediaType, type, parseMethod) {\n\t\tBoxParser.createSampleEntryCtor.call(this, mediaType, type, parseMethod, [\"sinf\"]);\n\t},\n\tcreateSampleGroupCtor: function(type, parseMethod) {\n\t\t//BoxParser.sampleGroupEntryCodes.push(type);\n\t\tBoxParser[type+\"SampleGroupEntry\"] = function(size) {\n\t\t\tBoxParser.SampleGroupEntry.call(this, type, size);\n\t\t}\n\t\tBoxParser[type+\"SampleGroupEntry\"].prototype = new BoxParser.SampleGroupEntry();\n\t\tif (parseMethod) BoxParser[type+\"SampleGroupEntry\"].prototype.parse = parseMethod;\n\t},\n\tcreateTrackGroupCtor: function(type, parseMethod) {\n\t\t//BoxParser.trackGroupTypes.push(type);\n\t\tBoxParser[type+\"TrackGroupTypeBox\"] = function(size) {\n\t\t\tBoxParser.TrackGroupTypeBox.call(this, type, size);\n\t\t}\n\t\tBoxParser[type+\"TrackGroupTypeBox\"].prototype = new BoxParser.TrackGroupTypeBox();\n\t\tif (parseMethod) BoxParser[type+\"TrackGroupTypeBox\"].prototype.parse = parseMethod;\n\t},\n\tcreateUUIDBox: function(uuid, isFullBox, isContainerBox, parseMethod) {\n\t\tBoxParser.UUIDs.push(uuid);\n\t\tBoxParser.UUIDBoxes[uuid] = function(size) {\n\t\t\tif (isFullBox) {\n\t\t\t\tBoxParser.FullBox.call(this, \"uuid\", size, uuid);\n\t\t\t} else {\n\t\t\t\tif (isContainerBox) {\n\t\t\t\t\tBoxParser.ContainerBox.call(this, \"uuid\", size, uuid);\n\t\t\t\t} else {\n\t\t\t\t\tBoxParser.Box.call(this, \"uuid\", size, uuid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tBoxParser.UUIDBoxes[uuid].prototype = (isFullBox ? new BoxParser.FullBox() : (isContainerBox ? new BoxParser.ContainerBox() : new BoxParser.Box()));\n\t\tif (parseMethod) {\n\t\t\tif (isFullBox) {\n\t\t\t\tBoxParser.UUIDBoxes[uuid].prototype.parse = function(stream) {\n\t\t\t\t\tthis.parseFullHeader(stream);\n\t\t\t\t\tif (parseMethod) {\n\t\t\t\t\t\tparseMethod.call(this, stream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tBoxParser.UUIDBoxes[uuid].prototype.parse = parseMethod;\n\t\t\t}\n\t\t}\n\t}\n}\n\nBoxParser.initialize();\n\nBoxParser.TKHD_FLAG_ENABLED    = 0x000001;\nBoxParser.TKHD_FLAG_IN_MOVIE   = 0x000002;\nBoxParser.TKHD_FLAG_IN_PREVIEW = 0x000004;\n\nBoxParser.TFHD_FLAG_BASE_DATA_OFFSET\t= 0x01;\nBoxParser.TFHD_FLAG_SAMPLE_DESC\t\t\t= 0x02;\nBoxParser.TFHD_FLAG_SAMPLE_DUR\t\t\t= 0x08;\nBoxParser.TFHD_FLAG_SAMPLE_SIZE\t\t\t= 0x10;\nBoxParser.TFHD_FLAG_SAMPLE_FLAGS\t\t= 0x20;\nBoxParser.TFHD_FLAG_DUR_EMPTY\t\t\t= 0x10000;\nBoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF= 0x20000;\n\nBoxParser.TRUN_FLAGS_DATA_OFFSET= 0x01;\nBoxParser.TRUN_FLAGS_FIRST_FLAG\t= 0x04;\nBoxParser.TRUN_FLAGS_DURATION\t= 0x100;\nBoxParser.TRUN_FLAGS_SIZE\t\t= 0x200;\nBoxParser.TRUN_FLAGS_FLAGS\t\t= 0x400;\nBoxParser.TRUN_FLAGS_CTS_OFFSET\t= 0x800;\n\nBoxParser.Box.prototype.add = function(name) {\n\treturn this.addBox(new BoxParser[name+\"Box\"]());\n}\n\nBoxParser.Box.prototype.addBox = function(box) {\n\tthis.boxes.push(box);\n\tif (this[box.type+\"s\"]) {\n\t\tthis[box.type+\"s\"].push(box);\n\t} else {\n\t\tthis[box.type] = box;\n\t}\n\treturn box;\n}\n\nBoxParser.Box.prototype.set = function(prop, value) {\n\tthis[prop] = value;\n\treturn this;\n}\n\nBoxParser.Box.prototype.addEntry = function(value, _prop) {\n\tvar prop = _prop || \"entries\";\n\tif (!this[prop]) {\n\t\tthis[prop] = [];\n\t}\n\tthis[prop].push(value);\n\treturn this;\n}\n\nif (typeof exports !== \"undefined\") {\n\texports.BoxParser = BoxParser;\n}\n// file:src/box-parse.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nBoxParser.parseUUID = function(stream) {\n\treturn BoxParser.parseHex16(stream);\n}\n\nBoxParser.parseHex16 = function(stream) {\n\tvar hex16 = \"\"\n\tfor (var i = 0; i <16; i++) {\n\t\tvar hex = stream.readUint8().toString(16);\n\t\thex16 += (hex.length === 1 ? \"0\"+hex : hex);\n\t}\n\treturn hex16;\n}\n\nBoxParser.parseOneBox = function(stream, headerOnly, parentSize) {\n\tvar box;\n\tvar start = stream.getPosition();\n\tvar hdr_size = 0;\n\tvar diff;\n\tvar uuid;\n\tif (stream.getEndPosition() - start < 8) {\n\t\tLog.debug(\"BoxParser\", \"Not enough data in stream to parse the type and size of the box\");\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA };\n\t}\n\tif (parentSize && parentSize < 8) {\n\t\tLog.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a new box\");\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA };\n\t}\n\tvar size = stream.readUint32();\n\tvar type = stream.readString(4);\n\tvar box_type = type;\n\tLog.debug(\"BoxParser\", \"Found box of type '\"+type+\"' and size \"+size+\" at position \"+start);\n\thdr_size = 8;\n\tif (type == \"uuid\") {\n\t\tif ((stream.getEndPosition() - stream.getPosition() < 16) || (parentSize -hdr_size < 16)) {\n\t\t\tstream.seek(start);\n\t\t\tLog.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a UUID box\");\n\t\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA };\n\t\t}\n\t\tuuid = BoxParser.parseUUID(stream);\n\t\thdr_size += 16;\n\t\tbox_type = uuid;\n\t}\n\tif (size == 1) {\n\t\tif ((stream.getEndPosition() - stream.getPosition() < 8) || (parentSize && (parentSize - hdr_size) < 8)) {\n\t\t\tstream.seek(start);\n\t\t\tLog.warn(\"BoxParser\", \"Not enough data in stream to parse the extended size of the \\\"\"+type+\"\\\" box\");\n\t\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA };\n\t\t}\n\t\tsize = stream.readUint64();\n\t\thdr_size += 8;\n\t} else if (size === 0) {\n\t\t/* box extends till the end of file or invalid file */\n\t\tif (parentSize) {\n\t\t\tsize = parentSize;\n\t\t} else {\n\t\t\t/* box extends till the end of file */\n\t\t\tif (type !== \"mdat\") {\n\t\t\t\tLog.error(\"BoxParser\", \"Unlimited box size not supported for type: '\"+type+\"'\");\n\t\t\t\tbox = new BoxParser.Box(type, size);\n\t\t\t\treturn { code: BoxParser.OK, box: box, size: box.size };\n\t\t\t}\n\t\t}\n\t}\n\tif (size !== 0 && size < hdr_size) {\n\t\tLog.error(\"BoxParser\", \"Box of type \"+type+\" has an invalid size \"+size+\" (too small to be a box)\");\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: type, size: size, hdr_size: hdr_size, start: start };\n\t}\n\tif (size !== 0 && parentSize && size > parentSize) {\n\t\tLog.error(\"BoxParser\", \"Box of type '\"+type+\"' has a size \"+size+\" greater than its container size \"+parentSize);\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: type, size: size, hdr_size: hdr_size, start: start };\n\t}\n\tif (size !== 0 && start + size > stream.getEndPosition()) {\n\t\tstream.seek(start);\n\t\tLog.info(\"BoxParser\", \"Not enough data in stream to parse the entire '\"+type+\"' box\");\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: type, size: size, hdr_size: hdr_size, start: start };\n\t}\n\tif (headerOnly) {\n\t\treturn { code: BoxParser.OK, type: type, size: size, hdr_size: hdr_size, start: start };\n\t} else {\n\t\tif (BoxParser[type+\"Box\"]) {\n\t\t\tbox = new BoxParser[type+\"Box\"](size);\n\t\t} else {\n\t\t\tif (type !== \"uuid\") {\n\t\t\t\tLog.warn(\"BoxParser\", \"Unknown box type: '\"+type+\"'\");\n\t\t\t\tbox = new BoxParser.Box(type, size);\n\t\t\t\tbox.has_unparsed_data = true;\n\t\t\t} else {\n\t\t\t\tif (BoxParser.UUIDBoxes[uuid]) {\n\t\t\t\t\tbox = new BoxParser.UUIDBoxes[uuid](size);\n\t\t\t\t} else {\n\t\t\t\t\tLog.warn(\"BoxParser\", \"Unknown uuid type: '\"+uuid+\"'\");\n\t\t\t\t\tbox = new BoxParser.Box(type, size);\n\t\t\t\t\tbox.uuid = uuid;\n\t\t\t\t\tbox.has_unparsed_data = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbox.hdr_size = hdr_size;\n\t/* recording the position of the box in the input stream */\n\tbox.start = start;\n\tif (box.write === BoxParser.Box.prototype.write && box.type !== \"mdat\") {\n\t\tLog.info(\"BoxParser\", \"'\"+box_type+\"' box writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\tbox.parseDataAndRewind(stream);\n\t}\n\tbox.parse(stream);\n\tdiff = stream.getPosition() - (box.start+box.size);\n\tif (diff < 0) {\n\t\tLog.warn(\"BoxParser\", \"Parsing of box '\"+box_type+\"' did not read the entire indicated box data size (missing \"+(-diff)+\" bytes), seeking forward\");\n\t\tstream.seek(box.start+box.size);\n\t} else if (diff > 0) {\n\t\tLog.error(\"BoxParser\", \"Parsing of box '\"+box_type+\"' read \"+diff+\" more bytes than the indicated box data size, seeking backwards\");\n\t\tif (box.size !== 0) stream.seek(box.start+box.size);\n\t}\n\treturn { code: BoxParser.OK, box: box, size: box.size };\n}\n\nBoxParser.Box.prototype.parse = function(stream) {\n\tif (this.type != \"mdat\") {\n\t\tthis.data = stream.readUint8Array(this.size-this.hdr_size);\n\t} else {\n\t\tif (this.size === 0) {\n\t\t\tstream.seek(stream.getEndPosition());\n\t\t} else {\n\t\t\tstream.seek(this.start+this.size);\n\t\t}\n\t}\n}\n\n/* Used to parse a box without consuming its data, to allow detailled parsing\n   Useful for boxes for which a write method is not yet implemented */\nBoxParser.Box.prototype.parseDataAndRewind = function(stream) {\n\tthis.data = stream.readUint8Array(this.size-this.hdr_size);\n\t// rewinding\n\tstream.position -= this.size-this.hdr_size;\n}\n\nBoxParser.FullBox.prototype.parseDataAndRewind = function(stream) {\n\tthis.parseFullHeader(stream);\n\tthis.data = stream.readUint8Array(this.size-this.hdr_size);\n\t// restore the header size as if the full header had not been parsed\n\tthis.hdr_size -= 4;\n\t// rewinding\n\tstream.position -= this.size-this.hdr_size;\n}\n\nBoxParser.FullBox.prototype.parseFullHeader = function (stream) {\n\tthis.version = stream.readUint8();\n\tthis.flags = stream.readUint24();\n\tthis.hdr_size += 4;\n}\n\nBoxParser.FullBox.prototype.parse = function (stream) {\n\tthis.parseFullHeader(stream);\n\tthis.data = stream.readUint8Array(this.size-this.hdr_size);\n}\n\nBoxParser.ContainerBox.prototype.parse = function(stream) {\n\tvar ret;\n\tvar box;\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = ret.box;\n\t\t\t/* store the box in the 'boxes' array to preserve box order (for offset) but also store box in a property for more direct access */\n\t\t\tthis.boxes.push(box);\n\t\t\tif (this.subBoxNames && this.subBoxNames.indexOf(box.type) != -1) {\n\t\t\t\tthis[this.subBoxNames[this.subBoxNames.indexOf(box.type)]+\"s\"].push(box);\n\t\t\t} else {\n\t\t\t\tvar box_type = box.type !== \"uuid\" ? box.type : box.uuid;\n\t\t\t\tif (this[box_type]) {\n\t\t\t\t\tLog.warn(\"Box of type \"+box_type+\" already stored in field of this type\");\n\t\t\t\t} else {\n\t\t\t\t\tthis[box_type] = box;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nBoxParser.Box.prototype.parseLanguage = function(stream) {\n\tthis.language = stream.readUint16();\n\tvar chars = [];\n\tchars[0] = (this.language>>10)&0x1F;\n\tchars[1] = (this.language>>5)&0x1F;\n\tchars[2] = (this.language)&0x1F;\n\tthis.languageString = String.fromCharCode(chars[0]+0x60, chars[1]+0x60, chars[2]+0x60);\n}\n\n// file:src/parsing/sampleentries/sampleentry.js\nBoxParser.SAMPLE_ENTRY_TYPE_VISUAL \t\t= \"Visual\";\nBoxParser.SAMPLE_ENTRY_TYPE_AUDIO \t\t= \"Audio\";\nBoxParser.SAMPLE_ENTRY_TYPE_HINT \t\t= \"Hint\";\nBoxParser.SAMPLE_ENTRY_TYPE_METADATA \t= \"Metadata\";\nBoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE \t= \"Subtitle\";\nBoxParser.SAMPLE_ENTRY_TYPE_SYSTEM \t\t= \"System\";\nBoxParser.SAMPLE_ENTRY_TYPE_TEXT \t\t= \"Text\";\n\nBoxParser.SampleEntry.prototype.parseHeader = function(stream) {\n\tstream.readUint8Array(6);\n\tthis.data_reference_index = stream.readUint16();\n\tthis.hdr_size += 8;\n}\n\nBoxParser.SampleEntry.prototype.parse = function(stream) {\n\tthis.parseHeader(stream);\n\tthis.data = stream.readUint8Array(this.size - this.hdr_size);\n}\n\nBoxParser.SampleEntry.prototype.parseDataAndRewind = function(stream) {\n\tthis.parseHeader(stream);\n\tthis.data = stream.readUint8Array(this.size - this.hdr_size);\n\t// restore the header size as if the sample entry header had not been parsed\n\tthis.hdr_size -= 8;\n\t// rewinding\n\tstream.position -= this.size-this.hdr_size;\n}\n\nBoxParser.SampleEntry.prototype.parseFooter = function(stream) {\n\tBoxParser.ContainerBox.prototype.parse.call(this, stream);\n}\n\n// Base SampleEntry types with default parsing\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_HINT);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_TEXT);\n\n//Base SampleEntry types for Audio and Video with specific parsing\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, function(stream) {\n\tvar compressorname_length;\n\tthis.parseHeader(stream);\n\tstream.readUint16();\n\tstream.readUint16();\n\tstream.readUint32Array(3);\n\tthis.width = stream.readUint16();\n\tthis.height = stream.readUint16();\n\tthis.horizresolution = stream.readUint32();\n\tthis.vertresolution = stream.readUint32();\n\tstream.readUint32();\n\tthis.frame_count = stream.readUint16();\n\tcompressorname_length = Math.min(31, stream.readUint8());\n\tthis.compressorname = stream.readString(compressorname_length);\n\tif (compressorname_length < 31) {\n\t\tstream.readString(31 - compressorname_length);\n\t}\n\tthis.depth = stream.readUint16();\n\tstream.readUint16();\n\tthis.parseFooter(stream);\n});\n\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, function(stream) {\n\tthis.parseHeader(stream);\n\tstream.readUint32Array(2);\n\tthis.channel_count = stream.readUint16();\n\tthis.samplesize = stream.readUint16();\n\tstream.readUint16();\n\tstream.readUint16();\n\tthis.samplerate = (stream.readUint32()/(1<<16));\n\tthis.parseFooter(stream);\n});\n\n// Sample entries inheriting from Audio and Video\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc4\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"av01\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"dav1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"hvc1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"hev1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"hvt1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"lhe1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"dvh1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"dvhe\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vvc1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vvi1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vvs1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vvcN\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vp08\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"vp09\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avs3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"j2ki\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"mjp2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"mjpg\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL,\t\"uncv\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"mp4a\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"ac-3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"ac-4\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"ec-3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"Opus\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"mha1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"mha2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"mhm1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"mhm2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"fLaC\");\n\n// Encrypted sample entries\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \t\"encv\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"enca\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \t\"encu\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM, \t\"encs\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_TEXT, \t\t\"enct\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \t\"encm\");\n// file:src/parsing/a1lx.js\nBoxParser.createBoxCtor(\"a1lx\", function(stream) {\n\tvar large_size = stream.readUint8() & 1;\n\tvar FieldLength = ((large_size & 1) + 1) * 16;\n\tthis.layer_size = [];\n\tfor (var i = 0; i < 3; i++) {\n\t\tif (FieldLength == 16) {\n\t\t\tthis.layer_size[i] = stream.readUint16();\n\t\t} else {\n\t\t\tthis.layer_size[i] = stream.readUint32();\n\t\t}\n\t}\n});// file:src/parsing/a1op.js\nBoxParser.createBoxCtor(\"a1op\", function(stream) {\n\tthis.op_index = stream.readUint8();\n});// file:src/parsing/auxC.js\nBoxParser.createFullBoxCtor(\"auxC\", function(stream) {\n\tthis.aux_type = stream.readCString();\n\tvar aux_subtype_length = this.size - this.hdr_size - (this.aux_type.length + 1);\n\tthis.aux_subtype = stream.readUint8Array(aux_subtype_length);\n});// file:src/parsing/av1C.js\nBoxParser.createBoxCtor(\"av1C\", function(stream) {\n\tvar i;\n\tvar toparse;\n\tvar tmp = stream.readUint8();\n\tif ((tmp >> 7) & 0x1 !== 1) {\n\t\tLog.error(\"av1C marker problem\");\n\t\treturn;\n\t}\n\tthis.version = tmp & 0x7F;\n\tif (this.version !== 1) {\n\t\tLog.error(\"av1C version \"+this.version+\" not supported\");\n\t\treturn;\n\t}\n\ttmp = stream.readUint8();\n\tthis.seq_profile = (tmp >> 5) & 0x7;\n\tthis.seq_level_idx_0 = tmp & 0x1F;\n\ttmp = stream.readUint8();\n\tthis.seq_tier_0 = (tmp >> 7) & 0x1;\n\tthis.high_bitdepth = (tmp >> 6) & 0x1;\n\tthis.twelve_bit = (tmp >> 5) & 0x1;\n\tthis.monochrome = (tmp >> 4) & 0x1;\n\tthis.chroma_subsampling_x = (tmp >> 3) & 0x1;\n\tthis.chroma_subsampling_y = (tmp >> 2) & 0x1;\n\tthis.chroma_sample_position = (tmp & 0x3);\n\ttmp = stream.readUint8();\n\tthis.reserved_1 = (tmp >> 5) & 0x7;\n\tif (this.reserved_1 !== 0) {\n\t\tLog.error(\"av1C reserved_1 parsing problem\");\n\t\treturn;\n\t}\n\tthis.initial_presentation_delay_present = (tmp >> 4) & 0x1;\n\tif (this.initial_presentation_delay_present === 1) {\n\t\tthis.initial_presentation_delay_minus_one = (tmp & 0xF);\n\t} else {\n\t\tthis.reserved_2 = (tmp & 0xF);\n\t\tif (this.reserved_2 !== 0) {\n\t\t\tLog.error(\"av1C reserved_2 parsing problem\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvar configOBUs_length = this.size - this.hdr_size - 4;\n\tthis.configOBUs = stream.readUint8Array(configOBUs_length);\n});\n\n// file:src/parsing/avcC.js\nBoxParser.createBoxCtor(\"avcC\", function(stream) {\n\tvar i;\n\tvar toparse;\n\tthis.configurationVersion = stream.readUint8();\n\tthis.AVCProfileIndication = stream.readUint8();\n\tthis.profile_compatibility = stream.readUint8();\n\tthis.AVCLevelIndication = stream.readUint8();\n\tthis.lengthSizeMinusOne = (stream.readUint8() & 0x3);\n\tthis.nb_SPS_nalus = (stream.readUint8() & 0x1F);\n\ttoparse = this.size - this.hdr_size - 6;\n\tthis.SPS = [];\n\tfor (i = 0; i < this.nb_SPS_nalus; i++) {\n\t\tthis.SPS[i] = {};\n\t\tthis.SPS[i].length = stream.readUint16();\n\t\tthis.SPS[i].nalu = stream.readUint8Array(this.SPS[i].length);\n\t\ttoparse -= 2+this.SPS[i].length;\n\t}\n\tthis.nb_PPS_nalus = stream.readUint8();\n\ttoparse--;\n\tthis.PPS = [];\n\tfor (i = 0; i < this.nb_PPS_nalus; i++) {\n\t\tthis.PPS[i] = {};\n\t\tthis.PPS[i].length = stream.readUint16();\n\t\tthis.PPS[i].nalu = stream.readUint8Array(this.PPS[i].length);\n\t\ttoparse -= 2+this.PPS[i].length;\n\t}\n\tif (toparse>0) {\n\t\tthis.ext = stream.readUint8Array(toparse);\n\t}\n});\n\n// file:src/parsing/btrt.js\nBoxParser.createBoxCtor(\"btrt\", function(stream) {\n\tthis.bufferSizeDB = stream.readUint32();\n\tthis.maxBitrate = stream.readUint32();\n\tthis.avgBitrate = stream.readUint32();\n});\n\n// file:src/parsing/ccst.js\nBoxParser.createFullBoxCtor(\"ccst\", function(stream) {\n\tvar flags = stream.readUint8();\n\tthis.all_ref_pics_intra = ((flags & 0x80) == 0x80);\n\tthis.intra_pred_used = ((flags & 0x40) == 0x40);\n\tthis.max_ref_per_pic = ((flags & 0x3f) >> 2);\n\tstream.readUint24();\n});\n\n// file:src/parsing/cdef.js\nBoxParser.createBoxCtor(\"cdef\", function(stream) {\n    var i;\n    this.channel_count = stream.readUint16();\n    this.channel_indexes = [];\n    this.channel_types = [];\n    this.channel_associations = [];\n    for (i = 0; i < this.channel_count; i++) {\n        this.channel_indexes.push(stream.readUint16());\n        this.channel_types.push(stream.readUint16());\n        this.channel_associations.push(stream.readUint16());\n    }\n});\n\n// file:src/parsing/clap.js\nBoxParser.createBoxCtor(\"clap\", function(stream) {\n\tthis.cleanApertureWidthN = stream.readUint32();\n\tthis.cleanApertureWidthD = stream.readUint32();\n\tthis.cleanApertureHeightN = stream.readUint32();\n\tthis.cleanApertureHeightD = stream.readUint32();\n\tthis.horizOffN = stream.readUint32();\n\tthis.horizOffD = stream.readUint32();\n\tthis.vertOffN = stream.readUint32();\n\tthis.vertOffD = stream.readUint32();\n});// file:src/parsing/clli.js\nBoxParser.createBoxCtor(\"clli\", function(stream) {\n\tthis.max_content_light_level = stream.readUint16();\n    this.max_pic_average_light_level = stream.readUint16();\n});\n\n// file:src/parsing/cmex.js\nBoxParser.createFullBoxCtor(\"cmex\", function(stream) {\n\tif (this.flags & 0x1) {\n\t\tthis.pos_x = stream.readInt32();\n\t}\n\tif (this.flags & 0x2) {\n\t\tthis.pos_y = stream.readInt32();\n\t}\n\tif (this.flags & 0x4) {\n\t\tthis.pos_z = stream.readInt32();\n\t}\n\tif (this.flags & 0x8) {\n\t\tif (this.version == 0) {\n\t\t\tif (this.flags & 0x10) {\n\t\t\t\tthis.quat_x = stream.readInt32();\n\t\t\t\tthis.quat_y = stream.readInt32();\n\t\t\t\tthis.quat_z = stream.readInt32();\n\t\t\t} else {\n\t\t\t\tthis.quat_x = stream.readInt16();\n\t\t\t\tthis.quat_y = stream.readInt16();\n\t\t\t\tthis.quat_z = stream.readInt16();\n\t\t\t}\n\t\t} else if (this.version == 1) {\n\t\t\t//ViewpointGlobalCoordinateSysRotationStruct rot;\n\t\t}\n\t}\n\tif (this.flags & 0x20) {\n\t\tthis.id = stream.readUint32();\n\t}\n});\n// file:src/parsing/cmin.js\nBoxParser.createFullBoxCtor(\"cmin\", function(stream) {\n\tthis.focal_length_x = stream.readInt32();\n\tthis.principal_point_x = stream.readInt32();\n\tthis.principal_point_y = stream.readInt32();\n\tif (this.flags & 0x1) {\n\t\tthis.focal_length_y = stream.readInt32();\n\t\tthis.skew_factor = stream.readInt32();\n\t}\n});// file:src/parsing/cmpd.js\nBoxParser.createBoxCtor(\"cmpd\", function(stream) {\n\tthis.component_count = stream.readUint32();\n\tthis.component_types = [];\n\tthis.component_type_urls = [];\n\tfor (i = 0; i < this.component_count; i++) {\n\t\tvar component_type = stream.readUint16();\n\t\tthis.component_types.push(component_type);\n\t\tif (component_type >= 0x8000) {\n\t\t\tthis.component_type_urls.push(stream.readCString());\n\t\t}\n\t}\n});// file:src/parsing/co64.js\nBoxParser.createFullBoxCtor(\"co64\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tentry_count = stream.readUint32();\n\tthis.chunk_offsets = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.chunk_offsets.push(stream.readUint64());\n\t\t}\n\t}\n});\n\n// file:src/parsing/CoLL.js\nBoxParser.createFullBoxCtor(\"CoLL\", function(stream) {\n\tthis.maxCLL = stream.readUint16();\n    this.maxFALL = stream.readUint16();\n});\n\n// file:src/parsing/colr.js\nBoxParser.createBoxCtor(\"colr\", function(stream) {\n\tthis.colour_type = stream.readString(4);\n\tif (this.colour_type === 'nclx') {\n\t\tthis.colour_primaries = stream.readUint16();\n\t\tthis.transfer_characteristics = stream.readUint16();\n\t\tthis.matrix_coefficients = stream.readUint16();\n\t\tvar tmp = stream.readUint8();\n\t\tthis.full_range_flag = tmp >> 7;\n\t} else if (this.colour_type === 'rICC') {\n\t\tthis.ICC_profile = stream.readUint8Array(this.size - 4);\n\t} else if (this.colour_type === 'prof') {\n\t\tthis.ICC_profile = stream.readUint8Array(this.size - 4);\n\t}\n});// file:src/parsing/cprt.js\nBoxParser.createFullBoxCtor(\"cprt\", function (stream) {\n\tthis.parseLanguage(stream);\n\tthis.notice = stream.readCString();\n});\n\n// file:src/parsing/cslg.js\nBoxParser.createFullBoxCtor(\"cslg\", function(stream) {\n\tvar entry_count;\n\tif (this.version === 0) {\n\t\tthis.compositionToDTSShift = stream.readInt32(); /* signed */\n\t\tthis.leastDecodeToDisplayDelta = stream.readInt32(); /* signed */\n\t\tthis.greatestDecodeToDisplayDelta = stream.readInt32(); /* signed */\n\t\tthis.compositionStartTime = stream.readInt32(); /* signed */\n\t\tthis.compositionEndTime = stream.readInt32(); /* signed */\n\t}\n});\n\n// file:src/parsing/ctts.js\nBoxParser.createFullBoxCtor(\"ctts\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tentry_count = stream.readUint32();\n\tthis.sample_counts = [];\n\tthis.sample_offsets = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.sample_counts.push(stream.readUint32());\n\t\t\t/* some files are buggy and declare version=0 while using signed offsets.\n\t\t\t   The likelyhood of using the most significant bit in a 32-bits time offset is very low,\n\t\t\t   so using signed value here as well */\n\t\t\t   var value = stream.readInt32();\n\t\t\t   if (value < 0) {\n\t\t\t   \t\tLog.warn(\"BoxParser\", \"ctts box uses negative values without using version 1\");\n\t\t\t   }\n\t\t\tthis.sample_offsets.push(value);\n\t\t}\n\t} else if (this.version == 1) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.sample_counts.push(stream.readUint32());\n\t\t\tthis.sample_offsets.push(stream.readInt32()); /* signed */\n\t\t}\n\t}\n});\n\n// file:src/parsing/dac3.js\nBoxParser.createBoxCtor(\"dac3\", function(stream) {\n\tvar tmp_byte1 = stream.readUint8();\n\tvar tmp_byte2 = stream.readUint8();\n\tvar tmp_byte3 = stream.readUint8();\n\tthis.fscod = tmp_byte1 >> 6;\n\tthis.bsid  = ((tmp_byte1 >> 1) & 0x1F);\n\tthis.bsmod = ((tmp_byte1 & 0x1) <<  2) | ((tmp_byte2 >> 6) & 0x3);\n\tthis.acmod = ((tmp_byte2 >> 3) & 0x7);\n\tthis.lfeon = ((tmp_byte2 >> 2) & 0x1);\n\tthis.bit_rate_code = (tmp_byte2 & 0x3) | ((tmp_byte3 >> 5) & 0x7);\n});\n\n// file:src/parsing/dec3.js\nBoxParser.createBoxCtor(\"dec3\", function(stream) {\n\tvar tmp_16 = stream.readUint16();\n\tthis.data_rate = tmp_16 >> 3;\n\tthis.num_ind_sub = tmp_16 & 0x7;\n\tthis.ind_subs = [];\n\tfor (var i = 0; i < this.num_ind_sub+1; i++) {\n\t\tvar ind_sub = {};\n\t\tthis.ind_subs.push(ind_sub);\n\t\tvar tmp_byte1 = stream.readUint8();\n\t\tvar tmp_byte2 = stream.readUint8();\n\t\tvar tmp_byte3 = stream.readUint8();\n\t\tind_sub.fscod = tmp_byte1 >> 6;\n\t\tind_sub.bsid  = ((tmp_byte1 >> 1) & 0x1F);\n\t\tind_sub.bsmod = ((tmp_byte1 & 0x1) << 4) | ((tmp_byte2 >> 4) & 0xF);\n\t\tind_sub.acmod = ((tmp_byte2 >> 1) & 0x7);\n\t\tind_sub.lfeon = (tmp_byte2 & 0x1);\n\t\tind_sub.num_dep_sub = ((tmp_byte3 >> 1) & 0xF);\n\t\tif (ind_sub.num_dep_sub > 0) {\n\t\t\tind_sub.chan_loc = ((tmp_byte3 & 0x1) << 8) | stream.readUint8();\n\t\t}\n\t}\n});\n\n// file:src/parsing/dfLa.js\nBoxParser.createFullBoxCtor(\"dfLa\", function(stream) {\n    var BLOCKTYPE_MASK = 0x7F;\n    var LASTMETADATABLOCKFLAG_MASK = 0x80;\n\n    var boxesFound = [];\n    var knownBlockTypes = [\n        \"STREAMINFO\",\n        \"PADDING\",\n        \"APPLICATION\",\n        \"SEEKTABLE\",\n        \"VORBIS_COMMENT\",\n        \"CUESHEET\",\n        \"PICTURE\",\n        \"RESERVED\"\n    ];\n\n    // for (i=0; ; i++) { // to end of box\n    do {\n        var flagAndType = stream.readUint8();\n\n        var type = Math.min(\n            (flagAndType & BLOCKTYPE_MASK),\n            (knownBlockTypes.length - 1)\n        );\n\n        // if this is a STREAMINFO block, read the true samplerate since this\n        // can be different to the AudioSampleEntry samplerate.\n        if (!(type)) {\n            // read past all the other stuff\n            stream.readUint8Array(13);\n\n            // extract samplerate\n            this.samplerate = (stream.readUint32() >> 12);\n\n            // read to end of STREAMINFO\n            stream.readUint8Array(20);\n        } else {\n            // not interested in other block types so just discard length bytes\n            stream.readUint8Array(stream.readUint24());\n        }\n\n        boxesFound.push(knownBlockTypes[type]);\n\n        if (!!(flagAndType & LASTMETADATABLOCKFLAG_MASK)) {\n            break;\n        }\n    } while (true);\n\n    this.numMetadataBlocks =\n        boxesFound.length + \" (\" + boxesFound.join(\", \") + \")\";\n});\n// file:src/parsing/dimm.js\nBoxParser.createBoxCtor(\"dimm\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/dmax.js\nBoxParser.createBoxCtor(\"dmax\", function(stream) {\n\tthis.time = stream.readUint32();\n});\n\n// file:src/parsing/dmed.js\nBoxParser.createBoxCtor(\"dmed\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/dOps.js\nBoxParser.createBoxCtor(\"dOps\", function(stream) {\n\tthis.Version = stream.readUint8();\n\tthis.OutputChannelCount = stream.readUint8();\n\tthis.PreSkip = stream.readUint16();\n\tthis.InputSampleRate = stream.readUint32();\n\tthis.OutputGain = stream.readInt16();\n\tthis.ChannelMappingFamily = stream.readUint8();\n\tif (this.ChannelMappingFamily !== 0) {\n\t\tthis.StreamCount = stream.readUint8();\n\t\tthis.CoupledCount = stream.readUint8();\n\t\tthis.ChannelMapping = [];\n\t\tfor (var i = 0; i < this.OutputChannelCount; i++) {\n\t\t\tthis.ChannelMapping[i] = stream.readUint8();\n\t\t}\n\t}\n});\n\n// file:src/parsing/dref.js\nBoxParser.createFullBoxCtor(\"dref\", function(stream) {\n\tvar ret;\n\tvar box;\n\tthis.entries = [];\n\tvar entry_count = stream.readUint32();\n\tfor (var i = 0; i < entry_count; i++) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = ret.box;\n\t\t\tthis.entries.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/drep.js\nBoxParser.createBoxCtor(\"drep\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/elng.js\nBoxParser.createFullBoxCtor(\"elng\", function(stream) {\n\tthis.extended_language = stream.readString(this.size-this.hdr_size);\n});\n\n// file:src/parsing/elst.js\nBoxParser.createFullBoxCtor(\"elst\", function(stream) {\n\tthis.entries = [];\n\tvar entry_count = stream.readUint32();\n\tfor (var i = 0; i < entry_count; i++) {\n\t\tvar entry = {};\n\t\tthis.entries.push(entry);\n\t\tif (this.version === 1) {\n\t\t\tentry.segment_duration = stream.readUint64();\n\t\t\tentry.media_time = stream.readInt64();\n\t\t} else {\n\t\t\tentry.segment_duration = stream.readUint32();\n\t\t\tentry.media_time = stream.readInt32();\n\t\t}\n\t\tentry.media_rate_integer = stream.readInt16();\n\t\tentry.media_rate_fraction = stream.readInt16();\n\t}\n});\n\n// file:src/parsing/emsg.js\nBoxParser.createFullBoxCtor(\"emsg\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.timescale \t\t\t\t\t= stream.readUint32();\n\t\tthis.presentation_time \t\t\t= stream.readUint64();\n\t\tthis.event_duration\t\t\t \t= stream.readUint32();\n\t\tthis.id \t\t\t\t\t\t= stream.readUint32();\n\t\tthis.scheme_id_uri \t\t\t\t= stream.readCString();\n\t\tthis.value \t\t\t\t\t\t= stream.readCString();\n\t} else {\n\t\tthis.scheme_id_uri \t\t\t\t= stream.readCString();\n\t\tthis.value \t\t\t\t\t\t= stream.readCString();\n\t\tthis.timescale \t\t\t\t\t= stream.readUint32();\n\t\tthis.presentation_time_delta \t= stream.readUint32();\n\t\tthis.event_duration\t\t\t \t= stream.readUint32();\n\t\tthis.id \t\t\t\t\t\t= stream.readUint32();\n\t}\n\tvar message_size = this.size - this.hdr_size - (4*4 + (this.scheme_id_uri.length+1) + (this.value.length+1));\n\tif (this.version == 1) {\n\t\tmessage_size -= 4;\n\t}\n\tthis.message_data = stream.readUint8Array(message_size);\n});\n\n// file:src/parsing/EntityToGroup.js\n// ISO/IEC 14496-12:2022 Section 8.18.3 Entity to group box\nBoxParser.createEntityToGroupCtor = function(type, parseMethod) {\n    BoxParser[type+\"Box\"] = function(size) {\n        BoxParser.FullBox.call(this, type, size);\n    }\n    BoxParser[type+\"Box\"].prototype = new BoxParser.FullBox();\n    BoxParser[type+\"Box\"].prototype.parse = function(stream) {\n        this.parseFullHeader(stream);\n        if (parseMethod) {\n            parseMethod.call(this, stream);\n        } else {\n            this.group_id = stream.readUint32();\n            this.num_entities_in_group = stream.readUint32();\n            this.entity_ids = [];\n            for (i = 0; i < this.num_entities_in_group; i++) {\n                var entity_id = stream.readUint32();\n                this.entity_ids.push(entity_id);\n            }\n        }\n    };\n};\n\n// Auto exposure bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.2.1)\nBoxParser.createEntityToGroupCtor(\"aebr\");\n\n// Flash exposure bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.5.1)\nBoxParser.createEntityToGroupCtor(\"afbr\");\n\n// Album collection (ISO/IEC 23008-12:2022 Section 6.8.7.1)\nBoxParser.createEntityToGroupCtor(\"albc\");\n\n// Alternative entity (ISO/IEC 14496-12:2022 Section 8.18.3.1)\nBoxParser.createEntityToGroupCtor(\"altr\");\n\n// Burst image entity group (ISO/IEC 23008-12:2022 Section 6.8.2.2)\nBoxParser.createEntityToGroupCtor(\"brst\");\n\n// Depth of field bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.6.1)\nBoxParser.createEntityToGroupCtor(\"dobr\");\n\n// Equivalent entity (ISO/IEC 23008-12:2022 Section 6.8.1.1)\nBoxParser.createEntityToGroupCtor(\"eqiv\");\n\n// Favourites collection (ISO/IEC 23008-12:2022 Section 6.8.7.2)\nBoxParser.createEntityToGroupCtor(\"favc\");\n\n// Focus bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.4.1)\nBoxParser.createEntityToGroupCtor(\"fobr\");\n\n// Audio to image entity group (ISO/IEC 23008-12:2022 Section 6.8.4)\nBoxParser.createEntityToGroupCtor(\"iaug\");\n\n// Panorama (ISO/IEC 23008-12:2022 Section 6.8.8.1)\nBoxParser.createEntityToGroupCtor(\"pano\");\n\n// Slideshow (ISO/IEC 23008-12:2022 Section 6.8.9.1)\nBoxParser.createEntityToGroupCtor(\"slid\");\n\n// Stereo pair (ISO/IEC 23008-12:2022 Section 6.8.5)\nBoxParser.createEntityToGroupCtor(\"ster\");\n\n// Time-synchronised capture entity group (ISO/IEC 23008-12:2022 Section 6.8.3)\nBoxParser.createEntityToGroupCtor(\"tsyn\");\n\n// White balance bracketing (ISO/IEC 23008-12:2022 Section 6.8.6.3.1)\nBoxParser.createEntityToGroupCtor(\"wbbr\");\n\n// Alternative entity (ISO/IEC 23008-12:2022 AMD1 Section 6.8.10)\nBoxParser.createEntityToGroupCtor(\"prgr\");\n\n// Image Pyramid entity group (ISO/IEC 23008-12:20xx Section 6.8.11)\nBoxParser.createEntityToGroupCtor(\"pymd\", function(stream) {\n    this.group_id = stream.readUint32();\n    this.num_entities_in_group = stream.readUint32();\n    this.entity_ids = [];\n    for (var i = 0; i < this.num_entities_in_group; i++) {\n        var entity_id = stream.readUint32();\n        this.entity_ids.push(entity_id);\n    }\n    \n    this.tile_size_x = stream.readUint16();\n    this.tile_size_y = stream.readUint16();\n    this.layer_binning = [];\n    this.tiles_in_layer_column_minus1 = [];\n    this.tiles_in_layer_row_minus1 = [];\n    for (i = 0; i < this.num_entities_in_group; i++) {\n        this.layer_binning[i] = stream.readUint16();\n        this.tiles_in_layer_row_minus1[i] = stream.readUint16();\n        this.tiles_in_layer_column_minus1[i] = stream.readUint16();\n    }\n});\n\n// file:src/parsing/esds.js\nBoxParser.createFullBoxCtor(\"esds\", function(stream) {\n\tvar esd_data = stream.readUint8Array(this.size-this.hdr_size);\n\tthis.data = esd_data\n\tif (typeof MPEG4DescriptorParser !== \"undefined\") {\n\t\tvar esd_parser = new MPEG4DescriptorParser();\n\t\tthis.esd = esd_parser.parseOneDescriptor(new DataStream(esd_data.buffer, 0, DataStream.BIG_ENDIAN));\n\t}\n});\n\n// file:src/parsing/fiel.js\nBoxParser.createBoxCtor(\"fiel\", function(stream) {\n\tthis.fieldCount = stream.readUint8();\n\tthis.fieldOrdering = stream.readUint8();\n});\n\n// file:src/parsing/frma.js\nBoxParser.createBoxCtor(\"frma\", function(stream) {\n\tthis.data_format = stream.readString(4);\n});\n\n// file:src/parsing/ftyp.js\nBoxParser.createBoxCtor(\"ftyp\", function(stream) {\n\tvar toparse = this.size - this.hdr_size;\n\tthis.major_brand = stream.readString(4);\n\tthis.minor_version = stream.readUint32();\n\ttoparse -= 8;\n\tthis.compatible_brands = [];\n\tvar i = 0;\n\twhile (toparse>=4) {\n\t\tthis.compatible_brands[i] = stream.readString(4);\n\t\ttoparse -= 4;\n\t\ti++;\n\t}\n});\n\n// file:src/parsing/hdlr.js\nBoxParser.createFullBoxCtor(\"hdlr\", function(stream) {\n\tif (this.version === 0) {\n\t\tstream.readUint32();\n\t\tthis.handler = stream.readString(4);\n\t\tstream.readUint32Array(3);\n\t\tthis.name = stream.readString(this.size-this.hdr_size-20);\n\t\tif (this.name[this.name.length-1]==='\\0') {\n\t\t\tthis.name = this.name.slice(0,-1);\n\t\t}\n\t}\n});\n\n// file:src/parsing/hvcC.js\nBoxParser.createBoxCtor(\"hvcC\", function(stream) {\n\tvar i, j;\n\tvar nb_nalus;\n\tvar length;\n\tvar tmp_byte;\n\tthis.configurationVersion = stream.readUint8();\n\ttmp_byte = stream.readUint8();\n\tthis.general_profile_space = tmp_byte >> 6;\n\tthis.general_tier_flag = (tmp_byte & 0x20) >> 5;\n\tthis.general_profile_idc = (tmp_byte & 0x1F);\n\tthis.general_profile_compatibility = stream.readUint32();\n\tthis.general_constraint_indicator = stream.readUint8Array(6);\n\tthis.general_level_idc = stream.readUint8();\n\tthis.min_spatial_segmentation_idc = stream.readUint16() & 0xFFF;\n\tthis.parallelismType = (stream.readUint8() & 0x3);\n\tthis.chroma_format_idc = (stream.readUint8() & 0x3);\n\tthis.bit_depth_luma_minus8 = (stream.readUint8() & 0x7);\n\tthis.bit_depth_chroma_minus8 = (stream.readUint8() & 0x7);\n\tthis.avgFrameRate = stream.readUint16();\n\ttmp_byte = stream.readUint8();\n\tthis.constantFrameRate = (tmp_byte >> 6);\n\tthis.numTemporalLayers = (tmp_byte & 0XD) >> 3;\n\tthis.temporalIdNested = (tmp_byte & 0X4) >> 2;\n\tthis.lengthSizeMinusOne = (tmp_byte & 0X3);\n\n\tthis.nalu_arrays = [];\n\tvar numOfArrays = stream.readUint8();\n\tfor (i = 0; i < numOfArrays; i++) {\n\t\tvar nalu_array = [];\n\t\tthis.nalu_arrays.push(nalu_array);\n\t\ttmp_byte = stream.readUint8()\n\t\tnalu_array.completeness = (tmp_byte & 0x80) >> 7;\n\t\tnalu_array.nalu_type = tmp_byte & 0x3F;\n\t\tvar numNalus = stream.readUint16();\n\t\tfor (j = 0; j < numNalus; j++) {\n\t\t\tvar nalu = {}\n\t\t\tnalu_array.push(nalu);\n\t\t\tlength = stream.readUint16();\n\t\t\tnalu.data   = stream.readUint8Array(length);\n\t\t}\n\t}\n});\n\n// file:src/parsing/iinf.js\nBoxParser.createFullBoxCtor(\"iinf\", function(stream) {\n\tvar ret;\n\tif (this.version === 0) {\n\t\tthis.entry_count = stream.readUint16();\n\t} else {\n\t\tthis.entry_count = stream.readUint32();\n\t}\n\tthis.item_infos = [];\n\tfor (var i = 0; i < this.entry_count; i++) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tif (ret.box.type !== \"infe\") {\n\t\t\t\tLog.error(\"BoxParser\", \"Expected 'infe' box, got \"+ret.box.type);\n\t\t\t}\n\t\t\tthis.item_infos[i] = ret.box;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/iloc.js\nBoxParser.createFullBoxCtor(\"iloc\", function(stream) {\n\tvar byte;\n\tbyte = stream.readUint8();\n\tthis.offset_size = (byte >> 4) & 0xF;\n\tthis.length_size = byte & 0xF;\n\tbyte = stream.readUint8();\n\tthis.base_offset_size = (byte >> 4) & 0xF;\n\tif (this.version === 1 || this.version === 2) {\n\t\tthis.index_size = byte & 0xF;\n\t} else {\n\t\tthis.index_size = 0;\n\t\t// reserved = byte & 0xF;\n\t}\n\tthis.items = [];\n\tvar item_count = 0;\n\tif (this.version < 2) {\n\t\titem_count = stream.readUint16();\n\t} else if (this.version === 2) {\n\t\titem_count = stream.readUint32();\n\t} else {\n\t\tthrow \"version of iloc box not supported\";\n\t}\n\tfor (var i = 0; i < item_count; i++) {\n\t\tvar item = {};\n\t\tthis.items.push(item);\n\t\tif (this.version < 2) {\n\t\t\titem.item_ID = stream.readUint16();\n\t\t} else if (this.version === 2) {\n\t\t\titem.item_ID = stream.readUint32();\n\t\t} else {\n\t\t\tthrow \"version of iloc box not supported\";\n\t\t}\n\t\tif (this.version === 1 || this.version === 2) {\n\t\t\titem.construction_method = (stream.readUint16() & 0xF);\n\t\t} else {\n\t\t\titem.construction_method = 0;\n\t\t}\n\t\titem.data_reference_index = stream.readUint16();\n\t\tswitch(this.base_offset_size) {\n\t\t\tcase 0:\n\t\t\t\titem.base_offset = 0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\titem.base_offset = stream.readUint32();\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\titem.base_offset = stream.readUint64();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow \"Error reading base offset size\";\n\t\t}\n\t\tvar extent_count = stream.readUint16();\n\t\titem.extents = [];\n\t\tfor (var j=0; j < extent_count; j++) {\n\t\t\tvar extent = {};\n\t\t\titem.extents.push(extent);\n\t\t\tif (this.version === 1 || this.version === 2) {\n\t\t\t\tswitch(this.index_size) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\textent.extent_index = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\textent.extent_index = stream.readUint32();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\textent.extent_index = stream.readUint64();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow \"Error reading extent index\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch(this.offset_size) {\n\t\t\t\tcase 0:\n\t\t\t\t\textent.extent_offset = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\textent.extent_offset = stream.readUint32();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\textent.extent_offset = stream.readUint64();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Error reading extent index\";\n\t\t\t}\n\t\t\tswitch(this.length_size) {\n\t\t\t\tcase 0:\n\t\t\t\t\textent.extent_length = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\textent.extent_length = stream.readUint32();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\textent.extent_length = stream.readUint64();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Error reading extent index\";\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/imir.js\nBoxParser.createBoxCtor(\"imir\", function(stream) {\n\tvar tmp = stream.readUint8();\n\tthis.reserved = tmp >> 7;\n\tthis.axis = tmp & 1;\n});// file:src/parsing/infe.js\nBoxParser.createFullBoxCtor(\"infe\", function(stream) {\n\tif (this.version === 0 || this.version === 1) {\n\t\tthis.item_ID = stream.readUint16();\n\t\tthis.item_protection_index = stream.readUint16();\n\t\tthis.item_name = stream.readCString();\n\t\tthis.content_type = stream.readCString();\n\t\tthis.content_encoding = stream.readCString();\n\t}\n\tif (this.version === 1) {\n\t\tthis.extension_type = stream.readString(4);\n\t\tLog.warn(\"BoxParser\", \"Cannot parse extension type\");\n\t\tstream.seek(this.start+this.size);\n\t\treturn;\n\t}\n\tif (this.version >= 2) {\n\t\tif (this.version === 2) {\n\t\t\tthis.item_ID = stream.readUint16();\n\t\t} else if (this.version === 3) {\n\t\t\tthis.item_ID = stream.readUint32();\n\t\t}\n\t\tthis.item_protection_index = stream.readUint16();\n\t\tthis.item_type = stream.readString(4);\n\t\tthis.item_name = stream.readCString();\n\t\tif (this.item_type === \"mime\") {\n\t\t\tthis.content_type = stream.readCString();\n\t\t\tthis.content_encoding = stream.readCString();\n\t\t} else if (this.item_type === \"uri \") {\n\t\t\tthis.item_uri_type = stream.readCString();\n\t\t}\n\t}\n});\n// file:src/parsing/ipma.js\nBoxParser.createFullBoxCtor(\"ipma\", function(stream) {\n\tvar i, j;\n\tentry_count = stream.readUint32();\n\tthis.associations = [];\n\tfor(i=0; i<entry_count; i++) {\n\t\tvar item_assoc = {};\n\t\tthis.associations.push(item_assoc);\n\t\tif (this.version < 1) {\n\t\t\titem_assoc.id = stream.readUint16();\n\t\t} else {\n\t\t\titem_assoc.id = stream.readUint32();\n\t\t}\n\t\tvar association_count = stream.readUint8();\n\t\titem_assoc.props = [];\n\t\tfor (j = 0; j < association_count; j++) {\n\t\t\tvar tmp = stream.readUint8();\n\t\t\tvar p = {};\n\t\t\titem_assoc.props.push(p);\n\t\t\tp.essential = ((tmp & 0x80) >> 7) === 1;\n\t\t\tif (this.flags & 0x1) {\n\t\t\t\tp.property_index = (tmp & 0x7F) << 8 | stream.readUint8();\n\t\t\t} else {\n\t\t\t\tp.property_index = (tmp & 0x7F);\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/iref.js\nBoxParser.createFullBoxCtor(\"iref\", function(stream) {\n\tvar ret;\n\tvar entryCount;\n\tvar box;\n\tthis.references = [];\n\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tif (this.version === 0) {\n\t\t\t\tbox = new BoxParser.SingleItemTypeReferenceBox(ret.type, ret.size, ret.hdr_size, ret.start);\n\t\t\t} else {\n\t\t\t\tbox = new BoxParser.SingleItemTypeReferenceBoxLarge(ret.type, ret.size, ret.hdr_size, ret.start);\n\t\t\t}\n\t\t\tif (box.write === BoxParser.Box.prototype.write && box.type !== \"mdat\") {\n\t\t\t\tLog.warn(\"BoxParser\", box.type+\" box writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\t\t\tbox.parseDataAndRewind(stream);\n\t\t\t}\n\t\t\tbox.parse(stream);\n\t\t\tthis.references.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n// file:src/parsing/irot.js\nBoxParser.createBoxCtor(\"irot\", function(stream) {\n\tthis.angle = stream.readUint8() & 0x3;\n});\n\n// file:src/parsing/ispe.js\nBoxParser.createFullBoxCtor(\"ispe\", function(stream) {\n\tthis.image_width = stream.readUint32();\n\tthis.image_height = stream.readUint32();\n});// file:src/parsing/kind.js\nBoxParser.createFullBoxCtor(\"kind\", function(stream) {\n\tthis.schemeURI = stream.readCString();\n\tthis.value = stream.readCString();\n});\n// file:src/parsing/leva.js\nBoxParser.createFullBoxCtor(\"leva\", function(stream) {\n\tvar count = stream.readUint8();\n\tthis.levels = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tvar level = {};\n\t\tthis.levels[i] = level;\n\t\tlevel.track_ID = stream.readUint32();\n\t\tvar tmp_byte = stream.readUint8();\n\t\tlevel.padding_flag = tmp_byte >> 7;\n\t\tlevel.assignment_type = tmp_byte & 0x7F;\n\t\tswitch (level.assignment_type) {\n\t\t\tcase 0:\n\t\t\t\tlevel.grouping_type = stream.readString(4);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlevel.grouping_type = stream.readString(4);\n\t\t\t\tlevel.grouping_type_parameter = stream.readUint32();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tlevel.sub_track_id = stream.readUint32();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLog.warn(\"BoxParser\", \"Unknown leva assignement type\");\n\t\t}\n\t}\n});\n\n// file:src/parsing/lhvC.js\nBoxParser.createBoxCtor(\"lhvC\", function(stream) {\n\tvar i, j;\n\tvar tmp_byte;\n\tthis.configurationVersion = stream.readUint8();\n\tthis.min_spatial_segmentation_idc = stream.readUint16() & 0xFFF;\n\tthis.parallelismType = (stream.readUint8() & 0x3);\n\ttmp_byte = stream.readUint8();\n\tthis.numTemporalLayers = (tmp_byte & 0XD) >> 3;\n\tthis.temporalIdNested = (tmp_byte & 0X4) >> 2;\n\tthis.lengthSizeMinusOne = (tmp_byte & 0X3);\n\n\tthis.nalu_arrays = [];\n\tvar numOfArrays = stream.readUint8();\n\tfor (i = 0; i < numOfArrays; i++) {\n\t\tvar nalu_array = [];\n\t\tthis.nalu_arrays.push(nalu_array);\n\t\ttmp_byte = stream.readUint8()\n\t\tnalu_array.completeness = (tmp_byte & 0x80) >> 7;\n\t\tnalu_array.nalu_type = tmp_byte & 0x3F;\n\t\tvar numNalus = stream.readUint16();\n\t\tfor (j = 0; j < numNalus; j++) {\n\t\t\tvar nalu = {}\n\t\t\tnalu_array.push(nalu);\n\t\t\tvar length = stream.readUint16();\n\t\t\tnalu.data  = stream.readUint8Array(length);\n\t\t}\n\t}\n});\n\n// file:src/parsing/lsel.js\nBoxParser.createBoxCtor(\"lsel\", function(stream) {\n\tthis.layer_id = stream.readUint16();\n});// file:src/parsing/maxr.js\nBoxParser.createBoxCtor(\"maxr\", function(stream) {\n\tthis.period = stream.readUint32();\n\tthis.bytes = stream.readUint32();\n});\n\n// file:src/parsing/mdcv.js\nfunction ColorPoint(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nColorPoint.prototype.toString = function() {\n    return \"(\"+this.x+\",\"+this.y+\")\";\n}\n\nBoxParser.createBoxCtor(\"mdcv\", function(stream) {\n    this.display_primaries = [];\n    this.display_primaries[0] = new ColorPoint(stream.readUint16(),stream.readUint16());\n    this.display_primaries[1] = new ColorPoint(stream.readUint16(),stream.readUint16());\n    this.display_primaries[2] = new ColorPoint(stream.readUint16(),stream.readUint16());\n    this.white_point = new ColorPoint(stream.readUint16(),stream.readUint16());\n    this.max_display_mastering_luminance = stream.readUint32();\n    this.min_display_mastering_luminance = stream.readUint32();\n});\n\n// file:src/parsing/mdhd.js\nBoxParser.createFullBoxCtor(\"mdhd\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.creation_time = stream.readUint64();\n\t\tthis.modification_time = stream.readUint64();\n\t\tthis.timescale = stream.readUint32();\n\t\tthis.duration = stream.readUint64();\n\t} else {\n\t\tthis.creation_time = stream.readUint32();\n\t\tthis.modification_time = stream.readUint32();\n\t\tthis.timescale = stream.readUint32();\n\t\tthis.duration = stream.readUint32();\n\t}\n\tthis.parseLanguage(stream);\n\tstream.readUint16();\n});\n\n// file:src/parsing/mehd.js\nBoxParser.createFullBoxCtor(\"mehd\", function(stream) {\n\tif (this.flags & 0x1) {\n\t\tLog.warn(\"BoxParser\", \"mehd box incorrectly uses flags set to 1, converting version to 1\");\n\t\tthis.version = 1;\n\t}\n\tif (this.version == 1) {\n\t\tthis.fragment_duration = stream.readUint64();\n\t} else {\n\t\tthis.fragment_duration = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/meta.js\nBoxParser.createFullBoxCtor(\"meta\", function(stream) {\n\tthis.boxes = [];\n\tBoxParser.ContainerBox.prototype.parse.call(this, stream);\n});\n// file:src/parsing/mfhd.js\nBoxParser.createFullBoxCtor(\"mfhd\", function(stream) {\n\tthis.sequence_number = stream.readUint32();\n});\n\n// file:src/parsing/mfro.js\nBoxParser.createFullBoxCtor(\"mfro\", function(stream) {\n\tthis._size = stream.readUint32();\n});\n\n// file:src/parsing/mskC.js\nBoxParser.createFullBoxCtor(\"mskC\", function(stream) {\n    this.bits_per_pixel = stream.readUint8();\n});\n\n// file:src/parsing/mvhd.js\nBoxParser.createFullBoxCtor(\"mvhd\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.creation_time = stream.readUint64();\n\t\tthis.modification_time = stream.readUint64();\n\t\tthis.timescale = stream.readUint32();\n\t\tthis.duration = stream.readUint64();\n\t} else {\n\t\tthis.creation_time = stream.readUint32();\n\t\tthis.modification_time = stream.readUint32();\n\t\tthis.timescale = stream.readUint32();\n\t\tthis.duration = stream.readUint32();\n\t}\n\tthis.rate = stream.readUint32();\n\tthis.volume = stream.readUint16()>>8;\n\tstream.readUint16();\n\tstream.readUint32Array(2);\n\tthis.matrix = stream.readUint32Array(9);\n\tstream.readUint32Array(6);\n\tthis.next_track_id = stream.readUint32();\n});\n// file:src/parsing/npck.js\nBoxParser.createBoxCtor(\"npck\", function(stream) {\n\tthis.packetssent = stream.readUint32();\n});\n\n// file:src/parsing/nump.js\nBoxParser.createBoxCtor(\"nump\", function(stream) {\n\tthis.packetssent = stream.readUint64();\n});\n\n// file:src/parsing/padb.js\nBoxParser.createFullBoxCtor(\"padb\", function(stream) {\n\tvar sample_count = stream.readUint32();\n\tthis.padbits = [];\n\tfor (var i = 0; i < Math.floor((sample_count+1)/2); i++) {\n\t\tthis.padbits = stream.readUint8();\n\t}\n});\n\n// file:src/parsing/pasp.js\nBoxParser.createBoxCtor(\"pasp\", function(stream) {\n\tthis.hSpacing = stream.readUint32();\n\tthis.vSpacing = stream.readUint32();\n});// file:src/parsing/payl.js\nBoxParser.createBoxCtor(\"payl\", function(stream) {\n\tthis.text = stream.readString(this.size - this.hdr_size);\n});\n\n// file:src/parsing/payt.js\nBoxParser.createBoxCtor(\"payt\", function(stream) {\n\tthis.payloadID = stream.readUint32();\n\tvar count = stream.readUint8();\n\tthis.rtpmap_string = stream.readString(count);\n});\n\n// file:src/parsing/pdin.js\nBoxParser.createFullBoxCtor(\"pdin\", function(stream) {\n\tvar count = (this.size - this.hdr_size)/8;\n\tthis.rate = [];\n\tthis.initial_delay = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.rate[i] = stream.readUint32();\n\t\tthis.initial_delay[i] = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/pitm.js\nBoxParser.createFullBoxCtor(\"pitm\", function(stream) {\n\tif (this.version === 0) {\n\t\tthis.item_id = stream.readUint16();\n\t} else {\n\t\tthis.item_id = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/pixi.js\nBoxParser.createFullBoxCtor(\"pixi\", function(stream) {\n\tvar i;\n\tthis.num_channels = stream.readUint8();\n\tthis.bits_per_channels = [];\n\tfor (i = 0; i < this.num_channels; i++) {\n\t\tthis.bits_per_channels[i] = stream.readUint8();\n\t}\n});\n\n// file:src/parsing/pmax.js\nBoxParser.createBoxCtor(\"pmax\", function(stream) {\n\tthis.bytes = stream.readUint32();\n});\n\n// file:src/parsing/prdi.js\nBoxParser.createFullBoxCtor(\"prdi\", function(stream) {\n\tthis.step_count = stream.readUint16();\n\tthis.item_count = [];\n\tif (this.flags & 0x2) {\n\t\tfor (var i = 0; i < this.step_count; i++) {\n\t\t\tthis.item_count[i] = stream.readUint16();\n\t\t}\n\t}\n});// file:src/parsing/prft.js\nBoxParser.createFullBoxCtor(\"prft\", function(stream) {\n\tthis.ref_track_id = stream.readUint32();\n\tthis.ntp_timestamp = stream.readUint64();\n\tif (this.version === 0) {\n\t\tthis.media_time = stream.readUint32();\n\t} else {\n\t\tthis.media_time = stream.readUint64();\n\t}\n});\n\n// file:src/parsing/pssh.js\nBoxParser.createFullBoxCtor(\"pssh\", function(stream) {\n\tthis.system_id = BoxParser.parseHex16(stream);\n\tif (this.version > 0) {\n\t\tvar count = stream.readUint32();\n\t\tthis.kid = [];\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tthis.kid[i] = BoxParser.parseHex16(stream);\n\t\t}\n\t}\n\tvar datasize = stream.readUint32();\n\tif (datasize > 0) {\n\t\tthis.data = stream.readUint8Array(datasize);\n\t}\n});\n\n// file:src/parsing/qt/clef.js\nBoxParser.createFullBoxCtor(\"clef\", function(stream) {\n\tthis.width = stream.readUint32();\n\tthis.height = stream.readUint32();\n});// file:src/parsing/qt/enof.js\nBoxParser.createFullBoxCtor(\"enof\", function(stream) {\n\tthis.width = stream.readUint32();\n\tthis.height = stream.readUint32();\n});// file:src/parsing/qt/prof.js\nBoxParser.createFullBoxCtor(\"prof\", function(stream) {\n\tthis.width = stream.readUint32();\n\tthis.height = stream.readUint32();\n});// file:src/parsing/qt/tapt.js\nBoxParser.createContainerBoxCtor(\"tapt\", null, [ \"clef\", \"prof\", \"enof\"]);// file:src/parsing/rtp.js\nBoxParser.createBoxCtor(\"rtp \", function(stream) {\n\tthis.descriptionformat = stream.readString(4);\n\tthis.sdptext = stream.readString(this.size - this.hdr_size - 4);\n});\n\n// file:src/parsing/saio.js\nBoxParser.createFullBoxCtor(\"saio\", function(stream) {\n\tif (this.flags & 0x1) {\n\t\tthis.aux_info_type = stream.readUint32();\n\t\tthis.aux_info_type_parameter = stream.readUint32();\n\t}\n\tvar count = stream.readUint32();\n\tthis.offset = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tif (this.version === 0) {\n\t\t\tthis.offset[i] = stream.readUint32();\n\t\t} else {\n\t\t\tthis.offset[i] = stream.readUint64();\n\t\t}\n\t}\n});\n// file:src/parsing/saiz.js\nBoxParser.createFullBoxCtor(\"saiz\", function(stream) {\n\tif (this.flags & 0x1) {\n\t\tthis.aux_info_type = stream.readUint32();\n\t\tthis.aux_info_type_parameter = stream.readUint32();\n\t}\n\tthis.default_sample_info_size = stream.readUint8();\n\tvar count = stream.readUint32();\n\tthis.sample_info_size = [];\n\tif (this.default_sample_info_size === 0) {\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tthis.sample_info_size[i] = stream.readUint8();\n\t\t}\n\t}\n});\n\n// file:src/parsing/sampleentries/mett.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"mett\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.content_encoding = stream.readCString();\n\tthis.mime_format = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/metx.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"metx\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.content_encoding = stream.readCString();\n\tthis.namespace = stream.readCString();\n\tthis.schema_location = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/sbtt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"sbtt\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.content_encoding = stream.readCString();\n\tthis.mime_format = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/stpp.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stpp\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.namespace = stream.readCString();\n\tthis.schema_location = stream.readCString();\n\tthis.auxiliary_mime_types = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/stxt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stxt\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.content_encoding = stream.readCString();\n\tthis.mime_format = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/tx3g.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"tx3g\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.displayFlags = stream.readUint32();\n\tthis.horizontal_justification = stream.readInt8();\n\tthis.vertical_justification = stream.readInt8();\n\tthis.bg_color_rgba = stream.readUint8Array(4);\n\tthis.box_record = stream.readInt16Array(4);\n\tthis.style_record = stream.readUint8Array(12);\n\tthis.parseFooter(stream);\n});\n// file:src/parsing/sampleentries/wvtt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"wvtt\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/samplegroups/alst.js\nBoxParser.createSampleGroupCtor(\"alst\", function(stream) {\n\tvar i;\n\tvar roll_count = stream.readUint16();\n\tthis.first_output_sample = stream.readUint16();\n\tthis.sample_offset = [];\n\tfor (i = 0; i < roll_count; i++) {\n\t\tthis.sample_offset[i] = stream.readUint32();\n\t}\n\tvar remaining = this.description_length - 4 - 4*roll_count;\n\tthis.num_output_samples = [];\n\tthis.num_total_samples = [];\n\tfor (i = 0; i < remaining/4; i++) {\n\t\tthis.num_output_samples[i] = stream.readUint16();\n\t\tthis.num_total_samples[i] = stream.readUint16();\n\t}\n});\n\n// file:src/parsing/samplegroups/avll.js\nBoxParser.createSampleGroupCtor(\"avll\", function(stream) {\n\tthis.layerNumber = stream.readUint8();\n\tthis.accurateStatisticsFlag = stream.readUint8();\n\tthis.avgBitRate = stream.readUint16();\n\tthis.avgFrameRate = stream.readUint16();\n});\n\n// file:src/parsing/samplegroups/avss.js\nBoxParser.createSampleGroupCtor(\"avss\", function(stream) {\n\tthis.subSequenceIdentifier = stream.readUint16();\n\tthis.layerNumber = stream.readUint8();\n\tvar tmp_byte = stream.readUint8();\n\tthis.durationFlag = tmp_byte >> 7;\n\tthis.avgRateFlag = (tmp_byte >> 6) & 0x1;\n\tif (this.durationFlag) {\n\t\tthis.duration = stream.readUint32();\n\t}\n\tif (this.avgRateFlag) {\n\t\tthis.accurateStatisticsFlag = stream.readUint8();\n\t\tthis.avgBitRate = stream.readUint16();\n\t\tthis.avgFrameRate = stream.readUint16();\n\t}\n\tthis.dependency = [];\n\tvar numReferences = stream.readUint8();\n\tfor (var i = 0; i < numReferences; i++) {\n\t\tvar dependencyInfo = {};\n\t\tthis.dependency.push(dependencyInfo);\n\t\tdependencyInfo.subSeqDirectionFlag = stream.readUint8();\n\t\tdependencyInfo.layerNumber = stream.readUint8();\n\t\tdependencyInfo.subSequenceIdentifier = stream.readUint16();\n\t}\n});\n\n// file:src/parsing/samplegroups/dtrt.js\nBoxParser.createSampleGroupCtor(\"dtrt\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/mvif.js\nBoxParser.createSampleGroupCtor(\"mvif\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/prol.js\nBoxParser.createSampleGroupCtor(\"prol\", function(stream) {\n\tthis.roll_distance = stream.readInt16();\n});\n\n// file:src/parsing/samplegroups/rap.js\nBoxParser.createSampleGroupCtor(\"rap \", function(stream) {\n\tvar tmp_byte = stream.readUint8();\n\tthis.num_leading_samples_known = tmp_byte >> 7;\n\tthis.num_leading_samples = tmp_byte & 0x7F;\n});\n\n// file:src/parsing/samplegroups/rash.js\nBoxParser.createSampleGroupCtor(\"rash\", function(stream) {\n\tthis.operation_point_count = stream.readUint16();\n\tif (this.description_length !== 2+(this.operation_point_count === 1?2:this.operation_point_count*6)+9) {\n\t\tLog.warn(\"BoxParser\", \"Mismatch in \"+this.grouping_type+\" sample group length\");\n\t\tthis.data =  stream.readUint8Array(this.description_length-2);\n\t} else {\n\t\tif (this.operation_point_count === 1) {\n\t\t\tthis.target_rate_share = stream.readUint16();\n\t\t} else {\n\t\t\tthis.target_rate_share = [];\n\t\t\tthis.available_bitrate = [];\n\t\t\tfor (var i = 0; i < this.operation_point_count; i++) {\n\t\t\t\tthis.available_bitrate[i] = stream.readUint32();\n\t\t\t\tthis.target_rate_share[i] = stream.readUint16();\n\t\t\t}\n\t\t}\n\t\tthis.maximum_bitrate = stream.readUint32();\n\t\tthis.minimum_bitrate = stream.readUint32();\n\t\tthis.discard_priority = stream.readUint8();\n\t}\n});\n\n// file:src/parsing/samplegroups/roll.js\nBoxParser.createSampleGroupCtor(\"roll\", function(stream) {\n\tthis.roll_distance = stream.readInt16();\n});\n\n// file:src/parsing/samplegroups/samplegroup.js\nBoxParser.SampleGroupEntry.prototype.parse = function(stream) {\n\tLog.warn(\"BoxParser\", \"Unknown Sample Group type: \"+this.grouping_type);\n\tthis.data =  stream.readUint8Array(this.description_length);\n}\n\n// file:src/parsing/samplegroups/scif.js\nBoxParser.createSampleGroupCtor(\"scif\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/scnm.js\nBoxParser.createSampleGroupCtor(\"scnm\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/seig.js\nBoxParser.createSampleGroupCtor(\"seig\", function(stream) {\n\tthis.reserved = stream.readUint8();\n\tvar tmp = stream.readUint8();\n\tthis.crypt_byte_block = tmp >> 4;\n\tthis.skip_byte_block = tmp & 0xF;\n\tthis.isProtected = stream.readUint8();\n\tthis.Per_Sample_IV_Size = stream.readUint8();\n\tthis.KID = BoxParser.parseHex16(stream);\n\tthis.constant_IV_size = 0;\n\tthis.constant_IV = 0;\n\tif (this.isProtected === 1 && this.Per_Sample_IV_Size === 0) {\n\t\tthis.constant_IV_size = stream.readUint8();\n\t\tthis.constant_IV = stream.readUint8Array(this.constant_IV_size);\n\t}\n});\n\n// file:src/parsing/samplegroups/stsa.js\nBoxParser.createSampleGroupCtor(\"stsa\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/sync.js\nBoxParser.createSampleGroupCtor(\"sync\", function(stream) {\n\tvar tmp_byte = stream.readUint8();\n\tthis.NAL_unit_type = tmp_byte & 0x3F;\n});\n\n// file:src/parsing/samplegroups/tele.js\nBoxParser.createSampleGroupCtor(\"tele\", function(stream) {\n\tvar tmp_byte = stream.readUint8();\n\tthis.level_independently_decodable = tmp_byte >> 7;\n});\n\n// file:src/parsing/samplegroups/tsas.js\nBoxParser.createSampleGroupCtor(\"tsas\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/tscl.js\nBoxParser.createSampleGroupCtor(\"tscl\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/vipr.js\nBoxParser.createSampleGroupCtor(\"vipr\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/sbgp.js\nBoxParser.createFullBoxCtor(\"sbgp\", function(stream) {\n\tthis.grouping_type = stream.readString(4);\n\tif (this.version === 1) {\n\t\tthis.grouping_type_parameter = stream.readUint32();\n\t} else {\n\t\tthis.grouping_type_parameter = 0;\n\t}\n\tthis.entries = [];\n\tvar entry_count = stream.readUint32();\n\tfor (var i = 0; i < entry_count; i++) {\n\t\tvar entry = {};\n\t\tthis.entries.push(entry);\n\t\tentry.sample_count = stream.readInt32();\n\t\tentry.group_description_index = stream.readInt32();\n\t}\n});\n\n// file:src/parsing/sbpm.js\nfunction Pixel(row, col) {\n\tthis.bad_pixel_row = row;\n\tthis.bad_pixel_column = col;\n}\n\nPixel.prototype.toString = function pixelToString() {\n\treturn \"[row: \" + this.bad_pixel_row + \", column: \" + this.bad_pixel_column + \"]\";\n}\n\nBoxParser.createFullBoxCtor(\"sbpm\", function(stream) {\n\tvar i;\n\tthis.component_count = stream.readUint16();\n    this.component_index = [];\n    for (i = 0; i < this.component_count; i++) {\n        this.component_index.push(stream.readUint16());\n    }\n\tvar flags = stream.readUint8();\n\tthis.correction_applied = (0x80 == (flags & 0x80));\n\tthis.num_bad_rows = stream.readUint32();\n\tthis.num_bad_cols = stream.readUint32();\n\tthis.num_bad_pixels = stream.readUint32();\n\tthis.bad_rows = [];\n\tthis.bad_columns = [];\n\tthis.bad_pixels = [];\n\tfor (i = 0; i < this.num_bad_rows; i++) {\n\t\tthis.bad_rows.push(stream.readUint32());\n\t}\n\tfor (i = 0; i < this.num_bad_cols; i++) {\n\t\tthis.bad_columns.push(stream.readUint32());\n\t}\n\tfor (i = 0; i < this.num_bad_pixels; i++) {\n\t\tvar row = stream.readUint32();\n\t\tvar col = stream.readUint32();\n\t\tthis.bad_pixels.push(new Pixel(row, col));\n\t}\n});\n\n// file:src/parsing/schm.js\nBoxParser.createFullBoxCtor(\"schm\", function(stream) {\n\tthis.scheme_type = stream.readString(4);\n\tthis.scheme_version = stream.readUint32();\n\tif (this.flags & 0x000001) {\n\t\tthis.scheme_uri = stream.readString(this.size - this.hdr_size - 8);\n\t}\n});\n\n// file:src/parsing/sdp.js\nBoxParser.createBoxCtor(\"sdp \", function(stream) {\n\tthis.sdptext = stream.readString(this.size - this.hdr_size);\n});\n\n// file:src/parsing/sdtp.js\nBoxParser.createFullBoxCtor(\"sdtp\", function(stream) {\n\tvar tmp_byte;\n\tvar count = (this.size - this.hdr_size);\n\tthis.is_leading = [];\n\tthis.sample_depends_on = [];\n\tthis.sample_is_depended_on = [];\n\tthis.sample_has_redundancy = [];\n\tfor (var i = 0; i < count; i++) {\n\t\ttmp_byte = stream.readUint8();\n\t\tthis.is_leading[i] = tmp_byte >> 6;\n\t\tthis.sample_depends_on[i] = (tmp_byte >> 4) & 0x3;\n\t\tthis.sample_is_depended_on[i] = (tmp_byte >> 2) & 0x3;\n\t\tthis.sample_has_redundancy[i] = tmp_byte & 0x3;\n\t}\n});\n\n// file:src/parsing/senc.js\n// Cannot be fully parsed because Per_Sample_IV_Size needs to be known\r\nBoxParser.createFullBoxCtor(\"senc\" /*, function(stream) {\r\n\tthis.parseFullHeader(stream);\r\n\tvar sample_count = stream.readUint32();\r\n\tthis.samples = [];\r\n\tfor (var i = 0; i < sample_count; i++) {\r\n\t\tvar sample = {};\r\n\t\t// tenc.default_Per_Sample_IV_Size or seig.Per_Sample_IV_Size\r\n\t\tsample.InitializationVector = this.readUint8Array(Per_Sample_IV_Size*8);\r\n\t\tif (this.flags & 0x2) {\r\n\t\t\tsample.subsamples = [];\r\n\t\t\tsubsample_count = stream.readUint16();\r\n\t\t\tfor (var j = 0; j < subsample_count; j++) {\r\n\t\t\t\tvar subsample = {};\r\n\t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\r\n\t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\r\n\t\t\t\tsample.subsamples.push(subsample);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// TODO\r\n\t\tthis.samples.push(sample);\r\n\t}\r\n}*/);\r\n// file:src/parsing/sgpd.js\nBoxParser.createFullBoxCtor(\"sgpd\", function(stream) {\n\tthis.grouping_type = stream.readString(4);\n\tLog.debug(\"BoxParser\", \"Found Sample Groups of type \"+this.grouping_type);\n\tif (this.version === 1) {\n\t\tthis.default_length = stream.readUint32();\n\t} else {\n\t\tthis.default_length = 0;\n\t}\n\tif (this.version >= 2) {\n\t\tthis.default_group_description_index = stream.readUint32();\n\t}\n\tthis.entries = [];\n\tvar entry_count = stream.readUint32();\n\tfor (var i = 0; i < entry_count; i++) {\n\t\tvar entry;\n\t\tif (BoxParser[this.grouping_type+\"SampleGroupEntry\"]) {\n\t\t\tentry = new BoxParser[this.grouping_type+\"SampleGroupEntry\"](this.grouping_type);\n\t\t}  else {\n\t\t\tentry = new BoxParser.SampleGroupEntry(this.grouping_type);\n\t\t}\n\t\tthis.entries.push(entry);\n\t\tif (this.version === 1) {\n\t\t\tif (this.default_length === 0) {\n\t\t\t\tentry.description_length = stream.readUint32();\n\t\t\t} else {\n\t\t\t\tentry.description_length = this.default_length;\n\t\t\t}\n\t\t} else {\n\t\t\tentry.description_length = this.default_length;\n\t\t}\n\t\tif (entry.write === BoxParser.SampleGroupEntry.prototype.write) {\n\t\t\tLog.info(\"BoxParser\", \"SampleGroup for type \"+this.grouping_type+\" writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\t\t// storing data\n\t\t\tentry.data = stream.readUint8Array(entry.description_length);\n\t\t\t// rewinding\n\t\t\tstream.position -= entry.description_length;\n\t\t}\n\t\tentry.parse(stream);\n\t}\n});\n\n// file:src/parsing/sidx.js\nBoxParser.createFullBoxCtor(\"sidx\", function(stream) {\n\tthis.reference_ID = stream.readUint32();\n\tthis.timescale = stream.readUint32();\n\tif (this.version === 0) {\n\t\tthis.earliest_presentation_time = stream.readUint32();\n\t\tthis.first_offset = stream.readUint32();\n\t} else {\n\t\tthis.earliest_presentation_time = stream.readUint64();\n\t\tthis.first_offset = stream.readUint64();\n\t}\n\tstream.readUint16();\n\tthis.references = [];\n\tvar count = stream.readUint16();\n\tfor (var i = 0; i < count; i++) {\n\t\tvar ref = {};\n\t\tthis.references.push(ref);\n\t\tvar tmp_32 = stream.readUint32();\n\t\tref.reference_type = (tmp_32 >> 31) & 0x1;\n\t\tref.referenced_size = tmp_32 & 0x7FFFFFFF;\n\t\tref.subsegment_duration = stream.readUint32();\n\t\ttmp_32 = stream.readUint32();\n\t\tref.starts_with_SAP = (tmp_32 >> 31) & 0x1;\n\t\tref.SAP_type = (tmp_32 >> 28) & 0x7;\n\t\tref.SAP_delta_time = tmp_32 & 0xFFFFFFF;\n\t}\n});\n\n// file:src/parsing/singleitemtypereference.js\nBoxParser.SingleItemTypeReferenceBox = function(type, size, hdr_size, start) {\n\tBoxParser.Box.call(this, type, size);\n\tthis.hdr_size = hdr_size;\n\tthis.start = start;\n}\nBoxParser.SingleItemTypeReferenceBox.prototype = new BoxParser.Box();\nBoxParser.SingleItemTypeReferenceBox.prototype.parse = function(stream) {\n\tthis.from_item_ID = stream.readUint16();\n\tvar count =  stream.readUint16();\n\tthis.references = [];\n\tfor(var i = 0; i < count; i++) {\n\t\tthis.references[i] = {};\n\t\tthis.references[i].to_item_ID = stream.readUint16();\n\t}\n}\n\n// file:src/parsing/singleitemtypereferencelarge.js\nBoxParser.SingleItemTypeReferenceBoxLarge = function(type, size, hdr_size, start) {\n\tBoxParser.Box.call(this, type, size);\n\tthis.hdr_size = hdr_size;\n\tthis.start = start;\n}\nBoxParser.SingleItemTypeReferenceBoxLarge.prototype = new BoxParser.Box();\nBoxParser.SingleItemTypeReferenceBoxLarge.prototype.parse = function(stream) {\n\tthis.from_item_ID = stream.readUint32();\n\tvar count =  stream.readUint16();\n\tthis.references = [];\n\tfor(var i = 0; i < count; i++) {\n\t\tthis.references[i] = {};\n\t\tthis.references[i].to_item_ID = stream.readUint32();\n\t}\n}\n\n// file:src/parsing/SmDm.js\nBoxParser.createFullBoxCtor(\"SmDm\", function(stream) {\n\tthis.primaryRChromaticity_x = stream.readUint16();\n    this.primaryRChromaticity_y = stream.readUint16();\n    this.primaryGChromaticity_x = stream.readUint16();\n    this.primaryGChromaticity_y = stream.readUint16();\n    this.primaryBChromaticity_x = stream.readUint16();\n    this.primaryBChromaticity_y = stream.readUint16();\n    this.whitePointChromaticity_x = stream.readUint16();\n    this.whitePointChromaticity_y = stream.readUint16();\n    this.luminanceMax = stream.readUint32();\n    this.luminanceMin = stream.readUint32();\n});\n\n// file:src/parsing/smhd.js\nBoxParser.createFullBoxCtor(\"smhd\", function(stream) {\n\tthis.balance = stream.readUint16();\n\tstream.readUint16();\n});\n\n// file:src/parsing/ssix.js\nBoxParser.createFullBoxCtor(\"ssix\", function(stream) {\n\tthis.subsegments = [];\n\tvar subsegment_count = stream.readUint32();\n\tfor (var i = 0; i < subsegment_count; i++) {\n\t\tvar subsegment = {};\n\t\tthis.subsegments.push(subsegment);\n\t\tsubsegment.ranges = [];\n\t\tvar range_count = stream.readUint32();\n\t\tfor (var j = 0; j < range_count; j++) {\n\t\t\tvar range = {};\n\t\t\tsubsegment.ranges.push(range);\n\t\t\trange.level = stream.readUint8();\n\t\t\trange.range_size = stream.readUint24();\n\t\t}\n\t}\n});\n\n// file:src/parsing/stco.js\nBoxParser.createFullBoxCtor(\"stco\", function(stream) {\n\tvar entry_count;\n\tentry_count = stream.readUint32();\n\tthis.chunk_offsets = [];\n\tif (this.version === 0) {\n\t\tfor (var i = 0; i < entry_count; i++) {\n\t\t\tthis.chunk_offsets.push(stream.readUint32());\n\t\t}\n\t}\n});\n\n// file:src/parsing/stdp.js\nBoxParser.createFullBoxCtor(\"stdp\", function(stream) {\n\tvar count = (this.size - this.hdr_size)/2;\n\tthis.priority = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.priority[i] = stream.readUint16();\n\t}\n});\n\n// file:src/parsing/sthd.js\nBoxParser.createFullBoxCtor(\"sthd\");\n\n// file:src/parsing/stri.js\nBoxParser.createFullBoxCtor(\"stri\", function(stream) {\n\tthis.switch_group = stream.readUint16();\n\tthis.alternate_group = stream.readUint16();\n\tthis.sub_track_id = stream.readUint32();\n\tvar count = (this.size - this.hdr_size - 8)/4;\n\tthis.attribute_list = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.attribute_list[i] = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/stsc.js\nBoxParser.createFullBoxCtor(\"stsc\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tentry_count = stream.readUint32();\n\tthis.first_chunk = [];\n\tthis.samples_per_chunk = [];\n\tthis.sample_description_index = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.first_chunk.push(stream.readUint32());\n\t\t\tthis.samples_per_chunk.push(stream.readUint32());\n\t\t\tthis.sample_description_index.push(stream.readUint32());\n\t\t}\n\t}\n});\n\n// file:src/parsing/stsd.js\nBoxParser.createFullBoxCtor(\"stsd\", function(stream) {\n\tvar i;\n\tvar ret;\n\tvar entryCount;\n\tvar box;\n\tthis.entries = [];\n\tentryCount = stream.readUint32();\n\tfor (i = 1; i <= entryCount; i++) {\n\t\tret = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tif (BoxParser[ret.type+\"SampleEntry\"]) {\n\t\t\t\tbox = new BoxParser[ret.type+\"SampleEntry\"](ret.size);\n\t\t\t\tbox.hdr_size = ret.hdr_size;\n\t\t\t\tbox.start = ret.start;\n\t\t\t} else {\n\t\t\t\tLog.warn(\"BoxParser\", \"Unknown sample entry type: \"+ret.type);\n\t\t\t\tbox = new BoxParser.SampleEntry(ret.type, ret.size, ret.hdr_size, ret.start);\n\t\t\t}\n\t\t\tif (box.write === BoxParser.SampleEntry.prototype.write) {\n\t\t\t\tLog.info(\"BoxParser\", \"SampleEntry \"+box.type+\" box writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\t\t\tbox.parseDataAndRewind(stream);\n\t\t\t}\n\t\t\tbox.parse(stream);\n\t\t\tthis.entries.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/stsg.js\nBoxParser.createFullBoxCtor(\"stsg\", function(stream) {\n\tthis.grouping_type = stream.readUint32();\n\tvar count = stream.readUint16();\n\tthis.group_description_index = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.group_description_index[i] = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/stsh.js\nBoxParser.createFullBoxCtor(\"stsh\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tentry_count = stream.readUint32();\n\tthis.shadowed_sample_numbers = [];\n\tthis.sync_sample_numbers = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.shadowed_sample_numbers.push(stream.readUint32());\n\t\t\tthis.sync_sample_numbers.push(stream.readUint32());\n\t\t}\n\t}\n});\n\n// file:src/parsing/stss.js\nBoxParser.createFullBoxCtor(\"stss\", function(stream) {\n\tvar i;\n\tvar entry_count;\n\tentry_count = stream.readUint32();\n\tif (this.version === 0) {\n\t\tthis.sample_numbers = [];\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.sample_numbers.push(stream.readUint32());\n\t\t}\n\t}\n});\n\n// file:src/parsing/stsz.js\nBoxParser.createFullBoxCtor(\"stsz\", function(stream) {\n\tvar i;\n\tthis.sample_sizes = [];\n\tif (this.version === 0) {\n\t\tthis.sample_size = stream.readUint32();\n\t\tthis.sample_count = stream.readUint32();\n\t\tfor (i = 0; i < this.sample_count; i++) {\n\t\t\tif (this.sample_size === 0) {\n\t\t\t\tthis.sample_sizes.push(stream.readUint32());\n\t\t\t} else {\n\t\t\t\tthis.sample_sizes[i] = this.sample_size;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/stts.js\nBoxParser.createFullBoxCtor(\"stts\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tvar delta;\n\tentry_count = stream.readUint32();\n\tthis.sample_counts = [];\n\tthis.sample_deltas = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.sample_counts.push(stream.readUint32());\n\t\t\tdelta = stream.readInt32();\n\t\t\tif (delta < 0) {\n\t\t\t\tLog.warn(\"BoxParser\", \"File uses negative stts sample delta, using value 1 instead, sync may be lost!\");\n\t\t\t\tdelta = 1;\n\t\t\t}\n\t\t\tthis.sample_deltas.push(delta);\n\t\t}\n\t}\n});\n\n// file:src/parsing/stvi.js\nBoxParser.createFullBoxCtor(\"stvi\", function(stream) {\n\tvar tmp32 = stream.readUint32();\n\tthis.single_view_allowed = tmp32 & 0x3;\n\tthis.stereo_scheme = stream.readUint32();\n\tvar length = stream.readUint32();\n\tthis.stereo_indication_type = stream.readString(length);\n\tvar ret;\n\tvar box;\n\tthis.boxes = [];\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = ret.box;\n\t\t\tthis.boxes.push(box);\n\t\t\tthis[box.type] = box;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/styp.js\nBoxParser.createBoxCtor(\"styp\", function(stream) {\n\tBoxParser.ftypBox.prototype.parse.call(this, stream);\n});\n\n// file:src/parsing/stz2.js\nBoxParser.createFullBoxCtor(\"stz2\", function(stream) {\n\tvar i;\n\tvar sample_size;\n\tvar sample_count;\n\tthis.sample_sizes = [];\n\tif (this.version === 0) {\n\t\tthis.reserved = stream.readUint24();\n\t\tthis.field_size = stream.readUint8();\n\t\tsample_count = stream.readUint32();\n\t\tif (this.field_size === 4) {\n\t\t\tfor (i = 0; i < sample_count; i+=2) {\n\t\t\t\tvar tmp = stream.readUint8();\n\t\t\t\tthis.sample_sizes[i] = (tmp >> 4) & 0xF;\n\t\t\t\tthis.sample_sizes[i+1] = tmp & 0xF;\n\t\t\t}\n\t\t} else if (this.field_size === 8) {\n\t\t\tfor (i = 0; i < sample_count; i++) {\n\t\t\t\tthis.sample_sizes[i] = stream.readUint8();\n\t\t\t}\n\t\t} else if (this.field_size === 16) {\n\t\t\tfor (i = 0; i < sample_count; i++) {\n\t\t\t\tthis.sample_sizes[i] = stream.readUint16();\n\t\t\t}\n\t\t} else {\n\t\t\tLog.error(\"BoxParser\", \"Error in length field in stz2 box\");\n\t\t}\n\t}\n});\n\n// file:src/parsing/subs.js\nBoxParser.createFullBoxCtor(\"subs\", function(stream) {\n\tvar i,j;\n\tvar entry_count;\n\tvar subsample_count;\n\tentry_count = stream.readUint32();\n\tthis.entries = [];\n\tfor (i = 0; i < entry_count; i++) {\n\t\tvar sampleInfo = {};\n\t\tthis.entries[i] = sampleInfo;\n\t\tsampleInfo.sample_delta = stream.readUint32();\n\t\tsampleInfo.subsamples = [];\n\t\tsubsample_count = stream.readUint16();\n\t\tif (subsample_count>0) {\n\t\t\tfor (j = 0; j < subsample_count; j++) {\n\t\t\t\tvar subsample = {};\n\t\t\t\tsampleInfo.subsamples.push(subsample);\n\t\t\t\tif (this.version == 1) {\n\t\t\t\t\tsubsample.size = stream.readUint32();\n\t\t\t\t} else {\n\t\t\t\t\tsubsample.size = stream.readUint16();\n\t\t\t\t}\n\t\t\t\tsubsample.priority = stream.readUint8();\n\t\t\t\tsubsample.discardable = stream.readUint8();\n\t\t\t\tsubsample.codec_specific_parameters = stream.readUint32();\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/tenc.js\nBoxParser.createFullBoxCtor(\"tenc\", function(stream) {\n\tstream.readUint8(); // reserved\n\tif (this.version === 0) {\n\t\tstream.readUint8();\n\t} else {\n\t\tvar tmp = stream.readUint8();\n\t\tthis.default_crypt_byte_block = (tmp >> 4) & 0xF;\n\t\tthis.default_skip_byte_block = tmp & 0xF;\n\t}\n\tthis.default_isProtected = stream.readUint8();\n\tthis.default_Per_Sample_IV_Size = stream.readUint8();\n\tthis.default_KID = BoxParser.parseHex16(stream);\n\tif (this.default_isProtected === 1 && this.default_Per_Sample_IV_Size === 0) {\n\t\tthis.default_constant_IV_size = stream.readUint8();\n\t\tthis.default_constant_IV = stream.readUint8Array(this.default_constant_IV_size);\n\t}\n});// file:src/parsing/tfdt.js\nBoxParser.createFullBoxCtor(\"tfdt\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.baseMediaDecodeTime = stream.readUint64();\n\t} else {\n\t\tthis.baseMediaDecodeTime = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/tfhd.js\nBoxParser.createFullBoxCtor(\"tfhd\", function(stream) {\n\tvar readBytes = 0;\n\tthis.track_id = stream.readUint32();\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET)) {\n\t\tthis.base_data_offset = stream.readUint64();\n\t\treadBytes += 8;\n\t} else {\n\t\tthis.base_data_offset = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC)) {\n\t\tthis.default_sample_description_index = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.default_sample_description_index = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR)) {\n\t\tthis.default_sample_duration = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.default_sample_duration = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE)) {\n\t\tthis.default_sample_size = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.default_sample_size = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS)) {\n\t\tthis.default_sample_flags = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.default_sample_flags = 0;\n\t}\n});\n\n// file:src/parsing/tfra.js\nBoxParser.createFullBoxCtor(\"tfra\", function(stream) {\n\tthis.track_ID = stream.readUint32();\n\tstream.readUint24();\n\tvar tmp_byte = stream.readUint8();\n\tthis.length_size_of_traf_num = (tmp_byte >> 4) & 0x3;\n\tthis.length_size_of_trun_num = (tmp_byte >> 2) & 0x3;\n\tthis.length_size_of_sample_num = (tmp_byte) & 0x3;\n\tthis.entries = [];\n\tvar number_of_entries = stream.readUint32();\n\tfor (var i = 0; i < number_of_entries; i++) {\n\t\tif (this.version === 1) {\n\t\t\tthis.time = stream.readUint64();\n\t\t\tthis.moof_offset = stream.readUint64();\n\t\t} else {\n\t\t\tthis.time = stream.readUint32();\n\t\t\tthis.moof_offset = stream.readUint32();\n\t\t}\n\t\tthis.traf_number = stream[\"readUint\"+(8*(this.length_size_of_traf_num+1))]();\n\t\tthis.trun_number = stream[\"readUint\"+(8*(this.length_size_of_trun_num+1))]();\n\t\tthis.sample_number = stream[\"readUint\"+(8*(this.length_size_of_sample_num+1))]();\n\t}\n});\n\n// file:src/parsing/tkhd.js\nBoxParser.createFullBoxCtor(\"tkhd\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.creation_time = stream.readUint64();\n\t\tthis.modification_time = stream.readUint64();\n\t\tthis.track_id = stream.readUint32();\n\t\tstream.readUint32();\n\t\tthis.duration = stream.readUint64();\n\t} else {\n\t\tthis.creation_time = stream.readUint32();\n\t\tthis.modification_time = stream.readUint32();\n\t\tthis.track_id = stream.readUint32();\n\t\tstream.readUint32();\n\t\tthis.duration = stream.readUint32();\n\t}\n\tstream.readUint32Array(2);\n\tthis.layer = stream.readInt16();\n\tthis.alternate_group = stream.readInt16();\n\tthis.volume = stream.readInt16()>>8;\n\tstream.readUint16();\n\tthis.matrix = stream.readInt32Array(9);\n\tthis.width = stream.readUint32();\n\tthis.height = stream.readUint32();\n});\n\n// file:src/parsing/tmax.js\nBoxParser.createBoxCtor(\"tmax\", function(stream) {\n\tthis.time = stream.readUint32();\n});\n\n// file:src/parsing/tmin.js\nBoxParser.createBoxCtor(\"tmin\", function(stream) {\n\tthis.time = stream.readUint32();\n});\n\n// file:src/parsing/totl.js\nBoxParser.createBoxCtor(\"totl\",function(stream) {\n\tthis.bytessent = stream.readUint32();\n});\n\n// file:src/parsing/tpay.js\nBoxParser.createBoxCtor(\"tpay\", function(stream) {\n\tthis.bytessent = stream.readUint32();\n});\n\n// file:src/parsing/tpyl.js\nBoxParser.createBoxCtor(\"tpyl\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/TrackGroup.js\nBoxParser.TrackGroupTypeBox.prototype.parse = function(stream) {\n\tthis.parseFullHeader(stream);\n\tthis.track_group_id = stream.readUint32();\n}\n\n// file:src/parsing/trackgroups/msrc.js\nBoxParser.createTrackGroupCtor(\"msrc\");// file:src/parsing/TrakReference.js\nBoxParser.TrackReferenceTypeBox = function(type, size, hdr_size, start) {\n\tBoxParser.Box.call(this, type, size);\n\tthis.hdr_size = hdr_size;\n\tthis.start = start;\n}\nBoxParser.TrackReferenceTypeBox.prototype = new BoxParser.Box();\nBoxParser.TrackReferenceTypeBox.prototype.parse = function(stream) {\n\tthis.track_ids = stream.readUint32Array((this.size-this.hdr_size)/4);\n}\n\n// file:src/parsing/tref.js\nBoxParser.trefBox.prototype.parse = function(stream) {\n\tvar ret;\n\tvar box;\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = new BoxParser.TrackReferenceTypeBox(ret.type, ret.size, ret.hdr_size, ret.start);\n\t\t\tif (box.write === BoxParser.Box.prototype.write && box.type !== \"mdat\") {\n\t\t\t\tLog.info(\"BoxParser\", \"TrackReference \"+box.type+\" box writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\t\t\tbox.parseDataAndRewind(stream);\n\t\t\t}\n\t\t\tbox.parse(stream);\n\t\t\tthis.boxes.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n// file:src/parsing/trep.js\nBoxParser.createFullBoxCtor(\"trep\", function(stream) {\n\tthis.track_ID = stream.readUint32();\n\tthis.boxes = [];\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = ret.box;\n\t\t\tthis.boxes.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/trex.js\nBoxParser.createFullBoxCtor(\"trex\", function(stream) {\n\tthis.track_id = stream.readUint32();\n\tthis.default_sample_description_index = stream.readUint32();\n\tthis.default_sample_duration = stream.readUint32();\n\tthis.default_sample_size = stream.readUint32();\n\tthis.default_sample_flags = stream.readUint32();\n});\n\n// file:src/parsing/trpy.js\nBoxParser.createBoxCtor(\"trpy\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/trun.js\nBoxParser.createFullBoxCtor(\"trun\", function(stream) {\n\tvar readBytes = 0;\n\tthis.sample_count = stream.readUint32();\n\treadBytes+= 4;\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) ) {\n\t\tthis.data_offset = stream.readInt32(); //signed\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.data_offset = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) ) {\n\t\tthis.first_sample_flags = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.first_sample_flags = 0;\n\t}\n\tthis.sample_duration = [];\n\tthis.sample_size = [];\n\tthis.sample_flags = [];\n\tthis.sample_composition_time_offset = [];\n\tif (this.size - this.hdr_size > readBytes) {\n\t\tfor (var i = 0; i < this.sample_count; i++) {\n\t\t\tif (this.flags & BoxParser.TRUN_FLAGS_DURATION) {\n\t\t\t\tthis.sample_duration[i] = stream.readUint32();\n\t\t\t}\n\t\t\tif (this.flags & BoxParser.TRUN_FLAGS_SIZE) {\n\t\t\t\tthis.sample_size[i] = stream.readUint32();\n\t\t\t}\n\t\t\tif (this.flags & BoxParser.TRUN_FLAGS_FLAGS) {\n\t\t\t\tthis.sample_flags[i] = stream.readUint32();\n\t\t\t}\n\t\t\tif (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n\t\t\t\tif (this.version === 0) {\n\t\t\t\t\tthis.sample_composition_time_offset[i] = stream.readUint32();\n\t\t\t\t} else {\n\t\t\t\t\tthis.sample_composition_time_offset[i] = stream.readInt32(); //signed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/tsel.js\nBoxParser.createFullBoxCtor(\"tsel\", function(stream) {\n\tthis.switch_group = stream.readUint32();\n\tvar count = (this.size - this.hdr_size - 4)/4;\n\tthis.attribute_list = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.attribute_list[i] = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/txtC.js\nBoxParser.createFullBoxCtor(\"txtC\", function(stream) {\n\tthis.config = stream.readCString();\n});\n\n// file:src/parsing/tyco.js\nBoxParser.createBoxCtor(\"tyco\", function(stream) {\n\tvar count = (this.size - this.hdr_size) / 4;\n\tthis.compatible_brands = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.compatible_brands[i] = stream.readString(4);\n\t}\n});\n\n// file:src/parsing/udes.js\nBoxParser.createFullBoxCtor(\"udes\", function(stream) {\n\tthis.lang = stream.readCString();\n\tthis.name = stream.readCString();\n\tthis.description = stream.readCString();\n\tthis.tags = stream.readCString();\n});\n\n// file:src/parsing/uncC.js\nBoxParser.createFullBoxCtor(\"uncC\", function(stream) {\n    var i;\n    this.profile = stream.readUint32();\n    if (this.version == 1) {\n        // Nothing - just the profile\n    } else if (this.version == 0) {\n        this.component_count = stream.readUint32();\n        this.component_index = [];\n        this.component_bit_depth_minus_one = [];\n        this.component_format = [];\n        this.component_align_size = [];\n        for (i = 0; i < this.component_count; i++) {\n            this.component_index.push(stream.readUint16());\n            this.component_bit_depth_minus_one.push(stream.readUint8());\n            this.component_format.push(stream.readUint8());\n            this.component_align_size.push(stream.readUint8());\n        }\n        this.sampling_type = stream.readUint8();\n        this.interleave_type = stream.readUint8();\n        this.block_size = stream.readUint8();\n        var flags = stream.readUint8();\n        this.component_little_endian = (flags >> 7) & 0x1;\n        this.block_pad_lsb = (flags >> 6) & 0x1;\n        this.block_little_endian = (flags >> 5) & 0x1;\n        this.block_reversed = (flags >> 4) & 0x1;\n        this.pad_unknown = (flags >> 3) & 0x1;\n        this.pixel_size = stream.readUint32();\n        this.row_align_size = stream.readUint32();\n        this.tile_align_size = stream.readUint32();\n        this.num_tile_cols_minus_one = stream.readUint32();\n        this.num_tile_rows_minus_one = stream.readUint32();\n    }\n});\n\n// file:src/parsing/url.js\nBoxParser.createFullBoxCtor(\"url \", function(stream) {\n\tif (this.flags !== 0x000001) {\n\t\tthis.location = stream.readCString();\n\t}\n});\n\n// file:src/parsing/urn.js\nBoxParser.createFullBoxCtor(\"urn \", function(stream) {\n\tthis.name = stream.readCString();\n\tif (this.size - this.hdr_size - this.name.length - 1 > 0) {\n\t\tthis.location = stream.readCString();\n\t}\n});\n\n// file:src/parsing/uuid/piff/piffLsm.js\nBoxParser.createUUIDBox(\"a5d40b30e81411ddba2f0800200c9a66\", true, false, function(stream) {\n    this.LiveServerManifest = stream.readString(this.size - this.hdr_size)\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n});// file:src/parsing/uuid/piff/piffPssh.js\nBoxParser.createUUIDBox(\"d08a4f1810f34a82b6c832d8aba183d3\", true, false, function(stream) {\n\tthis.system_id = BoxParser.parseHex16(stream);\n\tvar datasize = stream.readUint32();\n\tif (datasize > 0) {\n\t\tthis.data = stream.readUint8Array(datasize);\n\t}\n});\n\n// file:src/parsing/uuid/piff/piffSenc.js\nBoxParser.createUUIDBox(\"a2394f525a9b4f14a2446c427c648df4\", true, false /*, function(stream) {\n\tif (this.flags & 0x1) {\n\t\tthis.AlgorithmID = stream.readUint24();\n\t\tthis.IV_size = stream.readUint8();\n\t\tthis.KID = BoxParser.parseHex16(stream);\n\t}\n\tvar sample_count = stream.readUint32();\n\tthis.samples = [];\n\tfor (var i = 0; i < sample_count; i++) {\n\t\tvar sample = {};\n\t\tsample.InitializationVector = this.readUint8Array(this.IV_size*8);\n\t\tif (this.flags & 0x2) {\n\t\t\tsample.subsamples = [];\n\t\t\tsample.NumberOfEntries = stream.readUint16();\n\t\t\tfor (var j = 0; j < sample.NumberOfEntries; j++) {\n\t\t\t\tvar subsample = {};\n\t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\n\t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\n\t\t\t\tsample.subsamples.push(subsample);\n\t\t\t}\n\t\t}\n\t\tthis.samples.push(sample);\n\t}\n}*/);\n// file:src/parsing/uuid/piff/piffTenc.js\nBoxParser.createUUIDBox(\"8974dbce7be74c5184f97148f9882554\", true, false, function(stream) {\n\tthis.default_AlgorithmID = stream.readUint24();\n\tthis.default_IV_size = stream.readUint8();\n\tthis.default_KID = BoxParser.parseHex16(stream);\n});// file:src/parsing/uuid/piff/piffTfrf.js\nBoxParser.createUUIDBox(\"d4807ef2ca3946958e5426cb9e46a79f\", true, false, function(stream) {\n    this.fragment_count = stream.readUint8();\n    this.entries = [];\n\n    for (var i = 0; i < this.fragment_count; i++) {\n        var entry = {};\n        var absolute_time = 0;\n        var absolute_duration = 0;\n\n        if (this.version === 1) {\n            absolute_time = stream.readUint64();\n            absolute_duration = stream.readUint64();\n        } else {\n            absolute_time = stream.readUint32();\n            absolute_duration = stream.readUint32();\n        }\n\n        entry.absolute_time = absolute_time;\n        entry.absolute_duration = absolute_duration;\n\n        this.entries.push(entry);\n    }\n});// file:src/parsing/uuid/piff/piffTfxd.js\nBoxParser.createUUIDBox(\"6d1d9b0542d544e680e2141daff757b2\", true, false, function(stream) {\n    if (this.version === 1) {\n       this.absolute_time = stream.readUint64();\n       this.duration = stream.readUint64();\n    } else {\n       this.absolute_time = stream.readUint32();\n       this.duration = stream.readUint32();\n    }\n});// file:src/parsing/vmhd.js\nBoxParser.createFullBoxCtor(\"vmhd\", function(stream) {\n\tthis.graphicsmode = stream.readUint16();\n\tthis.opcolor = stream.readUint16Array(3);\n});\n\n// file:src/parsing/vpcC.js\nBoxParser.createFullBoxCtor(\"vpcC\", function (stream) {\n\tvar tmp;\n\tif (this.version === 1) {\n\t\tthis.profile = stream.readUint8();\n\t\tthis.level = stream.readUint8();\n\t\ttmp = stream.readUint8();\n\t\tthis.bitDepth = tmp >> 4;\n\t\tthis.chromaSubsampling = (tmp >> 1) & 0x7;\n\t\tthis.videoFullRangeFlag = tmp & 0x1;\n\t\tthis.colourPrimaries = stream.readUint8();\n\t\tthis.transferCharacteristics = stream.readUint8();\n\t\tthis.matrixCoefficients = stream.readUint8();\n\t\tthis.codecIntializationDataSize = stream.readUint16();\n\t\tthis.codecIntializationData = stream.readUint8Array(this.codecIntializationDataSize);\n\t} else {\n\t\tthis.profile = stream.readUint8();\n\t\tthis.level = stream.readUint8();\n\t\ttmp = stream.readUint8();\n\t\tthis.bitDepth = (tmp >> 4) & 0xF;\n\t\tthis.colorSpace = tmp & 0xF;\n\t\ttmp = stream.readUint8();\n\t\tthis.chromaSubsampling = (tmp >> 4) & 0xF;\n\t\tthis.transferFunction = (tmp >> 1) & 0x7;\n\t\tthis.videoFullRangeFlag = tmp & 0x1;\n\t\tthis.codecIntializationDataSize = stream.readUint16();\n\t\tthis.codecIntializationData = stream.readUint8Array(this.codecIntializationDataSize);\n\t}\n});// file:src/parsing/vttC.js\nBoxParser.createBoxCtor(\"vttC\", function(stream) {\n\tthis.text = stream.readString(this.size - this.hdr_size);\n});\n\n// file:src/parsing/vvcC.js\nBoxParser.createFullBoxCtor(\"vvcC\", function (stream) {\n  var i, j;\n\n  // helper object to simplify extracting individual bits\n  var bitReader = {\n    held_bits: undefined,\n    num_held_bits: 0,\n\n    stream_read_1_bytes: function (strm) {\n      this.held_bits = strm.readUint8();\n      this.num_held_bits = 1 * 8;\n    },\n    stream_read_2_bytes: function (strm) {\n      this.held_bits = strm.readUint16();\n      this.num_held_bits = 2 * 8;\n    },\n\n    extract_bits: function (num_bits) {\n      var ret = (this.held_bits >> (this.num_held_bits - num_bits)) & ((1 << num_bits) - 1);\n      this.num_held_bits -= num_bits;\n      return ret;\n    }\n  };\n\n  // VvcDecoderConfigurationRecord\n  bitReader.stream_read_1_bytes(stream);\n  bitReader.extract_bits(5);  // reserved\n  this.lengthSizeMinusOne = bitReader.extract_bits(2);\n  this.ptl_present_flag = bitReader.extract_bits(1);\n\n  if (this.ptl_present_flag) {\n    bitReader.stream_read_2_bytes(stream);\n    this.ols_idx = bitReader.extract_bits(9);\n    this.num_sublayers = bitReader.extract_bits(3);\n    this.constant_frame_rate = bitReader.extract_bits(2);\n    this.chroma_format_idc = bitReader.extract_bits(2);\n\n    bitReader.stream_read_1_bytes(stream);\n    this.bit_depth_minus8 = bitReader.extract_bits(3);\n    bitReader.extract_bits(5);  // reserved\n\n    // VvcPTLRecord\n    {\n      bitReader.stream_read_2_bytes(stream);\n      bitReader.extract_bits(2);  // reserved\n      this.num_bytes_constraint_info = bitReader.extract_bits(6);\n      this.general_profile_idc = bitReader.extract_bits(7);\n      this.general_tier_flag = bitReader.extract_bits(1);\n\n      this.general_level_idc = stream.readUint8();\n\n      bitReader.stream_read_1_bytes(stream);\n      this.ptl_frame_only_constraint_flag = bitReader.extract_bits(1);\n      this.ptl_multilayer_enabled_flag = bitReader.extract_bits(1);\n\n      this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info);\n      if (this.num_bytes_constraint_info) {\n        for (i = 0; i < this.num_bytes_constraint_info - 1; i++) {\n          var cnstr1 = bitReader.extract_bits(6);\n          bitReader.stream_read_1_bytes(stream);\n          var cnstr2 = bitReader.extract_bits(2);\n\n          this.general_constraint_info[i] = ((cnstr1 << 2) | cnstr2);\n        }\n        this.general_constraint_info[this.num_bytes_constraint_info - 1] = bitReader.extract_bits(6);\n      } else {\n        //forbidden in spec!\n        bitReader.extract_bits(6);\n      }\n\n      if (this.num_sublayers > 1) {\n        bitReader.stream_read_1_bytes(stream);\n        this.ptl_sublayer_present_mask = 0;\n        for (j = this.num_sublayers - 2; j >= 0; --j) {\n          var val = bitReader.extract_bits(1);\n          this.ptl_sublayer_present_mask |= val << j;\n        }\n        for (j = this.num_sublayers; j <= 8 && this.num_sublayers > 1; ++j) {\n          bitReader.extract_bits(1);  // ptl_reserved_zero_bit\n        }\n\n        this.sublayer_level_idc = [];\n        for (j = this.num_sublayers - 2; j >= 0; --j) {\n          if (this.ptl_sublayer_present_mask & (1 << j)) {\n            this.sublayer_level_idc[j] = stream.readUint8();\n          }\n        }\n      }\n\n      this.ptl_num_sub_profiles = stream.readUint8();\n      this.general_sub_profile_idc = [];\n      if (this.ptl_num_sub_profiles) {\n        for (i = 0; i < this.ptl_num_sub_profiles; i++) {\n          this.general_sub_profile_idc.push(stream.readUint32());\n        }\n      }\n    }  // end VvcPTLRecord\n\n    this.max_picture_width = stream.readUint16();\n    this.max_picture_height = stream.readUint16();\n    this.avg_frame_rate = stream.readUint16();\n  }\n\n  var VVC_NALU_OPI = 12;\n  var VVC_NALU_DEC_PARAM = 13;\n\n  this.nalu_arrays = [];\n  var num_of_arrays = stream.readUint8();\n  for (i = 0; i < num_of_arrays; i++) {\n    var nalu_array = [];\n    this.nalu_arrays.push(nalu_array);\n\n    bitReader.stream_read_1_bytes(stream);\n    nalu_array.completeness = bitReader.extract_bits(1);\n    bitReader.extract_bits(2);  // reserved\n    nalu_array.nalu_type = bitReader.extract_bits(5);\n\n    var numNalus = 1;\n    if (nalu_array.nalu_type != VVC_NALU_DEC_PARAM && nalu_array.nalu_type != VVC_NALU_OPI) {\n      numNalus = stream.readUint16();\n    }\n\n    for (j = 0; j < numNalus; j++) {\n      var len = stream.readUint16();\n      nalu_array.push({\n        data: stream.readUint8Array(len),\n        length: len\n      });\n    }\n  }\n});\n// file:src/parsing/vvnC.js\nBoxParser.createFullBoxCtor(\"vvnC\", function (stream) {\n  // VvcNALUConfigBox\n  var tmp = strm.readUint8();\n  this.lengthSizeMinusOne = (tmp & 0x3);\n});\n// file:src/box-codecs.js\nBoxParser.SampleEntry.prototype.isVideo = function() {\n\treturn false;\n}\n\nBoxParser.SampleEntry.prototype.isAudio = function() {\n\treturn false;\n}\n\nBoxParser.SampleEntry.prototype.isSubtitle = function() {\n\treturn false;\n}\n\nBoxParser.SampleEntry.prototype.isMetadata = function() {\n\treturn false;\n}\n\nBoxParser.SampleEntry.prototype.isHint = function() {\n\treturn false;\n}\n\nBoxParser.SampleEntry.prototype.getCodec = function() {\n\treturn this.type.replace('.','');\n}\n\nBoxParser.SampleEntry.prototype.getWidth = function() {\n\treturn \"\";\n}\n\nBoxParser.SampleEntry.prototype.getHeight = function() {\n\treturn \"\";\n}\n\nBoxParser.SampleEntry.prototype.getChannelCount = function() {\n\treturn \"\";\n}\n\nBoxParser.SampleEntry.prototype.getSampleRate = function() {\n\treturn \"\";\n}\n\nBoxParser.SampleEntry.prototype.getSampleSize = function() {\n\treturn \"\";\n}\n\nBoxParser.VisualSampleEntry.prototype.isVideo = function() {\n\treturn true;\n}\n\nBoxParser.VisualSampleEntry.prototype.getWidth = function() {\n\treturn this.width;\n}\n\nBoxParser.VisualSampleEntry.prototype.getHeight = function() {\n\treturn this.height;\n}\n\nBoxParser.AudioSampleEntry.prototype.isAudio = function() {\n\treturn true;\n}\n\nBoxParser.AudioSampleEntry.prototype.getChannelCount = function() {\n\treturn this.channel_count;\n}\n\nBoxParser.AudioSampleEntry.prototype.getSampleRate = function() {\n\treturn this.samplerate;\n}\n\nBoxParser.AudioSampleEntry.prototype.getSampleSize = function() {\n\treturn this.samplesize;\n}\n\nBoxParser.SubtitleSampleEntry.prototype.isSubtitle = function() {\n\treturn true;\n}\n\nBoxParser.MetadataSampleEntry.prototype.isMetadata = function() {\n\treturn true;\n}\n\n\nBoxParser.decimalToHex = function(d, padding) {\n\tvar hex = Number(d).toString(16);\n\tpadding = typeof (padding) === \"undefined\" || padding === null ? padding = 2 : padding;\n\twhile (hex.length < padding) {\n\t\thex = \"0\" + hex;\n\t}\n\treturn hex;\n}\n\nBoxParser.avc1SampleEntry.prototype.getCodec =\nBoxParser.avc2SampleEntry.prototype.getCodec =\nBoxParser.avc3SampleEntry.prototype.getCodec =\nBoxParser.avc4SampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif (this.avcC) {\n\t\treturn baseCodec+\".\"+BoxParser.decimalToHex(this.avcC.AVCProfileIndication)+\n\t\t\t\t\t\t  \"\"+BoxParser.decimalToHex(this.avcC.profile_compatibility)+\n\t\t\t\t\t\t  \"\"+BoxParser.decimalToHex(this.avcC.AVCLevelIndication);\n\t} else {\n\t\treturn baseCodec;\n\t}\n}\n\nBoxParser.hev1SampleEntry.prototype.getCodec =\nBoxParser.hvc1SampleEntry.prototype.getCodec = function() {\n\tvar i;\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif (this.hvcC) {\n\t\tbaseCodec += '.';\n\t\tswitch (this.hvcC.general_profile_space) {\n\t\t\tcase 0:\n\t\t\t\tbaseCodec += '';\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbaseCodec += 'A';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbaseCodec += 'B';\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tbaseCodec += 'C';\n\t\t\t\tbreak;\n\t\t}\n\t\tbaseCodec += this.hvcC.general_profile_idc;\n\t\tbaseCodec += '.';\n\t\tvar val = this.hvcC.general_profile_compatibility;\n\t\tvar reversed = 0;\n\t\tfor (i=0; i<32; i++) {\n\t\t\treversed |= val & 1;\n\t\t\tif (i==31) break;\n\t\t\treversed <<= 1;\n\t\t\tval >>=1;\n\t\t}\n\t\tbaseCodec += BoxParser.decimalToHex(reversed, 0);\n\t\tbaseCodec += '.';\n\t\tif (this.hvcC.general_tier_flag === 0) {\n\t\t\tbaseCodec += 'L';\n\t\t} else {\n\t\t\tbaseCodec += 'H';\n\t\t}\n\t\tbaseCodec += this.hvcC.general_level_idc;\n\t\tvar hasByte = false;\n\t\tvar constraint_string = \"\";\n\t\tfor (i = 5; i >= 0; i--) {\n\t\t\tif (this.hvcC.general_constraint_indicator[i] || hasByte) {\n\t\t\t\tconstraint_string = \".\"+BoxParser.decimalToHex(this.hvcC.general_constraint_indicator[i], 0)+constraint_string;\n\t\t\t\thasByte = true;\n\t\t\t}\n\t\t}\n\t\tbaseCodec += constraint_string;\n\t}\n\treturn baseCodec;\n}\n\nBoxParser.vvc1SampleEntry.prototype.getCodec =\nBoxParser.vvi1SampleEntry.prototype.getCodec = function () {\n\tvar i;\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif (this.vvcC) {\n\t\tbaseCodec += '.' + this.vvcC.general_profile_idc;\n\t\tif (this.vvcC.general_tier_flag) {\n\t\t\tbaseCodec += '.H';\n\t\t} else {\n\t\t\tbaseCodec += '.L';\n\t\t}\n\t\tbaseCodec += this.vvcC.general_level_idc;\n\n\t\tvar constraint_string = \"\";\n\t\tif (this.vvcC.general_constraint_info) {\n\t\t\tvar bytes = [];\n\t\t\tvar byte = 0;\n\t\t\tbyte |= this.vvcC.ptl_frame_only_constraint << 7;\n\t\t\tbyte |= this.vvcC.ptl_multilayer_enabled << 6;\n\t\t\tvar last_nonzero;\n\t\t\tfor (i = 0; i < this.vvcC.general_constraint_info.length; ++i) {\n\t\t\t\tbyte |= (this.vvcC.general_constraint_info[i] >> 2) & 0x3f;\n\t\t\t\tbytes.push(byte);\n\t\t\t\tif (byte) {\n\t\t\t\t\tlast_nonzero = i;\n\t\t\t\t}\n\n\t\t\t\tbyte = (this.vvcC.general_constraint_info[i] >> 2) & 0x03;\n\t\t\t}\n\n\t\t\tif (last_nonzero === undefined) {\n\t\t\t\tconstraint_string = \".CA\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconstraint_string = \".C\"\n\t\t\t\tvar base32_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n\t\t\t\tvar held_bits = 0;\n\t\t\t\tvar num_held_bits = 0;\n\t\t\t\tfor (i = 0; i <= last_nonzero; ++i) {\n\t\t\t\t\theld_bits = (held_bits << 8) | bytes[i];\n\t\t\t\t\tnum_held_bits += 8;\n\n\t\t\t\t\twhile (num_held_bits >= 5) {\n\t\t\t\t\t\tvar val = (held_bits >> (num_held_bits - 5)) & 0x1f;\n\t\t\t\t\t\tconstraint_string += base32_chars[val];\n\n\t\t\t\t\t\tnum_held_bits -= 5;\n\t\t\t\t\t\theld_bits &= (1 << num_held_bits) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (num_held_bits) {\n\t\t\t\t\theld_bits <<= (5 - num_held_bits);  // right-pad with zeros to 5 bits (is this correct?)\n\t\t\t\t\tconstraint_string += base32_chars[held_bits & 0x1f];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbaseCodec += constraint_string;\n\t}\n\treturn baseCodec;\n}\n\nBoxParser.mp4aSampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif (this.esds && this.esds.esd) {\n\t\tvar oti = this.esds.esd.getOTI();\n\t\tvar dsi = this.esds.esd.getAudioConfig();\n\t\treturn baseCodec+\".\"+BoxParser.decimalToHex(oti)+(dsi ? \".\"+dsi: \"\");\n\t} else {\n\t\treturn baseCodec;\n\t}\n}\n\nBoxParser.stxtSampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif(this.mime_format) {\n\t\treturn baseCodec + \".\" + this.mime_format;\n\t} else {\n\t\treturn baseCodec\n\t}\n}\n\nBoxParser.vp08SampleEntry.prototype.getCodec =\nBoxParser.vp09SampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tvar level = this.vpcC.level;\n\tif (level == 0) {\n\t\tlevel = \"00\";\n\t}\n\tvar bitDepth = this.vpcC.bitDepth;\n\tif (bitDepth == 8) {\n\t\tbitDepth = \"08\";\n\t}\n\treturn baseCodec + \".0\" + this.vpcC.profile + \".\" + level + \".\" + bitDepth;\n}\n\nBoxParser.av01SampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tvar level = this.av1C.seq_level_idx_0;\n\tif (level < 10) {\n\t\tlevel = \"0\" + level;\n\t}\n\tvar bitdepth;\n\tif (this.av1C.seq_profile === 2 && this.av1C.high_bitdepth === 1) {\n\t\tbitdepth = (this.av1C.twelve_bit === 1) ? \"12\" : \"10\";\n\t} else if ( this.av1C.seq_profile <= 2 ) {\n\t\tbitdepth = (this.av1C.high_bitdepth === 1) ? \"10\" : \"08\";\n\t}\n\t// TODO need to parse the SH to find color config\n\treturn baseCodec+\".\"+this.av1C.seq_profile+\".\"+level+(this.av1C.seq_tier_0?\"H\":\"M\")+\".\"+bitdepth;//+\".\"+this.av1C.monochrome+\".\"+this.av1C.chroma_subsampling_x+\"\"+this.av1C.chroma_subsampling_y+\"\"+this.av1C.chroma_sample_position;\n}\n// file:src/box-write.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nBoxParser.Box.prototype.writeHeader = function(stream, msg) {\n\tthis.size += 8;\n\tif (this.size > MAX_SIZE) {\n\t\tthis.size += 8;\n\t}\n\tif (this.type === \"uuid\") {\n\t\tthis.size += 16;\n\t}\n\tLog.debug(\"BoxWriter\", \"Writing box \"+this.type+\" of size: \"+this.size+\" at position \"+stream.getPosition()+(msg || \"\"));\n\tif (this.size > MAX_SIZE) {\n\t\tstream.writeUint32(1);\n\t} else {\n\t\tthis.sizePosition = stream.getPosition();\n\t\tstream.writeUint32(this.size);\n\t}\n\tstream.writeString(this.type, null, 4);\n\tif (this.type === \"uuid\") {\n\t\tstream.writeUint8Array(this.uuid);\n\t}\n\tif (this.size > MAX_SIZE) {\n\t\tstream.writeUint64(this.size);\n\t} \n}\n\nBoxParser.FullBox.prototype.writeHeader = function(stream) {\n\tthis.size += 4;\n\tBoxParser.Box.prototype.writeHeader.call(this, stream, \" v=\"+this.version+\" f=\"+this.flags);\n\tstream.writeUint8(this.version);\n\tstream.writeUint24(this.flags);\n}\n\nBoxParser.Box.prototype.write = function(stream) {\n\tif (this.type === \"mdat\") {\n\t\t/* TODO: fix this */\n\t\tif (this.data) {\n\t\t\tthis.size = this.data.length;\n\t\t\tthis.writeHeader(stream);\n\t\t\tstream.writeUint8Array(this.data);\n\t\t}\n\t} else {\n\t\tthis.size = (this.data ? this.data.length : 0);\n\t\tthis.writeHeader(stream);\n\t\tif (this.data) {\n\t\t\tstream.writeUint8Array(this.data);\n\t\t}\n\t}\n}\n\nBoxParser.ContainerBox.prototype.write = function(stream) {\n\tthis.size = 0;\n\tthis.writeHeader(stream);\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tif (this.boxes[i]) {\n\t\t\tthis.boxes[i].write(stream);\n\t\t\tthis.size += this.boxes[i].size;\n\t\t}\n\t}\n\t/* adjusting the size, now that all sub-boxes are known */\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\n}\n\nBoxParser.TrackReferenceTypeBox.prototype.write = function(stream) {\n\tthis.size = this.track_ids.length*4;\n\tthis.writeHeader(stream);\n\tstream.writeUint32Array(this.track_ids);\n}\n\n// file:src/writing/avcC.js\nBoxParser.avcCBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.size = 7;\n\tfor (i = 0; i < this.SPS.length; i++) {\n\t\tthis.size += 2+this.SPS[i].length;\n\t}\n\tfor (i = 0; i < this.PPS.length; i++) {\n\t\tthis.size += 2+this.PPS[i].length;\n\t}\n\tif (this.ext) {\n\t\tthis.size += this.ext.length;\n\t}\n\tthis.writeHeader(stream);\n\tstream.writeUint8(this.configurationVersion);\n\tstream.writeUint8(this.AVCProfileIndication);\n\tstream.writeUint8(this.profile_compatibility);\n\tstream.writeUint8(this.AVCLevelIndication);\n\tstream.writeUint8(this.lengthSizeMinusOne + (63<<2));\n\tstream.writeUint8(this.SPS.length + (7<<5));\n\tfor (i = 0; i < this.SPS.length; i++) {\n\t\tstream.writeUint16(this.SPS[i].length);\n\t\tstream.writeUint8Array(this.SPS[i].nalu);\n\t}\n\tstream.writeUint8(this.PPS.length);\n\tfor (i = 0; i < this.PPS.length; i++) {\n\t\tstream.writeUint16(this.PPS[i].length);\n\t\tstream.writeUint8Array(this.PPS[i].nalu);\n\t}\n\tif (this.ext) {\n\t\tstream.writeUint8Array(this.ext);\n\t}\n}\n\n// file:src/writing/co64.js\nBoxParser.co64Box.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+8*this.chunk_offsets.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.chunk_offsets.length);\n\tfor(i=0; i<this.chunk_offsets.length; i++) {\n\t\tstream.writeUint64(this.chunk_offsets[i]);\n\t}\n}\n\n// file:src/writing/cslg.js\nBoxParser.cslgBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4*5;\n\tthis.writeHeader(stream);\n\tstream.writeInt32(this.compositionToDTSShift);\n\tstream.writeInt32(this.leastDecodeToDisplayDelta);\n\tstream.writeInt32(this.greatestDecodeToDisplayDelta);\n\tstream.writeInt32(this.compositionStartTime);\n\tstream.writeInt32(this.compositionEndTime);\n}\n\n// file:src/writing/ctts.js\nBoxParser.cttsBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+8*this.sample_counts.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sample_counts.length);\n\tfor(i=0; i<this.sample_counts.length; i++) {\n\t\tstream.writeUint32(this.sample_counts[i]);\n\t\tif (this.version === 1) {\n\t\t\tstream.writeInt32(this.sample_offsets[i]); /* signed */\n\t\t} else {\t\t\t\n\t\t\tstream.writeUint32(this.sample_offsets[i]); /* unsigned */\n\t\t}\n\t}\n}\n\n// file:src/writing/dref.js\nBoxParser.drefBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4; //\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.entries.length);\n\tfor (var i = 0; i < this.entries.length; i++) {\n\t\tthis.entries[i].write(stream);\n\t\tthis.size += this.entries[i].size;\n\t}\t\n\t/* adjusting the size, now that all sub-boxes are known */\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\n}\n\n// file:src/writing/elng.js\nBoxParser.elngBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = this.extended_language.length;\n\tthis.writeHeader(stream);\n\tstream.writeString(this.extended_language);\n}\n\n// file:src/writing/elst.js\nBoxParser.elstBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = 4+12*this.entries.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.entries.length);\n\tfor (var i = 0; i < this.entries.length; i++) {\n\t\tvar entry = this.entries[i];\n\t\tstream.writeUint32(entry.segment_duration);\n\t\tstream.writeInt32(entry.media_time);\n\t\tstream.writeInt16(entry.media_rate_integer);\n\t\tstream.writeInt16(entry.media_rate_fraction);\n\t}\n}\n\n// file:src/writing/emsg.js\nBoxParser.emsgBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = 4*4+this.message_data.length+(this.scheme_id_uri.length+1)+(this.value.length+1);\n\tthis.writeHeader(stream);\n\tstream.writeCString(this.scheme_id_uri);\n\tstream.writeCString(this.value);\n\tstream.writeUint32(this.timescale);\n\tstream.writeUint32(this.presentation_time_delta);\n\tstream.writeUint32(this.event_duration);\n\tstream.writeUint32(this.id);\n\tstream.writeUint8Array(this.message_data);\n}\n\n// file:src/writing/ftyp.js\nBoxParser.ftypBox.prototype.write = function(stream) {\n\tthis.size = 8+4*this.compatible_brands.length;\n\tthis.writeHeader(stream);\n\tstream.writeString(this.major_brand, null, 4);\n\tstream.writeUint32(this.minor_version);\n\tfor (var i = 0; i < this.compatible_brands.length; i++) {\n\t\tstream.writeString(this.compatible_brands[i], null, 4);\n\t}\n}\n\n// file:src/writing/hdlr.js\nBoxParser.hdlrBox.prototype.write = function(stream) {\n\tthis.size = 5*4+this.name.length+1;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(0);\n\tstream.writeString(this.handler, null, 4);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeCString(this.name);\n}\n\n// file:src/writing/hvcC.js\nBoxParser.hvcCBox.prototype.write = function(stream) {\n    var i,j;\n    this.size = 23;\n\n    for (i = 0; i < this.nalu_arrays.length; i++) {\n      this.size += 3;\n      for (j = 0; j < this.nalu_arrays[i].length; j++) {\n        this.size += 2 + this.nalu_arrays[i][j].data.length;\n      }\n    }\n\n    this.writeHeader(stream);\n\n    stream.writeUint8(this.configurationVersion);\n    stream.writeUint8((this.general_profile_space << 6) +\n                      (this.general_tier_flag << 5) +\n                      this.general_profile_idc);\n    stream.writeUint32(this.general_profile_compatibility);\n    stream.writeUint8Array(this.general_constraint_indicator);\n    stream.writeUint8(this.general_level_idc);\n    stream.writeUint16(this.min_spatial_segmentation_idc + (15<<24));\n    stream.writeUint8(this.parallelismType + (63<<2));\n    stream.writeUint8(this.chroma_format_idc + (63<<2));\n    stream.writeUint8(this.bit_depth_luma_minus8 + (31<<3));\n    stream.writeUint8(this.bit_depth_chroma_minus8 + (31<<3));\n    stream.writeUint16(this.avgFrameRate);\n    stream.writeUint8((this.constantFrameRate<<6) +\n                   (this.numTemporalLayers<<3) +\n                   (this.temporalIdNested<<2) +\n                   this.lengthSizeMinusOne);\n    stream.writeUint8(this.nalu_arrays.length);\n    for (i = 0; i < this.nalu_arrays.length; i++) {\n      // bit(1) array_completeness + bit(1) reserved = 0 + bit(6) nal_unit_type\n      stream.writeUint8((this.nalu_arrays[i].completeness<<7) +\n                         this.nalu_arrays[i].nalu_type);\n      stream.writeUint16(this.nalu_arrays[i].length);\n      for (j = 0; j < this.nalu_arrays[i].length; j++) {\n        stream.writeUint16(this.nalu_arrays[i][j].data.length);\n        stream.writeUint8Array(this.nalu_arrays[i][j].data);\n      }\n    }\n}\n// file:src/writing/kind.js\nBoxParser.kindBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = (this.schemeURI.length+1)+(this.value.length+1);\n\tthis.writeHeader(stream);\n\tstream.writeCString(this.schemeURI);\n\tstream.writeCString(this.value);\n}\n\n// file:src/writing/mdhd.js\nBoxParser.mdhdBox.prototype.write = function(stream) {\n\tthis.size = 4*4+2*2;\n\tthis.flags = 0;\n\tthis.version = 0;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.creation_time);\n\tstream.writeUint32(this.modification_time);\n\tstream.writeUint32(this.timescale);\n\tstream.writeUint32(this.duration);\n\tstream.writeUint16(this.language);\n\tstream.writeUint16(0);\n}\n\n// file:src/writing/mehd.js\nBoxParser.mehdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.fragment_duration);\n}\n\n// file:src/writing/mfhd.js\nBoxParser.mfhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sequence_number);\n}\n\n// file:src/writing/mvhd.js\nBoxParser.mvhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 23*4+2*2;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.creation_time);\n\tstream.writeUint32(this.modification_time);\n\tstream.writeUint32(this.timescale);\n\tstream.writeUint32(this.duration);\n\tstream.writeUint32(this.rate);\n\tstream.writeUint16(this.volume<<8);\n\tstream.writeUint16(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32Array(this.matrix);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(this.next_track_id);\n}\n\n// file:src/writing/sampleentry.js\nBoxParser.SampleEntry.prototype.writeHeader = function(stream) {\n\tthis.size = 8;\n\tBoxParser.Box.prototype.writeHeader.call(this, stream);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint16(this.data_reference_index);\n}\n\nBoxParser.SampleEntry.prototype.writeFooter = function(stream) {\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tthis.boxes[i].write(stream);\n\t\tthis.size += this.boxes[i].size;\n\t}\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\t\n}\n\nBoxParser.SampleEntry.prototype.write = function(stream) {\n\tthis.writeHeader(stream);\n\tstream.writeUint8Array(this.data);\n\tthis.size += this.data.length;\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\t\n}\n\nBoxParser.VisualSampleEntry.prototype.write = function(stream) {\n\tthis.writeHeader(stream);\n\tthis.size += 2*7+6*4+32;\n\tstream.writeUint16(0); \n\tstream.writeUint16(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint16(this.width);\n\tstream.writeUint16(this.height);\n\tstream.writeUint32(this.horizresolution);\n\tstream.writeUint32(this.vertresolution);\n\tstream.writeUint32(0);\n\tstream.writeUint16(this.frame_count);\n\tstream.writeUint8(Math.min(31, this.compressorname.length));\n\tstream.writeString(this.compressorname, null, 31);\n\tstream.writeUint16(this.depth);\n\tstream.writeInt16(-1);\n\tthis.writeFooter(stream);\n}\n\nBoxParser.AudioSampleEntry.prototype.write = function(stream) {\n\tthis.writeHeader(stream);\n\tthis.size += 2*4+3*4;\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint16(this.channel_count);\n\tstream.writeUint16(this.samplesize);\n\tstream.writeUint16(0);\n\tstream.writeUint16(0);\n\tstream.writeUint32(this.samplerate<<16);\n\tthis.writeFooter(stream);\n}\n\nBoxParser.stppSampleEntry.prototype.write = function(stream) {\n\tthis.writeHeader(stream);\n\tthis.size += this.namespace.length+1+\n\t\t\t\t this.schema_location.length+1+\n\t\t\t\t this.auxiliary_mime_types.length+1;\n\tstream.writeCString(this.namespace);\n\tstream.writeCString(this.schema_location);\n\tstream.writeCString(this.auxiliary_mime_types);\n\tthis.writeFooter(stream);\n}\n\n// file:src/writing/samplegroups/samplegroup.js\nBoxParser.SampleGroupEntry.prototype.write = function(stream) {\n\tstream.writeUint8Array(this.data);\n}\n\n// file:src/writing/sbgp.js\nBoxParser.sbgpBox.prototype.write = function(stream) {\n\tthis.version = 1;\t\n\tthis.flags = 0;\n\tthis.size = 12+8*this.entries.length;\n\tthis.writeHeader(stream);\n\tstream.writeString(this.grouping_type, null, 4);\n\tstream.writeUint32(this.grouping_type_parameter);\n\tstream.writeUint32(this.entries.length);\n\tfor (var i = 0; i < this.entries.length; i++) {\n\t\tvar entry = this.entries[i];\n\t\tstream.writeInt32(entry.sample_count);\n\t\tstream.writeInt32(entry.group_description_index);\n\t}\n}\n\n// file:src/writing/sgpd.js\nBoxParser.sgpdBox.prototype.write = function(stream) {\n\tvar i;\n\tvar entry;\n\t// leave version as read\n\t// this.version;\n\tthis.flags = 0;\n\tthis.size = 12;\n\tfor (i = 0; i < this.entries.length; i++) {\n\t\tentry = this.entries[i];\n\t\tif (this.version === 1) {\n\t\t\tif (this.default_length === 0) {\n\t\t\t\tthis.size += 4;\n\t\t\t}\n\t\t\tthis.size += entry.data.length;\n\t\t}\n\t}\n\tthis.writeHeader(stream);\n\tstream.writeString(this.grouping_type, null, 4);\n\tif (this.version === 1) {\n\t\tstream.writeUint32(this.default_length);\n\t}\n\tif (this.version >= 2) {\n\t\tstream.writeUint32(this.default_sample_description_index);\n\t}\n\tstream.writeUint32(this.entries.length);\n\tfor (i = 0; i < this.entries.length; i++) {\n\t\tentry = this.entries[i];\n\t\tif (this.version === 1) {\n\t\t\tif (this.default_length === 0) {\n\t\t\t\tstream.writeUint32(entry.description_length);\n\t\t\t}\n\t\t}\n\t\tentry.write(stream);\n\t}\n}\n\n\n// file:src/writing/sidx.js\nBoxParser.sidxBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = 4*4+2+2+12*this.references.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.reference_ID);\n\tstream.writeUint32(this.timescale);\n\tstream.writeUint32(this.earliest_presentation_time);\n\tstream.writeUint32(this.first_offset);\n\tstream.writeUint16(0);\n\tstream.writeUint16(this.references.length);\n\tfor (var i = 0; i < this.references.length; i++) {\n\t\tvar ref = this.references[i];\n\t\tstream.writeUint32(ref.reference_type << 31 | ref.referenced_size);\n\t\tstream.writeUint32(ref.subsegment_duration);\n\t\tstream.writeUint32(ref.starts_with_SAP << 31 | ref.SAP_type << 28 | ref.SAP_delta_time);\n\t}\n}\n\n// file:src/writing/smhd.js\nBoxParser.smhdBox.prototype.write = function(stream) {\n  var i;\n  this.version = 0;\n  this.flags = 1;\n  this.size = 4;\n  this.writeHeader(stream);\n  stream.writeUint16(this.balance);\n  stream.writeUint16(0);\n}\n// file:src/writing/stco.js\nBoxParser.stcoBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+4*this.chunk_offsets.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.chunk_offsets.length);\n\tstream.writeUint32Array(this.chunk_offsets);\n}\n\n// file:src/writing/stsc.js\nBoxParser.stscBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+12*this.first_chunk.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.first_chunk.length);\n\tfor(i=0; i<this.first_chunk.length; i++) {\n\t\tstream.writeUint32(this.first_chunk[i]);\n\t\tstream.writeUint32(this.samples_per_chunk[i]);\n\t\tstream.writeUint32(this.sample_description_index[i]);\n\t}\n}\n\n// file:src/writing/stsd.js\nBoxParser.stsdBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 0;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.entries.length);\n\tthis.size += 4;\n\tfor (i = 0; i < this.entries.length; i++) {\n\t\tthis.entries[i].write(stream);\n\t\tthis.size += this.entries[i].size;\n\t}\n\t/* adjusting the size, now that all sub-boxes are known */\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\n}\n\n// file:src/writing/stsh.js\nBoxParser.stshBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+8*this.shadowed_sample_numbers.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.shadowed_sample_numbers.length);\n\tfor(i=0; i<this.shadowed_sample_numbers.length; i++) {\n\t\tstream.writeUint32(this.shadowed_sample_numbers[i]);\n\t\tstream.writeUint32(this.sync_sample_numbers[i]);\n\t}\n}\n\n// file:src/writing/stss.js\nBoxParser.stssBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+4*this.sample_numbers.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sample_numbers.length);\n\tstream.writeUint32Array(this.sample_numbers);\n}\n\n// file:src/writing/stsz.js\nBoxParser.stszBox.prototype.write = function(stream) {\n\tvar i;\n\tvar constant = true;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tif (this.sample_sizes.length > 0) {\n\t\ti = 0;\n\t\twhile (i+1 < this.sample_sizes.length) {\n\t\t\tif (this.sample_sizes[i+1] !==  this.sample_sizes[0]) {\n\t\t\t\tconstant = false;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconstant = false;\n\t}\n\tthis.size = 8;\n\tif (!constant) {\n\t\tthis.size += 4*this.sample_sizes.length;\n\t}\n\tthis.writeHeader(stream);\n\tif (!constant) {\n\t\tstream.writeUint32(0);\n\t} else {\n\t\tstream.writeUint32(this.sample_sizes[0]);\n\t}\n\tstream.writeUint32(this.sample_sizes.length);\n\tif (!constant) {\n\t\tstream.writeUint32Array(this.sample_sizes);\n\t}\t\n}\n\n// file:src/writing/stts.js\nBoxParser.sttsBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+8*this.sample_counts.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sample_counts.length);\n\tfor(i=0; i<this.sample_counts.length; i++) {\n\t\tstream.writeUint32(this.sample_counts[i]);\n\t\tstream.writeUint32(this.sample_deltas[i]);\n\t}\n}\n\n// file:src/writing/tfdt.js\nBoxParser.tfdtBox.prototype.write = function(stream) {\n\tvar UINT32_MAX = Math.pow(2, 32) - 1;\n\t// use version 1 if baseMediaDecodeTime does not fit 32 bits\n\tthis.version = this.baseMediaDecodeTime > UINT32_MAX ? 1 : 0;\n\tthis.flags = 0;\n\tthis.size = 4;\n\tif (this.version === 1) {\n\t\tthis.size += 4;\n\t}\n\tthis.writeHeader(stream);\n\tif (this.version === 1) {\n\t\tstream.writeUint64(this.baseMediaDecodeTime);\n\t} else {\n\t\tstream.writeUint32(this.baseMediaDecodeTime);\n\t}\n}\n\n// file:src/writing/tfhd.js\nBoxParser.tfhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.size = 4;\n\tif (this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) {\n\t\tthis.size += 8;\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) {\n\t\tthis.size += 4;\n\t}\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.track_id);\n\tif (this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) {\n\t\tstream.writeUint64(this.base_data_offset);\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) {\n\t\tstream.writeUint32(this.default_sample_description_index);\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) {\n\t\tstream.writeUint32(this.default_sample_duration);\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) {\n\t\tstream.writeUint32(this.default_sample_size);\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) {\n\t\tstream.writeUint32(this.default_sample_flags);\n\t}\n}\n\n// file:src/writing/tkhd.js\nBoxParser.tkhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\t//this.flags = 0;\n\tthis.size = 4*18+2*4;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.creation_time);\n\tstream.writeUint32(this.modification_time);\n\tstream.writeUint32(this.track_id);\n\tstream.writeUint32(0);\n\tstream.writeUint32(this.duration);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeInt16(this.layer);\n\tstream.writeInt16(this.alternate_group);\n\tstream.writeInt16(this.volume<<8);\n\tstream.writeUint16(0);\n\tstream.writeInt32Array(this.matrix);\n\tstream.writeUint32(this.width);\n\tstream.writeUint32(this.height);\n}\n\n// file:src/writing/trex.js\nBoxParser.trexBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4*5;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.track_id);\n\tstream.writeUint32(this.default_sample_description_index);\n\tstream.writeUint32(this.default_sample_duration);\n\tstream.writeUint32(this.default_sample_size);\n\tstream.writeUint32(this.default_sample_flags);\n}\n\n// file:src/writing/trun.js\nBoxParser.trunBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.size = 4;\n\tif (this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_DURATION) {\n\t\tthis.size += 4*this.sample_duration.length;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_SIZE) {\n\t\tthis.size += 4*this.sample_size.length;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_FLAGS) {\n\t\tthis.size += 4*this.sample_flags.length;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n\t\tthis.size += 4*this.sample_composition_time_offset.length;\n\t}\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sample_count);\n\tif (this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) {\n\t\tthis.data_offset_position = stream.getPosition();\n\t\tstream.writeInt32(this.data_offset); //signed\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) {\n\t\tstream.writeUint32(this.first_sample_flags);\n\t}\n\tfor (var i = 0; i < this.sample_count; i++) {\n\t\tif (this.flags & BoxParser.TRUN_FLAGS_DURATION) {\n\t\t\tstream.writeUint32(this.sample_duration[i]);\n\t\t}\n\t\tif (this.flags & BoxParser.TRUN_FLAGS_SIZE) {\n\t\t\tstream.writeUint32(this.sample_size[i]);\n\t\t}\n\t\tif (this.flags & BoxParser.TRUN_FLAGS_FLAGS) {\n\t\t\tstream.writeUint32(this.sample_flags[i]);\n\t\t}\n\t\tif (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n\t\t\tif (this.version === 0) {\n\t\t\t\tstream.writeUint32(this.sample_composition_time_offset[i]);\n\t\t\t} else {\n\t\t\t\tstream.writeInt32(this.sample_composition_time_offset[i]); //signed\n\t\t\t}\n\t\t}\n\t}\t\t\n}\n\n// file:src/writing/url.js\nBoxParser[\"url Box\"].prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tif (this.location) {\n\t\tthis.flags = 0;\n\t\tthis.size = this.location.length+1;\n\t} else {\n\t\tthis.flags = 0x000001;\n\t\tthis.size = 0;\n\t}\n\tthis.writeHeader(stream);\n\tif (this.location) {\n\t\tstream.writeCString(this.location);\n\t}\n}\n\n// file:src/writing/urn.js\nBoxParser[\"urn Box\"].prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = this.name.length+1+(this.location ? this.location.length+1 : 0);\n\tthis.writeHeader(stream);\n\tstream.writeCString(this.name);\n\tif (this.location) {\n\t\tstream.writeCString(this.location);\n\t}\n}\n\n// file:src/writing/vmhd.js\nBoxParser.vmhdBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 1;\n\tthis.size = 8;\n\tthis.writeHeader(stream);\n\tstream.writeUint16(this.graphicsmode);\n\tstream.writeUint16Array(this.opcolor);\n}\n\n// file:src/box-unpack.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nBoxParser.cttsBox.prototype.unpack = function(samples) {\n\tvar i, j, k;\n\tk = 0;\n\tfor (i = 0; i < this.sample_counts.length; i++) {\n\t\tfor (j = 0; j < this.sample_counts[i]; j++) {\n\t\t\tsamples[k].pts = samples[k].dts + this.sample_offsets[i];\n\t\t\tk++;\n\t\t}\n\t}\n}\n\nBoxParser.sttsBox.prototype.unpack = function(samples) {\n\tvar i, j, k;\n\tk = 0;\n\tfor (i = 0; i < this.sample_counts.length; i++) {\n\t\tfor (j = 0; j < this.sample_counts[i]; j++) {\n\t\t\tif (k === 0) {\n\t\t\t\tsamples[k].dts = 0;\n\t\t\t} else {\n\t\t\t\tsamples[k].dts = samples[k-1].dts + this.sample_deltas[i];\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n}\n\nBoxParser.stcoBox.prototype.unpack = function(samples) {\n\tvar i;\n\tfor (i = 0; i < this.chunk_offsets.length; i++) {\n\t\tsamples[i].offset = this.chunk_offsets[i];\n\t}\n}\n\nBoxParser.stscBox.prototype.unpack = function(samples) {\n\tvar i, j, k, l, m;\n\tl = 0;\n\tm = 0;\n\tfor (i = 0; i < this.first_chunk.length; i++) {\n\t\tfor (j = 0; j < (i+1 < this.first_chunk.length ? this.first_chunk[i+1] : Infinity); j++) {\n\t\t\tm++;\n\t\t\tfor (k = 0; k < this.samples_per_chunk[i]; k++) {\n\t\t\t\tif (samples[l]) {\n\t\t\t\t\tsamples[l].description_index = this.sample_description_index[i];\n\t\t\t\t\tsamples[l].chunk_index = m;\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n\nBoxParser.stszBox.prototype.unpack = function(samples) {\n\tvar i;\n\tfor (i = 0; i < this.sample_sizes.length; i++) {\n\t\tsamples[i].size = this.sample_sizes[i];\n\t}\n}\n// file:src/box-diff.js\n\nBoxParser.DIFF_BOXES_PROP_NAMES = [ \"boxes\", \"entries\", \"references\", \"subsamples\",\n\t\t\t\t\t \t \"items\", \"item_infos\", \"extents\", \"associations\",\n\t\t\t\t\t \t \"subsegments\", \"ranges\", \"seekLists\", \"seekPoints\",\n\t\t\t\t\t \t \"esd\", \"levels\"];\n\nBoxParser.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = [ \"compatible_brands\", \"matrix\", \"opcolor\", \"sample_counts\", \"sample_counts\", \"sample_deltas\",\n\"first_chunk\", \"samples_per_chunk\", \"sample_sizes\", \"chunk_offsets\", \"sample_offsets\", \"sample_description_index\", \"sample_duration\" ];\n\nBoxParser.boxEqualFields = function(box_a, box_b) {\n\tif (box_a && !box_b) return false;\n\tvar prop;\n\tfor (prop in box_a) {\n\t\tif (BoxParser.DIFF_BOXES_PROP_NAMES.indexOf(prop) > -1) {\n\t\t\tcontinue;\n\t\t// } else if (excluded_fields && excluded_fields.indexOf(prop) > -1) {\n\t\t// \tcontinue;\n\t\t} else if (box_a[prop] instanceof BoxParser.Box || box_b[prop] instanceof BoxParser.Box) {\n\t\t\tcontinue;\n\t\t} else if (typeof box_a[prop] === \"undefined\" || typeof box_b[prop] === \"undefined\") {\n\t\t\tcontinue;\n\t\t} else if (typeof box_a[prop] === \"function\" || typeof box_b[prop] === \"function\") {\n\t\t\tcontinue;\n\t\t} else if (\n\t\t\t(box_a.subBoxNames && box_a.subBoxNames.indexOf(prop.slice(0,4)) > -1) ||\n\t\t\t(box_b.subBoxNames && box_b.subBoxNames.indexOf(prop.slice(0,4)) > -1))  {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (prop === \"data\" || prop === \"start\" || prop === \"size\" || prop === \"creation_time\" || prop === \"modification_time\") {\n\t\t\t\tcontinue;\n\t\t\t} else if (BoxParser.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(prop) > -1) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (box_a[prop] !== box_b[prop]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nBoxParser.boxEqual = function(box_a, box_b) {\n\tif (!BoxParser.boxEqualFields(box_a, box_b)) {\n\t\treturn false;\n\t}\n\tfor (var j = 0; j < BoxParser.DIFF_BOXES_PROP_NAMES.length; j++) {\n\t\tvar name = BoxParser.DIFF_BOXES_PROP_NAMES[j];\n\t\tif (box_a[name] && box_b[name]) {\n\t\t\tif (!BoxParser.boxEqual(box_a[name], box_b[name])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}// file:src/text-mp4.js\n/* \n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar VTTin4Parser = function() {\t\n}\n\nVTTin4Parser.prototype.parseSample = function(data) {\n\tvar cues, cue;\n\tvar stream = new MP4BoxStream(data.buffer);\n\tcues = [];\n\twhile (!stream.isEos()) {\n\t\tcue = BoxParser.parseOneBox(stream, false);\n\t\tif (cue.code === BoxParser.OK && cue.box.type === \"vttc\") {\n\t\t\tcues.push(cue.box);\n\t\t}\t\t\n\t}\n\treturn cues;\n}\n\nVTTin4Parser.prototype.getText = function (startTime, endTime, data) {\n\tfunction pad(n, width, z) {\n\t  z = z || '0';\n\t  n = n + '';\n\t  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n\t}\n\tfunction secToTimestamp(insec) {\n\t\tvar h = Math.floor(insec/3600);\n\t\tvar m = Math.floor((insec - h*3600)/60);\n\t\tvar s = Math.floor(insec - h*3600 - m*60);\n\t\tvar ms = Math.floor((insec - h*3600 - m*60 - s)*1000);\n\t\treturn \"\"+pad(h, 2)+\":\"+pad(m,2)+\":\"+pad(s, 2)+\".\"+pad(ms, 3);\n\t}\n\tvar cues = this.parseSample(data);\n\tvar string = \"\";\n\tfor (var i = 0; i < cues.length; i++) {\n\t\tvar cueIn4 = cues[i];\n\t\tstring += secToTimestamp(startTime)+\" --> \"+secToTimestamp(endTime)+\"\\r\\n\";\n\t\tstring += cueIn4.payl.text;\n\t}\n\treturn string;\n}\n\nvar XMLSubtitlein4Parser = function() {\t\n}\n\nXMLSubtitlein4Parser.prototype.parseSample = function(sample) {\n\tvar res = {};\t\n\tvar i;\n\tres.resources = [];\n\tvar stream = new MP4BoxStream(sample.data.buffer);\n\tif (!sample.subsamples || sample.subsamples.length === 0) {\n\t\tres.documentString = stream.readString(sample.data.length);\n\t} else {\n\t\tres.documentString = stream.readString(sample.subsamples[0].size);\n\t\tif (sample.subsamples.length > 1) {\n\t\t\tfor (i = 1; i < sample.subsamples.length; i++) {\n\t\t\t\tres.resources[i] = stream.readUint8Array(sample.subsamples[i].size);\n\t\t\t}\n\t\t}\n\t}\n\tif (typeof (DOMParser) !== \"undefined\") {\n\t\tres.document = (new DOMParser()).parseFromString(res.documentString, \"application/xml\");\n\t}\n\treturn res;\n}\n\nvar Textin4Parser = function() {\t\n}\n\nTextin4Parser.prototype.parseSample = function(sample) {\n\tvar textString;\n\tvar stream = new MP4BoxStream(sample.data.buffer);\n\ttextString = stream.readString(sample.data.length);\n\treturn textString;\n}\n\nTextin4Parser.prototype.parseConfig = function(data) {\n\tvar textString;\n\tvar stream = new MP4BoxStream(data.buffer);\n\tstream.readUint32(); // version & flags\n\ttextString = stream.readCString();\n\treturn textString;\n}\n\nif (typeof exports !== 'undefined') {\n\texports.XMLSubtitlein4Parser = XMLSubtitlein4Parser;\n\texports.Textin4Parser = Textin4Parser;\n}\n// file:src/isofile.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar ISOFile = function (stream) {\n\t/* MutiBufferStream object used to parse boxes */\n\tthis.stream = stream || new MultiBufferStream();\n\t/* Array of all boxes (in order) found in the file */\n\tthis.boxes = [];\n\t/* Array of all mdats */\n\tthis.mdats = [];\n\t/* Array of all moofs */\n\tthis.moofs = [];\n\t/* Boolean indicating if the file is compatible with progressive parsing (moov first) */\n\tthis.isProgressive = false;\n\t/* Boolean used to fire moov start event only once */\n\tthis.moovStartFound = false;\n\t/* Callback called when the moov parsing starts */\n\tthis.onMoovStart = null;\n\t/* Boolean keeping track of the call to onMoovStart, to avoid double calls */\n\tthis.moovStartSent = false;\n\t/* Callback called when the moov is entirely parsed */\n\tthis.onReady = null;\n\t/* Boolean keeping track of the call to onReady, to avoid double calls */\n\tthis.readySent = false;\n\t/* Callback to call when segments are ready */\n\tthis.onSegment = null;\n\t/* Callback to call when samples are ready */\n\tthis.onSamples = null;\n\t/* Callback to call when there is an error in the parsing or processing of samples */\n\tthis.onError = null;\n\t/* Boolean indicating if the moov box run-length encoded tables of sample information have been processed */\n\tthis.sampleListBuilt = false;\n\t/* Array of Track objects for which fragmentation of samples is requested */\n\tthis.fragmentedTracks = [];\n\t/* Array of Track objects for which extraction of samples is requested */\n\tthis.extractedTracks = [];\n\t/* Boolean indicating that fragmention is ready */\n\tthis.isFragmentationInitialized = false;\n\t/* Boolean indicating that fragmented has started */\n\tthis.sampleProcessingStarted = false;\n\t/* Number of the next 'moof' to generate when fragmenting */\n\tthis.nextMoofNumber = 0;\n\t/* Boolean indicating if the initial list of items has been produced */\n\tthis.itemListBuilt = false;\n\t/* Callback called when the sidx box is entirely parsed */\n\tthis.onSidx = null;\n\t/* Boolean keeping track of the call to onSidx, to avoid double calls */\n\tthis.sidxSent = false;\n}\n\nISOFile.prototype.setSegmentOptions = function(id, user, options) {\n\tvar trak = this.getTrackById(id);\n\tif (trak) {\n\t\tvar fragTrack = {};\n\t\tthis.fragmentedTracks.push(fragTrack);\n\t\tfragTrack.id = id;\n\t\tfragTrack.user = user;\n\t\tfragTrack.trak = trak;\n\t\ttrak.nextSample = 0;\n\t\tfragTrack.segmentStream = null;\n\t\tfragTrack.nb_samples = 1000;\n\t\tfragTrack.rapAlignement = true;\n\t\tif (options) {\n\t\t\tif (options.nbSamples) fragTrack.nb_samples = options.nbSamples;\n\t\t\tif (options.rapAlignement) fragTrack.rapAlignement = options.rapAlignement;\n\t\t}\n\t}\n}\n\nISOFile.prototype.unsetSegmentOptions = function(id) {\n\tvar index = -1;\n\tfor (var i = 0; i < this.fragmentedTracks.length; i++) {\n\t\tvar fragTrack = this.fragmentedTracks[i];\n\t\tif (fragTrack.id == id) {\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index > -1) {\n\t\tthis.fragmentedTracks.splice(index, 1);\n\t}\n}\n\nISOFile.prototype.setExtractionOptions = function(id, user, options) {\n\tvar trak = this.getTrackById(id);\n\tif (trak) {\n\t\tvar extractTrack = {};\n\t\tthis.extractedTracks.push(extractTrack);\n\t\textractTrack.id = id;\n\t\textractTrack.user = user;\n\t\textractTrack.trak = trak;\n\t\ttrak.nextSample = 0;\n\t\textractTrack.nb_samples = 1000;\n\t\textractTrack.samples = [];\n\t\tif (options) {\n\t\t\tif (options.nbSamples) extractTrack.nb_samples = options.nbSamples;\n\t\t}\n\t}\n}\n\nISOFile.prototype.unsetExtractionOptions = function(id) {\n\tvar index = -1;\n\tfor (var i = 0; i < this.extractedTracks.length; i++) {\n\t\tvar extractTrack = this.extractedTracks[i];\n\t\tif (extractTrack.id == id) {\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index > -1) {\n\t\tthis.extractedTracks.splice(index, 1);\n\t}\n}\n\nISOFile.prototype.parse = function() {\n\tvar found;\n\tvar ret;\n\tvar box;\n\tvar parseBoxHeadersOnly = false;\n\n\tif (this.restoreParsePosition)\t{\n\t\tif (!this.restoreParsePosition()) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\twhile (true) {\n\n\t\tif (this.hasIncompleteMdat && this.hasIncompleteMdat()) {\n\t\t\tif (this.processIncompleteMdat()) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.saveParsePosition)\t{\n\t\t\t\tthis.saveParsePosition();\n\t\t\t}\n\t\t\tret = BoxParser.parseOneBox(this.stream, parseBoxHeadersOnly);\n\t\t\tif (ret.code === BoxParser.ERR_NOT_ENOUGH_DATA) {\n\t\t\t\tif (this.processIncompleteBox) {\n\t\t\t\t\tif (this.processIncompleteBox(ret)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar box_type;\n\t\t\t\t/* the box is entirely parsed */\n\t\t\t\tbox = ret.box;\n\t\t\t\tbox_type = (box.type !== \"uuid\" ? box.type : box.uuid);\n\t\t\t\t/* store the box in the 'boxes' array to preserve box order (for file rewrite if needed)  */\n\t\t\t\tthis.boxes.push(box);\n\t\t\t\t/* but also store box in a property for more direct access */\n\t\t\t\tswitch (box_type) {\n\t\t\t\t\tcase \"mdat\":\n\t\t\t\t\t\tthis.mdats.push(box);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"moof\":\n\t\t\t\t\t\tthis.moofs.push(box);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"moov\":\n\t\t\t\t\t\tthis.moovStartFound = true;\n\t\t\t\t\t\tif (this.mdats.length === 0) {\n\t\t\t\t\t\t\tthis.isProgressive = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* no break */\n\t\t\t\t\t\t/* falls through */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (this[box_type] !== undefined) {\n\t\t\t\t\t\t\tLog.warn(\"ISOFile\", \"Duplicate Box of type: \"+box_type+\", overriding previous occurrence\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis[box_type] = box;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this.updateUsedBytes) {\n\t\t\t\t\tthis.updateUsedBytes(box, ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nISOFile.prototype.checkBuffer = function (ab) {\n\tif (ab === null || ab === undefined) {\n\t\tthrow(\"Buffer must be defined and non empty\");\n\t}\n\tif (ab.fileStart === undefined) {\n\t\tthrow(\"Buffer must have a fileStart property\");\n\t}\n\tif (ab.byteLength === 0) {\n\t\tLog.warn(\"ISOFile\", \"Ignoring empty buffer (fileStart: \"+ab.fileStart+\")\");\n\t\tthis.stream.logBufferLevel();\n\t\treturn false;\n\t}\n\tLog.info(\"ISOFile\", \"Processing buffer (fileStart: \"+ab.fileStart+\")\");\n\n\t/* mark the bytes in the buffer as not being used yet */\n\tab.usedBytes = 0;\n\tthis.stream.insertBuffer(ab);\n\tthis.stream.logBufferLevel();\n\n\tif (!this.stream.initialized()) {\n\t\tLog.warn(\"ISOFile\", \"Not ready to start parsing\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* Processes a new ArrayBuffer (with a fileStart property)\n   Returns the next expected file position, or undefined if not ready to parse */\nISOFile.prototype.appendBuffer = function(ab, last) {\n\tvar nextFileStart;\n\tif (!this.checkBuffer(ab)) {\n\t\treturn;\n\t}\n\n\t/* Parse whatever is in the existing buffers */\n\tthis.parse();\n\n\t/* Check if the moovStart callback needs to be called */\n\tif (this.moovStartFound && !this.moovStartSent) {\n\t\tthis.moovStartSent = true;\n\t\tif (this.onMoovStart) this.onMoovStart();\n\t}\n\n\tif (this.moov) {\n\t\t/* A moov box has been entirely parsed */\n\n\t\t/* if this is the first call after the moov is found we initialize the list of samples (may be empty in fragmented files) */\n\t\tif (!this.sampleListBuilt) {\n\t\t\tthis.buildSampleLists();\n\t\t\tthis.sampleListBuilt = true;\n\t\t}\n\n\t\t/* We update the sample information if there are any new moof boxes */\n\t\tthis.updateSampleLists();\n\n\t\t/* If the application needs to be informed that the 'moov' has been found,\n\t\t   we create the information object and callback the application */\n\t\tif (this.onReady && !this.readySent) {\n\t\t\tthis.readySent = true;\n\t\t\tthis.onReady(this.getInfo());\n\t\t}\n\n\t\t/* See if any sample extraction or segment creation needs to be done with the available samples */\n\t\tthis.processSamples(last);\n\n\t\t/* Inform about the best range to fetch next */\n\t\tif (this.nextSeekPosition) {\n\t\t\tnextFileStart = this.nextSeekPosition;\n\t\t\tthis.nextSeekPosition = undefined;\n\t\t} else {\n\t\t\tnextFileStart = this.nextParsePosition;\n\t\t}\n\t\tif (this.stream.getEndFilePositionAfter) {\n\t\t\tnextFileStart = this.stream.getEndFilePositionAfter(nextFileStart);\n\t\t}\n\t} else {\n\t\tif (this.nextParsePosition) {\n\t\t\t/* moov has not been parsed but the first buffer was received,\n\t\t\t   the next fetch should probably be the next box start */\n\t\t\tnextFileStart = this.nextParsePosition;\n\t\t} else {\n\t\t\t/* No valid buffer has been parsed yet, we cannot know what to parse next */\n\t\t\tnextFileStart = 0;\n\t\t}\n\t}\n\tif (this.sidx) {\n\t\tif (this.onSidx && !this.sidxSent) {\n\t\t\tthis.onSidx(this.sidx);\n\t\t\tthis.sidxSent = true;\n\t\t}\n\t}\n\tif (this.meta) {\n\t\tif (this.flattenItemInfo && !this.itemListBuilt) {\n\t\t\tthis.flattenItemInfo();\n\t\t\tthis.itemListBuilt = true;\n\t\t}\n\t\tif (this.processItems) {\n\t\t\tthis.processItems(this.onItem);\n\t\t}\n\t}\n\n\tif (this.stream.cleanBuffers) {\n\t\tLog.info(\"ISOFile\", \"Done processing buffer (fileStart: \"+ab.fileStart+\") - next buffer to fetch should have a fileStart position of \"+nextFileStart);\n\t\tthis.stream.logBufferLevel();\n\t\tthis.stream.cleanBuffers();\n\t\tthis.stream.logBufferLevel(true);\n\t\tLog.info(\"ISOFile\", \"Sample data size in memory: \"+this.getAllocatedSampleDataSize());\n\t}\n\treturn nextFileStart;\n}\n\nISOFile.prototype.getInfo = function() {\n\tvar i, j;\n\tvar movie = {};\n\tvar trak;\n\tvar track;\n\tvar ref;\n\tvar sample_desc;\n\tvar _1904 = (new Date('1904-01-01T00:00:00Z').getTime());\n\n\tif (this.moov) {\n\t\tmovie.hasMoov = true;\n\t\tmovie.duration = this.moov.mvhd.duration;\n\t\tmovie.timescale = this.moov.mvhd.timescale;\n\t\tmovie.isFragmented = (this.moov.mvex != null);\n\t\tif (movie.isFragmented && this.moov.mvex.mehd) {\n\t\t\tmovie.fragment_duration = this.moov.mvex.mehd.fragment_duration;\n\t\t}\n\t\tmovie.isProgressive = this.isProgressive;\n\t\tmovie.hasIOD = (this.moov.iods != null);\n\t\tmovie.brands = [];\n\t\tmovie.brands.push(this.ftyp.major_brand);\n\t\tmovie.brands = movie.brands.concat(this.ftyp.compatible_brands);\n\t\tmovie.created = new Date(_1904+this.moov.mvhd.creation_time*1000);\n\t\tmovie.modified = new Date(_1904+this.moov.mvhd.modification_time*1000);\n\t\tmovie.tracks = [];\n\t\tmovie.audioTracks = [];\n\t\tmovie.videoTracks = [];\n\t\tmovie.subtitleTracks = [];\n\t\tmovie.metadataTracks = [];\n\t\tmovie.hintTracks = [];\n\t\tmovie.otherTracks = [];\n\t\tfor (i = 0; i < this.moov.traks.length; i++) {\n\t\t\ttrak = this.moov.traks[i];\n\t\t\tsample_desc = trak.mdia.minf.stbl.stsd.entries[0];\n\t\t\ttrack = {};\n\t\t\tmovie.tracks.push(track);\n\t\t\ttrack.id = trak.tkhd.track_id;\n\t\t\ttrack.name = trak.mdia.hdlr.name;\n\t\t\ttrack.references = [];\n\t\t\tif (trak.tref) {\n\t\t\t\tfor (j = 0; j < trak.tref.boxes.length; j++) {\n\t\t\t\t\tref = {};\n\t\t\t\t\ttrack.references.push(ref);\n\t\t\t\t\tref.type = trak.tref.boxes[j].type;\n\t\t\t\t\tref.track_ids = trak.tref.boxes[j].track_ids;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (trak.edts) {\n\t\t\t\ttrack.edits = trak.edts.elst.entries;\n\t\t\t}\n\t\t\ttrack.created = new Date(_1904+trak.tkhd.creation_time*1000);\n\t\t\ttrack.modified = new Date(_1904+trak.tkhd.modification_time*1000);\n\t\t\ttrack.movie_duration = trak.tkhd.duration;\n\t\t\ttrack.movie_timescale = movie.timescale;\n\t\t\ttrack.layer = trak.tkhd.layer;\n\t\t\ttrack.alternate_group = trak.tkhd.alternate_group;\n\t\t\ttrack.volume = trak.tkhd.volume;\n\t\t\ttrack.matrix = trak.tkhd.matrix;\n\t\t\ttrack.track_width = trak.tkhd.width/(1<<16);\n\t\t\ttrack.track_height = trak.tkhd.height/(1<<16);\n\t\t\ttrack.timescale = trak.mdia.mdhd.timescale;\n\t\t\ttrack.cts_shift = trak.mdia.minf.stbl.cslg;\n\t\t\ttrack.duration = trak.mdia.mdhd.duration;\n\t\t\ttrack.samples_duration = trak.samples_duration;\n\t\t\ttrack.codec = sample_desc.getCodec();\n\t\t\ttrack.kind = (trak.udta && trak.udta.kinds.length ? trak.udta.kinds[0] : { schemeURI: \"\", value: \"\"});\n\t\t\ttrack.language = (trak.mdia.elng ? trak.mdia.elng.extended_language : trak.mdia.mdhd.languageString);\n\t\t\ttrack.nb_samples = trak.samples.length;\n\t\t\ttrack.size = trak.samples_size;\n\t\t\ttrack.bitrate = (track.size*8*track.timescale)/track.samples_duration;\n\t\t\tif (sample_desc.isAudio()) {\n\t\t\t\ttrack.type = \"audio\";\n\t\t\t\tmovie.audioTracks.push(track);\n\t\t\t\ttrack.audio = {};\n\t\t\t\ttrack.audio.sample_rate = sample_desc.getSampleRate();\n\t\t\t\ttrack.audio.channel_count = sample_desc.getChannelCount();\n\t\t\t\ttrack.audio.sample_size = sample_desc.getSampleSize();\n\t\t\t} else if (sample_desc.isVideo()) {\n\t\t\t\ttrack.type = \"video\";\n\t\t\t\tmovie.videoTracks.push(track);\n\t\t\t\ttrack.video = {};\n\t\t\t\ttrack.video.width = sample_desc.getWidth();\n\t\t\t\ttrack.video.height = sample_desc.getHeight();\n\t\t\t} else if (sample_desc.isSubtitle()) {\n\t\t\t\ttrack.type = \"subtitles\";\n\t\t\t\tmovie.subtitleTracks.push(track);\n\t\t\t} else if (sample_desc.isHint()) {\n\t\t\t\ttrack.type = \"metadata\";\n\t\t\t\tmovie.hintTracks.push(track);\n\t\t\t} else if (sample_desc.isMetadata()) {\n\t\t\t\ttrack.type = \"metadata\";\n\t\t\t\tmovie.metadataTracks.push(track);\n\t\t\t} else {\n\t\t\t\ttrack.type = \"metadata\";\n\t\t\t\tmovie.otherTracks.push(track);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmovie.hasMoov = false;\n\t}\n\tmovie.mime = \"\";\n\tif (movie.hasMoov && movie.tracks) {\n\t\tif (movie.videoTracks && movie.videoTracks.length > 0) {\n\t\t\tmovie.mime += 'video/mp4; codecs=\\\"';\n\t\t} else if (movie.audioTracks && movie.audioTracks.length > 0) {\n\t\t\tmovie.mime += 'audio/mp4; codecs=\\\"';\n\t\t} else {\n\t\t\tmovie.mime += 'application/mp4; codecs=\\\"';\n\t\t}\n\t\tfor (i = 0; i < movie.tracks.length; i++) {\n\t\t\tif (i !== 0) movie.mime += ',';\n\t\t\tmovie.mime+= movie.tracks[i].codec;\n\t\t}\n\t\tmovie.mime += '\\\"; profiles=\\\"';\n\t\tmovie.mime += this.ftyp.compatible_brands.join();\n\t\tmovie.mime += '\\\"';\n\t}\n\treturn movie;\n}\n\nISOFile.prototype.setNextSeekPositionFromSample = function (sample) {\n\tif (!sample) {\n\t\treturn;\n\t}\n\tif (this.nextSeekPosition) {\n\t\tthis.nextSeekPosition = Math.min(sample.offset+sample.alreadyRead,this.nextSeekPosition);\n\t} else {\n\t\tthis.nextSeekPosition = sample.offset+sample.alreadyRead;\n\t}\n}\n\nISOFile.prototype.processSamples = function(last) {\n\tvar i;\n\tvar trak;\n\tif (!this.sampleProcessingStarted) return;\n\n\t/* For each track marked for fragmentation,\n\t   check if the next sample is there (i.e. if the sample information is known (i.e. moof has arrived) and if it has been downloaded)\n\t   and create a fragment with it */\n\tif (this.isFragmentationInitialized && this.onSegment !== null) {\n\t\tfor (i = 0; i < this.fragmentedTracks.length; i++) {\n\t\t\tvar fragTrak = this.fragmentedTracks[i];\n\t\t\ttrak = fragTrak.trak;\n\t\t\twhile (trak.nextSample < trak.samples.length && this.sampleProcessingStarted) {\n\t\t\t\t/* The sample information is there (either because the file is not fragmented and this is not the last sample,\n\t\t\t\tor because the file is fragmented and the moof for that sample has been received */\n\t\t\t\tLog.debug(\"ISOFile\", \"Creating media fragment on track #\"+fragTrak.id +\" for sample \"+trak.nextSample);\n\t\t\t\tvar result = this.createFragment(fragTrak.id, trak.nextSample, fragTrak.segmentStream);\n\t\t\t\tif (result) {\n\t\t\t\t\tfragTrak.segmentStream = result;\n\t\t\t\t\ttrak.nextSample++;\n\t\t\t\t} else {\n\t\t\t\t\t/* The fragment could not be created because the media data is not there (not downloaded), wait for it */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* A fragment is created by sample, but the segment is the accumulation in the buffer of these fragments.\n\t\t\t\t   It is flushed only as requested by the application (nb_samples) to avoid too many callbacks */\n\t\t\t\tif (trak.nextSample % fragTrak.nb_samples === 0 || (last || trak.nextSample >= trak.samples.length)) {\n\t\t\t\t\tLog.info(\"ISOFile\", \"Sending fragmented data on track #\"+fragTrak.id+\" for samples [\"+Math.max(0,trak.nextSample-fragTrak.nb_samples)+\",\"+(trak.nextSample-1)+\"]\");\n\t\t\t\t\tLog.info(\"ISOFile\", \"Sample data size in memory: \"+this.getAllocatedSampleDataSize());\n\t\t\t\t\tif (this.onSegment) {\n\t\t\t\t\t\tthis.onSegment(fragTrak.id, fragTrak.user, fragTrak.segmentStream.buffer, trak.nextSample, (last || trak.nextSample >= trak.samples.length));\n\t\t\t\t\t}\n\t\t\t\t\t/* force the creation of a new buffer */\n\t\t\t\t\tfragTrak.segmentStream = null;\n\t\t\t\t\tif (fragTrak !== this.fragmentedTracks[i]) {\n\t\t\t\t\t\t/* make sure we can stop fragmentation if needed */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.onSamples !== null) {\n\t\t/* For each track marked for data export,\n\t\t   check if the next sample is there (i.e. has been downloaded) and send it */\n\t\tfor (i = 0; i < this.extractedTracks.length; i++) {\n\t\t\tvar extractTrak = this.extractedTracks[i];\n\t\t\ttrak = extractTrak.trak;\n\t\t\twhile (trak.nextSample < trak.samples.length && this.sampleProcessingStarted) {\n\t\t\t\tLog.debug(\"ISOFile\", \"Exporting on track #\"+extractTrak.id +\" sample #\"+trak.nextSample);\n\t\t\t\tvar sample = this.getSample(trak, trak.nextSample);\n\t\t\t\tif (sample) {\n\t\t\t\t\ttrak.nextSample++;\n\t\t\t\t\textractTrak.samples.push(sample);\n\t\t\t\t} else {\n\t\t\t\t\tthis.setNextSeekPositionFromSample(trak.samples[trak.nextSample]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (trak.nextSample % extractTrak.nb_samples === 0 || trak.nextSample >= trak.samples.length) {\n\t\t\t\t\tLog.debug(\"ISOFile\", \"Sending samples on track #\"+extractTrak.id+\" for sample \"+trak.nextSample);\n\t\t\t\t\tif (this.onSamples) {\n\t\t\t\t\t\tthis.onSamples(extractTrak.id, extractTrak.user, extractTrak.samples);\n\t\t\t\t\t}\n\t\t\t\t\textractTrak.samples = [];\n\t\t\t\t\tif (extractTrak !== this.extractedTracks[i]) {\n\t\t\t\t\t\t/* check if the extraction needs to be stopped */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Find and return specific boxes using recursion and early return */\nISOFile.prototype.getBox = function(type) {\n  var result = this.getBoxes(type, true);\n  return (result.length ? result[0] : null);\n}\n\nISOFile.prototype.getBoxes = function(type, returnEarly) {\n  var result = [];\n  ISOFile._sweep.call(this, type, result, returnEarly);\n  return result;\n}\n\nISOFile._sweep = function(type, result, returnEarly) {\n  if (this.type && this.type == type) result.push(this);\n  for (var box in this.boxes) {\n    if (result.length && returnEarly) return;\n    ISOFile._sweep.call(this.boxes[box], type, result, returnEarly);\n  }\n}\n\nISOFile.prototype.getTrackSamplesInfo = function(track_id) {\n\tvar track = this.getTrackById(track_id);\n\tif (track) {\n\t\treturn track.samples;\n\t} else {\n\t\treturn;\n\t}\n}\n\nISOFile.prototype.getTrackSample = function(track_id, number) {\n\tvar track = this.getTrackById(track_id);\n\tvar sample = this.getSample(track, number);\n\treturn sample;\n}\n\n/* Called by the application to release the resources associated to samples already forwarded to the application */\nISOFile.prototype.releaseUsedSamples = function (id, sampleNum) {\n\tvar size = 0;\n\tvar trak = this.getTrackById(id);\n\tif (!trak.lastValidSample) trak.lastValidSample = 0;\n\tfor (var i = trak.lastValidSample; i < sampleNum; i++) {\n\t\tsize+=this.releaseSample(trak, i);\n\t}\n\tLog.info(\"ISOFile\", \"Track #\"+id+\" released samples up to \"+sampleNum+\" (released size: \"+size+\", remaining: \"+this.samplesDataSize+\")\");\n\ttrak.lastValidSample = sampleNum;\n}\n\nISOFile.prototype.start = function() {\n\tthis.sampleProcessingStarted = true;\n\tthis.processSamples(false);\n}\n\nISOFile.prototype.stop = function() {\n\tthis.sampleProcessingStarted = false;\n}\n\n/* Called by the application to flush the remaining samples (e.g. once the download is finished or when no more samples will be added) */\nISOFile.prototype.flush = function() {\n\tLog.info(\"ISOFile\", \"Flushing remaining samples\");\n\tthis.updateSampleLists();\n\tthis.processSamples(true);\n\tthis.stream.cleanBuffers();\n\tthis.stream.logBufferLevel(true);\n}\n\n/* Finds the byte offset for a given time on a given track\n   also returns the time of the previous rap */\nISOFile.prototype.seekTrack = function(time, useRap, trak) {\n\tvar j;\n\tvar sample;\n\tvar seek_offset = Infinity;\n\tvar rap_seek_sample_num = 0;\n\tvar seek_sample_num = 0;\n\tvar timescale;\n\n\tif (trak.samples.length === 0) {\n\t\tLog.info(\"ISOFile\", \"No sample in track, cannot seek! Using time \"+Log.getDurationString(0, 1) +\" and offset: \"+0);\n\t\treturn { offset: 0, time: 0 };\n\t}\n\n\tfor (j = 0; j < trak.samples.length; j++) {\n\t\tsample = trak.samples[j];\n\t\tif (j === 0) {\n\t\t\tseek_sample_num = 0;\n\t\t\ttimescale = sample.timescale;\n\t\t} else if (sample.cts > time * sample.timescale) {\n\t\t\tseek_sample_num = j-1;\n\t\t\tbreak;\n\t\t}\n\t\tif (useRap && sample.is_sync) {\n\t\t\trap_seek_sample_num = j;\n\t\t}\n\t}\n\tif (useRap) {\n\t\tseek_sample_num = rap_seek_sample_num;\n\t}\n\ttime = trak.samples[seek_sample_num].cts;\n\ttrak.nextSample = seek_sample_num;\n\twhile (trak.samples[seek_sample_num].alreadyRead === trak.samples[seek_sample_num].size) {\n\t\t// No remaining samples to look for, all are downloaded.\n\t\tif (!trak.samples[seek_sample_num + 1]) {\n\t\t\tbreak;\n\t\t}\n\t\tseek_sample_num++;\n\t}\n\tseek_offset = trak.samples[seek_sample_num].offset+trak.samples[seek_sample_num].alreadyRead;\n\tLog.info(\"ISOFile\", \"Seeking to \"+(useRap ? \"RAP\": \"\")+\" sample #\"+trak.nextSample+\" on track \"+trak.tkhd.track_id+\", time \"+Log.getDurationString(time, timescale) +\" and offset: \"+seek_offset);\n\treturn { offset: seek_offset, time: time/timescale };\n}\n\nISOFile.prototype.getTrackDuration = function (trak) {\n\tvar sample;\n\n\tif (!trak.samples) {\n\t\treturn Infinity;\n\t}\n\tsample = trak.samples[trak.samples.length - 1];\n\treturn (sample.cts + sample.duration) / sample.timescale;\n}\n\n/* Finds the byte offset in the file corresponding to the given time or to the time of the previous RAP */\nISOFile.prototype.seek = function(time, useRap) {\n\tvar moov = this.moov;\n\tvar trak;\n\tvar trak_seek_info;\n\tvar i;\n\tvar seek_info = { offset: Infinity, time: Infinity };\n\tif (!this.moov) {\n\t\tthrow \"Cannot seek: moov not received!\";\n\t} else {\n\t\tfor (i = 0; i<moov.traks.length; i++) {\n\t\t\ttrak = moov.traks[i];\n\t\t\tif (time > this.getTrackDuration(trak)) { // skip tracks that already ended\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrak_seek_info = this.seekTrack(time, useRap, trak);\n\t\t\tif (trak_seek_info.offset < seek_info.offset) {\n\t\t\t\tseek_info.offset = trak_seek_info.offset;\n\t\t\t}\n\t\t\tif (trak_seek_info.time < seek_info.time) {\n\t\t\t\tseek_info.time = trak_seek_info.time;\n\t\t\t}\n\t\t}\n\t\tLog.info(\"ISOFile\", \"Seeking at time \"+Log.getDurationString(seek_info.time, 1)+\" needs a buffer with a fileStart position of \"+seek_info.offset);\n\t\tif (seek_info.offset === Infinity) {\n\t\t\t/* No sample info, in all tracks, cannot seek */\n\t\t\tseek_info = { offset: this.nextParsePosition, time: 0 };\n\t\t} else {\n\t\t\t/* check if the seek position is already in some buffer and\n\t\t\t in that case return the end of that buffer (or of the last contiguous buffer) */\n\t\t\t/* TODO: Should wait until append operations are done */\n\t\t\tseek_info.offset = this.stream.getEndFilePositionAfter(seek_info.offset);\n\t\t}\n\t\tLog.info(\"ISOFile\", \"Adjusted seek position (after checking data already in buffer): \"+seek_info.offset);\n\t\treturn seek_info;\n\t}\n}\n\nISOFile.prototype.equal = function(b) {\n\tvar box_index = 0;\n\twhile (box_index < this.boxes.length && box_index < b.boxes.length) {\n\t\tvar a_box = this.boxes[box_index];\n\t\tvar b_box = b.boxes[box_index];\n\t\tif (!BoxParser.boxEqual(a_box, b_box)) {\n\t\t\treturn false;\n\t\t}\n\t\tbox_index++;\n\t}\n\treturn true;\n}\n\nif (typeof exports !== 'undefined') {\n\texports.ISOFile = ISOFile;\n}\n// file:src/isofile-advanced-parsing.js\n/* position in the current buffer of the beginning of the last box parsed */\nISOFile.prototype.lastBoxStartPosition = 0;\n/* indicator if the parsing is stuck in the middle of an mdat box */\nISOFile.prototype.parsingMdat = null;\n/* next file position that the parser needs:\n    - 0 until the first buffer (i.e. fileStart ===0) has been received \n    - otherwise, the next box start until the moov box has been parsed\n    - otherwise, the position of the next sample to fetch\n */\nISOFile.prototype.nextParsePosition = 0;\n/* keep mdat data */\nISOFile.prototype.discardMdatData = false;\n\nISOFile.prototype.processIncompleteBox = function(ret) {\n\tvar box;\n\tvar merged;\n\tvar found;\n\t\n\t/* we did not have enough bytes in the current buffer to parse the entire box */\n\tif (ret.type === \"mdat\") { \n\t\t/* we had enough bytes to get its type and size and it's an 'mdat' */\n\t\t\n\t\t/* special handling for mdat boxes, since we don't actually need to parse it linearly \n\t\t   we create the box */\n\t\tbox = new BoxParser[ret.type+\"Box\"](ret.size);\t\n\t\tthis.parsingMdat = box;\n\t\tthis.boxes.push(box);\n\t\tthis.mdats.push(box);\t\t\t\n\t\tbox.start = ret.start;\n\t\tbox.hdr_size = ret.hdr_size;\n\t\tthis.stream.addUsedBytes(box.hdr_size);\n\n\t\t/* indicate that the parsing should start from the end of the box */\n\t\tthis.lastBoxStartPosition = box.start + box.size;\n \t\t/* let's see if we have the end of the box in the other buffers */\n\t\tfound = this.stream.seek(box.start + box.size, false, this.discardMdatData);\n\t\tif (found) {\n\t\t\t/* found the end of the box */\n\t\t\tthis.parsingMdat = null;\n\t\t\t/* let's see if we can parse more in this buffer */\n\t\t\treturn true;\n\t\t} else {\n\t\t\t/* 'mdat' end not found in the existing buffers */\n\t\t\t/* determine the next position in the file to start parsing from */\n\t\t\tif (!this.moovStartFound) {\n\t\t\t\t/* moov not find yet, \n\t\t\t\t   the file probably has 'mdat' at the beginning, and 'moov' at the end, \n\t\t\t\t   indicate that the downloader should not try to download those bytes now */\n\t\t\t\tthis.nextParsePosition = box.start + box.size;\n\t\t\t} else {\n\t\t\t\t/* we have the start of the moov box, \n\t\t\t\t   the next bytes should try to complete the current 'mdat' */\n\t\t\t\tthis.nextParsePosition = this.stream.findEndContiguousBuf();\n\t\t\t}\n\t\t\t/* not much we can do, wait for more buffers to arrive */\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t/* box is incomplete, we may not even know its type */\n\t\tif (ret.type === \"moov\") { \n\t\t\t/* the incomplete box is a 'moov' box */\n\t\t\tthis.moovStartFound = true;\n\t\t\tif (this.mdats.length === 0) {\n\t\t\t\tthis.isProgressive = true;\n\t\t\t}\n\t\t}\n\t\t/* either it's not an mdat box (and we need to parse it, we cannot skip it)\n\t\t   (TODO: we could skip 'free' boxes ...)\n\t\t\t   or we did not have enough data to parse the type and size of the box, \n\t\t   we try to concatenate the current buffer with the next buffer to restart parsing */\n\t\tmerged = (this.stream.mergeNextBuffer ? this.stream.mergeNextBuffer() : false);\n\t\tif (merged) {\n\t\t\t/* The next buffer was contiguous, the merging succeeded,\n\t\t\t   we can now continue parsing, \n\t\t\t   the next best position to parse is at the end of this new buffer */\n\t\t\tthis.nextParsePosition = this.stream.getEndPosition();\n\t\t\treturn true;\n\t\t} else {\n\t\t\t/* we cannot concatenate existing buffers because they are not contiguous or because there is no additional buffer */\n\t\t\t/* The next best position to parse is still at the end of this old buffer */\n\t\t\tif (!ret.type) {\n\t\t\t\t/* There were not enough bytes in the buffer to parse the box type and length,\n\t\t\t\t   the next fetch should retrieve those missing bytes, i.e. the next bytes after this buffer */\n\t\t\t\tthis.nextParsePosition = this.stream.getEndPosition();\n\t\t\t} else {\n\t\t\t\t/* we had enough bytes to parse size and type of the incomplete box\n\t\t\t\t   if we haven't found yet the moov box, skip this one and try the next one \n\t\t\t\t   if we have found the moov box, let's continue linear parsing */\n\t\t\t\tif (this.moovStartFound) {\n\t\t\t\t\tthis.nextParsePosition = this.stream.getEndPosition();\n\t\t\t\t} else {\n\t\t\t\t\tthis.nextParsePosition = this.stream.getPosition() + ret.size;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nISOFile.prototype.hasIncompleteMdat = function () {\n\treturn (this.parsingMdat !== null);\n}\n\nISOFile.prototype.processIncompleteMdat = function () {\n\tvar box;\n\tvar found;\n\t\n\t/* we are in the parsing of an incomplete mdat box */\n\tbox = this.parsingMdat;\n\n\tfound = this.stream.seek(box.start + box.size, false, this.discardMdatData);\n\tif (found) {\n\t\tLog.debug(\"ISOFile\", \"Found 'mdat' end in buffered data\");\n\t\t/* the end of the mdat has been found */ \n\t\tthis.parsingMdat = null;\n\t\t/* we can parse more in this buffer */\n\t\treturn true;\n\t} else {\n\t\t/* we don't have the end of this mdat yet, \n\t\t   indicate that the next byte to fetch is the end of the buffers we have so far, \n\t\t   return and wait for more buffer to come */\n\t\tthis.nextParsePosition = this.stream.findEndContiguousBuf();\n\t\treturn false;\n\t}\n}\n\nISOFile.prototype.restoreParsePosition = function() {\n\t/* Reposition at the start position of the previous box not entirely parsed */\n\treturn this.stream.seek(this.lastBoxStartPosition, true, this.discardMdatData);\n}\n\nISOFile.prototype.saveParsePosition = function() {\n\t/* remember the position of the box start in case we need to roll back (if the box is incomplete) */\n\tthis.lastBoxStartPosition = this.stream.getPosition();\t\n}\n\nISOFile.prototype.updateUsedBytes = function(box, ret) {\n\tif (this.stream.addUsedBytes) {\n\t\tif (box.type === \"mdat\") {\n\t\t\t/* for an mdat box, only its header is considered used, other bytes will be used when sample data is requested */\n\t\t\tthis.stream.addUsedBytes(box.hdr_size);\n\t\t\tif (this.discardMdatData) {\n\t\t\t\tthis.stream.addUsedBytes(box.size-box.hdr_size);\n\t\t\t}\n\t\t} else {\n\t\t\t/* for all other boxes, the entire box data is considered used */\n\t\t\tthis.stream.addUsedBytes(box.size);\n\t\t}\t\n\t}\n}\n// file:src/isofile-advanced-creation.js\nISOFile.prototype.add = BoxParser.Box.prototype.add;\nISOFile.prototype.addBox = BoxParser.Box.prototype.addBox;\n\nISOFile.prototype.init = function (_options) {\n\tvar options = _options || {}; \n\tvar ftyp = this.add(\"ftyp\").set(\"major_brand\", (options.brands && options.brands[0]) || \"iso4\")\n\t\t\t\t\t\t\t   .set(\"minor_version\", 0)\n\t\t\t\t\t\t\t   .set(\"compatible_brands\", options.brands || [\"iso4\"]);\n\tvar moov = this.add(\"moov\");\n\tmoov.add(\"mvhd\").set(\"timescale\", options.timescale || 600)\n\t\t\t\t\t.set(\"rate\", options.rate || 1<<16)\n\t\t\t\t\t.set(\"creation_time\", 0)\n\t\t\t\t\t.set(\"modification_time\", 0)\n\t\t\t\t\t.set(\"duration\", options.duration || 0)\n\t\t\t\t\t.set(\"volume\", (options.width) ? 0 : 0x0100)\n\t\t\t\t\t.set(\"matrix\", [ 1<<16, 0, 0, 0, 1<<16, 0, 0, 0, 0x40000000])\n\t\t\t\t\t.set(\"next_track_id\", 1);\n\tmoov.add(\"mvex\");\n\treturn this;\n}\n\nISOFile.prototype.addTrack = function (_options) {\n\tif (!this.moov) {\n\t\tthis.init(_options);\n\t}\n\n\tvar options = _options || {}; \n\toptions.width = options.width || 320;\n\toptions.height = options.height || 320;\n\toptions.id = options.id || this.moov.mvhd.next_track_id;\n\toptions.type = options.type || \"avc1\";\n\n\tvar trak = this.moov.add(\"trak\");\n\tthis.moov.mvhd.next_track_id = options.id+1;\n\ttrak.add(\"tkhd\").set(\"flags\",BoxParser.TKHD_FLAG_ENABLED | \n\t\t\t\t\t\t\t\t BoxParser.TKHD_FLAG_IN_MOVIE | \n\t\t\t\t\t\t\t\t BoxParser.TKHD_FLAG_IN_PREVIEW)\n\t\t\t\t\t.set(\"creation_time\",0)\n\t\t\t\t\t.set(\"modification_time\", 0)\n\t\t\t\t\t.set(\"track_id\", options.id)\n\t\t\t\t\t.set(\"duration\", options.duration || 0)\n\t\t\t\t\t.set(\"layer\", options.layer || 0)\n\t\t\t\t\t.set(\"alternate_group\", 0)\n\t\t\t\t\t.set(\"volume\", 1)\n\t\t\t\t\t.set(\"matrix\", [ 1<<16, 0, 0, 0, 1<<16, 0, 0, 0, 0x40000000])\n\t\t\t\t\t.set(\"width\", options.width << 16)\n\t\t\t\t\t.set(\"height\", options.height << 16);\n\n\tvar mdia = trak.add(\"mdia\");\n\tmdia.add(\"mdhd\").set(\"creation_time\", 0)\n\t\t\t\t\t.set(\"modification_time\", 0)\n\t\t\t\t\t.set(\"timescale\", options.timescale || 1)\n\t\t\t\t\t.set(\"duration\", options.media_duration || 0)\n\t\t\t\t\t.set(\"language\", options.language || \"und\");\n\n\tmdia.add(\"hdlr\").set(\"handler\", options.hdlr || \"vide\")\n\t\t\t\t\t.set(\"name\", options.name || \"Track created with MP4Box.js\");\n\n\tmdia.add(\"elng\").set(\"extended_language\", options.language || \"fr-FR\");\n\n\tvar minf = mdia.add(\"minf\");\n\tif (BoxParser[options.type+\"SampleEntry\"] === undefined) return;\n\tvar sample_description_entry = new BoxParser[options.type+\"SampleEntry\"]();\n\tsample_description_entry.data_reference_index = 1;\n\tvar media_type = \"\";\n\tfor (var mediaType in BoxParser.sampleEntryCodes) {\n\t\tvar codes = BoxParser.sampleEntryCodes[mediaType];\n\t\tfor (var i = 0; i < codes.length; i++) {\n\t\t\tif (codes.indexOf(options.type) > -1) {\n\t\t\t\tmedia_type = mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tswitch(media_type) {\n\t\tcase \"Visual\":\n\t\t\tminf.add(\"vmhd\").set(\"graphicsmode\",0).set(\"opcolor\", [ 0, 0, 0 ]);\n\t\t\tsample_description_entry.set(\"width\", options.width)\n\t\t\t\t\t\t.set(\"height\", options.height)\n\t\t\t\t\t\t.set(\"horizresolution\", 0x48<<16)\n\t\t\t\t\t\t.set(\"vertresolution\", 0x48<<16)\n\t\t\t\t\t\t.set(\"frame_count\", 1)\n\t\t\t\t\t\t.set(\"compressorname\", options.type+\" Compressor\")\n\t\t\t\t\t\t.set(\"depth\", 0x18);\n\t\t\tif (options.avcDecoderConfigRecord) {\n\t\t\t\tvar avcC = new BoxParser.avcCBox();\n\t\t\t\tavcC.parse(new MP4BoxStream(options.avcDecoderConfigRecord));\n\t\t\t\tsample_description_entry.addBox(avcC);\n\t\t\t} else if (options.hevcDecoderConfigRecord) {\n\t\t\t\tvar hvcC = new BoxParser.hvcCBox();\n\t\t\t\thvcC.parse(new MP4BoxStream(options.hevcDecoderConfigRecord));\n\t\t\t\tsample_description_entry.addBox(hvcC);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Audio\":\n\t\t\tminf.add(\"smhd\").set(\"balance\", options.balance || 0);\n\t\t\tsample_description_entry.set(\"channel_count\", options.channel_count || 2)\n\t\t\t\t\t\t.set(\"samplesize\", options.samplesize || 16)\n\t\t\t\t\t\t.set(\"samplerate\", options.samplerate || 1<<16);\n\t\t\tbreak;\n\t\tcase \"Hint\":\n\t\t\tminf.add(\"hmhd\"); // TODO: add properties\n\t\t\tbreak;\n\t\tcase \"Subtitle\":\n\t\t\tminf.add(\"sthd\");\n\t\t\tswitch (options.type) {\n\t\t\t\tcase \"stpp\":\n\t\t\t\t\tsample_description_entry.set(\"namespace\", options.namespace || \"nonamespace\")\n\t\t\t\t\t\t\t\t.set(\"schema_location\", options.schema_location || \"\")\n\t\t\t\t\t\t\t\t.set(\"auxiliary_mime_types\", options.auxiliary_mime_types || \"\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Metadata\":\n\t\t\tminf.add(\"nmhd\");\n\t\t\tbreak;\n\t\tcase \"System\":\n\t\t\tminf.add(\"nmhd\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tminf.add(\"nmhd\");\n\t\t\tbreak;\n\t}\n\tif (options.description) {\n\t\tsample_description_entry.addBox(options.description);\n\t}\n\tif (options.description_boxes) {\n\t\toptions.description_boxes.forEach(function (b) {\n\t\t\tsample_description_entry.addBox(b);\n\t\t});\n\t}\n\tminf.add(\"dinf\").add(\"dref\").addEntry((new BoxParser[\"url Box\"]()).set(\"flags\", 0x1));\n\tvar stbl = minf.add(\"stbl\");\n\tstbl.add(\"stsd\").addEntry(sample_description_entry);\n\tstbl.add(\"stts\").set(\"sample_counts\", [])\n\t\t\t\t\t.set(\"sample_deltas\", []);\n\tstbl.add(\"stsc\").set(\"first_chunk\", [])\n\t\t\t\t\t.set(\"samples_per_chunk\", [])\n\t\t\t\t\t.set(\"sample_description_index\", []);\n\tstbl.add(\"stco\").set(\"chunk_offsets\", []);\n\tstbl.add(\"stsz\").set(\"sample_sizes\", []);\n\n\tthis.moov.mvex.add(\"trex\").set(\"track_id\", options.id)\n\t\t\t\t\t\t\t  .set(\"default_sample_description_index\", options.default_sample_description_index || 1)\n\t\t\t\t\t\t\t  .set(\"default_sample_duration\", options.default_sample_duration || 0)\n\t\t\t\t\t\t\t  .set(\"default_sample_size\", options.default_sample_size || 0)\n\t\t\t\t\t\t\t  .set(\"default_sample_flags\", options.default_sample_flags || 0);\n\tthis.buildTrakSampleLists(trak);\n\treturn options.id;\n}\n\nBoxParser.Box.prototype.computeSize = function(stream_) {\n\tvar stream = stream_ || new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\tthis.write(stream);\n}\n\nISOFile.prototype.addSample = function (track_id, data, _options) {\n\tvar options = _options || {};\n\tvar sample = {};\n\tvar trak = this.getTrackById(track_id);\n\tif (trak === null) return;\n    sample.number = trak.samples.length;\n\tsample.track_id = trak.tkhd.track_id;\n\tsample.timescale = trak.mdia.mdhd.timescale;\n\tsample.description_index = (options.sample_description_index ? options.sample_description_index - 1: 0);\n\tsample.description = trak.mdia.minf.stbl.stsd.entries[sample.description_index];\n\tsample.data = data;\n\tsample.size = data.byteLength;\n\tsample.alreadyRead = sample.size;\n\tsample.duration = options.duration || 1;\n\tsample.cts = options.cts || 0;\n\tsample.dts = options.dts || 0;\n\tsample.is_sync = options.is_sync || false;\n\tsample.is_leading = options.is_leading || 0;\n\tsample.depends_on = options.depends_on || 0;\n\tsample.is_depended_on = options.is_depended_on || 0;\n\tsample.has_redundancy = options.has_redundancy || 0;\n\tsample.degradation_priority = options.degradation_priority || 0;\n\tsample.offset = 0;\n\tsample.subsamples = options.subsamples;\n\ttrak.samples.push(sample);\n\ttrak.samples_size += sample.size;\n\ttrak.samples_duration += sample.duration;\n\tif (trak.first_dts === undefined) {\n\t\ttrak.first_dts = options.dts;\n\t}\n\n\tthis.processSamples();\n\t\n\tvar moof = this.createSingleSampleMoof(sample);\n\tthis.addBox(moof);\n\tmoof.computeSize();\n\t/* adjusting the data_offset now that the moof size is known*/\n\tmoof.trafs[0].truns[0].data_offset = moof.size+8; //8 is mdat header\n\tthis.add(\"mdat\").data = new Uint8Array(data);\n\treturn sample;\n}\n\nISOFile.prototype.createSingleSampleMoof = function(sample) {\n\tvar sample_flags = 0;\n\tif (sample.is_sync)\n\t\tsample_flags = (1 << 25);  // sample_depends_on_none (I picture)\n\telse\n\t\tsample_flags = (1 << 16);  // non-sync\n\n\tvar moof = new BoxParser.moofBox();\n\tmoof.add(\"mfhd\").set(\"sequence_number\", this.nextMoofNumber);\n\tthis.nextMoofNumber++;\n\tvar traf = moof.add(\"traf\");\n\tvar trak = this.getTrackById(sample.track_id);\n\ttraf.add(\"tfhd\").set(\"track_id\", sample.track_id)\n\t\t\t\t\t.set(\"flags\", BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF);\n\ttraf.add(\"tfdt\").set(\"baseMediaDecodeTime\", (sample.dts - (trak.first_dts || 0)));\n\ttraf.add(\"trun\").set(\"flags\", BoxParser.TRUN_FLAGS_DATA_OFFSET | BoxParser.TRUN_FLAGS_DURATION | \n\t\t\t\t \t\t\t\t  BoxParser.TRUN_FLAGS_SIZE | BoxParser.TRUN_FLAGS_FLAGS | \n\t\t\t\t \t\t\t\t  BoxParser.TRUN_FLAGS_CTS_OFFSET)\n\t\t\t\t\t.set(\"data_offset\",0)\n\t\t\t\t\t.set(\"first_sample_flags\",0)\n\t\t\t\t\t.set(\"sample_count\",1)\n\t\t\t\t\t.set(\"sample_duration\",[sample.duration])\n\t\t\t\t\t.set(\"sample_size\",[sample.size])\n\t\t\t\t\t.set(\"sample_flags\",[sample_flags])\n\t\t\t\t\t.set(\"sample_composition_time_offset\", [sample.cts - sample.dts]);\n\treturn moof;\n}\n\n// file:src/isofile-sample-processing.js\n/* Index of the last moof box received */\nISOFile.prototype.lastMoofIndex = 0;\n\n/* size of the buffers allocated for samples */\nISOFile.prototype.samplesDataSize = 0;\n\n/* Resets all sample tables */\nISOFile.prototype.resetTables = function () {\n\tvar i;\n\tvar trak, stco, stsc, stsz, stts, ctts, stss;\n\tthis.initial_duration = this.moov.mvhd.duration;\n\tthis.moov.mvhd.duration = 0;\n\tfor (i = 0; i < this.moov.traks.length; i++) {\n\t\ttrak = this.moov.traks[i];\n\t\ttrak.tkhd.duration = 0;\n\t\ttrak.mdia.mdhd.duration = 0;\n\t\tstco = trak.mdia.minf.stbl.stco || trak.mdia.minf.stbl.co64;\n\t\tstco.chunk_offsets = [];\n\t\tstsc = trak.mdia.minf.stbl.stsc;\n\t\tstsc.first_chunk = [];\n\t\tstsc.samples_per_chunk = [];\n\t\tstsc.sample_description_index = [];\n\t\tstsz = trak.mdia.minf.stbl.stsz || trak.mdia.minf.stbl.stz2;\n\t\tstsz.sample_sizes = [];\n\t\tstts = trak.mdia.minf.stbl.stts;\n\t\tstts.sample_counts = [];\n\t\tstts.sample_deltas = [];\n\t\tctts = trak.mdia.minf.stbl.ctts;\n\t\tif (ctts) {\n\t\t\tctts.sample_counts = [];\n\t\t\tctts.sample_offsets = [];\n\t\t}\n\t\tstss = trak.mdia.minf.stbl.stss;\n\t\tvar k = trak.mdia.minf.stbl.boxes.indexOf(stss);\n\t\tif (k != -1) trak.mdia.minf.stbl.boxes[k] = null;\n\t}\n}\n\nISOFile.initSampleGroups = function(trak, traf, sbgps, trak_sgpds, traf_sgpds) {\n\tvar l;\n\tvar k;\n\tvar sample_groups_info;\n\tvar sample_group_info;\n\tvar sample_group_key;\n\tfunction SampleGroupInfo(_type, _parameter, _sbgp) {\n\t\tthis.grouping_type = _type;\n\t\tthis.grouping_type_parameter = _parameter;\n\t\tthis.sbgp = _sbgp;\n\t\tthis.last_sample_in_run = -1;\n\t\tthis.entry_index = -1;\t\t\n\t}\n\tif (traf) {\n\t\ttraf.sample_groups_info = [];\n\t} \n\tif (!trak.sample_groups_info) {\n\t\ttrak.sample_groups_info = [];\n\t}\n\tfor (k = 0; k < sbgps.length; k++) {\n\t\tsample_group_key = sbgps[k].grouping_type +\"/\"+ sbgps[k].grouping_type_parameter;\n\t\tsample_group_info = new SampleGroupInfo(sbgps[k].grouping_type, sbgps[k].grouping_type_parameter, sbgps[k]);\n\t\tif (traf) {\n\t\t\ttraf.sample_groups_info[sample_group_key] = sample_group_info;\n\t\t}\n\t\tif (!trak.sample_groups_info[sample_group_key]) {\n\t\t\ttrak.sample_groups_info[sample_group_key] = sample_group_info;\n\t\t}\n\t\tfor (l=0; l <trak_sgpds.length; l++) {\n\t\t\tif (trak_sgpds[l].grouping_type === sbgps[k].grouping_type) {\n\t\t\t\tsample_group_info.description = trak_sgpds[l];\n\t\t\t\tsample_group_info.description.used = true;\n\t\t\t}\n\t\t}\n\t\tif (traf_sgpds) {\n\t\t\tfor (l=0; l <traf_sgpds.length; l++) {\n\t\t\t\tif (traf_sgpds[l].grouping_type === sbgps[k].grouping_type) {\n\t\t\t\t\tsample_group_info.fragment_description = traf_sgpds[l];\n\t\t\t\t\tsample_group_info.fragment_description.used = true;\n\t\t\t\t\tsample_group_info.is_fragment = true;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\tif (!traf) {\n\t\tfor (k = 0; k < trak_sgpds.length; k++) {\n\t\t\tif (!trak_sgpds[k].used && trak_sgpds[k].version >= 2) {\n\t\t\t\tsample_group_key = trak_sgpds[k].grouping_type +\"/0\";\n\t\t\t\tsample_group_info = new SampleGroupInfo(trak_sgpds[k].grouping_type, 0);\n\t\t\t\tif (!trak.sample_groups_info[sample_group_key]) {\n\t\t\t\t\ttrak.sample_groups_info[sample_group_key] = sample_group_info;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (traf_sgpds) {\n\t\t\tfor (k = 0; k < traf_sgpds.length; k++) {\n\t\t\t\tif (!traf_sgpds[k].used && traf_sgpds[k].version >= 2) {\n\t\t\t\t\tsample_group_key = traf_sgpds[k].grouping_type +\"/0\";\n\t\t\t\t\tsample_group_info = new SampleGroupInfo(traf_sgpds[k].grouping_type, 0);\n\t\t\t\t\tsample_group_info.is_fragment = true;\n\t\t\t\t\tif (!traf.sample_groups_info[sample_group_key]) {\n\t\t\t\t\t\ttraf.sample_groups_info[sample_group_key] = sample_group_info;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nISOFile.setSampleGroupProperties = function(trak, sample, sample_number, sample_groups_info) {\n\tvar k;\n\tvar index;\n\tsample.sample_groups = [];\n\tfor (k in sample_groups_info) {\n\t\tsample.sample_groups[k] = {};\n\t\tsample.sample_groups[k].grouping_type = sample_groups_info[k].grouping_type;\n\t\tsample.sample_groups[k].grouping_type_parameter = sample_groups_info[k].grouping_type_parameter;\n\t\tif (sample_number >= sample_groups_info[k].last_sample_in_run) {\n\t\t\tif (sample_groups_info[k].last_sample_in_run < 0) {\n\t\t\t\tsample_groups_info[k].last_sample_in_run = 0;\n\t\t\t}\n\t\t\tsample_groups_info[k].entry_index++;\t\n\t\t\tif (sample_groups_info[k].entry_index <= sample_groups_info[k].sbgp.entries.length - 1) {\n\t\t\t\tsample_groups_info[k].last_sample_in_run += sample_groups_info[k].sbgp.entries[sample_groups_info[k].entry_index].sample_count;\n\t\t\t}\n\t\t}\n\t\tif (sample_groups_info[k].entry_index <= sample_groups_info[k].sbgp.entries.length - 1) {\n\t\t\tsample.sample_groups[k].group_description_index = sample_groups_info[k].sbgp.entries[sample_groups_info[k].entry_index].group_description_index;\n\t\t} else {\n\t\t\tsample.sample_groups[k].group_description_index = -1; // special value for not defined\n\t\t}\n\t\tif (sample.sample_groups[k].group_description_index !== 0) {\n\t\t\tvar description;\n\t\t\tif (sample_groups_info[k].fragment_description) {\n\t\t\t\tdescription = sample_groups_info[k].fragment_description;\n\t\t\t} else {\n\t\t\t\tdescription = sample_groups_info[k].description;\n\t\t\t}\n\t\t\tif (sample.sample_groups[k].group_description_index > 0) {\n\t\t\t\tif (sample.sample_groups[k].group_description_index > 65535) {\n\t\t\t\t\tindex = (sample.sample_groups[k].group_description_index >> 16)-1;\n\t\t\t\t} else {\n\t\t\t\t\tindex = sample.sample_groups[k].group_description_index-1;\n\t\t\t\t}\n\t\t\t\tif (description && index >= 0) {\n\t\t\t\t\tsample.sample_groups[k].description = description.entries[index];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (description && description.version >= 2) {\n\t\t\t\t\tif (description.default_group_description_index > 0) {\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tsample.sample_groups[k].description = description.entries[description.default_group_description_index-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nISOFile.process_sdtp = function (sdtp, sample, number) {\n\tif (!sample) {\n\t\treturn;\n\t}\n\tif (sdtp) {\n\t\tsample.is_leading = sdtp.is_leading[number];\n\t\tsample.depends_on = sdtp.sample_depends_on[number];\n\t\tsample.is_depended_on = sdtp.sample_is_depended_on[number];\n\t\tsample.has_redundancy = sdtp.sample_has_redundancy[number];\n\t} else {\n\t\tsample.is_leading = 0;\n\t\tsample.depends_on = 0;\n\t\tsample.is_depended_on = 0\n\t\tsample.has_redundancy = 0;\n\t}\t\n}\n\n/* Build initial sample list from  sample tables */\nISOFile.prototype.buildSampleLists = function() {\t\n\tvar i;\n\tvar trak;\n\tfor (i = 0; i < this.moov.traks.length; i++) {\n\t\ttrak = this.moov.traks[i];\n\t\tthis.buildTrakSampleLists(trak);\n\t}\n}\n\nISOFile.prototype.buildTrakSampleLists = function(trak) {\t\n\tvar j, k;\n\tvar stco, stsc, stsz, stts, ctts, stss, stsd, subs, sbgps, sgpds, stdp;\n\tvar chunk_run_index, chunk_index, last_chunk_in_run, offset_in_chunk, last_sample_in_chunk;\n\tvar last_sample_in_stts_run, stts_run_index, last_sample_in_ctts_run, ctts_run_index, last_stss_index, last_subs_index, subs_entry_index, last_subs_sample_index;\n\n\ttrak.samples = [];\n\ttrak.samples_duration = 0;\n\ttrak.samples_size = 0;\n\tstco = trak.mdia.minf.stbl.stco || trak.mdia.minf.stbl.co64;\n\tstsc = trak.mdia.minf.stbl.stsc;\n\tstsz = trak.mdia.minf.stbl.stsz || trak.mdia.minf.stbl.stz2;\n\tstts = trak.mdia.minf.stbl.stts;\n\tctts = trak.mdia.minf.stbl.ctts;\n\tstss = trak.mdia.minf.stbl.stss;\n\tstsd = trak.mdia.minf.stbl.stsd;\n\tsubs = trak.mdia.minf.stbl.subs;\n\tstdp = trak.mdia.minf.stbl.stdp;\n\tsbgps = trak.mdia.minf.stbl.sbgps;\n\tsgpds = trak.mdia.minf.stbl.sgpds;\n\t\n\tlast_sample_in_stts_run = -1;\n\tstts_run_index = -1;\n\tlast_sample_in_ctts_run = -1;\n\tctts_run_index = -1;\n\tlast_stss_index = 0;\n\tsubs_entry_index = 0;\n\tlast_subs_sample_index = 0;\t\t\n\n\tISOFile.initSampleGroups(trak, null, sbgps, sgpds);\n\n\tif (typeof stsz === \"undefined\") {\n\t\treturn;\n\t}\n\n\t/* we build the samples one by one and compute their properties */\n\tfor (j = 0; j < stsz.sample_sizes.length; j++) {\n\t\tvar sample = {};\n\t\tsample.number = j;\n\t\tsample.track_id = trak.tkhd.track_id;\n\t\tsample.timescale = trak.mdia.mdhd.timescale;\n\t\tsample.alreadyRead = 0;\n\t\ttrak.samples[j] = sample;\n\t\t/* size can be known directly */\n\t\tsample.size = stsz.sample_sizes[j];\n\t\ttrak.samples_size += sample.size;\n\t\t/* computing chunk-based properties (offset, sample description index)*/\n\t\tif (j === 0) {\t\t\t\t\n\t\t\tchunk_index = 1; /* the first sample is in the first chunk (chunk indexes are 1-based) */\n\t\t\tchunk_run_index = 0; /* the first chunk is the first entry in the first_chunk table */\n\t\t\tsample.chunk_index = chunk_index;\n\t\t\tsample.chunk_run_index = chunk_run_index;\n\t\t\tlast_sample_in_chunk = stsc.samples_per_chunk[chunk_run_index];\n\t\t\toffset_in_chunk = 0;\n\n\t\t\t/* Is there another entry in the first_chunk table ? */\n\t\t\tif (chunk_run_index + 1 < stsc.first_chunk.length) {\n\t\t\t\t/* The last chunk in the run is the chunk before the next first chunk */\n\t\t\t\tlast_chunk_in_run = stsc.first_chunk[chunk_run_index+1]-1; \t\n\t\t\t} else {\n\t\t\t\t/* There is only one entry in the table, it is valid for all future chunks*/\n\t\t\t\tlast_chunk_in_run = Infinity;\n\t\t\t}\n\t\t} else {\n\t\t\tif (j < last_sample_in_chunk) {\n\t\t\t\t/* the sample is still in the current chunk */\n\t\t\t\tsample.chunk_index = chunk_index;\n\t\t\t\tsample.chunk_run_index = chunk_run_index;\n\t\t\t} else {\n\t\t\t\t/* the sample is in the next chunk */\n\t\t\t\tchunk_index++;\n\t\t\t\tsample.chunk_index = chunk_index;\n\t\t\t\t/* reset the accumulated offset in the chunk */\n\t\t\t\toffset_in_chunk = 0;\n\t\t\t\tif (chunk_index <= last_chunk_in_run) {\n\t\t\t\t\t/* stay in the same entry of the first_chunk table */\n\t\t\t\t\t/* chunk_run_index unmodified */\n\t\t\t\t} else {\n\t\t\t\t\tchunk_run_index++;\n\t\t\t\t\t/* Is there another entry in the first_chunk table ? */\n\t\t\t\t\tif (chunk_run_index + 1 < stsc.first_chunk.length) {\n\t\t\t\t\t\t/* The last chunk in the run is the chunk before the next first chunk */\n\t\t\t\t\t\tlast_chunk_in_run = stsc.first_chunk[chunk_run_index+1]-1; \t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* There is only one entry in the table, it is valid for all future chunks*/\n\t\t\t\t\t\tlast_chunk_in_run = Infinity;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tsample.chunk_run_index = chunk_run_index;\n\t\t\t\tlast_sample_in_chunk += stsc.samples_per_chunk[chunk_run_index];\n\t\t\t}\n\t\t}\n\n\t\tsample.description_index = stsc.sample_description_index[sample.chunk_run_index]-1;\n\t\tsample.description = stsd.entries[sample.description_index];\n\t\tsample.offset = stco.chunk_offsets[sample.chunk_index-1] + offset_in_chunk; /* chunk indexes are 1-based */\n\t\toffset_in_chunk += sample.size;\n\n\t\t/* setting dts, cts, duration and rap flags */\n\t\tif (j > last_sample_in_stts_run) {\n\t\t\tstts_run_index++;\n\t\t\tif (last_sample_in_stts_run < 0) {\n\t\t\t\tlast_sample_in_stts_run = 0;\n\t\t\t}\n\t\t\tlast_sample_in_stts_run += stts.sample_counts[stts_run_index];\t\t\t\t\n\t\t}\n\t\tif (j > 0) {\n\t\t\ttrak.samples[j-1].duration = stts.sample_deltas[stts_run_index];\n\t\t\ttrak.samples_duration += trak.samples[j-1].duration;\n\t\t\tsample.dts = trak.samples[j-1].dts + trak.samples[j-1].duration;\n\t\t} else {\n\t\t\tsample.dts = 0;\n\t\t}\n\t\tif (ctts) {\n\t\t\tif (j >= last_sample_in_ctts_run) {\n\t\t\t\tctts_run_index++;\n\t\t\t\tif (last_sample_in_ctts_run < 0) {\n\t\t\t\t\tlast_sample_in_ctts_run = 0;\n\t\t\t\t}\n\t\t\t\tlast_sample_in_ctts_run += ctts.sample_counts[ctts_run_index];\t\t\t\t\n\t\t\t}\n\t\t\tsample.cts = trak.samples[j].dts + ctts.sample_offsets[ctts_run_index];\n\t\t} else {\n\t\t\tsample.cts = sample.dts;\n\t\t}\n\t\tif (stss) {\n\t\t\tif (j == stss.sample_numbers[last_stss_index] - 1) { // sample numbers are 1-based\n\t\t\t\tsample.is_sync = true;\n\t\t\t\tlast_stss_index++;\n\t\t\t} else {\n\t\t\t\tsample.is_sync = false;\t\t\t\t\n\t\t\t\tsample.degradation_priority = 0;\n\t\t\t}\n\t\t\tif (subs) {\n\t\t\t\tif (subs.entries[subs_entry_index].sample_delta + last_subs_sample_index == j+1) {\n\t\t\t\t\tsample.subsamples = subs.entries[subs_entry_index].subsamples;\n\t\t\t\t\tlast_subs_sample_index += subs.entries[subs_entry_index].sample_delta;\n\t\t\t\t\tsubs_entry_index++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsample.is_sync = true;\n\t\t}\n\t\tISOFile.process_sdtp(trak.mdia.minf.stbl.sdtp, sample, sample.number);\n\t\tif (stdp) {\n\t\t\tsample.degradation_priority = stdp.priority[j];\n\t\t} else {\n\t\t\tsample.degradation_priority = 0;\n\t\t}\n\t\tif (subs) {\n\t\t\tif (subs.entries[subs_entry_index].sample_delta + last_subs_sample_index == j) {\n\t\t\t\tsample.subsamples = subs.entries[subs_entry_index].subsamples;\n\t\t\t\tlast_subs_sample_index += subs.entries[subs_entry_index].sample_delta;\n\t\t\t}\n\t\t}\n\t\tif (sbgps.length > 0 || sgpds.length > 0) {\n\t\t\tISOFile.setSampleGroupProperties(trak, sample, j, trak.sample_groups_info);\n\t\t}\n\t}\n\tif (j>0) {\n\t\ttrak.samples[j-1].duration = Math.max(trak.mdia.mdhd.duration - trak.samples[j-1].dts, 0);\n\t\ttrak.samples_duration += trak.samples[j-1].duration;\n\t}\n}\n\n/* Update sample list when new 'moof' boxes are received */\nISOFile.prototype.updateSampleLists = function() {\t\n\tvar i, j, k;\n\tvar default_sample_description_index, default_sample_duration, default_sample_size, default_sample_flags;\n\tvar last_run_position;\n\tvar box, moof, traf, trak, trex;\n\tvar sample;\n\tvar sample_flags;\n\t\n\tif (this.moov === undefined) {\n\t\treturn;\n\t}\n\t/* if the input file is fragmented and fetched in multiple downloads, we need to update the list of samples */\n\twhile (this.lastMoofIndex < this.moofs.length) {\n\t\tbox = this.moofs[this.lastMoofIndex];\n\t\tthis.lastMoofIndex++;\n\t\tif (box.type == \"moof\") {\n\t\t\tmoof = box;\n\t\t\tfor (i = 0; i < moof.trafs.length; i++) {\n\t\t\t\ttraf = moof.trafs[i];\n\t\t\t\ttrak = this.getTrackById(traf.tfhd.track_id);\n\t\t\t\tif (trak.samples == null) trak.samples = []\n\n\t\t\t\ttrex = this.getTrexById(traf.tfhd.track_id);\n\t\t\t\tif (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) {\n\t\t\t\t\tdefault_sample_description_index = traf.tfhd.default_sample_description_index;\n\t\t\t\t} else {\n\t\t\t\t\tdefault_sample_description_index = (trex ? trex.default_sample_description_index: 1);\n\t\t\t\t}\n\t\t\t\tif (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) {\n\t\t\t\t\tdefault_sample_duration = traf.tfhd.default_sample_duration;\n\t\t\t\t} else {\n\t\t\t\t\tdefault_sample_duration = (trex ? trex.default_sample_duration : 0);\n\t\t\t\t}\n\t\t\t\tif (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) {\n\t\t\t\t\tdefault_sample_size = traf.tfhd.default_sample_size;\n\t\t\t\t} else {\n\t\t\t\t\tdefault_sample_size = (trex ? trex.default_sample_size : 0);\n\t\t\t\t}\n\t\t\t\tif (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) {\n\t\t\t\t\tdefault_sample_flags = traf.tfhd.default_sample_flags;\n\t\t\t\t} else {\n\t\t\t\t\tdefault_sample_flags = (trex ? trex.default_sample_flags : 0);\n\t\t\t\t}\n\t\t\t\ttraf.sample_number = 0;\n\t\t\t\t/* process sample groups */\n\t\t\t\tif (traf.sbgps.length > 0) {\n\t\t\t\t\tISOFile.initSampleGroups(trak, traf, traf.sbgps, trak.mdia.minf.stbl.sgpds, traf.sgpds);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < traf.truns.length; j++) {\n\t\t\t\t\tvar trun = traf.truns[j];\n\t\t\t\t\tfor (k = 0; k < trun.sample_count; k++) {\n\t\t\t\t\t\tsample = {};\n\t\t\t\t\t\tsample.moof_number = this.lastMoofIndex;\n\t\t\t\t\t\tsample.number_in_traf = traf.sample_number;\n\t\t\t\t\t\ttraf.sample_number++;\n\t\t\t            sample.number = trak.samples.length;\n\t\t\t\t\t\ttraf.first_sample_index = trak.samples.length;\n\t\t\t\t\t\ttrak.samples.push(sample);\n\t\t\t\t\t\tsample.track_id = trak.tkhd.track_id;\n\t\t\t\t\t\tsample.timescale = trak.mdia.mdhd.timescale;\n\t\t\t\t\t\tsample.description_index = default_sample_description_index-1;\n\t\t\t\t\t\tsample.description = trak.mdia.minf.stbl.stsd.entries[sample.description_index];\n\t\t\t\t\t\tsample.size = default_sample_size;\n\t\t\t\t\t\tif (trun.flags & BoxParser.TRUN_FLAGS_SIZE) {\n\t\t\t\t\t\t\tsample.size = trun.sample_size[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrak.samples_size += sample.size;\n\t\t\t\t\t\tsample.duration = default_sample_duration;\n\t\t\t\t\t\tif (trun.flags & BoxParser.TRUN_FLAGS_DURATION) {\n\t\t\t\t\t\t\tsample.duration = trun.sample_duration[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrak.samples_duration += sample.duration;\n\t\t\t\t\t\tif (trak.first_traf_merged || k > 0) {\n\t\t\t\t\t\t\tsample.dts = trak.samples[trak.samples.length-2].dts+trak.samples[trak.samples.length-2].duration;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (traf.tfdt) {\n\t\t\t\t\t\t\t\tsample.dts = traf.tfdt.baseMediaDecodeTime;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsample.dts = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttrak.first_traf_merged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsample.cts = sample.dts;\n\t\t\t\t\t\tif (trun.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n\t\t\t\t\t\t\tsample.cts = sample.dts + trun.sample_composition_time_offset[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsample_flags = default_sample_flags;\n\t\t\t\t\t\tif (trun.flags & BoxParser.TRUN_FLAGS_FLAGS) {\n\t\t\t\t\t\t\tsample_flags = trun.sample_flags[k];\n\t\t\t\t\t\t} else if (k === 0 && (trun.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG)) {\n\t\t\t\t\t\t\tsample_flags = trun.first_sample_flags;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsample.is_sync = ((sample_flags >> 16 & 0x1) ? false : true);\n\t\t\t\t\t\tsample.is_leading = (sample_flags >> 26 & 0x3);\n\t\t\t\t\t\tsample.depends_on = (sample_flags >> 24 & 0x3);\n\t\t\t\t\t\tsample.is_depended_on = (sample_flags >> 22 & 0x3);\n\t\t\t\t\t\tsample.has_redundancy = (sample_flags >> 20 & 0x3);\n\t\t\t\t\t\tsample.degradation_priority = (sample_flags & 0xFFFF);\n\t\t\t\t\t\t//ISOFile.process_sdtp(traf.sdtp, sample, sample.number_in_traf);\n\t\t\t\t\t\tvar bdop = (traf.tfhd.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) ? true : false;\n\t\t\t\t\t\tvar dbim = (traf.tfhd.flags & BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF) ? true : false;\n\t\t\t\t\t\tvar dop = (trun.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) ? true : false;\n\t\t\t\t\t\tvar bdo = 0;\n\t\t\t\t\t\tif (!bdop) {\n\t\t\t\t\t\t\tif (!dbim) {\n\t\t\t\t\t\t\t\tif (j === 0) { // the first track in the movie fragment\n\t\t\t\t\t\t\t\t\tbdo = moof.start; // the position of the first byte of the enclosing Movie Fragment Box\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbdo = last_run_position; // end of the data defined by the preceding *track* (irrespective of the track id) fragment in the moof\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbdo = moof.start;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbdo = traf.tfhd.base_data_offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === 0 && k === 0) {\n\t\t\t\t\t\t\tif (dop) {\n\t\t\t\t\t\t\t\tsample.offset = bdo + trun.data_offset; // If the data-offset is present, it is relative to the base-data-offset established in the track fragment header\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsample.offset = bdo; // the data for this run starts the base-data-offset defined by the track fragment header\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsample.offset = last_run_position; // this run starts immediately after the data of the previous run\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast_run_position = sample.offset + sample.size;\n\t\t\t\t\t\tif (traf.sbgps.length > 0 || traf.sgpds.length > 0 ||\n\t\t\t\t\t\t\ttrak.mdia.minf.stbl.sbgps.length > 0 || trak.mdia.minf.stbl.sgpds.length > 0) {\n\t\t\t\t\t\t\tISOFile.setSampleGroupProperties(trak, sample, sample.number_in_traf, traf.sample_groups_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (traf.subs) {\n\t\t\t\t\ttrak.has_fragment_subsamples = true;\n\t\t\t\t\tvar sample_index = traf.first_sample_index;\n\t\t\t\t\tfor (j = 0; j < traf.subs.entries.length; j++) {\n\t\t\t\t\t\tsample_index += traf.subs.entries[j].sample_delta;\n\t\t\t\t\t\tsample = trak.samples[sample_index-1];\n\t\t\t\t\t\tsample.subsamples = traf.subs.entries[j].subsamples;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\n/* Try to get sample data for a given sample:\n   returns null if not found\n   returns the same sample if already requested\n */\nISOFile.prototype.getSample = function(trak, sampleNum) {\t\n\tvar buffer;\n\tvar sample = trak.samples[sampleNum];\n\t\n\tif (!this.moov) {\n\t\treturn null;\n\t}\n\n\tif (!sample.data) {\n\t\t/* Not yet fetched */\n\t\tsample.data = new Uint8Array(sample.size);\n\t\tsample.alreadyRead = 0;\n\t\tthis.samplesDataSize += sample.size;\n\t\tLog.debug(\"ISOFile\", \"Allocating sample #\"+sampleNum+\" on track #\"+trak.tkhd.track_id+\" of size \"+sample.size+\" (total: \"+this.samplesDataSize+\")\");\n\t} else if (sample.alreadyRead == sample.size) {\n\t\t/* Already fetched entirely */\n\t\treturn sample;\n\t}\n\n\t/* The sample has only been partially fetched, we need to check in all buffers */\n\twhile(true) {\n\t\tvar index =\tthis.stream.findPosition(true, sample.offset + sample.alreadyRead, false);\n\t\tif (index > -1) {\n\t\t\tbuffer = this.stream.buffers[index];\n\t\t\tvar lengthAfterStart = buffer.byteLength - (sample.offset + sample.alreadyRead - buffer.fileStart);\n\t\t\tif (sample.size - sample.alreadyRead <= lengthAfterStart) {\n\t\t\t\t/* the (rest of the) sample is entirely contained in this buffer */\n\n\t\t\t\tLog.debug(\"ISOFile\",\"Getting sample #\"+sampleNum+\" data (alreadyRead: \"+sample.alreadyRead+\" offset: \"+\n\t\t\t\t\t(sample.offset+sample.alreadyRead - buffer.fileStart)+\" read size: \"+(sample.size - sample.alreadyRead)+\" full size: \"+sample.size+\")\");\n\n\t\t\t\tDataStream.memcpy(sample.data.buffer, sample.alreadyRead,\n\t\t\t\t                  buffer, sample.offset+sample.alreadyRead - buffer.fileStart, sample.size - sample.alreadyRead);\n\n\t\t\t\t/* update the number of bytes used in this buffer and check if it needs to be removed */\n\t\t\t\tbuffer.usedBytes += sample.size - sample.alreadyRead;\n\t\t\t\tthis.stream.logBufferLevel();\n\n\t\t\t\tsample.alreadyRead = sample.size;\n\n\t\t\t\treturn sample;\n\t\t\t} else {\n\t\t\t\t/* the sample does not end in this buffer */\n\n\t\t\t\tif (lengthAfterStart === 0) return null;\n\n\t\t\t\tLog.debug(\"ISOFile\",\"Getting sample #\"+sampleNum+\" partial data (alreadyRead: \"+sample.alreadyRead+\" offset: \"+\n\t\t\t\t\t(sample.offset+sample.alreadyRead - buffer.fileStart)+\" read size: \"+lengthAfterStart+\" full size: \"+sample.size+\")\");\n\n\t\t\t\tDataStream.memcpy(sample.data.buffer, sample.alreadyRead,\n\t\t\t\t                  buffer, sample.offset+sample.alreadyRead - buffer.fileStart, lengthAfterStart);\n\t\t\t\tsample.alreadyRead += lengthAfterStart;\n\n\t\t\t\t/* update the number of bytes used in this buffer and check if it needs to be removed */\n\t\t\t\tbuffer.usedBytes += lengthAfterStart;\n\t\t\t\tthis.stream.logBufferLevel();\n\n\t\t\t\t/* keep looking in the next buffer */\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\n/* Release the memory used to store the data of the sample */\nISOFile.prototype.releaseSample = function(trak, sampleNum) {\t\n\tvar sample = trak.samples[sampleNum];\n\tif (sample.data) {\n\t\tthis.samplesDataSize -= sample.size;\n\t\tsample.data = null;\n\t\tsample.alreadyRead = 0;\n\t\treturn sample.size;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nISOFile.prototype.getAllocatedSampleDataSize = function() {\n\treturn this.samplesDataSize;\n}\n\n/* Builds the MIME Type 'codecs' sub-parameters for the whole file */\nISOFile.prototype.getCodecs = function() {\t\n\tvar i;\n\tvar codecs = \"\";\n\tfor (i = 0; i < this.moov.traks.length; i++) {\n\t\tvar trak = this.moov.traks[i];\n\t\tif (i>0) {\n\t\t\tcodecs+=\",\"; \n\t\t}\n\t\tcodecs += trak.mdia.minf.stbl.stsd.entries[0].getCodec();\t\t\n\t}\n\treturn codecs;\n}\n\n/* Helper function */\nISOFile.prototype.getTrexById = function(id) {\t\n\tvar i;\n\tif (!this.moov || !this.moov.mvex) return null;\n\tfor (i = 0; i < this.moov.mvex.trexs.length; i++) {\n\t\tvar trex = this.moov.mvex.trexs[i];\n\t\tif (trex.track_id == id) return trex;\n\t}\n\treturn null;\n}\n\n/* Helper function */\nISOFile.prototype.getTrackById = function(id) {\n\tif (this.moov === undefined) {\n\t\treturn null;\n\t}\n\tfor (var j = 0; j < this.moov.traks.length; j++) {\n\t\tvar trak = this.moov.traks[j];\n\t\tif (trak.tkhd.track_id == id) return trak;\n\t}\n\treturn null;\n}\n// file:src/isofile-item-processing.js\nISOFile.prototype.items = [];\nISOFile.prototype.entity_groups = [];\n/* size of the buffers allocated for samples */\nISOFile.prototype.itemsDataSize = 0;\n\nISOFile.prototype.flattenItemInfo = function() {\t\n\tvar items = this.items;\n\tvar entity_groups = this.entity_groups;\n\tvar i, j;\n\tvar item;\n\tvar meta = this.meta;\n\tif (meta === null || meta === undefined) return;\n\tif (meta.hdlr === undefined) return;\n\tif (meta.iinf === undefined) return;\n\tfor (i = 0; i < meta.iinf.item_infos.length; i++) {\n\t\titem = {};\n\t\titem.id = meta.iinf.item_infos[i].item_ID;\n\t\titems[item.id] = item;\n\t\titem.ref_to = [];\n\t\titem.name = meta.iinf.item_infos[i].item_name;\n\t\tif (meta.iinf.item_infos[i].protection_index > 0) {\n\t\t\titem.protection = meta.ipro.protections[meta.iinf.item_infos[i].protection_index-1];\n\t\t}\n\t\tif (meta.iinf.item_infos[i].item_type) {\n\t\t\titem.type = meta.iinf.item_infos[i].item_type;\n\t\t} else {\n\t\t\titem.type = \"mime\";\n\t\t}\n\t\titem.content_type = meta.iinf.item_infos[i].content_type;\n\t\titem.content_encoding = meta.iinf.item_infos[i].content_encoding;\n\t}\n\tif (meta.grpl) {\n\t\tfor (i = 0; i < meta.grpl.boxes.length; i++) {\n\t\t\tentity_group = {};\n\t\t\tentity_group.id = meta.grpl.boxes[i].group_id;\n\t\t\tentity_group.entity_ids = meta.grpl.boxes[i].entity_ids;\n\t\t\tentity_group.type = meta.grpl.boxes[i].type;\n\t\t\tentity_groups[entity_group.id] = entity_group;\n\t\t}\n\t}\n\tif (meta.iloc) {\n\t\tfor(i = 0; i < meta.iloc.items.length; i++) {\n\t\t\tvar offset;\n\t\t\tvar itemloc = meta.iloc.items[i];\n\t\t\titem = items[itemloc.item_ID];\n\t\t\tif (itemloc.data_reference_index !== 0) {\n\t\t\t\tLog.warn(\"Item storage with reference to other files: not supported\");\n\t\t\t\titem.source = meta.dinf.boxes[itemloc.data_reference_index-1];\n\t\t\t}\n\t\t\tswitch(itemloc.construction_method) {\n\t\t\t\tcase 0: // offset into the file referenced by the data reference index\n\t\t\t\tbreak;\n\t\t\t\tcase 1: // offset into the idat box of this meta box\n\t\t\t\tLog.warn(\"Item storage with construction_method : not supported\");\n\t\t\t\tbreak;\n\t\t\t\tcase 2: // offset into another item\n\t\t\t\tLog.warn(\"Item storage with construction_method : not supported\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem.extents = [];\n\t\t\titem.size = 0;\n\t\t\tfor (j = 0; j < itemloc.extents.length; j++) {\n\t\t\t\titem.extents[j] = {};\n\t\t\t\titem.extents[j].offset = itemloc.extents[j].extent_offset + itemloc.base_offset;\n\t\t\t\titem.extents[j].length = itemloc.extents[j].extent_length;\n\t\t\t\titem.extents[j].alreadyRead = 0;\n\t\t\t\titem.size += item.extents[j].length;\n\t\t\t}\n\t\t}\n\t}\n\tif (meta.pitm) {\n\t\titems[meta.pitm.item_id].primary = true;\n\t}\n\tif (meta.iref) {\n\t\tfor (i=0; i <meta.iref.references.length; i++) {\n\t\t\tvar ref = meta.iref.references[i];\n\t\t\tfor (j=0; j<ref.references.length; j++) {\n\t\t\t\titems[ref.from_item_ID].ref_to.push({type: ref.type, id: ref.references[j]});\n\t\t\t}\n\t\t}\n\t}\n\tif (meta.iprp) {\n\t\tfor (var k = 0; k < meta.iprp.ipmas.length; k++) {\n\t\t\tvar ipma = meta.iprp.ipmas[k];\n\t\t\tfor (i = 0; i < ipma.associations.length; i++) {\n\t\t\t\tvar association = ipma.associations[i];\n\t\t\t\titem = items[association.id];\n\t\t\t\tif (!item) {\n\t\t\t\t\titem = entity_groups[association.id];\n\t\t\t\t}\n\t\t\t\tif (item) {\n\t\t\t\t\tif (item.properties === undefined) {\n\t\t\t\t\t\titem.properties = {};\n\t\t\t\t\t\titem.properties.boxes = [];\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < association.props.length; j++) {\n\t\t\t\t\t\tvar propEntry = association.props[j];\n\t\t\t\t\t\tif (propEntry.property_index > 0 && propEntry.property_index-1 < meta.iprp.ipco.boxes.length) {\n\t\t\t\t\t\t\tvar propbox = meta.iprp.ipco.boxes[propEntry.property_index-1];\n\t\t\t\t\t\t\titem.properties[propbox.type] = propbox;\n\t\t\t\t\t\t\titem.properties.boxes.push(propbox);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nISOFile.prototype.getItem = function(item_id) {\t\n\tvar buffer;\n\tvar item;\n\t\n\tif (!this.meta) {\n\t\treturn null;\n\t}\n\n \titem = this.items[item_id];\n\tif (!item.data && item.size) {\n\t\t/* Not yet fetched */\n\t\titem.data = new Uint8Array(item.size);\n\t\titem.alreadyRead = 0;\n\t\tthis.itemsDataSize += item.size;\n\t\tLog.debug(\"ISOFile\", \"Allocating item #\"+item_id+\" of size \"+item.size+\" (total: \"+this.itemsDataSize+\")\");\n\t} else if (item.alreadyRead === item.size) {\n\t\t/* Already fetched entirely */\n\t\treturn item;\n\t}\n\n\t/* The item has only been partially fetched, we need to check in all buffers to find the remaining extents*/\n\n\tfor (var i = 0; i < item.extents.length; i++) {\n\t\tvar extent = item.extents[i];\n\t\tif (extent.alreadyRead === extent.length) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tvar index =\tthis.stream.findPosition(true, extent.offset + extent.alreadyRead, false);\n\t\t\tif (index > -1) {\n\t\t\t\tbuffer = this.stream.buffers[index];\n\t\t\t\tvar lengthAfterStart = buffer.byteLength - (extent.offset + extent.alreadyRead - buffer.fileStart);\n\t\t\t\tif (extent.length - extent.alreadyRead <= lengthAfterStart) {\n\t\t\t\t\t/* the (rest of the) extent is entirely contained in this buffer */\n\n\t\t\t\t\tLog.debug(\"ISOFile\",\"Getting item #\"+item_id+\" extent #\"+i+\" data (alreadyRead: \"+extent.alreadyRead+\n\t\t\t\t\t\t\" offset: \"+(extent.offset+extent.alreadyRead - buffer.fileStart)+\" read size: \"+(extent.length - extent.alreadyRead)+\n\t\t\t\t\t\t\" full extent size: \"+extent.length+\" full item size: \"+item.size+\")\");\n\n\t\t\t\t\tDataStream.memcpy(item.data.buffer, item.alreadyRead, \n\t\t\t\t\t                  buffer, extent.offset+extent.alreadyRead - buffer.fileStart, extent.length - extent.alreadyRead);\n\n\t\t\t\t\t/* update the number of bytes used in this buffer and check if it needs to be removed */\n\t\t\t\t\tbuffer.usedBytes += extent.length - extent.alreadyRead;\n\t\t\t\t\tthis.stream.logBufferLevel();\n\n\t\t\t\t\titem.alreadyRead += (extent.length - extent.alreadyRead);\n\t\t\t\t\textent.alreadyRead = extent.length;\n\t\t\t\t} else {\n\t\t\t\t\t/* the sample does not end in this buffer */\n\n\t\t\t\t\tLog.debug(\"ISOFile\",\"Getting item #\"+item_id+\" extent #\"+i+\" partial data (alreadyRead: \"+extent.alreadyRead+\" offset: \"+\n\t\t\t\t\t\t(extent.offset+extent.alreadyRead - buffer.fileStart)+\" read size: \"+lengthAfterStart+\n\t\t\t\t\t\t\" full extent size: \"+extent.length+\" full item size: \"+item.size+\")\");\n\n\t\t\t\t\tDataStream.memcpy(item.data.buffer, item.alreadyRead, \n\t\t\t\t\t                  buffer, extent.offset+extent.alreadyRead - buffer.fileStart, lengthAfterStart);\n\t\t\t\t\textent.alreadyRead += lengthAfterStart;\n\t\t\t\t\titem.alreadyRead += lengthAfterStart;\n\n\t\t\t\t\t/* update the number of bytes used in this buffer and check if it needs to be removed */\n\t\t\t\t\tbuffer.usedBytes += lengthAfterStart;\n\t\t\t\t\tthis.stream.logBufferLevel();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tif (item.alreadyRead === item.size) {\n\t\t/* fetched entirely */\n\t\treturn item;\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/* Release the memory used to store the data of the item */\nISOFile.prototype.releaseItem = function(item_id) {\t\n\tvar item = this.items[item_id];\n\tif (item.data) {\n\t\tthis.itemsDataSize -= item.size;\n\t\titem.data = null;\n\t\titem.alreadyRead = 0;\n\t\tfor (var i = 0; i < item.extents.length; i++) {\n\t\t\tvar extent = item.extents[i];\n\t\t\textent.alreadyRead = 0;\n\t\t}\n\t\treturn item.size;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n\nISOFile.prototype.processItems = function(callback) {\n\tfor(var i in this.items) {\n\t\tvar item = this.items[i];\n\t\tthis.getItem(item.id);\n\t\tif (callback && !item.sent) {\n\t\t\tcallback(item);\n\t\t\titem.sent = true;\n\t\t\titem.data = null;\n\t\t}\n\t}\n}\n\nISOFile.prototype.hasItem = function(name) {\n\tfor(var i in this.items) {\n\t\tvar item = this.items[i];\n\t\tif (item.name === name) {\n\t\t\treturn item.id;\n\t\t}\n\t}\n\treturn -1;\n}\n\nISOFile.prototype.getMetaHandler = function() {\n\tif (!this.meta) {\n\t\treturn null;\n\t} else {\n\t\treturn this.meta.hdlr.handler;\t\t\n\t}\n}\n\nISOFile.prototype.getPrimaryItem = function() {\n\tif (!this.meta || !this.meta.pitm) {\n\t\treturn null;\n\t} else {\n\t\treturn this.getItem(this.meta.pitm.item_id);\n\t}\n}\n\nISOFile.prototype.itemToFragmentedTrackFile = function(_options) {\n\tvar options = _options || {};\n\tvar item = null;\n\tif (options.itemId) {\n\t\titem = this.getItem(options.itemId);\n\t} else {\n\t\titem = this.getPrimaryItem();\n\t}\n\tif (item == null) return null;\n\n\tvar file = new ISOFile();\n\tfile.discardMdatData = false;\n\t// assuming the track type is the same as the item type\n\tvar trackOptions = { type: item.type, description_boxes: item.properties.boxes};\n\tif (item.properties.ispe) {\n\t\ttrackOptions.width = item.properties.ispe.image_width;\n\t\ttrackOptions.height = item.properties.ispe.image_height;\n\t}\n\tvar trackId = file.addTrack(trackOptions);\n\tif (trackId) {\n\t\tfile.addSample(trackId, item.data);\n\t\treturn file;\n\t} else {\n\t\treturn null;\n\t}\n}\n\n// file:src/isofile-write.js\n/* Rewrite the entire file */\nISOFile.prototype.write = function(outstream) {\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tthis.boxes[i].write(outstream);\n\t}\n}\n\nISOFile.prototype.createFragment = function(track_id, sampleNumber, stream_) {\n\tvar trak = this.getTrackById(track_id);\n\tvar sample = this.getSample(trak, sampleNumber);\n\tif (sample == null) {\n\t\tthis.setNextSeekPositionFromSample(trak.samples[sampleNumber]);\n\t\treturn null;\n\t}\n\t\n\tvar stream = stream_ || new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\n\tvar moof = this.createSingleSampleMoof(sample);\n\tmoof.write(stream);\n\n\t/* adjusting the data_offset now that the moof size is known*/\n\tmoof.trafs[0].truns[0].data_offset = moof.size+8; //8 is mdat header\n\tLog.debug(\"MP4Box\", \"Adjusting data_offset with new value \"+moof.trafs[0].truns[0].data_offset);\n\tstream.adjustUint32(moof.trafs[0].truns[0].data_offset_position, moof.trafs[0].truns[0].data_offset);\n\t\t\n\tvar mdat = new BoxParser.mdatBox();\n\tmdat.data = sample.data;\n\tmdat.write(stream);\n\treturn stream;\n}\n\n/* Modify the file and create the initialization segment */\nISOFile.writeInitializationSegment = function(ftyp, moov, total_duration, sample_duration) {\n\tvar i;\n\tvar index;\n\tvar mehd;\n\tvar trex;\n\tvar box;\n\tLog.debug(\"ISOFile\", \"Generating initialization segment\");\n\n\tvar stream = new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\tftyp.write(stream);\n\t\n\t/* we can now create the new mvex box */\n\tvar mvex = moov.add(\"mvex\");\n\tif (total_duration) {\n\t\tmvex.add(\"mehd\").set(\"fragment_duration\", total_duration);\n\t}\n\tfor (i = 0; i < moov.traks.length; i++) {\n\t\tmvex.add(\"trex\").set(\"track_id\", moov.traks[i].tkhd.track_id)\n\t\t\t\t\t\t.set(\"default_sample_description_index\", 1)\n\t\t\t\t\t\t.set(\"default_sample_duration\", sample_duration)\n\t\t\t\t\t\t.set(\"default_sample_size\", 0)\n\t\t\t\t\t\t.set(\"default_sample_flags\", 1<<16)\n\t}\n\tmoov.write(stream);\n\n\treturn stream.buffer;\n\n}\n\nISOFile.prototype.save = function(name) {\n\tvar stream = new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\tthis.write(stream);\n\tstream.save(name);\t\n}\n\nISOFile.prototype.getBuffer = function() {\n\tvar stream = new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\tthis.write(stream);\n\treturn stream.buffer;\n}\n\nISOFile.prototype.initializeSegmentation = function() {\n\tvar i;\n\tvar j;\n\tvar box;\n\tvar initSegs;\n\tvar trak;\n\tvar seg;\n\tif (this.onSegment === null) {\n\t\tLog.warn(\"MP4Box\", \"No segmentation callback set!\");\n\t}\n\tif (!this.isFragmentationInitialized) {\n\t\tthis.isFragmentationInitialized = true;\t\t\n\t\tthis.nextMoofNumber = 0;\n\t\tthis.resetTables();\n\t}\t\n\tinitSegs = [];\t\n\tfor (i = 0; i < this.fragmentedTracks.length; i++) {\n\t\tvar moov = new BoxParser.moovBox();\n\t\tmoov.mvhd = this.moov.mvhd;\n\t    moov.boxes.push(moov.mvhd);\n\t\ttrak = this.getTrackById(this.fragmentedTracks[i].id);\n\t\tmoov.boxes.push(trak);\n\t\tmoov.traks.push(trak);\n\t\tseg = {};\n\t\tseg.id = trak.tkhd.track_id;\n\t\tseg.user = this.fragmentedTracks[i].user;\n\t\tseg.buffer = ISOFile.writeInitializationSegment(this.ftyp, moov, (this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration: undefined), (this.moov.traks[i].samples.length>0 ? this.moov.traks[i].samples[0].duration: 0));\n\t\tinitSegs.push(seg);\n\t}\n\treturn initSegs;\n}\n\n// file:src/box-print.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nBoxParser.Box.prototype.printHeader = function(output) {\n\tthis.size += 8;\n\tif (this.size > MAX_SIZE) {\n\t\tthis.size += 8;\n\t}\n\tif (this.type === \"uuid\") {\n\t\tthis.size += 16;\n\t}\n\toutput.log(output.indent+\"size:\"+this.size);\n\toutput.log(output.indent+\"type:\"+this.type);\n}\n\nBoxParser.FullBox.prototype.printHeader = function(output) {\n\tthis.size += 4;\n\tBoxParser.Box.prototype.printHeader.call(this, output);\n\toutput.log(output.indent+\"version:\"+this.version);\n\toutput.log(output.indent+\"flags:\"+this.flags);\n}\n\nBoxParser.Box.prototype.print = function(output) {\n\tthis.printHeader(output);\n}\n\nBoxParser.ContainerBox.prototype.print = function(output) {\n\tthis.printHeader(output);\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tif (this.boxes[i]) {\n\t\t\tvar prev_indent = output.indent;\n\t\t\toutput.indent += \" \";\n\t\t\tthis.boxes[i].print(output);\n\t\t\toutput.indent = prev_indent;\n\t\t}\n\t}\n}\n\nISOFile.prototype.print = function(output) {\n\toutput.indent = \"\";\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tif (this.boxes[i]) {\n\t\t\tthis.boxes[i].print(output);\n\t\t}\n\t}\t\n}\n\nBoxParser.mvhdBox.prototype.print = function(output) {\n\tBoxParser.FullBox.prototype.printHeader.call(this, output);\n\toutput.log(output.indent+\"creation_time: \"+this.creation_time);\n\toutput.log(output.indent+\"modification_time: \"+this.modification_time);\n\toutput.log(output.indent+\"timescale: \"+this.timescale);\n\toutput.log(output.indent+\"duration: \"+this.duration);\n\toutput.log(output.indent+\"rate: \"+this.rate);\n\toutput.log(output.indent+\"volume: \"+(this.volume>>8));\n\toutput.log(output.indent+\"matrix: \"+this.matrix.join(\", \"));\n\toutput.log(output.indent+\"next_track_id: \"+this.next_track_id);\n}\n\nBoxParser.tkhdBox.prototype.print = function(output) {\n\tBoxParser.FullBox.prototype.printHeader.call(this, output);\n\toutput.log(output.indent+\"creation_time: \"+this.creation_time);\n\toutput.log(output.indent+\"modification_time: \"+this.modification_time);\n\toutput.log(output.indent+\"track_id: \"+this.track_id);\n\toutput.log(output.indent+\"duration: \"+this.duration);\n\toutput.log(output.indent+\"volume: \"+(this.volume>>8));\n\toutput.log(output.indent+\"matrix: \"+this.matrix.join(\", \"));\n\toutput.log(output.indent+\"layer: \"+this.layer);\n\toutput.log(output.indent+\"alternate_group: \"+this.alternate_group);\n\toutput.log(output.indent+\"width: \"+this.width);\n\toutput.log(output.indent+\"height: \"+this.height);\n}// file:src/mp4box.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar MP4Box = {};\n\nMP4Box.createFile = function (_keepMdatData, _stream) {\n\t/* Boolean indicating if bytes containing media data should be kept in memory */\n\tvar keepMdatData = (_keepMdatData !== undefined ? _keepMdatData : true);\n\tvar file = new ISOFile(_stream);\n\tfile.discardMdatData = (keepMdatData ? false : true);\n\treturn file;\n}\n\nif (typeof exports !== 'undefined') {\n\texports.createFile = MP4Box.createFile;\n}\n","var N = Object.defineProperty;\nvar E = (e) => {\n  throw TypeError(e);\n};\nvar P = (e, t, n) => t in e ? N(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar R = (e, t, n) => P(e, typeof t != \"symbol\" ? t + \"\" : t, n), Q = (e, t, n) => t.has(e) || E(\"Cannot \" + n);\nvar z = (e, t, n) => (Q(e, t, \"read from private field\"), n ? n.call(e) : t.get(e)), M = (e, t, n) => t.has(e) ? E(\"Cannot add the same private member more than once\") : t instanceof WeakSet ? t.add(e) : t.set(e, n);\nimport T from \"@webav/mp4box.js\";\nvar A;\nclass H {\n  constructor() {\n    M(this, A, /* @__PURE__ */ new Map());\n    /**\n     * 监听 EventType 中定义的事件\n     */\n    R(this, \"on\", (t, n) => {\n      const r = z(this, A).get(t) ?? /* @__PURE__ */ new Set();\n      return r.add(n), z(this, A).has(t) || z(this, A).set(t, r), () => {\n        r.delete(n), r.size === 0 && z(this, A).delete(t);\n      };\n    });\n    /**\n     * 监听事件，首次触发后自动移除监听\n     *\n     * 期望回调一次的事件，使用 once; 期望多次回调使用 on\n     */\n    R(this, \"once\", (t, n) => {\n      const r = this.on(t, (...o) => {\n        r(), n(...o);\n      });\n      return r;\n    });\n    /**\n     * 触发事件\n     * @param type\n     * @param args\n     * @returns\n     */\n    R(this, \"emit\", (t, ...n) => {\n      const r = z(this, A).get(t);\n      r != null && r.forEach((o) => o(...n));\n    });\n  }\n  /**\n   * 在两个 EventTool 实例间转发消息\n   * @param from\n   * @param to\n   * @param evtTypes 需转发的消息类型\n   *\n   * @example\n   * EventTool.forwardEvent(from, to, ['evtName']),\n   */\n  static forwardEvent(t, n, r) {\n    const o = r.map((s) => {\n      const [a, i] = Array.isArray(s) ? s : [s, s];\n      return t.on(a, (...d) => {\n        n.emit(i, ...d);\n      });\n    });\n    return () => {\n      o.forEach((s) => s());\n    };\n  }\n  destroy() {\n    z(this, A).clear();\n  }\n}\nA = new WeakMap();\nconst J = () => {\n  let e, t = 16.6;\n  self.onmessage = (n) => {\n    n.data.event === \"start\" && (self.clearInterval(e), e = self.setInterval(() => {\n      self.postMessage({});\n    }, t)), n.data.event === \"stop\" && self.clearInterval(e);\n  };\n}, j = () => {\n  const e = new Blob([`(${J.toString()})()`]), t = URL.createObjectURL(e);\n  return new Worker(t);\n}, k = /* @__PURE__ */ new Map();\nlet I = 1, B = null;\nglobalThis.Worker != null && (B = j(), B.onmessage = () => {\n  I += 1;\n  for (const [e, t] of k)\n    if (I % e === 0) for (const n of t) n();\n});\nconst q = (e, t) => {\n  const n = Math.round(t / 16.6), r = k.get(n) ?? /* @__PURE__ */ new Set();\n  return r.add(e), k.set(n, r), k.size === 1 && r.size === 1 && (B == null || B.postMessage({ event: \"start\" })), () => {\n    r.delete(e), r.size === 0 && k.delete(n), k.size === 0 && (I = 0, B == null || B.postMessage({ event: \"stop\" }));\n  };\n};\nfunction ae(e, t) {\n  let n = !1;\n  async function r() {\n    const o = e.getReader();\n    for (; !n; ) {\n      const { value: s, done: a } = await o.read();\n      if (a) {\n        t.onDone();\n        return;\n      }\n      await t.onChunk(s);\n    }\n    o.releaseLock(), await e.cancel();\n  }\n  return r().catch(console.error), () => {\n    n = !0;\n  };\n}\nfunction ce(e, t, n) {\n  let r = 0, o = 0;\n  const s = e.boxes;\n  let a = !1;\n  const i = () => {\n    var m;\n    if (!a)\n      if (s.find((y) => y.type === \"moof\") != null)\n        a = !0;\n      else\n        return null;\n    if (o >= s.length) return null;\n    const l = new T.DataStream();\n    l.endianness = T.DataStream.BIG_ENDIAN;\n    let h = o;\n    try {\n      for (; h < s.length; )\n        s[h].write(l), delete s[h], h += 1;\n    } catch (y) {\n      const x = s[h];\n      throw y instanceof Error && x != null ? Error(\n        `${y.message} | deltaBuf( boxType: ${x.type}, boxSize: ${x.size}, boxDataLen: ${((m = x.data) == null ? void 0 : m.length) ?? -1})`\n      ) : y;\n    }\n    return W(e), o = s.length, new Uint8Array(l.buffer);\n  };\n  let d = !1, c = !1, u = null;\n  return {\n    stream: new ReadableStream({\n      start(l) {\n        r = self.setInterval(() => {\n          const h = i();\n          h != null && !c && l.enqueue(h);\n        }, t), u = (h) => {\n          if (clearInterval(r), e.flush(), h != null) {\n            l.error(h);\n            return;\n          }\n          const m = i();\n          m != null && !c && l.enqueue(m), c || l.close();\n        }, d && u();\n      },\n      cancel() {\n        c = !0, clearInterval(r), n == null || n();\n      }\n    }),\n    stop: (l) => {\n      d || (d = !0, u == null || u(l));\n    }\n  };\n}\nfunction W(e) {\n  if (e.moov != null) {\n    for (var t = 0; t < e.moov.traks.length; t++)\n      e.moov.traks[t].samples = [];\n    e.mdats = [], e.moofs = [];\n  }\n}\nconst U = (e, t) => {\n  const n = new Uint8Array(8);\n  new DataView(n.buffer).setUint32(0, t);\n  for (let o = 0; o < 4; o++)\n    n[4 + o] = e.charCodeAt(o);\n  return n;\n}, F = () => {\n  const e = new TextEncoder(), t = e.encode(\"mdta\"), n = e.encode(\"mp4 handler\"), r = 32 + n.byteLength + 1, o = new Uint8Array(r), s = new DataView(o.buffer);\n  return o.set(U(\"hdlr\", r), 0), s.setUint32(8, 0), o.set(t, 16), o.set(n, 32), o;\n}, G = (e) => {\n  const t = new TextEncoder(), n = t.encode(\"mdta\"), r = e.map((c) => {\n    const u = t.encode(c), g = 8 + u.byteLength, l = new Uint8Array(g);\n    return new DataView(l.buffer).setUint32(0, g), l.set(n, 4), l.set(u, 4 + n.byteLength), l;\n  }), s = 16 + r.reduce((c, u) => c + u.byteLength, 0), a = new Uint8Array(s), i = new DataView(a.buffer);\n  a.set(U(\"keys\", s), 0), i.setUint32(8, 0), i.setUint32(12, e.length);\n  let d = 16;\n  for (const c of r)\n    a.set(c, d), d += c.byteLength;\n  return a;\n}, K = (e) => {\n  const t = new TextEncoder(), n = t.encode(\"data\"), r = Object.entries(e).map(([d, c], u) => {\n    const g = u + 1, l = t.encode(c), h = 24 + l.byteLength, m = new Uint8Array(h), y = new DataView(m.buffer);\n    return y.setUint32(0, h), y.setUint32(4, g), y.setUint32(8, 16 + l.byteLength), m.set(n, 12), y.setUint32(16, 1), m.set(l, 24), m;\n  }), s = 8 + r.reduce((d, c) => d + c.byteLength, 0), a = new Uint8Array(s);\n  a.set(U(\"ilst\", s), 0);\n  let i = 8;\n  for (const d of r)\n    a.set(d, i), i += d.byteLength;\n  return a;\n}, X = (e) => {\n  const t = F(), n = G(Object.keys(e)), r = K(e), o = t.length + n.length + r.length, s = new Uint8Array(o);\n  return s.set(t, 0), s.set(n, t.length), s.set(r, t.length + n.length), s;\n};\nfunction Y(e) {\n  return e instanceof Error ? String(e) : typeof e == \"object\" ? JSON.stringify(e, (t, n) => n instanceof Error ? String(n) : n) : String(e);\n}\nfunction Z() {\n  const e = /* @__PURE__ */ new Date();\n  return `${e.getHours()}:${e.getMinutes()}:${e.getSeconds()}.${e.getMilliseconds()}`;\n}\nlet C = 1;\nconst O = [], V = [\"debug\", \"info\", \"warn\", \"error\"].reduce(\n  (e, t, n) => Object.assign(e, {\n    [t]: (...r) => {\n      C <= n && (console[t](...r), O.push({\n        lvName: t,\n        timeStr: Z(),\n        args: r\n      }));\n    }\n  }),\n  {}\n), $ = /* @__PURE__ */ new Map(), S = {\n  /**\n   * 设置记录日志的级别\n   *\n   * @example\n   * Log.setLogLevel(Log.warn) // 记录 warn，error 日志\n   */\n  setLogLevel: (e) => {\n    C = $.get(e) ?? 1;\n  },\n  ...V,\n  /**\n   * 生成一个 log 实例，所有输出前都会附加 tag\n   *\n   * @example\n   * const log = Log.create('<prefix>')\n   * log.info('xxx') // '<prefix> xxx'\n   */\n  create: (e) => Object.fromEntries(\n    Object.entries(V).map(([t, n]) => [\n      t,\n      (...r) => n(e, ...r)\n    ])\n  ),\n  /**\n   * 将所有日志导出为一个字符串\n   *\n   * @example\n   * Log.dump() // => [level][time]  内容...\n   *\n   */\n  async dump() {\n    return O.reduce(\n      (e, { lvName: t, timeStr: n, args: r }) => e + `[${t}][${n}]  ${r.map((o) => Y(o)).join(\" \")}\n`,\n      \"\"\n    );\n  }\n};\n$.set(S.debug, 0);\n$.set(S.info, 1);\n$.set(S.warn, 2);\n$.set(S.error, 3);\n(async function() {\n  await Promise.resolve(), !(globalThis.navigator == null || globalThis.document == null) && (S.info(\n    `@webav version: 1.1.0, date: ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`\n  ), S.info(globalThis.navigator.userAgent), document.addEventListener(\"visibilitychange\", () => {\n    S.info(`visibilitychange: ${document.visibilityState}`);\n  }), \"PressureObserver\" in globalThis && new PressureObserver((n) => {\n    S.info(\n      `cpu state change: ${JSON.stringify(n.map((r) => r.state))}`\n    );\n  }).observe(\"cpu\"));\n})();\nfunction ie(e) {\n  S.info(\"recodemux opts:\", e);\n  const t = T.createFile(), n = new H(), r = (d, c) => {\n    const g = d.add(\"udta\").add(\"meta\");\n    g.data = X(c), g.size = g.data.byteLength;\n  };\n  let o = !1;\n  const s = () => {\n    t.moov == null || o || (o = !0, e.metaDataTags != null && r(t.moov, e.metaDataTags), e.duration != null && (t.moov.mvhd.duration = e.duration));\n  };\n  n.once(\"VideoReady\", s), n.once(\"AudioReady\", s);\n  let a = e.video != null ? ee(e.video, t, n) : null, i = e.audio != null ? ne(e.audio, t, n) : null;\n  return e.video == null && n.emit(\"VideoReady\"), e.audio == null && n.emit(\"AudioReady\"), {\n    encodeVideo: (d, c) => {\n      a == null || a.encode(d, c), d.close();\n    },\n    encodeAudio: (d) => {\n      if (i != null)\n        try {\n          i.encode(d), d.close();\n        } catch (c) {\n          const u = `encode audio chunk error: ${c.message}, state: ${JSON.stringify(\n            {\n              qSize: i.encodeQueueSize,\n              state: i.state\n            }\n          )}`;\n          throw S.error(u), Error(u);\n        }\n    },\n    getEncodeQueueSize: () => (a == null ? void 0 : a.encodeQueueSize) ?? (i == null ? void 0 : i.encodeQueueSize) ?? 0,\n    flush: async () => {\n      await Promise.all([\n        a == null ? void 0 : a.flush(),\n        (i == null ? void 0 : i.state) === \"configured\" ? i.flush() : null\n      ]);\n    },\n    close: () => {\n      n.destroy(), a == null || a.close(), (i == null ? void 0 : i.state) === \"configured\" && i.close();\n    },\n    mp4file: t\n  };\n}\nfunction ee(e, t, n) {\n  const r = {\n    // 微秒\n    timescale: 1e6,\n    width: e.width,\n    height: e.height,\n    brands: [\"isom\", \"iso2\", \"avc1\", \"mp42\", \"mp41\"],\n    avcDecoderConfigRecord: null,\n    name: \"Track created with WebAV\"\n  };\n  let o = -1, s = !1;\n  n.once(\"AudioReady\", () => {\n    s = !0;\n  });\n  const a = {\n    encoder0: [],\n    encoder1: []\n  }, i = (w, b, p) => {\n    var f;\n    if (o === -1 && p != null) {\n      const v = (f = p.decoderConfig) == null ? void 0 : f.description;\n      te(v), r.avcDecoderConfigRecord = v, o = t.addTrack(r), n.emit(\"VideoReady\"), S.info(\"VideoEncoder, video track ready, trackId:\", o);\n    }\n    a[w].push(L(b));\n  };\n  let d = \"encoder1\", c = 0;\n  const u = Math.floor(1e3 / e.expectFPS * 1e3);\n  function g() {\n    if (!s) return;\n    const w = d === \"encoder1\" ? \"encoder0\" : \"encoder1\", b = a[d], p = a[w];\n    if (b.length === 0 && p.length === 0) return;\n    let f = b[0];\n    if (f != null && (!f.is_sync || f.cts - c < u)) {\n      const D = l(b);\n      D > c && (c = D);\n    }\n    const v = p[0];\n    if (v != null && v.is_sync && v.cts - c < u) {\n      d = w, g();\n      return;\n    }\n    if (f != null && f.is_sync && (v != null && v.is_sync))\n      if (f.cts <= v.cts) {\n        const D = l(b);\n        D > c && (c = D);\n      } else {\n        d = w, g();\n        return;\n      }\n  }\n  function l(w) {\n    let b = -1, p = 0;\n    for (; p < w.length; p++) {\n      const f = w[p];\n      if (p > 0 && f.is_sync) break;\n      t.addSample(o, f.data, f), b = f.cts + f.duration;\n    }\n    return w.splice(0, p), b;\n  }\n  const h = q(g, 15), m = _(\n    e,\n    (w, b) => i(\"encoder0\", w, b)\n  ), y = _(\n    e,\n    (w, b) => i(\"encoder1\", w, b)\n  );\n  let x = 0;\n  return {\n    get encodeQueueSize() {\n      return m.encodeQueueSize + y.encodeQueueSize;\n    },\n    encode: (w, b) => {\n      try {\n        b.keyFrame && (x += 1), (x % 2 === 0 ? m : y).encode(w, b);\n      } catch (p) {\n        const f = `encode video frame error: ${p.message}, state: ${JSON.stringify(\n          {\n            ts: w.timestamp,\n            keyFrame: b.keyFrame,\n            duration: w.duration,\n            gopId: x\n          }\n        )}`;\n        throw S.error(f), Error(f);\n      }\n    },\n    flush: async () => {\n      await Promise.all([\n        m.state === \"configured\" ? await m.flush() : null,\n        y.state === \"configured\" ? await y.flush() : null\n      ]), h(), g();\n    },\n    close: () => {\n      m.state === \"configured\" && m.close(), y.state === \"configured\" && y.close();\n    }\n  };\n}\nfunction te(e) {\n  const t = new Uint8Array(e);\n  t[2].toString(2).slice(-2).includes(\"1\") && (t[2] = 0);\n}\nfunction _(e, t) {\n  const n = {\n    codec: e.codec,\n    framerate: e.expectFPS,\n    hardwareAcceleration: e.__unsafe_hardwareAcceleration__,\n    // 码率\n    bitrate: e.bitrate,\n    width: e.width,\n    height: e.height,\n    // H264 不支持背景透明度\n    alpha: \"discard\",\n    // macos 自带播放器只支持avc\n    avc: { format: \"avc\" }\n    // mp4box.js 无法解析 annexb 的 mimeCodec ，只会显示 avc1\n    // avc: { format: 'annexb' }\n  }, r = new VideoEncoder({\n    error: (o) => {\n      const s = `VideoEncoder error: ${o.message}, config: ${JSON.stringify(n)}, state: ${JSON.stringify(\n        {\n          qSize: r.encodeQueueSize,\n          state: r.state\n        }\n      )}`;\n      throw S.error(s), Error(s);\n    },\n    output: t\n  });\n  return r.configure(n), r;\n}\nfunction ne(e, t, n) {\n  const r = {\n    timescale: 1e6,\n    samplerate: e.sampleRate,\n    channel_count: e.channelCount,\n    hdlr: \"soun\",\n    type: e.codec === \"aac\" ? \"mp4a\" : \"Opus\",\n    name: \"Track created with WebAV\"\n  };\n  let o = -1, s = [], a = !1;\n  n.once(\"VideoReady\", () => {\n    a = !0, s.forEach((c) => {\n      const u = L(c);\n      t.addSample(o, u.data, u);\n    }), s = [];\n  });\n  const i = {\n    codec: e.codec === \"aac\" ? \"mp4a.40.2\" : \"opus\",\n    sampleRate: e.sampleRate,\n    numberOfChannels: e.channelCount,\n    bitrate: 128e3\n  }, d = new AudioEncoder({\n    error: (c) => {\n      const u = `AudioEncoder error: ${c.message}, config: ${JSON.stringify(\n        i\n      )}, state: ${JSON.stringify({\n        qSize: d.encodeQueueSize,\n        state: d.state\n      })}`;\n      throw S.error(u), Error(u);\n    },\n    output: (c, u) => {\n      var g;\n      if (o === -1) {\n        const l = (g = u.decoderConfig) == null ? void 0 : g.description;\n        o = t.addTrack({\n          ...r,\n          description: l == null ? void 0 : re(l)\n        }), n.emit(\"AudioReady\"), S.info(\"AudioEncoder, audio track ready, trackId:\", o);\n      }\n      if (a) {\n        const l = L(c);\n        t.addSample(o, l.data, l);\n      } else\n        s.push(c);\n    }\n  });\n  return d.configure(i), d;\n}\nfunction re(e) {\n  const t = e.byteLength, n = new Uint8Array([\n    0,\n    // version 0\n    0,\n    0,\n    0,\n    // flags\n    3,\n    // descriptor_type\n    23 + t,\n    // length\n    0,\n    // 0x01, // es_id\n    2,\n    // es_id\n    0,\n    // stream_priority\n    4,\n    // descriptor_type\n    18 + t,\n    // length\n    64,\n    // codec : mpeg4_audio\n    21,\n    // stream_type\n    0,\n    0,\n    0,\n    // buffer_size\n    0,\n    0,\n    0,\n    0,\n    // maxBitrate\n    0,\n    0,\n    0,\n    0,\n    // avgBitrate\n    5,\n    // descriptor_type\n    t,\n    ...new Uint8Array(e instanceof ArrayBuffer ? e : e.buffer),\n    6,\n    1,\n    2\n  ]), r = new T.BoxParser.esdsBox(n.byteLength);\n  return r.hdr_size = 0, r.parse(new T.DataStream(n, 0, T.DataStream.BIG_ENDIAN)), r;\n}\nfunction L(e) {\n  const t = new ArrayBuffer(e.byteLength);\n  e.copyTo(t);\n  const n = e.timestamp;\n  return {\n    duration: e.duration ?? 0,\n    dts: n,\n    cts: n,\n    is_sync: e.type === \"key\",\n    data: t\n  };\n}\nexport {\n  H as EventTool,\n  S as Log,\n  ae as autoReadStream,\n  ce as file2stream,\n  ie as recodemux,\n  q as workerTimer\n};\n//# sourceMappingURL=internal-utils.js.map\n","type EventKey = string | symbol;\n\ntype EventToolType = Record<EventKey, (...args: any[]) => any>;\n\n/**\n * 事件工具类\n *\n * @example\n * const evtTool = new EventTool<{\n *   timeupdate: (time: number) => void;\n *   paused: () => void;\n *   playing: () => void;\n * }>()\n * evtTool.on('paused', () => {})\n * evtTool.emit('paused')\n */\nexport class EventTool<T extends EventToolType> {\n  /**\n   * 在两个 EventTool 实例间转发消息\n   * @param from\n   * @param to\n   * @param evtTypes 需转发的消息类型\n   *\n   * @example\n   * EventTool.forwardEvent(from, to, ['evtName']),\n   */\n  static forwardEvent<\n    T1 extends EventToolType,\n    T2 extends EventToolType,\n    EvtType extends (keyof T1 | [keyof T1, keyof T2])[],\n  >(\n    from: { on: EventTool<T1>['on'] },\n    to: { emit: EventTool<T2>['emit'] },\n    // 转发的事件名，如果 evtTypes 为序对（元组）表示事件名称需要映射\n    evtTypes: EvtType,\n  ): () => void {\n    const removeHandlers = evtTypes.map((evtType) => {\n      const [fromEvtType, toEvtType] = (\n        Array.isArray(evtType) ? evtType : [evtType, evtType]\n      ) as [keyof T1, keyof T2];\n\n      // @ts-expect-error\n      return from.on(fromEvtType, (...args) => {\n        // @ts-expect-error\n        to.emit(toEvtType, ...args);\n      });\n    });\n    return () => {\n      removeHandlers.forEach((fn) => fn());\n    };\n  }\n\n  #listeners = new Map<keyof T, Set<T[keyof T]>>();\n\n  /**\n   * 监听 EventType 中定义的事件\n   */\n  on = <Type extends keyof T>(type: Type, listener: T[Type]): (() => void) => {\n    const handlers = this.#listeners.get(type) ?? new Set<T[keyof T]>();\n    handlers.add(listener);\n\n    if (!this.#listeners.has(type)) {\n      this.#listeners.set(type, handlers);\n    }\n\n    return () => {\n      handlers.delete(listener);\n      if (handlers.size === 0) {\n        this.#listeners.delete(type);\n      }\n    };\n  };\n\n  /**\n   * 监听事件，首次触发后自动移除监听\n   *\n   * 期望回调一次的事件，使用 once; 期望多次回调使用 on\n   */\n  once = <Type extends keyof T>(\n    type: Type,\n    listener: T[Type],\n  ): (() => void) => {\n    // @ts-ignore\n    const off = this.on(type, (...args) => {\n      off();\n      listener(...args);\n    });\n\n    return off;\n  };\n\n  /**\n   * 触发事件\n   * @param type\n   * @param args\n   * @returns\n   */\n  emit = <Type extends keyof T>(\n    type: Type,\n    ...args: Type extends string\n      ? T[Type] extends (...args: any[]) => any\n        ? Parameters<T[Type]>\n        : never\n      : never\n  ): void => {\n    const handlers = this.#listeners.get(type);\n    if (handlers == null) return;\n\n    handlers.forEach((handler) => handler(...args));\n  };\n\n  destroy(): void {\n    this.#listeners.clear();\n  }\n}\n","const setup = (): void => {\n  let timerId: number;\n\n  let interval: number = 16.6;\n\n  self.onmessage = (e) => {\n    if (e.data.event === 'start') {\n      self.clearInterval(timerId);\n      timerId = self.setInterval(() => {\n        self.postMessage({});\n      }, interval);\n    }\n\n    if (e.data.event === 'stop') {\n      self.clearInterval(timerId);\n    }\n  };\n};\n\nconst createWorker = (): Worker => {\n  const blob = new Blob([`(${setup.toString()})()`]);\n  const url = URL.createObjectURL(blob);\n  return new Worker(url);\n};\n\nconst handlerMap = new Map<number, Set<() => void>>();\nlet runCount = 1;\n\nlet worker: Worker | null = null;\nif (globalThis.Worker != null) {\n  worker = createWorker();\n  worker.onmessage = () => {\n    runCount += 1;\n    for (const [k, v] of handlerMap) {\n      if (runCount % k === 0) for (const fn of v) fn();\n    }\n  };\n}\n\n/**\n * 专门解决页面长时间处于后台时，定时器不（或延迟）执行的问题\n *\n * 跟 `setInterval` 很相似，⚠️ 但 time 会有一定偏差，请优先使用 `setInterval`\n *\n * @see [JS 定时器时长控制细节](https://hughfenghen.github.io/posts/2023/06/15/timer-delay/)\n */\nexport const workerTimer = (\n  handler: () => void,\n  time: number,\n): (() => void) => {\n  const groupId = Math.round(time / 16.6);\n  const fns = handlerMap.get(groupId) ?? new Set();\n  fns.add(handler);\n  handlerMap.set(groupId, fns);\n\n  if (handlerMap.size === 1 && fns.size === 1) {\n    worker?.postMessage({ event: 'start' });\n  }\n\n  return () => {\n    fns.delete(handler);\n    if (fns.size === 0) handlerMap.delete(groupId);\n    if (handlerMap.size === 0) {\n      runCount = 0;\n      worker?.postMessage({ event: 'stop' });\n    }\n  };\n};\n","import mp4box, { MP4File } from '@webav/mp4box.js';\n/**\n * 自动读取流并处理每个数据块。\n *\n * @template ST - 可读流的类型。\n * @param stream - 要读取的流。\n * @param cbs - 回调函数对象。\n * @param cbs.onChunk - 当读取到新的数据块时调用的函数。该函数接收一个参数，即数据块，并返回一个 Promise。\n * @param cbs.onDone - 当读取完所有数据块时调用的函数。\n * @returns - 返回一个函数，调用该函数可以停止读取流。\n *\n * @example\n * const stream = getSomeReadableStream();\n * const onChunk = async (chunk) => {\n *   console.log('New chunk:', chunk);\n * };\n * const onDone = () => {\n *   console.log('Done reading stream');\n * };\n * const stopReading = autoReadStream(stream, { onChunk, onDone });\n * // Later...\n * stopReading();\n */\nexport function autoReadStream<ST extends ReadableStream>(\n  stream: ST,\n  cbs: {\n    onChunk: ST extends ReadableStream<infer DT>\n      ? (chunk: DT) => Promise<void>\n      : never;\n    onDone: () => void;\n  },\n) {\n  let stoped = false;\n  async function run() {\n    const reader = stream.getReader();\n\n    while (!stoped) {\n      const { value, done } = await reader.read();\n      if (done) {\n        cbs.onDone();\n        return;\n      }\n      await cbs.onChunk(value);\n    }\n\n    reader.releaseLock();\n    await stream.cancel();\n  }\n\n  run().catch(console.error);\n\n  return () => {\n    stoped = true;\n  };\n}\n\n/**\n * 将 mp4box file 转换为文件流，用于上传服务器或存储到本地\n * @param file - MP4 文件实例 {@link MP4File}。\n * @param timeSlice - 时间片，用于控制流的发送速度。\n * @param onCancel - 当返回的流被取消时触发该回调函数\n */\nexport function file2stream(\n  file: MP4File,\n  timeSlice: number,\n  onCancel?: () => void,\n): {\n  /**\n   * 可读流，流的数据是 `Uint8Array`\n   */\n  stream: ReadableStream<Uint8Array>;\n  /**\n   * 流的生产者主动停止向流中输出数据，可向消费者传递错误信息\n   */\n  stop: (err?: Error) => void;\n} {\n  let timerId = 0;\n\n  let sendedBoxIdx = 0;\n  const boxes = file.boxes;\n\n  let firstMoofReady = false;\n  const deltaBuf = (): Uint8Array | null => {\n    // 避免 moov 未完成时写入文件，导致文件无法被识别\n    if (!firstMoofReady) {\n      if (boxes.find((box) => box.type === 'moof') != null) {\n        firstMoofReady = true;\n      } else {\n        return null;\n      }\n    }\n    if (sendedBoxIdx >= boxes.length) return null;\n\n    const ds = new mp4box.DataStream();\n    ds.endianness = mp4box.DataStream.BIG_ENDIAN;\n\n    let i = sendedBoxIdx;\n    try {\n      for (; i < boxes.length; ) {\n        boxes[i].write(ds);\n        delete boxes[i];\n        i += 1;\n      }\n    } catch (err) {\n      const errBox = boxes[i];\n      if (err instanceof Error && errBox != null) {\n        throw Error(\n          `${err.message} | deltaBuf( boxType: ${errBox.type}, boxSize: ${errBox.size}, boxDataLen: ${errBox.data?.length ?? -1})`,\n        );\n      }\n      throw err;\n    }\n\n    unsafeReleaseMP4BoxFile(file);\n\n    sendedBoxIdx = boxes.length;\n    return new Uint8Array(ds.buffer);\n  };\n\n  let stoped = false;\n  let canceled = false;\n  let exit: ((err?: Error) => void) | null = null;\n  const stream = new ReadableStream({\n    start(ctrl) {\n      timerId = self.setInterval(() => {\n        const d = deltaBuf();\n        if (d != null && !canceled) ctrl.enqueue(d);\n      }, timeSlice);\n\n      exit = (err) => {\n        clearInterval(timerId);\n        file.flush();\n        if (err != null) {\n          ctrl.error(err);\n          return;\n        }\n\n        const d = deltaBuf();\n        if (d != null && !canceled) ctrl.enqueue(d);\n\n        if (!canceled) ctrl.close();\n      };\n\n      // 安全起见，检测如果start触发时已经 stoped\n      if (stoped) exit();\n    },\n    cancel() {\n      canceled = true;\n      clearInterval(timerId);\n      onCancel?.();\n    },\n  });\n\n  return {\n    stream,\n    stop: (err) => {\n      if (stoped) return;\n      stoped = true;\n      exit?.(err);\n    },\n  };\n}\n\n/**\n * 强行回收 mp4boxfile 尽量降低内存占用，会破坏 file 导致无法正常使用\n * 仅用于获取二进制后，不再需要任何 file 功能的场景\n */\nfunction unsafeReleaseMP4BoxFile(file: MP4File) {\n  if (file.moov == null) return;\n  for (var j = 0; j < file.moov.traks.length; j++) {\n    file.moov.traks[j].samples = [];\n  }\n  file.mdats = [];\n  file.moofs = [];\n}\n","const createBoxHeader = (type: string, size: number): Uint8Array => {\n  const buffer = new Uint8Array(8);\n  const view = new DataView(buffer.buffer);\n  view.setUint32(0, size); // Write size as a 32-bit unsigned integer\n  for (let i = 0; i < 4; i++) {\n    buffer[4 + i] = type.charCodeAt(i); // Write type as a 4-character string\n  }\n  return buffer;\n};\n\nconst createHdlrBox = (): Uint8Array => {\n  const tec = new TextEncoder();\n  const handlerType = tec.encode('mdta');\n  const nameBytes = tec.encode('mp4 handler');\n  // header8 + ?8 + mdta4 + ?12 + nameSize + endFlag1\n  const size = 8 + 8 + 4 + 12 + nameBytes.byteLength + 1;\n  const buffer = new Uint8Array(size);\n  const view = new DataView(buffer.buffer);\n\n  // Box header\n  buffer.set(createBoxHeader('hdlr', size), 0);\n\n  // Full box header (version and flags)\n  view.setUint32(8, 0);\n\n  buffer.set(handlerType, 16);\n  buffer.set(nameBytes, 32);\n\n  return buffer;\n};\n\nconst createKeysBox = (keys: string[]): Uint8Array => {\n  const tec = new TextEncoder();\n  const keyNamespace = tec.encode('mdta');\n  const keyData = keys.map((key) => {\n    const keyBuf = tec.encode(key);\n    // size4 + namespace4 + keyBuf\n    const size = 4 + 4 + keyBuf.byteLength;\n\n    const entryBuf = new Uint8Array(size);\n    const dv = new DataView(entryBuf.buffer);\n    dv.setUint32(0, size);\n    entryBuf.set(keyNamespace, 4);\n    entryBuf.set(keyBuf, 4 + keyNamespace.byteLength);\n\n    return entryBuf;\n  });\n  const keyDataSize = keyData.reduce((acc, cur) => acc + cur.byteLength, 0);\n\n  const size = 16 + keyDataSize; // 16 bytes for the header and version/flags\n  const buffer = new Uint8Array(size);\n  const view = new DataView(buffer.buffer);\n\n  // Box header\n  buffer.set(createBoxHeader('keys', size), 0);\n\n  // Full box header (version and flags)\n  view.setUint32(8, 0);\n  view.setUint32(12, keys.length); // Entry count\n\n  // Keys\n  let offset = 16;\n  for (const keyBuf of keyData) {\n    buffer.set(keyBuf, offset);\n    offset += keyBuf.byteLength;\n  }\n\n  return buffer;\n};\n\nconst createIlstBox = (data: Record<string, string>): Uint8Array => {\n  const tec = new TextEncoder();\n  const dataStrBuf = tec.encode('data');\n  const valueData = Object.entries(data).map(([_, value], index) => {\n    const keyId = index + 1; // Assuming keys start from 1\n    const valueBytes = tec.encode(value);\n    // size4 + keyId4 + valueSize4 + data4 + idx4 + ?4 + value\n    const entrySize = 4 + 4 + 4 + 4 + 4 + 4 + valueBytes.byteLength;\n\n    const buffer = new Uint8Array(entrySize);\n    const view = new DataView(buffer.buffer);\n    view.setUint32(0, entrySize);\n    view.setUint32(4, keyId);\n\n    view.setUint32(8, 16 + valueBytes.byteLength);\n    buffer.set(dataStrBuf, 12); // 'data' type\n\n    // data idx=1\n    view.setUint32(16, 1);\n    // Value\n    buffer.set(valueBytes, 24);\n\n    return buffer;\n  });\n\n  const valueDataSize = valueData.reduce((acc, cur) => acc + cur.byteLength, 0);\n  const totalSizwe = 8 + valueDataSize;\n  const buffer = new Uint8Array(totalSizwe);\n  buffer.set(createBoxHeader('ilst', totalSizwe), 0);\n\n  let offset = 8;\n  for (const entry of valueData) {\n    buffer.set(entry, offset);\n    offset += entry.byteLength;\n  }\n\n  return buffer;\n};\n\nexport const createMetaBox = (data: Record<string, string>): Uint8Array => {\n  const hdlrBox = createHdlrBox();\n  const keysBox = createKeysBox(Object.keys(data));\n  const ilstBox = createIlstBox(data);\n\n  const size = hdlrBox.length + keysBox.length + ilstBox.length;\n  const buffer = new Uint8Array(size);\n\n  // buffer.set(createBoxHeader('meta', size), 0);\n  buffer.set(hdlrBox, 0);\n  buffer.set(keysBox, hdlrBox.length);\n  buffer.set(ilstBox, hdlrBox.length + keysBox.length);\n\n  return buffer;\n};\n","/**\n * 将任意对象转换成String，如果包含Error，则将Error转换为err.toString()\n * @param val any\n */\nfunction any2Str(val: any): string {\n  if (val instanceof Error) return String(val);\n  return typeof val === 'object'\n    ? JSON.stringify(val, (_, v) => (v instanceof Error ? String(v) : v))\n    : String(val);\n}\n\nfunction getTimeStr() {\n  const d = new Date();\n  return `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}.${d.getMilliseconds()}`;\n}\n\nlet THRESHOLD = 1;\n\ntype LvName = 'debug' | 'info' | 'warn' | 'error';\nconst history: Array<{ lvName: string; timeStr: string; args: any[] }> = [];\nconst lvHandler = ['debug', 'info', 'warn', 'error'].reduce(\n  (acc, lvName, lvThres) =>\n    Object.assign(acc, {\n      [lvName]: (...args: any[]) => {\n        if (THRESHOLD <= lvThres) {\n          console[lvName as LvName](...args);\n          history.push({\n            lvName,\n            timeStr: getTimeStr(),\n            args,\n          });\n        }\n      },\n    }),\n  {} as Record<LvName, typeof console.log>,\n);\n\nconst map = new Map<Function, number>();\n\n/**\n * 全局日志对象，将日志内容写入 OPFS 临时文件\n */\nexport const Log = {\n  /**\n   * 设置记录日志的级别\n   *\n   * @example\n   * Log.setLogLevel(Log.warn) // 记录 warn，error 日志\n   */\n  setLogLevel: <T extends Function>(logfn: T) => {\n    THRESHOLD = map.get(logfn) ?? 1;\n  },\n  ...lvHandler,\n  /**\n   * 生成一个 log 实例，所有输出前都会附加 tag\n   *\n   * @example\n   * const log = Log.create('<prefix>')\n   * log.info('xxx') // '<prefix> xxx'\n   */\n  create: (tag: string) => {\n    return Object.fromEntries(\n      Object.entries(lvHandler).map(([k, h]) => [\n        k,\n        (...args: any[]) => h(tag, ...args),\n      ]),\n    );\n  },\n\n  /**\n   * 将所有日志导出为一个字符串\n   *\n   * @example\n   * Log.dump() // => [level][time]  内容...\n   *\n   */\n  async dump() {\n    return history.reduce(\n      (acc, { lvName, timeStr, args }) =>\n        acc +\n        `[${lvName}][${timeStr}]  ${args.map((a) => any2Str(a)).join(' ')}\\n`,\n      '',\n    );\n  },\n};\n\nmap.set(Log.debug, 0);\nmap.set(Log.info, 1);\nmap.set(Log.warn, 2);\nmap.set(Log.error, 3);\n\ndeclare const PKG_VERSION: string;\n\ndeclare class PressureObserver {\n  constructor(\n    callback: (changes: PressureRecord[], observer: PressureObserver) => void,\n  );\n  observe(\n    resource: string,\n    options?: { sampleInterval?: number },\n  ): Promise<void>;\n  unobserve(): void;\n  takeRecords(): PressureRecord[];\n}\n\ninterface PressureRecord {\n  state: 'critical' | 'serious' | 'normal';\n}\n\n(async function init() {\n  await Promise.resolve();\n  if (globalThis.navigator == null || globalThis.document == null) return;\n  Log.info(\n    `@webav version: ${PKG_VERSION}, date: ${new Date().toLocaleDateString()}`,\n  );\n  Log.info(globalThis.navigator.userAgent);\n  document.addEventListener('visibilitychange', () => {\n    Log.info(`visibilitychange: ${document.visibilityState}`);\n  });\n\n  if ('PressureObserver' in globalThis) {\n    const observer = new PressureObserver((records) => {\n      Log.info(\n        `cpu state change: ${JSON.stringify(records.map((r) => r.state))}`,\n      );\n    });\n    observer.observe('cpu');\n  }\n})();\n\nif (import.meta.env?.DEV) {\n  Log.setLogLevel(Log.debug);\n}\n\nif (import.meta.env?.MODE === 'test') {\n  Log.setLogLevel(Log.warn);\n}\n","import mp4box, { MP4File, SampleOpts } from '@webav/mp4box.js';\nimport { EventTool } from './event-tool';\nimport { createMetaBox } from './meta-box';\nimport { workerTimer } from './worker-timer';\nimport { Log } from './log';\n\ntype TCleanFn = () => void;\n\n/**\n * 定义 recodemux 函数的配置选项\n */\ninterface IRecodeMuxOpts {\n  /**\n   * 视频配置选项，如果为 null 则不处理视频。\n   */\n  video: {\n    width: number;\n    height: number;\n    expectFPS: number;\n    codec: string;\n    bitrate: number;\n    /**\n     * 不安全，随时可能废弃\n     */\n    __unsafe_hardwareAcceleration__?: HardwareAcceleration;\n  } | null;\n  /**\n   * 音频配置选项，如果为 null 则不处理音频。\n   */\n  audio: {\n    codec: 'opus' | 'aac';\n    sampleRate: number;\n    channelCount: number;\n  } | null;\n  /**\n   * 预设时长，不代表 track 实际时长\n   */\n  duration?: number;\n  metaDataTags?: Record<string, string>;\n}\n\n/**\n * 处理音视频的编码和解码。\n * @param opts - 编码音视频数据的配置\n */\nexport function recodemux(opts: IRecodeMuxOpts): {\n  /**\n   * 编码视频帧\n   */\n  encodeVideo: (\n    frame: VideoFrame,\n    options: VideoEncoderEncodeOptions,\n    gopId?: number,\n  ) => void;\n  /**\n   * 编码音频数据\n   */\n  encodeAudio: (data: AudioData) => void;\n  /**\n   * close 编码器，停止任务\n   */\n  close: TCleanFn;\n  /**\n   * 清空编码器队列\n   */\n  flush: () => Promise<void>;\n  /**\n   * mp4box 实例\n   */\n  mp4file: MP4File;\n  /**\n   * 返回队列长度（背压），用于控制生产视频的进度，队列过大会会占用大量显存\n   */\n  getEncodeQueueSize: () => number;\n} {\n  Log.info('recodemux opts:', opts);\n  const mp4file = mp4box.createFile();\n\n  // 音视频轨道必须同时创建, 保存在 moov 中\n  const avSyncEvtTool = new EventTool<\n    Record<'VideoReady' | 'AudioReady', () => void>\n  >();\n\n  const addMetadata = (\n    moov: NonNullable<MP4File['moov']>,\n    tags: NonNullable<IRecodeMuxOpts['metaDataTags']>,\n  ) => {\n    const udtaBox = moov.add('udta');\n    const metaBox = udtaBox.add('meta');\n    metaBox.data = createMetaBox(tags);\n    metaBox.size = metaBox.data.byteLength;\n  };\n\n  let moovReady = false;\n  const onMoovReady = () => {\n    if (mp4file.moov == null || moovReady) return;\n    moovReady = true;\n\n    if (opts.metaDataTags != null) addMetadata(mp4file.moov, opts.metaDataTags);\n    if (opts.duration != null) {\n      mp4file.moov.mvhd.duration = opts.duration;\n    }\n  };\n\n  avSyncEvtTool.once('VideoReady', onMoovReady);\n  avSyncEvtTool.once('AudioReady', onMoovReady);\n\n  let vEncoder =\n    opts.video != null\n      ? encodeVideoTrack(opts.video, mp4file, avSyncEvtTool)\n      : null;\n  let aEncoder =\n    opts.audio != null\n      ? encodeAudioTrack(opts.audio, mp4file, avSyncEvtTool)\n      : null;\n  if (opts.video == null) avSyncEvtTool.emit('VideoReady');\n  if (opts.audio == null) avSyncEvtTool.emit('AudioReady');\n\n  return {\n    encodeVideo: (vf, opts) => {\n      vEncoder?.encode(vf, opts);\n      vf.close();\n    },\n    encodeAudio: (ad) => {\n      if (aEncoder == null) return;\n      try {\n        aEncoder.encode(ad);\n        ad.close();\n      } catch (err) {\n        const errMsg = `encode audio chunk error: ${(err as Error).message}, state: ${JSON.stringify(\n          {\n            qSize: aEncoder.encodeQueueSize,\n            state: aEncoder.state,\n          },\n        )}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      }\n    },\n    getEncodeQueueSize: () =>\n      vEncoder?.encodeQueueSize ?? aEncoder?.encodeQueueSize ?? 0,\n    flush: async () => {\n      await Promise.all([\n        vEncoder?.flush(),\n        aEncoder?.state === 'configured' ? aEncoder.flush() : null,\n      ]);\n      return;\n    },\n    close: () => {\n      avSyncEvtTool.destroy();\n      vEncoder?.close();\n      if (aEncoder?.state === 'configured') aEncoder.close();\n    },\n    mp4file,\n  };\n}\n\nfunction encodeVideoTrack(\n  opts: NonNullable<IRecodeMuxOpts['video']>,\n  mp4File: MP4File,\n  avSyncEvtTool: EventTool<Record<'VideoReady' | 'AudioReady', () => void>>,\n) {\n  const videoTrackOpts = {\n    // 微秒\n    timescale: 1e6,\n    width: opts.width,\n    height: opts.height,\n    brands: ['isom', 'iso2', 'avc1', 'mp42', 'mp41'],\n    avcDecoderConfigRecord: null as ArrayBuffer | undefined | null,\n    name: 'Track created with WebAV',\n  };\n\n  let trackId = -1;\n  let audioReady = false;\n  avSyncEvtTool.once('AudioReady', () => {\n    audioReady = true;\n  });\n\n  const samplesCache: Record<\n    'encoder0' | 'encoder1',\n    Array<ReturnType<typeof chunk2MP4SampleOpts>>\n  > = {\n    encoder0: [],\n    encoder1: [],\n  };\n  const outputHandler = (\n    encId: 'encoder0' | 'encoder1',\n    chunk: EncodedVideoChunk,\n    meta?: EncodedVideoChunkMetadata,\n  ) => {\n    if (trackId === -1 && meta != null) {\n      const desc = meta.decoderConfig?.description as ArrayBuffer;\n      fixChromeConstraintSetFlagsBug(desc);\n      videoTrackOpts.avcDecoderConfigRecord = desc;\n      trackId = mp4File.addTrack(videoTrackOpts);\n      avSyncEvtTool.emit('VideoReady');\n      Log.info('VideoEncoder, video track ready, trackId:', trackId);\n    }\n\n    samplesCache[encId].push(chunk2MP4SampleOpts(chunk));\n  };\n\n  let curEncId: 'encoder0' | 'encoder1' = 'encoder1';\n  let lastAddedSampleTime = 0;\n  // 双编码器交替消费，保证帧的顺序\n  // 小于期望帧间隔帧判定为连续的\n  const deltaTime = Math.floor((1000 / opts.expectFPS) * 1e3);\n  function checkCache() {\n    if (!audioReady) return;\n    const nextEncId = curEncId === 'encoder1' ? 'encoder0' : 'encoder1';\n    const curCache = samplesCache[curEncId];\n    const nextCache = samplesCache[nextEncId];\n    // 无数据\n    if (curCache.length === 0 && nextCache.length === 0) return;\n\n    let curFirst = curCache[0];\n    // 当前队列正在进行中（非关键帧 或 时间连续），继续消费\n    if (curFirst != null) {\n      if (!curFirst.is_sync || curFirst.cts - lastAddedSampleTime < deltaTime) {\n        const lastTs = addSampleToFile(curCache);\n        if (lastTs > lastAddedSampleTime) lastAddedSampleTime = lastTs;\n      }\n    }\n\n    const nextFirst = nextCache[0];\n\n    // 另一个队列跟已消费的最后一帧是连续的，则需要切换\n    if (nextFirst?.is_sync && nextFirst.cts - lastAddedSampleTime < deltaTime) {\n      curEncId = nextEncId;\n      // 说明另一个队列有数据，尽快消费\n      checkCache();\n      return;\n    }\n\n    // 如果时间不连续，但两个队列都有数据，且都是关键帧，消费时间较早的队列\n    if (curFirst?.is_sync && nextFirst?.is_sync) {\n      if (curFirst.cts <= nextFirst.cts) {\n        const lastTs = addSampleToFile(curCache);\n        if (lastTs > lastAddedSampleTime) lastAddedSampleTime = lastTs;\n      } else {\n        curEncId = nextEncId;\n        // 说明另一个队列有数据，尽快消费\n        checkCache();\n        return;\n      }\n    }\n  }\n\n  function addSampleToFile(\n    chunks: Array<ReturnType<typeof chunk2MP4SampleOpts>>,\n  ) {\n    let lastTime = -1;\n    let i = 0;\n    for (; i < chunks.length; i++) {\n      const c = chunks[i];\n      // 每次消费到下一个关键帧结束，可能需要切换队列\n      if (i > 0 && c.is_sync) break;\n\n      mp4File.addSample(trackId, c.data, c);\n      lastTime = c.cts + c.duration;\n    }\n    chunks.splice(0, i);\n    return lastTime;\n  }\n\n  const stopTimer = workerTimer(checkCache, 15);\n\n  const encoder0 = createVideoEncoder(opts, (chunk, meta) =>\n    outputHandler('encoder0', chunk, meta),\n  );\n  const encoder1 = createVideoEncoder(opts, (chunk, meta) =>\n    outputHandler('encoder1', chunk, meta),\n  );\n\n  let gopId = 0;\n  return {\n    get encodeQueueSize() {\n      return encoder0.encodeQueueSize + encoder1.encodeQueueSize;\n    },\n    encode: (vf: VideoFrame, opts: VideoEncoderEncodeOptions) => {\n      try {\n        if (opts.keyFrame) gopId += 1;\n        const encoder = gopId % 2 === 0 ? encoder0 : encoder1;\n        encoder.encode(vf, opts);\n      } catch (err) {\n        const errMsg = `encode video frame error: ${(err as Error).message}, state: ${JSON.stringify(\n          {\n            ts: vf.timestamp,\n            keyFrame: opts.keyFrame,\n            duration: vf.duration,\n            gopId,\n          },\n        )}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      }\n    },\n    flush: async () => {\n      await Promise.all([\n        encoder0.state === 'configured' ? await encoder0.flush() : null,\n        encoder1.state === 'configured' ? await encoder1.flush() : null,\n      ]);\n      stopTimer();\n      checkCache();\n    },\n    close: () => {\n      if (encoder0.state === 'configured') encoder0.close();\n      if (encoder1.state === 'configured') encoder1.close();\n    },\n  };\n}\n\n// https://github.com/WebAV-Tech/WebAV/issues/203\nfunction fixChromeConstraintSetFlagsBug(desc: ArrayBuffer) {\n  const u8 = new Uint8Array(desc);\n  const constraintSetFlag = u8[2];\n  // 如果 constraint_set_flags 字节二进制 第0位或第1位值为1\n  // 说明取值错误，忽略该字段避免解码异常\n  if (constraintSetFlag.toString(2).slice(-2).includes('1')) {\n    u8[2] = 0;\n  }\n}\n\nfunction createVideoEncoder(\n  videoOpts: NonNullable<IRecodeMuxOpts['video']>,\n  outHandler: EncodedVideoChunkOutputCallback,\n): VideoEncoder {\n  const encoderConf = {\n    codec: videoOpts.codec,\n    framerate: videoOpts.expectFPS,\n    hardwareAcceleration: videoOpts.__unsafe_hardwareAcceleration__,\n    // 码率\n    bitrate: videoOpts.bitrate,\n    width: videoOpts.width,\n    height: videoOpts.height,\n    // H264 不支持背景透明度\n    alpha: 'discard',\n    // macos 自带播放器只支持avc\n    avc: { format: 'avc' },\n    // mp4box.js 无法解析 annexb 的 mimeCodec ，只会显示 avc1\n    // avc: { format: 'annexb' }\n  } as const;\n  const encoder = new VideoEncoder({\n    error: (err) => {\n      const errMsg = `VideoEncoder error: ${err.message}, config: ${JSON.stringify(encoderConf)}, state: ${JSON.stringify(\n        {\n          qSize: encoder.encodeQueueSize,\n          state: encoder.state,\n        },\n      )}`;\n      Log.error(errMsg);\n      throw Error(errMsg);\n    },\n    output: outHandler,\n  });\n\n  encoder.configure(encoderConf);\n  return encoder;\n}\n\nfunction encodeAudioTrack(\n  audioOpts: NonNullable<IRecodeMuxOpts['audio']>,\n  mp4File: MP4File,\n  avSyncEvtTool: EventTool<Record<'VideoReady' | 'AudioReady', () => void>>,\n): AudioEncoder {\n  const audioTrackOpts = {\n    timescale: 1e6,\n    samplerate: audioOpts.sampleRate,\n    channel_count: audioOpts.channelCount,\n    hdlr: 'soun',\n    type: audioOpts.codec === 'aac' ? 'mp4a' : 'Opus',\n    name: 'Track created with WebAV',\n  };\n\n  let trackId = -1;\n  let cache: EncodedAudioChunk[] = [];\n  let videoReady = false;\n  avSyncEvtTool.once('VideoReady', () => {\n    videoReady = true;\n    cache.forEach((c) => {\n      const s = chunk2MP4SampleOpts(c);\n      mp4File.addSample(trackId, s.data, s);\n    });\n    cache = [];\n  });\n\n  const encoderConf = {\n    codec: audioOpts.codec === 'aac' ? 'mp4a.40.2' : 'opus',\n    sampleRate: audioOpts.sampleRate,\n    numberOfChannels: audioOpts.channelCount,\n    bitrate: 128_000,\n  } as const;\n\n  const encoder = new AudioEncoder({\n    error: (err) => {\n      const errMsg = `AudioEncoder error: ${err.message}, config: ${JSON.stringify(\n        encoderConf,\n      )}, state: ${JSON.stringify({\n        qSize: encoder.encodeQueueSize,\n        state: encoder.state,\n      })}`;\n      Log.error(errMsg);\n      throw Error(errMsg);\n    },\n    output: (chunk, meta) => {\n      if (trackId === -1) {\n        // 某些设备不会输出 description\n        const desc = meta.decoderConfig?.description;\n        trackId = mp4File.addTrack({\n          ...audioTrackOpts,\n          description: desc == null ? undefined : createESDSBox(desc),\n        });\n        avSyncEvtTool.emit('AudioReady');\n        Log.info('AudioEncoder, audio track ready, trackId:', trackId);\n      }\n\n      if (videoReady) {\n        const s = chunk2MP4SampleOpts(chunk);\n        mp4File.addSample(trackId, s.data, s);\n      } else {\n        cache.push(chunk);\n      }\n    },\n  });\n  encoder.configure(encoderConf);\n\n  return encoder;\n}\n\n/**\n * 创建 ESDS 盒子（MPEG-4 Elementary Stream Descriptor）\n * ESDS 盒子用于描述 MPEG-4 的流信息，如编解码器类型、流类型、最大比特率、平均比特率等\n * @param config - 配置信息，可以是 `ArrayBuffer` 或 `ArrayBufferView` 类型\n * @return 返回一个 ESDS box\n */\nfunction createESDSBox(config: ArrayBuffer | ArrayBufferView) {\n  const configlen = config.byteLength;\n  const buf = new Uint8Array([\n    0x00, // version 0\n    0x00,\n    0x00,\n    0x00, // flags\n\n    0x03, // descriptor_type\n    0x17 + configlen, // length\n    0x00,\n    // 0x01, // es_id\n    0x02, // es_id\n    0x00, // stream_priority\n\n    0x04, // descriptor_type\n    0x12 + configlen, // length\n    0x40, // codec : mpeg4_audio\n    0x15, // stream_type\n    0x00,\n    0x00,\n    0x00, // buffer_size\n    0x00,\n    0x00,\n    0x00,\n    0x00, // maxBitrate\n    0x00,\n    0x00,\n    0x00,\n    0x00, // avgBitrate\n\n    0x05, // descriptor_type\n\n    configlen,\n    ...new Uint8Array(config instanceof ArrayBuffer ? config : config.buffer),\n\n    0x06,\n    0x01,\n    0x02,\n  ]);\n\n  const esdsBox = new mp4box.BoxParser.esdsBox(buf.byteLength);\n  esdsBox.hdr_size = 0;\n  esdsBox.parse(new mp4box.DataStream(buf, 0, mp4box.DataStream.BIG_ENDIAN));\n  return esdsBox;\n}\n\n/**\n * EncodedAudioChunk | EncodedVideoChunk 转换为 MP4 addSample 需要的参数\n */\nfunction chunk2MP4SampleOpts(\n  chunk: EncodedAudioChunk | EncodedVideoChunk,\n): SampleOpts & {\n  data: ArrayBuffer;\n} {\n  const buf = new ArrayBuffer(chunk.byteLength);\n  chunk.copyTo(buf);\n  const dts = chunk.timestamp;\n  return {\n    duration: chunk.duration ?? 0,\n    dts,\n    cts: dts,\n    is_sync: chunk.type === 'key',\n    data: buf,\n  };\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The resample function.\r\n * @see https://github.com/rochars/wave-resampler\r\n */\r\n\r\nimport { Interpolator } from './lib/interpolator';\r\nimport { FIRLPF } from './lib/fir-lpf';\r\nimport { ButterworthLPF } from './lib/butterworth-lpf';\r\n\r\n/**\r\n * Configures wich resampling method uses LPF by default.\r\n * @private\r\n */\r\nconst DEFAULT_LPF_USE = {\r\n  'point': false,\r\n  'linear': false,\r\n  'cubic': true,\r\n  'sinc': true\r\n};\r\n\r\n/**\r\n * The default orders for the LPF types.\r\n * @private\r\n */\r\nconst DEFAULT_LPF_ORDER = {\r\n  'IIR': 16,\r\n  'FIR': 71\r\n};\r\n\r\n/**\r\n * The classes to use with each LPF type.\r\n * @private\r\n */\r\nconst DEFAULT_LPF = {\r\n  'IIR': ButterworthLPF,\r\n  'FIR': FIRLPF\r\n};\r\n\r\n/**\r\n * Change the sample rate of the samples to a new sample rate.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {number} oldSampleRate The original sample rate.\r\n * @param {number} sampleRate The target sample rate.\r\n * @param {?Object} details The extra configuration, if needed.\r\n * @return {!Float64Array} the new samples.\r\n */\r\nexport function resample(samples, oldSampleRate, sampleRate, details={}) {  \r\n  // Make the new sample container\r\n  let rate = ((sampleRate - oldSampleRate) / oldSampleRate) + 1;\r\n  let newSamples = new Float64Array(samples.length * (rate));\r\n  // Create the interpolator\r\n  details.method = details.method || 'cubic';\r\n  let interpolator = new Interpolator(\r\n    samples.length,\r\n    newSamples.length,\r\n    {\r\n      method: details.method,\r\n      tension: details.tension || 0,\r\n      sincFilterSize: details.sincFilterSize || 6,\r\n      sincWindow: details.sincWindow || undefined\r\n    });\r\n  // Resample + LPF\r\n  if (details.LPF === undefined) {\r\n    details.LPF = DEFAULT_LPF_USE[details.method];\r\n  } \r\n  if (details.LPF) {\r\n    details.LPFType = details.LPFType || 'IIR';\r\n    const LPF = DEFAULT_LPF[details.LPFType];\r\n    // Upsampling\r\n    if (sampleRate > oldSampleRate) {\r\n      let filter = new LPF(\r\n        details.LPFOrder || DEFAULT_LPF_ORDER[details.LPFType],\r\n        sampleRate,\r\n        (oldSampleRate / 2));\r\n      upsample_(\r\n        samples, newSamples, interpolator, filter);\r\n    // Downsampling\r\n    } else {\r\n      let filter = new LPF(\r\n        details.LPFOrder || DEFAULT_LPF_ORDER[details.LPFType],\r\n        oldSampleRate,\r\n        sampleRate / 2);\r\n      downsample_(\r\n        samples, newSamples, interpolator, filter);\r\n    }\r\n  // Resample, no LPF\r\n  } else {\r\n    resample_(samples, newSamples, interpolator);\r\n  }\r\n  return newSamples;\r\n}\r\n\r\n/**\r\n * Resample.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @private\r\n */\r\nfunction resample_(samples, newSamples, interpolator) {\r\n  // Resample\r\n  for (let i = 0, len = newSamples.length; i < len; i++) {\r\n    newSamples[i] = interpolator.interpolate(i, samples);\r\n  }\r\n}\r\n\r\n/**\r\n * Upsample with LPF.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */\r\nfunction upsample_(samples, newSamples, interpolator, filter) {\r\n  // Resample and filter\r\n  for (let i = 0, len = newSamples.length; i < len; i++) {\r\n    newSamples[i] = filter.filter(interpolator.interpolate(i, samples));\r\n  }\r\n  // Reverse filter\r\n  filter.reset();\r\n  for (let i = newSamples.length - 1; i >= 0; i--) {\r\n    newSamples[i]  = filter.filter(newSamples[i]);\r\n  }\r\n}\r\n\r\n/**\r\n * Downsample with LPF.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */\r\nfunction downsample_(samples, newSamples, interpolator, filter) {\r\n  // Filter\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    samples[i]  = filter.filter(samples[i]);\r\n  }\r\n  // Reverse filter\r\n  filter.reset();\r\n  for (let i = samples.length - 1; i >= 0; i--) {\r\n    samples[i]  = filter.filter(samples[i]);\r\n  }\r\n  // Resample\r\n  resample_(samples, newSamples, interpolator);\r\n}\r\n","/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright 2012 Spencer Cohen\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The Interpolator class. Based on Smooth.js by Spencer Cohen.\r\n * @see https://github.com/rochars/wave-resampler\r\n * @see https://github.com/osuushi/Smooth.js\r\n */\r\n\r\n/**\r\n * A class to get scaled values out of arrays.\r\n */\r\nexport class Interpolator {\r\n  \r\n  /**\r\n   * @param {number} scaleFrom the length of the original array.\r\n   * @param {number} scaleTo The length of the new array.\r\n   * @param {?Object} details The extra configuration, if needed.\r\n   */\r\n  constructor(scaleFrom, scaleTo, details) {\r\n    /**\r\n     * The length of the original array.\r\n     * @type {number}\r\n     */\r\n    this.length_ = scaleFrom;\r\n    /**\r\n     * The scaling factor.\r\n     * @type {number}\r\n     */\r\n    this.scaleFactor_ = (scaleFrom - 1) / scaleTo;\r\n    /**\r\n     * The interpolation function.\r\n     * @type {Function}\r\n     */\r\n    this.interpolate = this.cubic;\r\n    if (details.method === 'point') {\r\n    \tthis.interpolate = this.point;\r\n    } else if(details.method === 'linear') {\r\n    \tthis.interpolate = this.linear;\r\n    } else if(details.method === 'sinc') {\r\n    \tthis.interpolate = this.sinc;\r\n    }\r\n    /**\r\n     * The tanget factor for cubic interpolation.\r\n     * @type {number}\r\n     */\r\n    this.tangentFactor_ = 1 - Math.max(0, Math.min(1, details.tension || 0));\r\n    // Configure the kernel for sinc\r\n    /**\r\n     * The sinc filter size.\r\n     * @type {number}\r\n     */\r\n    this.sincFilterSize_ = details.sincFilterSize || 1;\r\n    /**\r\n     * The sinc kernel.\r\n     * @type {Function}\r\n     */\r\n    this.kernel_ = sincKernel_(details.sincWindow || window_);\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */\r\n  point(t, samples) {\r\n    return this.getClippedInput_(Math.round(this.scaleFactor_ * t), samples);\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */\r\n  linear(t, samples) {\r\n    t = this.scaleFactor_ * t;\r\n    let k = Math.floor(t);\r\n    t -= k;\r\n    return (1 - t) *\r\n    \tthis.getClippedInput_(k, samples) + t *\r\n    \tthis.getClippedInput_(k + 1, samples);\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */\r\n  cubic(t, samples) {\r\n    t = this.scaleFactor_ * t;\r\n    let k = Math.floor(t);\r\n    let m = [this.getTangent_(k, samples), this.getTangent_(k + 1, samples)];\r\n    let p = [this.getClippedInput_(k, samples),\r\n      this.getClippedInput_(k + 1, samples)];\r\n    t -= k;\r\n    let t2 = t * t;\r\n    let t3 = t * t2;\r\n    return (2 * t3 - 3 * t2 + 1) *\r\n      p[0] + (t3 - 2 * t2 + t) *\r\n      m[0] + (-2 * t3 + 3 * t2) *\r\n      p[1] + (t3 - t2) * m[1];\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */\r\n  sinc(t, samples) {\r\n    t = this.scaleFactor_ * t;\r\n    let k = Math.floor(t);\r\n    let ref = k - this.sincFilterSize_ + 1;\r\n    let ref1 = k + this.sincFilterSize_;\r\n    let sum = 0;\r\n    for (let n = ref; n <= ref1; n++) {\r\n      sum += this.kernel_(t - n) * this.getClippedInput_(n, samples);\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * @param {number} k The scaled index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The tangent.\r\n   * @private\r\n   */\r\n  getTangent_(k, samples) {\r\n    return this.tangentFactor_ *\r\n      (this.getClippedInput_(k + 1, samples) -\r\n        this.getClippedInput_(k - 1, samples)) / 2;\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The scaled index to interpolate.\r\n   * @param {Array|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   * @private\r\n   */\r\n  getClippedInput_(t, samples) {\r\n    if ((0 <= t && t < this.length_)) {\r\n      return samples[t];\r\n    }\r\n    return 0;\r\n  }\r\n}\r\n\r\n// Sinc functions\r\n\r\n/**\r\n * The default window function.\r\n * @param {number} x The sinc signal.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction window_(x) {\r\n  return Math.exp(-x / 2 * x / 2);\r\n}\r\n\r\n/**\r\n * @param {Function} window The window function.\r\n * @return {Function}\r\n * @private\r\n */\r\nfunction sincKernel_(window) {\r\n  return function(x) { return sinc_(x) * window(x); };\r\n}\r\n\r\n/**\r\n * @param {number} x The sinc signal.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction sinc_(x) {\r\n  if (x === 0) {\r\n    return 1;\r\n  }\r\n  return Math.sin(Math.PI * x) / (Math.PI * x);\r\n}\r\n\r\n","/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2014 Florian Markert\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview FIR LPF. Based on the FIR LPF from Fili by Florian Markert.\r\n * @see https://github.com/rochars/wave-resampler\r\n * @see https://github.com/markert/fili.js\r\n */\r\n\r\n/**\r\n * A FIR low pass filter.\r\n */\r\nexport class FIRLPF {\r\n  \r\n  /**\r\n   * @param {number} order The order of the filter.\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} cutOff The cut off frequency.\r\n   */\r\n  constructor(order, sampleRate, cutOff) {\r\n    let omega = 2 * Math.PI * cutOff / sampleRate;\r\n    let dc = 0;\r\n    this.filters = [];\r\n    for (let i = 0; i <= order; i++) {\r\n      if (i - order / 2 === 0) {\r\n        this.filters[i] = omega;\r\n      } else {\r\n        this.filters[i] = Math.sin(omega * (i - order / 2)) / (i - order / 2);\r\n        // Hamming window\r\n        this.filters[i] *= (0.54 - 0.46 * Math.cos(2 * Math.PI * i / order));\r\n      }\r\n      dc = dc + this.filters[i];\r\n    }\r\n    // normalize\r\n    for (let i = 0; i <= order; i++) {\r\n      this.filters[i] /= dc;\r\n    }\r\n    this.z = this.initZ_();\r\n  }\r\n\r\n  /**\r\n   * @param {number} sample A sample of a sequence.\r\n   * @return {number}\r\n   */\r\n  filter(sample) {\r\n    this.z.buf[this.z.pointer] = sample;\r\n    let out = 0;\r\n    for (let i = 0, len = this.z.buf.length; i < len; i++) {\r\n      out += (\r\n        this.filters[i] * this.z.buf[(this.z.pointer + i) % this.z.buf.length]);\r\n    }\r\n    this.z.pointer = (this.z.pointer + 1) % (this.z.buf.length);\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * Reset the filter.\r\n   */\r\n  reset() {\r\n    this.z = this.initZ_();\r\n  }\r\n\r\n  /**\r\n   * Return the default value for z.\r\n   * @private\r\n   */\r\n  initZ_() {\r\n    let r = [];\r\n    for (let i = 0; i < this.filters.length - 1; i++) {\r\n      r.push(0);\r\n    }\r\n    return {\r\n      buf: r,\r\n      pointer: 0\r\n    };\r\n  }\r\n}\r\n","/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2014 Florian Markert\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Butterworth LPF. Based on the Butterworth LPF from Fili.js.\r\n * @see https://github.com/rochars/wave-resampler\r\n * @see https://github.com/markert/fili.js\r\n */\r\n\r\n/**\r\n * Butterworth LPF.\r\n */\r\nexport class ButterworthLPF {\r\n  \r\n  /**\r\n   * @param {number} order The order of the filter.\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} cutOff The cut off frequency.\r\n   */\r\n  constructor(order, sampleRate, cutOff) {\r\n    let filters = [];\r\n    for (let i = 0; i < order; i++) {\r\n      filters.push(this.getCoeffs_({\r\n        Fs: sampleRate,\r\n        Fc: cutOff,\r\n        Q: 0.5 / (Math.sin((Math.PI / (order * 2)) * (i + 0.5)))\r\n      }));\r\n    }\r\n    this.stages = [];\r\n    for (let i = 0; i < filters.length; i++) {\r\n      this.stages[i] = {\r\n        b0 : filters[i].b[0],\r\n        b1 : filters[i].b[1],\r\n        b2 : filters[i].b[2],\r\n        a1 : filters[i].a[0],\r\n        a2 : filters[i].a[1],\r\n        k : filters[i].k,\r\n        z : [0, 0]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} sample A sample of a sequence.\r\n   * @return {number}\r\n   */\r\n  filter(sample) {\r\n    let out = sample;\r\n    for (let i = 0, len = this.stages.length; i < len; i++) {\r\n      out = this.runStage_(i, out);\r\n    }\r\n    return out;\r\n  }\r\n\r\n  getCoeffs_(params) {\r\n    let coeffs = {};\r\n    coeffs.z = [0, 0];\r\n    coeffs.a = [];\r\n    coeffs.b = [];\r\n    let p = this.preCalc_(params, coeffs);\r\n    coeffs.k = 1;\r\n    coeffs.b.push((1 - p.cw) / (2 * p.a0));\r\n    coeffs.b.push(2 * coeffs.b[0]);\r\n    coeffs.b.push(coeffs.b[0]);\r\n    return coeffs;\r\n  }\r\n\r\n  preCalc_(params, coeffs) {\r\n    let pre = {};\r\n    let w = 2 * Math.PI * params.Fc / params.Fs;\r\n    pre.alpha = Math.sin(w) / (2 * params.Q);\r\n    pre.cw = Math.cos(w);\r\n    pre.a0 = 1 + pre.alpha;\r\n    coeffs.a0 = pre.a0;\r\n    coeffs.a.push((-2 * pre.cw) / pre.a0);\r\n    coeffs.k = 1;\r\n    coeffs.a.push((1 - pre.alpha) / pre.a0);\r\n    return pre;\r\n  }\r\n  \r\n  runStage_(i, input) {\r\n    let temp =\r\n      input * this.stages[i].k - this.stages[i].a1 * this.stages[i].z[0] -\r\n      this.stages[i].a2 * this.stages[i].z[1];\r\n    let out =\r\n      this.stages[i].b0 * temp + this.stages[i].b1 * this.stages[i].z[0] +\r\n      this.stages[i].b2 * this.stages[i].z[1];\r\n    this.stages[i].z[1] = this.stages[i].z[0];\r\n    this.stages[i].z[0] = temp;\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * Reset the filter.\r\n   */\r\n  reset() {\r\n    for (let i = 0; i < this.stages.length; i++) {\r\n      this.stages[i].z = [0, 0];\r\n    }\r\n  }\r\n}\r\n","var U = (r) => {\n  throw TypeError(r);\n};\nvar O = (r, e, t) => e.has(r) || U(\"Cannot \" + t);\nvar s = (r, e, t) => (O(r, e, \"read from private field\"), t ? t.call(r) : e.get(r)), o = (r, e, t) => e.has(r) ? U(\"Cannot add the same private member more than once\") : e instanceof WeakSet ? e.add(r) : e.set(r, t), l = (r, e, t, a) => (O(r, e, \"write to private field\"), a ? a.call(r, t) : e.set(r, t), t);\nconst K = \"KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHUobil7aWYobj09PSIvIilyZXR1cm57cGFyZW50Om51bGwsbmFtZToiIn07Y29uc3QgZT1uLnNwbGl0KCIvIikuZmlsdGVyKGk9PmkubGVuZ3RoPjApO2lmKGUubGVuZ3RoPT09MCl0aHJvdyBFcnJvcigiSW52YWxpZCBwYXRoIik7Y29uc3QgYT1lW2UubGVuZ3RoLTFdLHI9Ii8iK2Uuc2xpY2UoMCwtMSkuam9pbigiLyIpO3JldHVybntuYW1lOmEscGFyZW50OnJ9fWFzeW5jIGZ1bmN0aW9uIHcobixlKXtjb25zdHtwYXJlbnQ6YSxuYW1lOnJ9PXUobik7aWYoYT09bnVsbClyZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7Y29uc3QgaT1hLnNwbGl0KCIvIikuZmlsdGVyKHQ9PnQubGVuZ3RoPjApO3RyeXtsZXQgdD1hd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtmb3IoY29uc3QgcyBvZiBpKXQ9YXdhaXQgdC5nZXREaXJlY3RvcnlIYW5kbGUocyx7Y3JlYXRlOmUuY3JlYXRlfSk7aWYoZS5pc0ZpbGUpcmV0dXJuIGF3YWl0IHQuZ2V0RmlsZUhhbmRsZShyLHtjcmVhdGU6ZS5jcmVhdGV9KX1jYXRjaCh0KXtpZih0Lm5hbWU9PT0iTm90Rm91bmRFcnJvciIpcmV0dXJuIG51bGw7dGhyb3cgdH19Y29uc3QgZj17fTtzZWxmLm9ubWVzc2FnZT1hc3luYyBuPT57dmFyIGk7Y29uc3R7ZXZ0VHlwZTplLGFyZ3M6YX09bi5kYXRhO2xldCByPWZbYS5maWxlSWRdO3RyeXtsZXQgdDtjb25zdCBzPVtdO2lmKGU9PT0icmVnaXN0ZXIiKXtjb25zdCBsPWF3YWl0IHcoYS5maWxlUGF0aCx7Y3JlYXRlOiEwLGlzRmlsZTohMH0pO2lmKGw9PW51bGwpdGhyb3cgRXJyb3IoYG5vdCBmb3VuZCBmaWxlOiAke2EuZmlsZUlkfWApO3I9YXdhaXQgbC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKHttb2RlOmEubW9kZX0pLGZbYS5maWxlSWRdPXJ9ZWxzZSBpZihlPT09ImNsb3NlIilhd2FpdCByLmNsb3NlKCksZGVsZXRlIGZbYS5maWxlSWRdO2Vsc2UgaWYoZT09PSJ0cnVuY2F0ZSIpYXdhaXQgci50cnVuY2F0ZShhLm5ld1NpemUpO2Vsc2UgaWYoZT09PSJ3cml0ZSIpe2NvbnN0e2RhdGE6bCxvcHRzOm99PW4uZGF0YS5hcmdzO3Q9YXdhaXQgci53cml0ZShsLG8pfWVsc2UgaWYoZT09PSJyZWFkIil7Y29uc3R7b2Zmc2V0Omwsc2l6ZTpvfT1uLmRhdGEuYXJncyxnPW5ldyBVaW50OEFycmF5KG8pLGQ9YXdhaXQgci5yZWFkKGcse2F0Omx9KSxjPWcuYnVmZmVyO3Q9ZD09PW8/YzooKGk9Yy50cmFuc2Zlcik9PW51bGw/dm9pZCAwOmkuY2FsbChjLGQpKT8/Yy5zbGljZSgwLGQpLHMucHVzaCh0KX1lbHNlIGU9PT0iZ2V0U2l6ZSI/dD1hd2FpdCByLmdldFNpemUoKTplPT09ImZsdXNoIiYmYXdhaXQgci5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2V2dFR5cGU6ImNhbGxiYWNrIixjYklkOm4uZGF0YS5jYklkLHJldHVyblZhbDp0fSxzKX1jYXRjaCh0KXtjb25zdCBzPXQ7c2VsZi5wb3N0TWVzc2FnZSh7ZXZ0VHlwZToidGhyb3dFcnJvciIsY2JJZDpuLmRhdGEuY2JJZCxlcnJNc2c6cy5uYW1lKyI6ICIrcy5tZXNzYWdlK2AKYCtKU09OLnN0cmluZ2lmeShuLmRhdGEpfSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZnMtd29ya2VyLUY0UldscWNfLmpzLm1hcAo=\", Q = (r) => Uint8Array.from(atob(r), (e) => e.charCodeAt(0)), C = typeof self < \"u\" && self.Blob && new Blob([Q(K)], { type: \"text/javascript;charset=utf-8\" });\nfunction D(r) {\n  let e;\n  try {\n    if (e = C && (self.URL || self.webkitURL).createObjectURL(C), !e) throw \"\";\n    const t = new Worker(e, {\n      name: r == null ? void 0 : r.name\n    });\n    return t.addEventListener(\"error\", () => {\n      (self.URL || self.webkitURL).revokeObjectURL(e);\n    }), t;\n  } catch {\n    return new Worker(\n      \"data:text/javascript;base64,\" + K,\n      {\n        name: r == null ? void 0 : r.name\n      }\n    );\n  } finally {\n    e && (self.URL || self.webkitURL).revokeObjectURL(e);\n  }\n}\nasync function M(r, e, t) {\n  const a = _();\n  return await a(\"register\", { fileId: r, filePath: e, mode: t }), {\n    read: async (i, n) => await a(\"read\", {\n      fileId: r,\n      offset: i,\n      size: n\n    }),\n    write: async (i, n) => await a(\n      \"write\",\n      {\n        fileId: r,\n        data: i,\n        opts: n\n      },\n      [ArrayBuffer.isView(i) ? i.buffer : i]\n    ),\n    close: async () => await a(\"close\", {\n      fileId: r\n    }),\n    truncate: async (i) => await a(\"truncate\", {\n      fileId: r,\n      newSize: i\n    }),\n    getSize: async () => await a(\"getSize\", {\n      fileId: r\n    }),\n    flush: async () => await a(\"flush\", {\n      fileId: r\n    })\n  };\n}\nconst I = [];\nlet k = 0;\nfunction _() {\n  if (I.length < 3) {\n    const e = r();\n    return I.push(e), e;\n  } else {\n    const e = I[k];\n    return k = (k + 1) % I.length, e;\n  }\n  function r() {\n    const e = new D();\n    let t = 0, a = {};\n    return e.onmessage = ({\n      data: i\n    }) => {\n      var n, c;\n      i.evtType === \"callback\" ? (n = a[i.cbId]) == null || n.resolve(i.returnVal) : i.evtType === \"throwError\" && ((c = a[i.cbId]) == null || c.reject(Error(i.errMsg))), delete a[i.cbId];\n    }, async function(n, c, u = []) {\n      t += 1;\n      const h = new Promise((p, V) => {\n        a[t] = { resolve: p, reject: V };\n      });\n      return e.postMessage(\n        {\n          cbId: t,\n          evtType: n,\n          args: c\n        },\n        u\n      ), h;\n    };\n  }\n}\nfunction T(r) {\n  if (r === \"/\") return { parent: null, name: \"\" };\n  const e = r.split(\"/\").filter((i) => i.length > 0);\n  if (e.length === 0) throw Error(\"Invalid path\");\n  const t = e[e.length - 1], a = \"/\" + e.slice(0, -1).join(\"/\");\n  return { name: t, parent: a };\n}\nasync function d(r, e) {\n  const { parent: t, name: a } = T(r);\n  if (t == null) return await navigator.storage.getDirectory();\n  const i = t.split(\"/\").filter((n) => n.length > 0);\n  try {\n    let n = await navigator.storage.getDirectory();\n    for (const c of i)\n      n = await n.getDirectoryHandle(c, {\n        create: e.create\n      });\n    return e.isFile ? await n.getFileHandle(a, {\n      create: e.create\n    }) : await n.getDirectoryHandle(a, {\n      create: e.create\n    });\n  } catch (n) {\n    if (n.name === \"NotFoundError\")\n      return null;\n    throw n;\n  }\n}\nasync function N(r) {\n  const { parent: e, name: t } = T(r);\n  if (e == null) {\n    const i = await navigator.storage.getDirectory();\n    for await (const n of i.keys())\n      await i.removeEntry(n, { recursive: !0 });\n    return;\n  }\n  const a = await d(e, {\n    create: !1,\n    isFile: !1\n  });\n  if (a != null)\n    try {\n      await a.removeEntry(t, { recursive: !0 });\n    } catch (i) {\n      if (i.name === \"NotFoundError\") return;\n      throw i;\n    }\n}\nfunction x(r, e) {\n  return `${r}/${e}`.replace(\"//\", \"/\");\n}\nfunction b(r) {\n  return new v(r);\n}\nvar w, S, g;\nconst P = class P {\n  constructor(e) {\n    o(this, w);\n    o(this, S);\n    o(this, g);\n    l(this, w, e);\n    const { parent: t, name: a } = T(e);\n    l(this, S, a), l(this, g, t);\n  }\n  get kind() {\n    return \"dir\";\n  }\n  get name() {\n    return s(this, S);\n  }\n  get path() {\n    return s(this, w);\n  }\n  get parent() {\n    return s(this, g) == null ? null : b(s(this, g));\n  }\n  /**\n   * Creates the directory.\n   * return A promise that resolves when the directory is created.\n   */\n  async create() {\n    return await d(s(this, w), {\n      create: !0,\n      isFile: !1\n    }), b(s(this, w));\n  }\n  /**\n   * Checks if the directory exists.\n   * return A promise that resolves to true if the directory exists, otherwise false.\n   */\n  async exists() {\n    return await d(s(this, w), {\n      create: !1,\n      isFile: !1\n    }) instanceof FileSystemDirectoryHandle;\n  }\n  /**\n   * Removes the directory.\n   * return A promise that resolves when the directory is removed.\n   */\n  async remove() {\n    for (const e of await this.children())\n      try {\n        await e.remove();\n      } catch (t) {\n        console.warn(t);\n      }\n    try {\n      await N(s(this, w));\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  /**\n   * Retrieves the children of the directory.\n   * return A promise that resolves to an array of objects representing the children.\n   */\n  async children() {\n    const e = await d(s(this, w), {\n      create: !1,\n      isFile: !1\n    });\n    if (e == null) return [];\n    const t = [];\n    for await (const a of e.values())\n      t.push((a.kind === \"file\" ? y : b)(x(s(this, w), a.name)));\n    return t;\n  }\n  async copyTo(e) {\n    if (!await this.exists())\n      throw Error(`dir ${this.path} not exists`);\n    if (e instanceof P) {\n      const t = await e.exists() ? b(x(e.path, this.name)) : e;\n      return await t.create(), await Promise.all((await this.children()).map((a) => a.copyTo(t))), t;\n    } else if (e instanceof FileSystemDirectoryHandle)\n      return await Promise.all(\n        (await this.children()).map(async (t) => {\n          t.kind === \"file\" ? await t.copyTo(\n            await e.getFileHandle(t.name, { create: !0 })\n          ) : await t.copyTo(\n            await e.getDirectoryHandle(t.name, { create: !0 })\n          );\n        })\n      ), null;\n    throw Error(\"Illegal target type\");\n  }\n  /**\n   * move directory, copy then remove current\n   */\n  async moveTo(e) {\n    const t = await this.copyTo(e);\n    return await this.remove(), t;\n  }\n};\nw = new WeakMap(), S = new WeakMap(), g = new WeakMap();\nlet v = P;\nconst z = /* @__PURE__ */ new Map();\nfunction y(r, e = \"rw\") {\n  if (e === \"rw\") {\n    const t = z.get(r) ?? new F(r, e);\n    return z.set(r, t), t;\n  }\n  return new F(r, e);\n}\nasync function J(r, e, t = { overwrite: !0 }) {\n  if (e instanceof F) {\n    await J(r, await e.stream(), t);\n    return;\n  }\n  const a = await (r instanceof F ? r : y(r, \"rw\")).createWriter();\n  try {\n    if (t.overwrite && await a.truncate(0), e instanceof ReadableStream) {\n      const i = e.getReader();\n      for (; ; ) {\n        const { done: n, value: c } = await i.read();\n        if (n) break;\n        await a.write(c);\n      }\n    } else\n      await a.write(e);\n  } catch (i) {\n    throw i;\n  } finally {\n    await a.close();\n  }\n}\nlet A = 0;\nconst $ = () => ++A;\nvar f, Z, G, Y, X, m, R, W;\nconst H = class H {\n  constructor(e, t) {\n    o(this, f);\n    o(this, Z);\n    o(this, G);\n    o(this, Y);\n    o(this, X);\n    o(this, m, 0);\n    o(this, R, /* @__PURE__ */ (() => {\n      let e = null;\n      return () => (l(this, m, s(this, m) + 1), e ?? (e = new Promise(async (t, a) => {\n        try {\n          const i = await M(\n            s(this, X),\n            s(this, f),\n            s(this, Y)\n          );\n          t([\n            i,\n            async () => {\n              l(this, m, s(this, m) - 1), !(s(this, m) > 0) && (e = null, await i.close());\n            }\n          ]);\n        } catch (i) {\n          a(i);\n        }\n      })));\n    })());\n    o(this, W, !1);\n    l(this, X, $()), l(this, f, e), l(this, Y, {\n      r: \"read-only\",\n      rw: \"readwrite\",\n      \"rw-unsafe\": \"readwrite-unsafe\"\n    }[t]);\n    const { parent: a, name: i } = T(e);\n    if (a == null) throw Error(\"Invalid path\");\n    l(this, G, i), l(this, Z, a);\n  }\n  get kind() {\n    return \"file\";\n  }\n  get path() {\n    return s(this, f);\n  }\n  get name() {\n    return s(this, G);\n  }\n  get parent() {\n    return s(this, Z) == null ? null : b(s(this, Z));\n  }\n  /**\n   * Random write to file\n   */\n  async createWriter() {\n    if (s(this, Y) === \"read-only\") throw Error(\"file is read-only\");\n    if (s(this, W)) throw Error(\"Other writer have not been closed\");\n    l(this, W, !0);\n    const e = new TextEncoder(), [t, a] = await s(this, R).call(this);\n    let i = await t.getSize(), n = !1;\n    return {\n      write: async (c, u = {}) => {\n        if (n) throw Error(\"Writer is closed\");\n        const h = typeof c == \"string\" ? e.encode(c) : c, p = u.at ?? i, V = h.byteLength;\n        return i = p + V, await t.write(h, { at: p });\n      },\n      truncate: async (c) => {\n        if (n) throw Error(\"Writer is closed\");\n        await t.truncate(c), i > c && (i = c);\n      },\n      flush: async () => {\n        if (n) throw Error(\"Writer is closed\");\n        await t.flush();\n      },\n      close: async () => {\n        if (n) throw Error(\"Writer is closed\");\n        n = !0, l(this, W, !1), await a();\n      }\n    };\n  }\n  /**\n   * Random access to file\n   */\n  async createReader() {\n    const [e, t] = await s(this, R).call(this);\n    let a = !1, i = 0;\n    return {\n      read: async (n, c = {}) => {\n        if (a) throw Error(\"Reader is closed\");\n        const u = c.at ?? i, h = await e.read(u, n);\n        return i = u + h.byteLength, h;\n      },\n      getSize: async () => {\n        if (a) throw Error(\"Reader is closed\");\n        return await e.getSize();\n      },\n      close: async () => {\n        a || (a = !0, await t());\n      }\n    };\n  }\n  async text() {\n    return new TextDecoder().decode(await this.arrayBuffer());\n  }\n  async arrayBuffer() {\n    const e = await d(s(this, f), { create: !1, isFile: !0 });\n    return e == null ? new ArrayBuffer(0) : (await e.getFile()).arrayBuffer();\n  }\n  async stream() {\n    const e = await this.getOriginFile();\n    return e == null ? new ReadableStream({\n      pull: (t) => {\n        t.close();\n      }\n    }) : e.stream();\n  }\n  async getOriginFile() {\n    var e;\n    return (e = await d(s(this, f), { create: !1, isFile: !0 })) == null ? void 0 : e.getFile();\n  }\n  async getSize() {\n    const e = await d(s(this, f), { create: !1, isFile: !0 });\n    return e == null ? 0 : (await e.getFile()).size;\n  }\n  async exists() {\n    return await d(s(this, f), {\n      create: !1,\n      isFile: !0\n    }) instanceof FileSystemFileHandle;\n  }\n  async remove() {\n    if (s(this, m)) throw Error(\"exists unclosed reader/writer\");\n    await N(s(this, f));\n  }\n  async copyTo(e) {\n    if (e instanceof H)\n      return e.path === this.path ? this : (await J(e.path, this), y(e.path));\n    if (e instanceof v) {\n      if (!await this.exists())\n        throw Error(`file ${this.path} not exists`);\n      return await this.copyTo(y(x(e.path, this.name)));\n    } else if (e instanceof FileSystemFileHandle)\n      return await (await this.stream()).pipeTo(await e.createWritable()), null;\n    throw Error(\"Illegal target type\");\n  }\n  /**\n   * move file, copy then remove current\n   */\n  async moveTo(e) {\n    const t = await this.copyTo(e);\n    return await this.remove(), t;\n  }\n};\nf = new WeakMap(), Z = new WeakMap(), G = new WeakMap(), Y = new WeakMap(), X = new WeakMap(), m = new WeakMap(), R = new WeakMap(), W = new WeakMap();\nlet F = H;\nconst E = \"/.opfs-tools-temp-dir\";\nasync function B(r) {\n  try {\n    if (r.kind === \"file\") {\n      if (!await r.exists()) return !0;\n      const e = await r.createWriter();\n      await e.truncate(0), await e.close(), await r.remove();\n    } else\n      await r.remove();\n    return !0;\n  } catch (e) {\n    return console.warn(e), !1;\n  }\n}\nfunction q() {\n  setInterval(async () => {\n    for (const e of await b(E).children()) {\n      const t = /^\\d+-(\\d+)$/.exec(e.name);\n      (t == null || Date.now() - Number(t[1]) > 2592e5) && await B(e);\n    }\n  }, 60 * 1e3);\n}\nconst L = [];\nlet j = !1;\nasync function ee() {\n  if (globalThis.localStorage == null) return;\n  const r = \"OPFS_TOOLS_EXPIRES_TMP_FILES\";\n  j || (j = !0, globalThis.addEventListener(\"unload\", () => {\n    L.length !== 0 && localStorage.setItem(\n      r,\n      `${localStorage.getItem(r) ?? \"\"},${L.join(\",\")}`\n    );\n  }));\n  let e = localStorage.getItem(r) ?? \"\";\n  for (const t of e.split(\",\"))\n    t.length !== 0 && await B(y(`${E}/${t}`)) && (e = e.replace(t, \"\"));\n  localStorage.setItem(r, e.replace(/,{2,}/g, \",\"));\n}\n(async function() {\n  var e;\n  globalThis.__opfs_tools_tmpfile_init__ !== !0 && (globalThis.__opfs_tools_tmpfile_init__ = !0, !(globalThis.FileSystemDirectoryHandle == null || globalThis.FileSystemFileHandle == null || ((e = globalThis.navigator) == null ? void 0 : e.storage.getDirectory) == null) && (q(), await ee()));\n})();\nfunction re() {\n  const r = `${Math.random().toString().slice(2)}-${Date.now()}`;\n  return L.push(r), y(`${E}/${r}`);\n}\nfunction ae(r, e) {\n  let t = y(r), a = 0, i = t.createWriter(), n = t.createReader();\n  const c = async (u) => {\n    const p = await (await n).read(a, { at: Math.round(a * 0.3) });\n    a = await u.write(p, { at: 0 }), await u.truncate(a);\n  };\n  return {\n    append: async (u) => {\n      const h = await i;\n      a += await h.write(u), a >= e && await c(h);\n    },\n    text: t.text.bind(t),\n    remove: async () => {\n      await (await n).close(), await (await i).close(), await t.remove();\n    },\n    getSize: async () => a\n  };\n}\nexport {\n  b as dir,\n  y as file,\n  ae as rollfile,\n  re as tmpfile,\n  J as write\n};\n//# sourceMappingURL=opfs-tools.js.map\n","import { FileSystemSyncAccessHandle } from './common';\nimport OPFSWorker from './opfs-worker?worker&inline';\n\nexport type OPFSWorkerAccessHandle = {\n  read: (offset: number, size: number) => Promise<ArrayBuffer>;\n  write: FileSystemSyncAccessHandle['write'];\n  close: FileSystemSyncAccessHandle['close'];\n  truncate: FileSystemSyncAccessHandle['truncate'];\n  getSize: FileSystemSyncAccessHandle['getSize'];\n  flush: FileSystemSyncAccessHandle['flush'];\n};\n\nexport type OpenMode = 'read-only' | 'readwrite' | 'readwrite-unsafe';\n\nexport async function createOPFSAccess(\n  fileId: number,\n  filePath: string,\n  mode: OpenMode\n): Promise<OPFSWorkerAccessHandle> {\n  const postMsg = getWorkerMsger();\n  await postMsg('register', { fileId, filePath, mode });\n  return {\n    read: async (offset, size) =>\n      (await postMsg('read', {\n        fileId,\n        offset,\n        size,\n      })) as ArrayBuffer,\n    write: async (data, opts) =>\n      (await postMsg(\n        'write',\n        {\n          fileId,\n          data,\n          opts,\n        },\n        [ArrayBuffer.isView(data) ? data.buffer : data]\n      )) as number,\n    close: async () =>\n      (await postMsg('close', {\n        fileId,\n      })) as void,\n    truncate: async (newSize: number) =>\n      (await postMsg('truncate', {\n        fileId,\n        newSize,\n      })) as void,\n    getSize: async () =>\n      (await postMsg('getSize', {\n        fileId,\n      })) as number,\n    flush: async () =>\n      (await postMsg('flush', {\n        fileId,\n      })) as void,\n  };\n}\n\nconst msgerCache: Array<Function> = [];\nlet nextMsgerIdx = 0;\nfunction getWorkerMsger() {\n  // Create a maximum of three workers\n  if (msgerCache.length < 3) {\n    const msger = create();\n    msgerCache.push(msger);\n    return msger;\n  } else {\n    const msger = msgerCache[nextMsgerIdx];\n    nextMsgerIdx = (nextMsgerIdx + 1) % msgerCache.length;\n    return msger;\n  }\n\n  function create() {\n    const worker = new OPFSWorker();\n\n    let cbId = 0;\n    let cbFns: Record<number, { resolve: Function; reject: Function }> = {};\n\n    worker.onmessage = ({\n      data,\n    }: {\n      data: {\n        cbId: number;\n        returnVal?: unknown;\n        evtType: string;\n        errMsg: string;\n      };\n    }) => {\n      if (data.evtType === 'callback') {\n        cbFns[data.cbId]?.resolve(data.returnVal);\n      } else if (data.evtType === 'throwError') {\n        cbFns[data.cbId]?.reject(Error(data.errMsg));\n      }\n      delete cbFns[data.cbId];\n    };\n\n    return async function postMsg(\n      evtType: string,\n      args: unknown,\n      trans: Transferable[] = []\n    ) {\n      cbId += 1;\n\n      const rsP = new Promise((resolve, reject) => {\n        cbFns[cbId] = { resolve, reject };\n      });\n      worker.postMessage(\n        {\n          cbId,\n          evtType,\n          args,\n        },\n        trans\n      );\n\n      return rsP;\n    };\n  }\n}\n","export interface FileSystemSyncAccessHandle {\n  read: (container: ArrayBuffer, opts: { at: number }) => Promise<number>;\n  write: (\n    data: ArrayBuffer | ArrayBufferView,\n    opts?: { at: number }\n  ) => Promise<number>;\n  flush: () => Promise<void>;\n  close: () => Promise<void>;\n  truncate: (newSize: number) => Promise<void>;\n  getSize: () => Promise<number>;\n}\n\nexport function parsePath(path: string) {\n  if (path === '/') return { parent: null, name: '' };\n\n  const pathArr = path.split('/').filter((s) => s.length > 0);\n  if (pathArr.length === 0) throw Error('Invalid path');\n\n  const name = pathArr[pathArr.length - 1];\n\n  const parent = '/' + pathArr.slice(0, -1).join('/');\n\n  return { name, parent };\n}\n\nexport async function getFSHandle<\n  ISFile extends boolean,\n  ISCreate extends boolean,\n  T = ISFile extends true ? FileSystemFileHandle : FileSystemDirectoryHandle,\n  RT = ISCreate extends true ? T : T | null\n>(\n  path: string,\n  opts: {\n    create?: ISCreate;\n    isFile?: ISFile;\n  }\n): Promise<RT> {\n  const { parent, name } = parsePath(path);\n\n  if (parent == null) return (await navigator.storage.getDirectory()) as RT;\n\n  const dirPaths = parent.split('/').filter((s) => s.length > 0);\n\n  try {\n    let dirHandle = await navigator.storage.getDirectory();\n    for (const p of dirPaths) {\n      dirHandle = await dirHandle.getDirectoryHandle(p, {\n        create: opts.create,\n      });\n    }\n    if (opts.isFile) {\n      return (await dirHandle.getFileHandle(name, {\n        create: opts.create,\n      })) as RT;\n    } else {\n      return (await dirHandle.getDirectoryHandle(name, {\n        create: opts.create,\n      })) as RT;\n    }\n  } catch (err) {\n    if ((err as Error).name === 'NotFoundError') {\n      return null as RT;\n    }\n    throw err;\n  }\n}\n\nexport async function remove(path: string) {\n  const { parent, name } = parsePath(path);\n  if (parent == null) {\n    const root = await navigator.storage.getDirectory();\n    for await (const it of root.keys()) {\n      await root.removeEntry(it, { recursive: true });\n    }\n    return;\n  }\n\n  const dirHandle = (await getFSHandle(parent, {\n    create: false,\n    isFile: false,\n  })) as FileSystemDirectoryHandle | null;\n  if (dirHandle == null) return;\n\n  try {\n    await dirHandle.removeEntry(name, { recursive: true });\n  } catch (err) {\n    if ((err as Error).name === 'NotFoundError') return;\n    throw err;\n  }\n}\n\nexport function joinPath(p1: string, p2: string) {\n  return `${p1}/${p2}`.replace('//', '/');\n}\n","import { getFSHandle, joinPath, parsePath, remove } from './common';\nimport { file, OTFile } from './file';\n\ndeclare global {\n  interface FileSystemDirectoryHandle {\n    keys: () => AsyncIterable<string>;\n    values: () => AsyncIterable<\n      FileSystemDirectoryHandle | FileSystemFileHandle\n    >;\n  }\n}\n\n/**\n * Represents a directory with utility functions.\n * @param {string} dirPath - The path of the directory.\n * @returns  An object with directory utility functions.\n * \n * @example\n  // Create a directory\n  await dir('/path/to/directory').create();\n\n  // Check if the directory exists\n  const exists = await dir('/path/to/directory').exists();\n\n  // Remove the directory\n\n  // Retrieve children of the directory\n  const children = await dir('/path/to/parent_directory').children();\n */\nexport function dir(dirPath: string) {\n  return new OTDir(dirPath);\n}\n\nexport class OTDir {\n  get kind(): 'dir' {\n    return 'dir';\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  get path() {\n    return this.#path;\n  }\n\n  get parent(): OTDir | null {\n    return this.#parentPath == null ? null : dir(this.#parentPath);\n  }\n\n  #path: string;\n  #name: string;\n  #parentPath: string | null;\n\n  constructor(dirPath: string) {\n    this.#path = dirPath;\n    const { parent, name } = parsePath(dirPath);\n    this.#name = name;\n    this.#parentPath = parent;\n  }\n\n  /**\n   * Creates the directory.\n   * return A promise that resolves when the directory is created.\n   */\n  async create() {\n    await getFSHandle(this.#path, {\n      create: true,\n      isFile: false,\n    });\n    return dir(this.#path);\n  }\n\n  /**\n   * Checks if the directory exists.\n   * return A promise that resolves to true if the directory exists, otherwise false.\n   */\n  async exists() {\n    return (\n      (await getFSHandle(this.#path, {\n        create: false,\n        isFile: false,\n      })) instanceof FileSystemDirectoryHandle\n    );\n  }\n\n  /**\n   * Removes the directory.\n   * return A promise that resolves when the directory is removed.\n   */\n  async remove() {\n    for (const it of await this.children()) {\n      try {\n        await it.remove();\n      } catch (err) {\n        console.warn(err);\n      }\n    }\n    try {\n      await remove(this.#path);\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  /**\n   * Retrieves the children of the directory.\n   * return A promise that resolves to an array of objects representing the children.\n   */\n  async children(): Promise<Array<OTDir | OTFile>> {\n    const handle = (await getFSHandle(this.#path, {\n      create: false,\n      isFile: false,\n    })) as FileSystemDirectoryHandle;\n    if (handle == null) return [];\n\n    const rs = [];\n    for await (const it of handle.values()) {\n      rs.push((it.kind === 'file' ? file : dir)(joinPath(this.#path, it.name)));\n    }\n    return rs;\n  }\n\n  /**\n   * If the dest folder exists, copy the current directory into the dest folder;\n   * if the dest folder does not exist, rename the current directory to dest name.\n   */\n  async copyTo(dest: OTDir): Promise<OTDir>;\n  async copyTo(dest: FileSystemDirectoryHandle): Promise<null>;\n  async copyTo<T>(dest: T) {\n    if (!(await this.exists())) {\n      throw Error(`dir ${this.path} not exists`);\n    }\n\n    if (dest instanceof OTDir) {\n      const newDir = (await dest.exists())\n        ? dir(joinPath(dest.path, this.name))\n        : dest;\n      await newDir.create();\n      await Promise.all((await this.children()).map((it) => it.copyTo(newDir)));\n      return newDir;\n    } else if (dest instanceof FileSystemDirectoryHandle) {\n      await Promise.all(\n        (\n          await this.children()\n        ).map(async (it) => {\n          if (it.kind === 'file') {\n            await it.copyTo(\n              await dest.getFileHandle(it.name, { create: true })\n            );\n          } else {\n            await it.copyTo(\n              await dest.getDirectoryHandle(it.name, { create: true })\n            );\n          }\n        })\n      );\n      return null;\n    }\n    throw Error('Illegal target type');\n  }\n\n  /**\n   * move directory, copy then remove current\n   */\n  async moveTo(dest: OTDir): Promise<OTDir> {\n    const newDir = await this.copyTo(dest);\n    await this.remove();\n    return newDir;\n  }\n}\n","import {\n  OPFSWorkerAccessHandle,\n  OpenMode,\n  createOPFSAccess,\n} from './access-worker';\nimport { getFSHandle, joinPath, parsePath, remove } from './common';\nimport { OTDir, dir } from './directory';\n\nconst fileCache = new Map<string, OTFile>();\n/**\n * Retrieves a file wrapper instance for the specified file path.\n * @param {string} filePath - The path of the file.\n * @param {'r' | 'rw' | 'rw-unsafe'} mode - A string specifying the locking mode for the access handle. The default value is \"rw\"\n * return A OTFile instance.\n * \n * @see [MDN createSyncAccessHandle](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle/createSyncAccessHandle)\n * \n * @example\n * // Read content from a file\n  const fileContent = await file('/path/to/file.txt', 'r').text();\n  console.log('File content:', fileContent);\n\n  // Check if a file exists\n  const fileExists = await file('/path/to/file.txt').exists();\n  console.log('File exists:', fileExists);\n\n  // Remove a file\n  await file('/path/to/file.txt').remove();\n */\nexport function file(filePath: string, mode: ShortOpenMode = 'rw') {\n  if (mode === 'rw') {\n    const f = fileCache.get(filePath) ?? new OTFile(filePath, mode);\n    fileCache.set(filePath, f);\n    return f;\n  }\n  return new OTFile(filePath, mode);\n}\n\n/**\n * Writes content to the specified file.\n * @param {string} target - The path of the file.\n * @param {string | BufferSource | ReadableStream<BufferSource>} content - The content to write to the file.\n * return A promise that resolves when the content is written to the file.\n * \n * @example\n * // Write content to a file\n   await write('/path/to/file.txt', 'Hello, world!');\n */\nexport async function write(\n  target: string | OTFile,\n  content: string | BufferSource | ReadableStream<BufferSource> | OTFile,\n  opts = { overwrite: true }\n) {\n  if (content instanceof OTFile) {\n    await write(target, await content.stream(), opts);\n    return;\n  }\n\n  const writer = await (target instanceof OTFile\n    ? target\n    : file(target, 'rw')\n  ).createWriter();\n  try {\n    if (opts.overwrite) await writer.truncate(0);\n    if (content instanceof ReadableStream) {\n      const reader = content.getReader();\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        await writer.write(value);\n      }\n    } else {\n      await writer.write(content);\n    }\n  } catch (err) {\n    throw err;\n  } finally {\n    await writer.close();\n  }\n}\n\nlet FILE_ID = 0;\nconst genFileId = () => ++FILE_ID;\n\ntype ShortOpenMode = 'r' | 'rw' | 'rw-unsafe';\n\n/**\n * Represents a wrapper for interacting with a file in the filesystem.\n */\nexport class OTFile {\n  get kind(): 'file' {\n    return 'file';\n  }\n\n  get path() {\n    return this.#path;\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  get parent(): ReturnType<typeof dir> | null {\n    return this.#parentPath == null ? null : dir(this.#parentPath);\n  }\n\n  #path: string;\n  #parentPath: string;\n  #name: string;\n  #mode: OpenMode;\n\n  #id: number;\n  constructor(filePath: string, mode: ShortOpenMode) {\n    this.#id = genFileId();\n    this.#path = filePath;\n    this.#mode = (\n      {\n        r: 'read-only',\n        rw: 'readwrite',\n        'rw-unsafe': 'readwrite-unsafe',\n      } as const\n    )[mode];\n    const { parent, name } = parsePath(filePath);\n    if (parent == null) throw Error('Invalid path');\n    this.#name = name;\n    this.#parentPath = parent;\n  }\n\n  #referCnt = 0;\n  #getAccessHandle = (() => {\n    let accPromise: Promise<\n      [OPFSWorkerAccessHandle, () => Promise<void>]\n    > | null = null;\n\n    return () => {\n      this.#referCnt += 1;\n      if (accPromise != null) return accPromise;\n\n      return (accPromise = new Promise(async (resolve, reject) => {\n        try {\n          const accHandle = await createOPFSAccess(\n            this.#id,\n            this.#path,\n            this.#mode\n          );\n          resolve([\n            accHandle,\n            async () => {\n              this.#referCnt -= 1;\n              if (this.#referCnt > 0) return;\n\n              accPromise = null;\n              await accHandle.close();\n            },\n          ]);\n        } catch (err) {\n          reject(err);\n        }\n      }));\n    };\n  })();\n\n  #writing = false;\n  /**\n   * Random write to file\n   */\n  async createWriter() {\n    if (this.#mode === 'read-only') throw Error('file is read-only');\n    if (this.#writing) throw Error('Other writer have not been closed');\n    this.#writing = true;\n\n    const txtEC = new TextEncoder();\n\n    // append content by default\n    const [accHandle, unref] = await this.#getAccessHandle();\n    let pos = await accHandle.getSize();\n    let closed = false;\n    return {\n      write: async (\n        chunk: string | BufferSource,\n        opts: { at?: number } = {}\n      ) => {\n        if (closed) throw Error('Writer is closed');\n        const content = typeof chunk === 'string' ? txtEC.encode(chunk) : chunk;\n        const at = opts.at ?? pos;\n        const contentSize = content.byteLength;\n        pos = at + contentSize;\n        return await accHandle.write(content, { at });\n      },\n      truncate: async (size: number) => {\n        if (closed) throw Error('Writer is closed');\n        await accHandle.truncate(size);\n        if (pos > size) pos = size;\n      },\n      flush: async () => {\n        if (closed) throw Error('Writer is closed');\n        await accHandle.flush();\n      },\n      close: async () => {\n        if (closed) throw Error('Writer is closed');\n        closed = true;\n        this.#writing = false;\n        await unref();\n      },\n    };\n  }\n\n  /**\n   * Random access to file\n   */\n  async createReader() {\n    const [accHandle, unref] = await this.#getAccessHandle();\n\n    let closed = false;\n    let pos = 0;\n    return {\n      read: async (size: number, opts: { at?: number } = {}) => {\n        if (closed) throw Error('Reader is closed');\n        const offset = opts.at ?? pos;\n        const buf = await accHandle.read(offset, size);\n        pos = offset + buf.byteLength;\n        return buf;\n      },\n      getSize: async () => {\n        if (closed) throw Error('Reader is closed');\n        return await accHandle.getSize();\n      },\n      close: async () => {\n        if (closed) return;\n        closed = true;\n        await unref();\n      },\n    };\n  }\n\n  async text() {\n    return new TextDecoder().decode(await this.arrayBuffer());\n  }\n\n  async arrayBuffer() {\n    const fh = await getFSHandle(this.#path, { create: false, isFile: true });\n    if (fh == null) return new ArrayBuffer(0);\n    return (await fh.getFile()).arrayBuffer();\n  }\n\n  async stream() {\n    const ofile = await this.getOriginFile();\n    if (ofile == null) {\n      return new ReadableStream<Uint8Array>({\n        pull: (ctrl) => {\n          ctrl.close();\n        },\n      });\n    }\n\n    return ofile.stream();\n  }\n\n  async getOriginFile() {\n    return (\n      await getFSHandle(this.#path, { create: false, isFile: true })\n    )?.getFile();\n  }\n\n  async getSize() {\n    const fh = await getFSHandle(this.#path, { create: false, isFile: true });\n    if (fh == null) return 0;\n    return (await fh.getFile()).size;\n  }\n\n  async exists() {\n    return (\n      (await getFSHandle(this.#path, {\n        create: false,\n        isFile: true,\n      })) instanceof FileSystemFileHandle\n    );\n  }\n\n  async remove() {\n    if (this.#referCnt) throw Error('exists unclosed reader/writer');\n    await remove(this.#path);\n    // fileCache.delete(this.#path);\n  }\n\n  /**\n   * If the target is a file, use current overwrite the target;\n   * if the target is a folder, copy the current file into that folder.\n   */\n  async copyTo(target: OTDir | OTFile): Promise<OTFile>;\n  async copyTo(target: FileSystemFileHandle): Promise<null>;\n  async copyTo<T>(target: T) {\n    if (target instanceof OTFile) {\n      if (target.path === this.path) return this;\n\n      await write(target.path, this);\n      return file(target.path);\n    } else if (target instanceof OTDir) {\n      if (!(await this.exists())) {\n        throw Error(`file ${this.path} not exists`);\n      }\n      return await this.copyTo(file(joinPath(target.path, this.name)));\n    } else if (target instanceof FileSystemFileHandle) {\n      await (await this.stream()).pipeTo(await target.createWritable());\n      return null;\n    }\n    throw Error('Illegal target type');\n  }\n\n  /**\n   * move file, copy then remove current\n   */\n  async moveTo(target: OTDir | OTFile): Promise<OTFile> {\n    const newFile = await this.copyTo(target);\n    await this.remove();\n    return newFile;\n  }\n}\n","import { OTDir, dir } from './directory';\nimport { OTFile, file } from './file';\n\nconst TMP_DIR = '/.opfs-tools-temp-dir';\n\nasync function safeRemove(it: OTFile | OTDir) {\n  try {\n    if (it.kind === 'file') {\n      if (!(await it.exists())) return true;\n\n      const writer = await it.createWriter();\n      await writer.truncate(0);\n      await writer.close();\n      await it.remove();\n    } else {\n      await it.remove();\n    }\n    return true;\n  } catch (e) {\n    console.warn(e);\n    return false;\n  }\n}\n\n// 'export' is for ease of testing\nexport function delByInterval() {\n  setInterval(async () => {\n    const timeOf3Days = 1000 * 60 * 60 * 24 * 3;\n    for (const it of await dir(TMP_DIR).children()) {\n      const match = /^\\d+-(\\d+)$/.exec(it.name);\n      if (match == null || Date.now() - Number(match[1]) > timeOf3Days) {\n        // Delete files that are older than three days and are not in writing\n        await safeRemove(it);\n      }\n    }\n  }, 60 * 1000);\n}\n\nconst currentPageTMPFiles: string[] = [];\nlet bindedUnloadEvt = false;\n\n// 'export' is for ease of testing\nexport async function delMarkFiles() {\n  if (globalThis.localStorage == null) return;\n\n  const opfsToolsExpires = 'OPFS_TOOLS_EXPIRES_TMP_FILES';\n\n  if (!bindedUnloadEvt) {\n    bindedUnloadEvt = true;\n    globalThis.addEventListener('unload', () => {\n      if (currentPageTMPFiles.length === 0) return;\n      localStorage.setItem(\n        opfsToolsExpires,\n        `${\n          localStorage.getItem(opfsToolsExpires) ?? ''\n        },${currentPageTMPFiles.join(',')}`\n      );\n    });\n  }\n\n  let markStr = localStorage.getItem(opfsToolsExpires) ?? '';\n  for (const name of markStr.split(',')) {\n    if (name.length === 0) continue;\n    if (await safeRemove(file(`${TMP_DIR}/${name}`))) {\n      markStr = markStr.replace(name, '');\n    }\n  }\n  localStorage.setItem(opfsToolsExpires, markStr.replace(/,{2,}/g, ','));\n}\n\n(async function init() {\n  if (globalThis.__opfs_tools_tmpfile_init__ === true) return;\n  globalThis.__opfs_tools_tmpfile_init__ = true;\n\n  // not web context\n  if (\n    globalThis.FileSystemDirectoryHandle == null ||\n    globalThis.FileSystemFileHandle == null ||\n    globalThis.navigator?.storage.getDirectory == null\n  ) {\n    return;\n  }\n\n  // clear tmpfile\n  delByInterval();\n  await delMarkFiles();\n})();\n\n/**\n * Create a temporary file that will automatically be cleared to avoid occupying too much storage space.\n * The temporary file name will be automatically generated and stored in a specific directory.\n */\nexport function tmpfile() {\n  const name = `${Math.random().toString().slice(2)}-${Date.now()}`;\n  currentPageTMPFiles.push(name);\n  return file(`${TMP_DIR}/${name}`);\n}\n","import { file } from './file';\n\nexport function rollfile(filePath: string, maxSize: number) {\n  let f = file(filePath);\n\n  let size = 0;\n  let writerPromise: ReturnType<typeof f.createWriter> = f.createWriter();\n  let readerPromise = f.createReader();\n\n  const reset = async (writer: Awaited<typeof writerPromise>) => {\n    const reader = await readerPromise;\n    const data = await reader.read(size, { at: Math.round(size * 0.3) });\n    size = await writer.write(data, { at: 0 });\n    await writer.truncate(size);\n  };\n\n  return {\n    append: async (content: string) => {\n      const writer = await writerPromise;\n      size += await writer.write(content);\n      if (size >= maxSize) await reset(writer);\n    },\n    text: f.text.bind(f),\n    remove: async () => {\n      await (await readerPromise).close();\n      await (await writerPromise).close();\n      await f.remove();\n    },\n    getSize: async () => size,\n  };\n}\n"],"names":["modules","entry","mainEntry","parcelRequireName","externals","distDir","publicUrl","devServer","globalObject","globalThis","self","window","global","previousRequire","importMap","i","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","length","mainExports","define","amd","__globalThis","parcelHelpers","defineInteropFlag","export","artplayerProxyWebAV","_avCliper","opt","art","audioCtx","gainNode","option","constructor","createElement","def","utils","canvas","ctx","getContext","clip","audioSource","intervalId","seekTarget","lastSeekTime","state","playing","duration","videoWidth","videoHeight","currentTime","playbackRate","paused","ended","readyState","buffered","muted","volume","autoplay","stop","clearInterval","updateVolume","effectiveVolume","gain","setValueAtTime","play","AudioContext","createGain","connect","destination","curTime","startAt","first","lastFrameTime","performance","now","frameHandler","currentFrameTime","deltaTime","clipState","video","audio","tick","Math","round","emit","type","clearRect","drawImage","close","buf","createBuffer","copyToChannel","createBufferSource","buffer","max","start","setInterval","preview","time","width","height","resize","player","template","$player","autoSize","aspectRatio","containerWidth","clientWidth","containerHeight","clientHeight","paddingLeft","paddingTop","containerRatio","assign","style","padding","init","Combinator","isSupported","notice","show","destroy","Promise","response","fetch","url","body","MP4Clip","error","info","ready","set","val","min","newTime","then","end","value","on","Ce","Jt","Yt","V","R","$","jt","L","rt","_t","bt","W","D","Ot","F","xt","Ct","Qt","vt","X","_","at","St","Mt","Kt","zt","ot","qt","Tt","Zt","te","ee","U","At","G","et","M","Vt","ie","ne","ve","Se","E","z","I","Te","fi","kt","it","ct","J","Ae","mi","lt","Y","It","se","Lt","Ut","P","re","j","Q","K","O","nt","st","Ie","pi","ae","oe","ce","le","he","de","ue","ht","Bt","dt","fe","Ft","Nt","ut","q","Rt","ft","me","Et","mt","Pt","Ht","pe","Me","we","ye","Z","ge","N","$t","be","xe","Dt","Wt","pt","Xt","bi","xi","ti","En","ii","Ze","_internalUtils","Log","Qe","ei","ri","Oe","ai","Rn","tn","In","Fn","kn","_mp4BoxJs","_mp4BoxJsDefault","interopDefault","_waveResampler","_opfsTools","vi","Je","s","TypeError","Si","t","e","enumerable","configurable","writable","S","Fe","has","n","d","WeakSet","add","h","B","Fi","document","cssText","textContent","appendChild","r","getBoundingClientRect","remove","visibility","a","Image","o","outerHTML","replace","src","onload","OffscreenCanvas","createImageBitmap","Ri","Float32Array","map","reduce","ci","format","numberOfChannels","ArrayBuffer","allocationSize","planeIndex","copyTo","push","Di","Array","from","Pi","Int16Array","Le","fill","getChannelData","Bi","ImageDecoder","data","all","completed","tracks","selectedTrack","frameCount","c","decode","frameIndex","image","Ye","l","m","u","_i","chanCount","OfflineAudioContext","resample","rate","method","LPF","forEach","startRendering","Ue","workerTimer","De","li","floor","T","sampleRate","channelCount","codec","Ne","videoTracks","Oi","mdia","minf","stbl","stsd","entries","avcC","hvcC","av1C","vpcC","default","DataStream","BIG_ENDIAN","write","Uint8Array","slice","getTrackById","descKey","startsWith","videoTrackConf","timescale","brands","videoDecoderConf","codedHeight","codedWidth","description","audioTracks","je","audioTrackConf","samplerate","sample_rate","channel_count","hdlr","audioDecoderConf","Mi","esd","descs","moov","traks","flat","find","esds","zi","createFile","read","byteLength","fileStart","appendBuffer","onReady","mp4boxFile","setExtractionOptions","nbSamples","onSamples","He","Re","kind","createReader","Function","yt","create","audioSampleRate","audioChanCount","AbortController","ReadableStream","isArray","videoSamples","localFile","tmpfile","Ke","audioSamples","decoderConf","headerBoxPos","videoFrameFinder","audioFrameFinder","hardwareAcceleration","__unsafe_hardwareAcceleration__","Ni","targetSampleRate","hi","Vi","deleted","cts","meta","getFileHeaderBinData","getOriginFile","Blob","size","arrayBuffer","tickInterceptor","thumbnails","abort","signal","aborted","Wi","convertToBlob","quality","w","p","b","ts","img","timestamp","addEventListener","f","y","step","g","C","v","Yi","split","Xi","is_idr","_e","Gi","clone","splitTrack","WeakMap","ftyp","dts","is_sync","Ji","DataView","getUint8","getUint32","offset","shift","catch","decodeQueueSize","JSON","stringify","samples","warn","di","localFileReader","Be","onDecodingError","conf","VideoDecoder","output","VideoFrame","message","includes","configure","decState","decQSize","decCusorIdx","sampleLen","inputCnt","outputCnt","cacheFrameLen","softDeocde","clipIdCnt","sleepCnt","memInfo","ui","Ui","ceil","frameCnt","qe","decoding","EncodedAudioChunk","Hi","$i","resampleRate","AudioDecoder","qSize","pcmLen","subarray","EncodedVideoChunk","flush","filter","memory","jsHeapSizeLimit","totalJSHeapSize","usedJSHeapSize","percentUsed","toFixed","percentTotal","gt","Response","blob","ImageBitmap","every","displayWidth","displayHeight","stream","tt","loop","getPCMData","ji","decodeAudioData","ke","audioTrack","getAudioTracks","getVideoTracks","contentHint","autoReadStream","MediaStreamTrackProcessor","track","readable","onChunk","onDone","getTracks","Gt","color","textBgColor","fontSize","letterSpacing","bottomOffset","fontFamily","strokeStyle","lineWidth","lineCap","lineJoin","textShadow","offsetX","offsetY","blur","Ki","trim","lineStr","match","test","text","ni","font","textAlign","textBaseline","unshift","reverse","globalAlpha","measureText","shadowOffsetX","shadowOffsetY","shadowBlur","fillStyle","fillRect","actualBoundingBoxLeft","shadowColor","strokeText","fillText","Number","wi","enqueue","chunkType","file","releaseUsedSamples","onFlush","cancel","highWaterMark","WritableStream","qi","boxes","mdats","moofs","findIndex","createWriter","mvhd","overwrite","endianness","en","pipeThrough","addTrack","k","addSample","file2stream","encode","Ei","H","Ci","nn","sn","AudioEncoder","Zi","AudioData","numberOfFrames","rn","Ge","an","cn","ln","si","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","keyColor","pn","getImageData","cvs","gl","fn","premultipliedAlpha","alpha","hn","VERTEX_SHADER","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","useProgram","uniform3fv","getUniformLocation","uniform1f","similarity","smoothness","spill","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","getAttribLocation","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","enableVertexAttribArray","pixelStorei","UNPACK_FLIP_Y_WEBGL","un","createTexture","bindTexture","TEXTURE_2D","RGBA","UNSIGNED_BYTE","texImage2D","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","drawArrays","TRIANGLES","imageOrientation","$e","EventTool","angle","center","fixedAspectRatio","fixedScaleCenter","checkHit","cos","sin","yi","rect","zIndex","_render","setTransform","flip","rotate","opacity","setAnimation","to","isNaN","delay","iterCount","animate","wn","copyStateTo","We","offscreenRender","done","Xe","getClip","preFrame","render","visible","finally","yn","gi","bgColor","videoCodec","bitrate","fps","metaDataTags","VideoEncoder","isConfigSupported","supported","addSprite","main","expired","sort","onProgress","debug","onEnded","onError","mp4file","recodemux","expectFPS","gn","sprites","aborter","save","restore","audios","mainSprDone","bn","outputAudio","remux","hasVideoTrack","timeSlice","xn","encodeAudio","encodeVideo","keyFrame","resetTransform","getEncodeQueueSize","log_level","Date","setLogLevel","level","msg","console","undefined","log","LOG_LEVEL_DEBUG","getDurationString","LOG_LEVEL_INFO","LOG_LEVEL_WARNING","LOG_LEVEL_ERROR","_timescale","pad","number","str","join","neg","duration_sec","hours","minutes","msec","printRanges","ranges","i1","MP4BoxStream","dataview","position","prototype","getPosition","getEndPosition","getLength","seek","pos","npos","isFinite","isEos","readAnyInt","signed","getInt8","getInt16","getUint16","getInt32","readUint8","readUint16","readUint24","readUint32","readUint64","readString","String","fromCharCode","readCString","arr","apply","readInt8","readInt16","readInt32","readInt64","readUint8Array","readInt16Array","readUint16Array","readUint32Array","Uint32Array","readInt32Array","Int32Array","byteOffset","_byteOffset","dataView","LITTLE_ENDIAN","_realloc","extra","_dynamicSize","req","blen","_buffer","_byteLength","dst","_trimAlloc","_dataView","isEof","mapUint8Array","memcpy","arrayToNative","readInt8Array","Int8Array","Uint16Array","readFloat64Array","Float64Array","readFloat32Array","readFloat32","getFloat32","readFloat64","getFloat64","dstOffset","srcOffset","dstU8","srcU8","array","arrayIsLittleEndian","flipArrayEndianness","nativeToEndian","littleEndian","u8","tmp","failurePosition","fromCharCodeUint8","uint8arr","encoding","TextDecoder","len","filename","URL","createObjectURL","setAttribute","click","revokeObjectURL","writeInt32Array","mapInt32Array","writeInt32","writeInt16Array","mapInt16Array","writeInt16","writeInt8Array","mapInt8Array","writeInt8","writeUint32Array","mapUint32Array","writeUint32","writeUint16Array","mapUint16Array","writeUint16","writeUint8Array","writeUint8","writeFloat64Array","mapFloat64Array","writeFloat64","writeFloat32Array","mapFloat32Array","writeFloat32","setInt32","setInt16","setInt8","setUint32","setUint16","setUint8","setFloat32","setFloat64","writeUCS2String","lengthOverride","charCodeAt","writeString","TextEncoder","substring","writeCString","writeStruct","structDefinition","struct","writeType","tp","charset","parseInt","ta","writeUint64","writeUint24","adjustUint32","MultiBufferStream","buffers","bufferIndex","insertBuffer","initialized","firstBuffer","logBufferLevel","concat","buffer1","buffer2","reduceBuffer","newLength","smallB","usedBytes","ab","to_add","splice","used","total","range","bufferedString","cleanBuffers","mergeNextBuffer","next_buffer","oldLength","oldUsedBytes","oldFileStart","findPosition","fromStart","filePosition","markAsUsed","abuffer","index","findEndContiguousBuf","inputindex","currentBuf","nextBuf","getEndFilePositionAfter","addUsedBytes","nbBytes","setAllUsedBytes","MPEG4DescriptorParser","descTagToName","getDescriptorName","tag","that","classes","parseOneDescriptor","desc","byteRead","hdrSize","Descriptor","parse","_tag","_size","findDescriptor","parseRemainingDescriptors","ES_Descriptor","ES_ID","flags","dependsOn_ES_ID","OCR_ES_ID","getOTI","dcd","oti","getAudioConfig","dsi","audioObjectType","DecoderConfigDescriptor","streamType","upStream","bufferSize","maxBitrate","avgBitrate","DecoderSpecificInfo","SLConfigDescriptor","BoxParser","ERR_INVALID_DATA","ERR_NOT_ENOUGH_DATA","OK","BASIC_BOXES","FULL_BOXES","CONTAINER_BOXES","boxCodes","fullBoxCodes","containerBoxCodes","sampleEntryCodes","sampleGroupEntryCodes","trackGroupTypes","UUIDBoxes","UUIDs","initialize","FullBox","Box","ContainerBox","SampleEntry","TrackGroupTypeBox","createBoxCtor","createFullBoxCtor","types","createContainerBoxCtor","_type","_uuid","uuid","version","hdr_size","SampleGroupEntry","grouping_type","parseMethod","parseFullHeader","addSubBoxArrays","subBoxNames","nbSubBoxes","createMediaSampleEntryCtor","mediaType","createSampleEntryCtor","createEncryptedSampleEntryCtor","createSampleGroupCtor","createTrackGroupCtor","createUUIDBox","isFullBox","isContainerBox","ColorPoint","Pixel","row","col","bad_pixel_row","bad_pixel_column","TKHD_FLAG_ENABLED","TKHD_FLAG_IN_MOVIE","TKHD_FLAG_IN_PREVIEW","TFHD_FLAG_BASE_DATA_OFFSET","TFHD_FLAG_SAMPLE_DESC","TFHD_FLAG_SAMPLE_DUR","TFHD_FLAG_SAMPLE_SIZE","TFHD_FLAG_SAMPLE_FLAGS","TFHD_FLAG_DUR_EMPTY","TFHD_FLAG_DEFAULT_BASE_IS_MOOF","TRUN_FLAGS_DATA_OFFSET","TRUN_FLAGS_FIRST_FLAG","TRUN_FLAGS_DURATION","TRUN_FLAGS_SIZE","TRUN_FLAGS_FLAGS","TRUN_FLAGS_CTS_OFFSET","addBox","box1","prop","addEntry","_prop","parseUUID","parseHex16","hex16","hex","toString","parseOneBox","headerOnly","parentSize","diff","box_type","box","has_unparsed_data","parseDataAndRewind","ret1","indexOf","parseLanguage","language","chars","languageString","SAMPLE_ENTRY_TYPE_VISUAL","SAMPLE_ENTRY_TYPE_AUDIO","SAMPLE_ENTRY_TYPE_HINT","SAMPLE_ENTRY_TYPE_METADATA","SAMPLE_ENTRY_TYPE_SUBTITLE","SAMPLE_ENTRY_TYPE_SYSTEM","SAMPLE_ENTRY_TYPE_TEXT","parseHeader","data_reference_index","parseFooter","compressorname_length","horizresolution","vertresolution","frame_count","compressorname","depth","samplesize","FieldLength","large_size","layer_size","op_index","aux_type","aux_subtype_length","aux_subtype","seq_profile","seq_level_idx_0","seq_tier_0","high_bitdepth","twelve_bit","monochrome","chroma_subsampling_x","chroma_subsampling_y","chroma_sample_position","reserved_1","initial_presentation_delay_present","initial_presentation_delay_minus_one","reserved_2","configOBUs_length","configOBUs","toparse","configurationVersion","AVCProfileIndication","profile_compatibility","AVCLevelIndication","lengthSizeMinusOne","nb_SPS_nalus","SPS","nalu","nb_PPS_nalus","PPS","ext","bufferSizeDB","all_ref_pics_intra","intra_pred_used","max_ref_per_pic","channel_indexes","channel_types","channel_associations","cleanApertureWidthN","cleanApertureWidthD","cleanApertureHeightN","cleanApertureHeightD","horizOffN","horizOffD","vertOffN","vertOffD","max_content_light_level","max_pic_average_light_level","pos_x","pos_y","pos_z","quat_x","quat_y","quat_z","focal_length_x","principal_point_x","principal_point_y","focal_length_y","skew_factor","component_count","component_types","component_type_urls","component_type","entry_count1","chunk_offsets","maxCLL","maxFALL","colour_type","colour_primaries","transfer_characteristics","matrix_coefficients","full_range_flag","ICC_profile","compositionToDTSShift","leastDecodeToDisplayDelta","greatestDecodeToDisplayDelta","compositionStartTime","compositionEndTime","sample_counts","sample_offsets","tmp_byte1","tmp_byte2","tmp_byte3","fscod","bsid","bsmod","acmod","lfeon","bit_rate_code","tmp_16","data_rate","num_ind_sub","ind_subs","ind_sub","num_dep_sub","chan_loc","boxesFound","knownBlockTypes","flagAndType","numMetadataBlocks","bytessent","Version","OutputChannelCount","PreSkip","InputSampleRate","OutputGain","ChannelMappingFamily","StreamCount","CoupledCount","ChannelMapping","extended_language","segment_duration","media_time","media_rate_integer","media_rate_fraction","presentation_time","event_duration","scheme_id_uri","presentation_time_delta","message_size","message_data","createEntityToGroupCtor","group_id","num_entities_in_group","entity_ids","entity_id","tile_size_x","tile_size_y","layer_binning","tiles_in_layer_column_minus1","tiles_in_layer_row_minus1","esd_data","esd_parser","fieldCount","fieldOrdering","data_format","major_brand","minor_version","compatible_brands","handler","tmp_byte","general_profile_space","general_tier_flag","general_profile_idc","general_profile_compatibility","general_constraint_indicator","general_level_idc","min_spatial_segmentation_idc","parallelismType","chroma_format_idc","bit_depth_luma_minus8","bit_depth_chroma_minus8","avgFrameRate","constantFrameRate","numTemporalLayers","temporalIdNested","nalu_arrays","numOfArrays","nalu_array","completeness","nalu_type","numNalus","entry_count","item_infos","byte","offset_size","length_size","base_offset_size","index_size","items","item_count","item","item_ID","construction_method","base_offset","extent_count","extents","extent","extent_index","extent_offset","extent_length","reserved","axis","item_protection_index","item_name","content_type","content_encoding","extension_type","item_type","item_uri_type","associations","item_assoc","association_count","props","essential","property_index","references","SingleItemTypeReferenceBox","SingleItemTypeReferenceBoxLarge","image_width","image_height","schemeURI","count","levels","track_ID","padding_flag","assignment_type","grouping_type_parameter","sub_track_id","layer_id","period","bytes","display_primaries","white_point","max_display_mastering_luminance","min_display_mastering_luminance","creation_time","modification_time","fragment_duration","sequence_number","bits_per_pixel","matrix","next_track_id","packetssent","sample_count","padbits","hSpacing","vSpacing","payloadID","rtpmap_string","initial_delay","item_id","num_channels","bits_per_channels","step_count","ref_track_id","ntp_timestamp","system_id","kid","datasize","descriptionformat","sdptext","aux_info_type","aux_info_type_parameter","default_sample_info_size","sample_info_size","mime_format","namespace","schema_location","auxiliary_mime_types","displayFlags","horizontal_justification","vertical_justification","bg_color_rgba","box_record","style_record","roll_count","first_output_sample","sample_offset","remaining","description_length","num_output_samples","num_total_samples","layerNumber","accurateStatisticsFlag","avgBitRate","subSequenceIdentifier","durationFlag","avgRateFlag","dependency","numReferences","dependencyInfo","subSeqDirectionFlag","roll_distance","num_leading_samples_known","num_leading_samples","operation_point_count","target_rate_share","available_bitrate","maximum_bitrate","minimum_bitrate","discard_priority","crypt_byte_block","skip_byte_block","isProtected","Per_Sample_IV_Size","KID","constant_IV_size","constant_IV","NAL_unit_type","level_independently_decodable","group_description_index","component_index","correction_applied","num_bad_rows","num_bad_cols","num_bad_pixels","bad_rows","bad_columns","bad_pixels","scheme_type","scheme_version","scheme_uri","is_leading","sample_depends_on","sample_is_depended_on","sample_has_redundancy","default_length","default_group_description_index","reference_ID","earliest_presentation_time","first_offset","ref","tmp_32","reference_type","referenced_size","subsegment_duration","starts_with_SAP","SAP_type","SAP_delta_time","from_item_ID","to_item_ID","primaryRChromaticity_x","primaryRChromaticity_y","primaryGChromaticity_x","primaryGChromaticity_y","primaryBChromaticity_x","primaryBChromaticity_y","whitePointChromaticity_x","whitePointChromaticity_y","luminanceMax","luminanceMin","balance","subsegments","subsegment_count","subsegment","range_count","range_size","priority","switch_group","alternate_group","attribute_list","first_chunk","samples_per_chunk","sample_description_index","entryCount","shadowed_sample_numbers","sync_sample_numbers","sample_numbers","sample_sizes","sample_size","delta","sample_deltas","tmp32","single_view_allowed","stereo_scheme","stereo_indication_type","ftypBox","field_size","subsample_count","sampleInfo","sample_delta","subsamples","subsample","discardable","codec_specific_parameters","default_crypt_byte_block","default_skip_byte_block","default_isProtected","default_Per_Sample_IV_Size","default_KID","default_constant_IV_size","default_constant_IV","baseMediaDecodeTime","readBytes","track_id","base_data_offset","default_sample_description_index","default_sample_duration","default_sample_size","default_sample_flags","length_size_of_traf_num","length_size_of_trun_num","length_size_of_sample_num","number_of_entries","moof_offset","traf_number","trun_number","sample_number","layer","track_group_id","TrackReferenceTypeBox","track_ids","trefBox","ret","data_offset","first_sample_flags","sample_duration","sample_flags","sample_composition_time_offset","config","lang","tags","profile","component_bit_depth_minus_one","component_format","component_align_size","sampling_type","interleave_type","block_size","component_little_endian","block_pad_lsb","block_little_endian","block_reversed","pad_unknown","pixel_size","row_align_size","tile_align_size","num_tile_cols_minus_one","num_tile_rows_minus_one","location","LiveServerManifest","default_AlgorithmID","default_IV_size","fragment_count","absolute_time","absolute_duration","graphicsmode","opcolor","bitDepth","chromaSubsampling","videoFullRangeFlag","colourPrimaries","transferCharacteristics","matrixCoefficients","colorSpace","transferFunction","codecIntializationDataSize","codecIntializationData","bitReader","held_bits","num_held_bits","stream_read_1_bytes","strm1","stream_read_2_bytes","extract_bits","num_bits","ptl_present_flag","ols_idx","num_sublayers","constant_frame_rate","bit_depth_minus8","num_bytes_constraint_info","ptl_frame_only_constraint_flag","ptl_multilayer_enabled_flag","general_constraint_info","cnstr1","cnstr2","ptl_sublayer_present_mask","sublayer_level_idc","ptl_num_sub_profiles","general_sub_profile_idc","max_picture_width","max_picture_height","avg_frame_rate","num_of_arrays","strm","isVideo","isAudio","isSubtitle","isMetadata","isHint","getCodec","getWidth","getHeight","getChannelCount","getSampleRate","getSampleSize","VisualSampleEntry","AudioSampleEntry","SubtitleSampleEntry","MetadataSampleEntry","decimalToHex","avc1SampleEntry","avc2SampleEntry","avc3SampleEntry","avc4SampleEntry","baseCodec","hev1SampleEntry","hvc1SampleEntry","reversed","hasByte","constraint_string","vvc1SampleEntry","vvi1SampleEntry","vvcC","last_nonzero","ptl_frame_only_constraint","ptl_multilayer_enabled","base32_chars","mp4aSampleEntry","stxtSampleEntry","vp08SampleEntry","vp09SampleEntry","av01SampleEntry","bitdepth","writeHeader","sizePosition","avcCBox","co64Box","cslgBox","cttsBox","drefBox","elngBox","elstBox","emsgBox","hdlrBox","hvcCBox","kindBox","mdhdBox","mehdBox","mfhdBox","mvhdBox","writeFooter","stppSampleEntry","sbgpBox","sgpdBox","sidxBox","smhdBox","stcoBox","stscBox","stsdBox","stshBox","stssBox","stszBox","constant","sttsBox","tfdtBox","tfhdBox","tkhdBox","trexBox","trunBox","data_offset_position","vmhdBox","unpack","pts","Infinity","description_index","chunk_index","DIFF_BOXES_PROP_NAMES","DIFF_PRIMITIVE_ARRAY_PROP_NAMES","boxEqualFields","box_a","box_b","boxEqual","VTTin4Parser","parseSample","cues","cue","getText","startTime","endTime","secToTimestamp","insec","ms","string","cueIn4","payl","XMLSubtitlein4Parser","sample","resources","documentString","DOMParser","parseFromString","Textin4Parser","parseConfig","ISOFile","isProgressive","moovStartFound","onMoovStart","moovStartSent","readySent","onSegment","sampleListBuilt","fragmentedTracks","extractedTracks","isFragmentationInitialized","sampleProcessingStarted","nextMoofNumber","itemListBuilt","onSidx","sidxSent","setSegmentOptions","user","options","trak","fragTrack","nextSample","segmentStream","nb_samples","rapAlignement","unsetSegmentOptions","extractTrack","unsetExtractionOptions","restoreParsePosition","hasIncompleteMdat","processIncompleteMdat","saveParsePosition","processIncompleteBox","updateUsedBytes","checkBuffer","last","nextFileStart","buildSampleLists","updateSampleLists","getInfo","processSamples","nextSeekPosition","nextParsePosition","sidx","flattenItemInfo","processItems","onItem","getAllocatedSampleDataSize","sample_desc","movie","_1904","getTime","hasMoov","isFragmented","mvex","mehd","hasIOD","iods","created","modified","subtitleTracks","metadataTracks","hintTracks","otherTracks","tkhd","tref","edts","edits","elst","movie_duration","movie_timescale","track_width","track_height","mdhd","cts_shift","cslg","samples_duration","udta","kinds","elng","samples_size","mime","setNextSeekPositionFromSample","alreadyRead","fragTrak","result","createFragment","extractTrak","getSample","getBox","getBoxes","returnEarly","_sweep","getTrackSamplesInfo","getTrackSample","sampleNum","lastValidSample","releaseSample","samplesDataSize","seekTrack","useRap","seek_offset","rap_seek_sample_num","seek_sample_num","getTrackDuration","trak_seek_info","seek_info","equal","box_index","a_box","b_box","lastBoxStartPosition","parsingMdat","discardMdatData","_options","media_duration","sample_description_entry","media_type","codes","avcDecoderConfigRecord","hevcDecoderConfigRecord","description_boxes","buildTrakSampleLists","computeSize","stream_","depends_on","is_depended_on","has_redundancy","degradation_priority","first_dts","moof","createSingleSampleMoof","trafs","truns","moofBox","traf","lastMoofIndex","resetTables","initial_duration","stco","co64","stsc","stsz","stz2","stts","ctts","stss","initSampleGroups","sbgps","trak_sgpds","traf_sgpds","sample_group_info","sample_group_key","SampleGroupInfo","_parameter","_sbgp","sbgp","last_sample_in_run","entry_index","sample_groups_info","fragment_description","is_fragment","setSampleGroupProperties","sample_groups","process_sdtp","sdtp","subs","stdp","sgpds","last_sample_in_stts_run","stts_run_index","last_sample_in_ctts_run","ctts_run_index","last_stss_index","subs_entry_index","last_subs_sample_index","chunk_run_index","last_chunk_in_run","offset_in_chunk","last_sample_in_chunk","tfhd","trex","getTrexById","last_run_position","trun","moof_number","number_in_traf","first_sample_index","first_traf_merged","tfdt","bdop","dbim","dop","bdo","has_fragment_subsamples","sample_index","lengthAfterStart","getCodecs","codecs","trexs","entity_groups","itemsDataSize","iinf","ref_to","protection_index","protection","ipro","protections","grpl","entity_group","iloc","itemloc","source","dinf","pitm","primary","iref","iprp","ipmas","ipma","association","properties","propEntry","ipco","propbox","getItem","releaseItem","callback","sent","hasItem","getMetaHandler","getPrimaryItem","itemToFragmentedTrackFile","itemId","trackOptions","ispe","trackId","outstream","sampleNumber","mdat","mdatBox","writeInitializationSegment","total_duration","getBuffer","initializeSegmentation","initSegs","seg","moovBox","printHeader","indent","print","prev_indent","MP4Box","_keepMdatData","_stream","A","Map","Set","delete","forwardEvent","clear","onmessage","event","postMessage","Worker","getReader","releaseLock","keys","lvName","timeStr","getHours","getMinutes","getSeconds","getMilliseconds","args","fromEntries","dump","once","encoder0","encoder1","decoderConfig","encodeQueueSize","gopId","esdsBox","framerate","avc","navigator","toLocaleDateString","userAgent","visibilityState","PressureObserver","observe","__esModule","exportAll","dest","key","hasOwnProperty","destName","_interpolator","_firLpf","_butterworthLpf","DEFAULT_LPF_USE","DEFAULT_LPF_ORDER","DEFAULT_LPF","ButterworthLPF","FIRLPF","oldSampleRate","details","newSamples","interpolator","Interpolator","tension","sincFilterSize","sincWindow","LPFType","upsample_","interpolate","reset","LPFOrder","downsample_","resample_","scaleFrom","scaleTo","length_","scaleFactor_","cubic","point","linear","sinc","tangentFactor_","sincFilterSize_","kernel_","window_","sinc_","PI","getClippedInput_","getTangent_","t2","t3","ref1","sum","exp","order","cutOff","omega","dc","filters","initZ_","pointer","out","getCoeffs_","Fs","Fc","stages","b0","b1","b2","a1","a2","runStage_","params","coeffs","preCalc_","cw","a0","pre","input","temp","atob","webkitURL","evtType","cbId","returnVal","reject","errMsg","fileId","filePath","mode","opts","isView","truncate","newSize","getSize","storage","getDirectory","getDirectoryHandle","isFile","getFileHandle","removeEntry","recursive","path","exists","FileSystemDirectoryHandle","children","values","moveTo","rw","getFile","pull","FileSystemFileHandle","pipeTo","createWritable","localStorage","setItem","random","append","__opfs_tools_tmpfile_init__","exec","_default","parcelRequire4dc0","createEl","tagName","renderTxt2Img","txt","div","svgStr","renderTxt2ImgBitmap","imgEl","concatFloat32Array","bufs","rs","concatPCMFragments","fragments","chanListPCM","extractPCM4AudioData","ad","idx","chanBufSize","chanBuf","convertF32ToPlanar","convertS16ToF32Planar","pcmS16Data","numChannels","numSamples","planarData","channel","pcmF32Data","extractPCM4AudioBuffer","decodeImg","imageDecoder","_a","mixinPCM","maxLen","bufIdx","chan0","chan1","trackIdx","_c0","_c1","_b","audioResample","pcmData","curRate","target","chanCnt","emptyPCM","waveResampler","abSource","sleep","ringSliceFloat32Array","cnt","changePCMPlaybackRate","newPcmData","originalIndex","intIndex","frac","DEFAULT_AUDIO_CONF","extractFileConfig","vTrack","videoDesc","parseVideoCodecDesc","aTrack","getESDSBoxFromMP4File","parseAudioInfo4ESDSBox","mp4box","mp4aBox","byte1","byte2","sampleRateIdx","quickParseMP4File","reader","vTrackId","aTrackId","cursor","maxReadSize","nextPos","CLIP_ID","isOTFile","obj","_MP4Clip","__privateAdd","_insId","_log","__privateGet","__publicField","_destroyed","_meta","_localFile","_headerBoxPos","_volume","_videoSamples","_audioSamples","_videoFrameFinder","_audioFrameFinder","_decoderConf","_opts","tickRet","_thumbAborter","__privateSet","initByStream","otFile","mp4FileToSamples","genDecoder","genMeta","oFile","_c","imgWidth","aborterSignal","abortMsg","convtr","createVF2BlobConvtr","pngPromises","vc","resolver","pushPngPromise","vf","cur","VideoFrameFinder","thumbnailByKeyFrame","preVideoSlice","postVideoSlice","splitVideoSampleByTime","preAudioSlice","postAudioSlice","splitAudioSampleByTime","preClip","postClip","clips","videoClip","audioClip","vDuration","aDuration","lastSampele","AudioFrameFinder","mp4Info","videoDeltaTS","audioDeltaTS","ac","normalizeTimescale","fixFirstBlackFrame","sampleType","idrOffset","idrNALUOffset","_dec","_ts","_curAborter","_reset","_parseFrame","_sleepCnt","_lastVfDur","_downgradeSoftDecode","_videoDecCusorIdx","_videoFrames","_outputFrameCnt","_inputChunkCnt","_predecodeErr","dec","_startDecode","_decoding","_getState","endIdx","hasValidFrame","readStarTime","chunks","videosamples2Chunks","readCost","rangSize","decodeGoP","keyIdx","encoderConf","rsVf","memoryUsageInfo","findIndexOfSamples","_sampleRate","needResetTime","_decCusorIdx","_pcmData","emitFrameCnt","ramainFrameCnt","emitAudioFrames","createAudioChunksDecoder","pcmArr","outputCb","outputHandler","pcm","resampleQ","createPromiseQueue","needResample","adec","handleDecodeError","prefixStr","chunk","onResult","rsCache","waitingIdx","updateRs","emitIdx","emitRs","addIdx","task","emitCnt","gapCnt","gopStartIdx","gopEndIdx","hitIdx","hitSample","preSlice","postSlice","u8Arr","dv","nalUnitType","decConf","abortSingl","onOutput","fileReader","createVideoDec","downgrade","iframeCnt","minCtsSample","mem","_ImgClip","dataSource","_ImgClip_instances","_img","_frames","initWithImgBitmap","imgBitmap","frame","acc","__privateMethod","initAnimateImg_fn","firstVf","ImgClip","_AudioClip","_AudioClip_instances","_chan0Buf","_chan1Buf","_frameOffset","init_fn","chan","tStart","parseStream2PCM","AudioClip","_MediaStreamClip","_stopRenderCvs","_cvs","_ms","videoTrack","renderVideoTrackToCvs","MediaStreamClip","onOffscreenCanvasReady","emitFF","cvsCtx","_EmbedSubtitlesClip","content","_EmbedSubtitlesClip_instances","_subtitles","_ctx","_lastVF","_lineHeight","_linePadding","parseSrt","renderTxt_fn","sub","preLastIt","postFirstIt","lines","bottomDistance","txtMeas","centerX","EmbedSubtitlesClip","srtTimeToSeconds","seconds","milliseconds","srt","SampleTransform","_inputBufOffset","streamCancelled","ctrl","releasedCnt","ui8Arr","inputBuf","fixMP4BoxFileDuration","inMP4File","sendedBoxIdx","totalDuration","write2TmpFile","box2Buf","tmpFileWriter","moovPrevBoxes","moovBoxReady","moovIdx","timerId","postFile","initPromise","stoped","rsFile","startIdx","ds","chunk2MP4SampleOpts","fastConcatMP4","streams","outfile","dumpFile","concatStreamsToMP4BoxFile","outStream","vDTS","vCTS","aDTS","aCTS","lastVSamp","lastASamp","offsetDTS","offsetCTS","lastSamp","fixFMP4Duration","createMP4AudioSampleDecoder","adConf","cacheAD","adDecoder","ss","createMP4AudioSampleEncoder","aeConf","adEncoder","lastData","createAD","audioFade","dataLen","fadeLen","mixinMP4AndAudio","mp4Stream","stopOut","audioSampleDecoder","audioSampleEncoder","inputAudioPCM","audioOffset","mp4HasAudio","safeAudioTrackConf","addInputAudio2Track","mixinAudioSampleAndInputPCM","getInputAudioSlice","vdieoSamples","firstSamp","pcmLength","audioDataBuf","pcmFragments","mp4AudioPCM","vertexShader","fragmentShader","POINT_POS","TEX_COORD_POS","initShaderProgram","vsSource","fsSource","loadShader","shaderProgram","shader","updateTexture","texture","initTexture","internalFormat","border","srcFormat","srcType","pixel","initCvs","posBuffer","a_position","texCoordBuffer","a_texCoord","getSourceWH","imgSource","getKeyColor","createChromakey","keyC","_Rect","master","_Rect_instances","_evtTool","_x","_y","_w","_h","_angle","_master","setBaseProps_fn","tx","ty","agl","tOX","tOY","mx","my","changed","Rect","BaseSprite","_time","_zIndex","_animatKeyFrame","_animatOpts","numK","updateProps","linearTimeFn","kf","offsetTime","process","startState","nextState","nextFrame","startFrame","stateProcess","_OffscreenSprite","_clip","_lastVf","outAudio","spr","OffscreenSprite","_VisibleSprite","_VisibleSprite_instances","_lastAudio","_ticking","_lastTime","update_fn","VisibleSprite","COM_ID","letEncoderCalmDown","getQSize","_Combinator_instances","_sprites","_stopOutput","_hasVideoTrack","os","logAttrs","pick","newOS","mainSpr","maxTime","startRecodeMux_fn","starTime","stopReCodeMux","run_fn","prog","closeOutStream","progress","sprRender","createSpritesRender","encodeData","createAVEncoder","exit","outProgTimer","gopSize","audioTrackBuf","createAudioTrackBuf","adFrames","adDataSize","putOffset","audioTs","adDuration","placeholderData","getAudioData","readOffset","adCnt","trackAudios","_listeners","listener","handlers","off","evtTypes","removeHandlers","fromEvtType","toEvtType","setup","interval","createWorker","handlerMap","runCount","worker","groupId","fns","cbs","run","onCancel","firstMoofReady","deltaBuf","errBox","unsafeReleaseMP4BoxFile","canceled","createBoxHeader","createHdlrBox","tec","handlerType","nameBytes","view","createKeysBox","keyNamespace","keyData","keyBuf","entryBuf","createIlstBox","dataStrBuf","valueData","keyId","valueBytes","entrySize","totalSizwe","createMetaBox","keysBox","ilstBox","any2Str","getTimeStr","THRESHOLD","history","lvHandler","lvThres","logfn","records","avSyncEvtTool","addMetadata","metaBox","moovReady","onMoovReady","vEncoder","encodeVideoTrack","aEncoder","encodeAudioTrack","mp4File","videoTrackOpts","audioReady","samplesCache","encId","fixChromeConstraintSetFlagsBug","curEncId","lastAddedSampleTime","checkCache","nextEncId","curCache","nextCache","curFirst","lastTs","addSampleToFile","nextFirst","lastTime","stopTimer","createVideoEncoder","videoOpts","outHandler","encoder","audioOpts","audioTrackOpts","videoReady","createESDSBox","configlen","createOPFSAccess","postMsg","getWorkerMsger","msgerCache","nextMsgerIdx","msger","OPFSWorker","cbFns","trans","rsP","parsePath","pathArr","getFSHandle","dirPaths","dirHandle","root","joinPath","p1","p2","dir","dirPath","OTDir","_OTDir","_path","_name","_parentPath","handle","newDir","fileCache","OTFile","writer","FILE_ID","genFileId","_OTFile","_mode","_id","_referCnt","_getAccessHandle","accPromise","accHandle","_writing","txtEC","unref","closed","contentSize","fh","ofile","newFile","TMP_DIR","safeRemove","delByInterval","currentPageTMPFiles","bindedUnloadEvt","delMarkFiles","opfsToolsExpires","markStr","rollfile","maxSize","writerPromise","readerPromise"],"version":3,"file":"index.js.map"}