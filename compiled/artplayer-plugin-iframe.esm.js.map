{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,C,E,C,E,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,G,C,C,E,C,O,C,C,E,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,O,C,K,E,E,S,C,K,E,E,S,C,K,E,E,C,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,A,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,M,C,S,C,C,C,C,C,C,C,E,A,E,kD,iB,C,ECAe,OAAM,EACjB,WAAW,QAAS,CAChB,OAAO,OAAO,GAAG,GAAK,MAC1B,CAEA,OAAO,YAAY,CAAE,KAAA,CAAI,CAAE,KAAA,CAAI,CAAE,GAAA,EAAK,CAAC,CAAE,CAAE,CACvC,GAAI,CAAC,EAAsB,MAAM,CAC7B,MAAM,AAAI,MAAM,6EAGpB,OAAO,MAAM,CAAC,WAAW,CACrB,CACI,KAAM,EACN,KAAM,EACN,GAAI,CACR,EACA,IAER,CAEA,aAAa,UAAU,CAAK,CAAE,CAC1B,GAAI,CAAC,EAAsB,MAAM,CAC7B,MAAM,AAAI,MAAM,2EAGpB,GAA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","sources":["<anon>","packages/artplayer-plugin-iframe/src/index.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (\n  modules,\n  entry,\n  mainEntry,\n  parcelRequireName,\n  externals,\n  distDir,\n  publicUrl,\n  devServer\n) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var importMap = previousRequire.i || {};\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        if (externals[name]) {\n          return externals[name];\n        }\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        globalObject\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.require = nodeRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.distDir = distDir;\n  newRequire.publicUrl = publicUrl;\n  newRequire.devServer = devServer;\n  newRequire.i = importMap;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  // Only insert newRequire.load when it is actually used.\n  // The code in this file is linted against ES5, so dynamic import is not allowed.\n  // INSERT_LOAD_HERE\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n    }\n  }\n})({\"cTaWs\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nclass ArtplayerPluginIframe {\n    static get iframe() {\n        return window.top !== window;\n    }\n    static postMessage({ type, data, id = 0 }) {\n        if (!ArtplayerPluginIframe.iframe) throw new Error('The \"ArtplayerPluginIframe.postMessage\" method can only be used in iframe');\n        window.parent.postMessage({\n            type: type,\n            data: data,\n            id: id\n        }, '*');\n    }\n    static async onMessage(event) {\n        if (!ArtplayerPluginIframe.iframe) throw new Error('The \"ArtplayerPluginIframe.onMessage\" method can only be used in iframe');\n        const { type, data, id } = event.data;\n        switch(type){\n            case 'commit':\n                try {\n                    if (data.match(/\\bresolve\\((.*?)\\)/)) {\n                        const string = `return new Promise(function(resolve){\\n${data}\\n})`;\n                        const result = await new Function(string)();\n                        ArtplayerPluginIframe.postMessage({\n                            type: 'response',\n                            data: result,\n                            id\n                        });\n                    } else {\n                        const result = new Function(data)();\n                        ArtplayerPluginIframe.postMessage({\n                            type: 'response',\n                            data: result,\n                            id\n                        });\n                    }\n                } catch (error) {\n                    ArtplayerPluginIframe.postMessage({\n                        type: 'error',\n                        data: error.message,\n                        id\n                    });\n                    throw error;\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    static inject() {\n        if (!ArtplayerPluginIframe.iframe) throw new Error('The \"ArtplayerPluginIframe.inject\" method can only be used in iframe');\n        ArtplayerPluginIframe.postMessage({\n            type: 'inject'\n        });\n        window.addEventListener('message', ArtplayerPluginIframe.onMessage);\n    }\n    constructor({ iframe, url }){\n        if (iframe instanceof HTMLIFrameElement === false) throw new Error('\"option.iframe\" needs to be a HTMLIFrameElement');\n        if (typeof url !== 'string') throw new Error('\"option.url\" needs to be a string');\n        this.url = url;\n        this.$iframe = iframe;\n        this.promises = {};\n        this.injected = false;\n        this.destroyed = false;\n        this.messageCallback = ()=>null;\n        this.onMessage = this.onMessage.bind(this);\n        window.addEventListener('message', this.onMessage);\n        this.$iframe.src = this.url;\n    }\n    onMessage(event) {\n        const { type, data, id } = event.data;\n        switch(type){\n            case 'inject':\n                this.injected = true;\n                break;\n            default:\n                break;\n        }\n        if (this.promises[id]) {\n            if (type === 'error') this.promises[id].reject(new Error(data));\n            else this.promises[id].resove(data);\n            delete this.promises[id];\n        }\n        if (this.messageCallback) this.messageCallback({\n            type,\n            data\n        });\n    }\n    postMessage({ type, data }) {\n        return new Promise((resove, reject)=>{\n            (function loop() {\n                if (this.destroyed) reject(new Error('The instance has been destroyed'));\n                else if (this.injected) {\n                    const id = Date.now();\n                    this.promises[id] = {\n                        resove,\n                        reject\n                    };\n                    this.$iframe.contentWindow.postMessage({\n                        type: type,\n                        data: data,\n                        id: id\n                    }, '*');\n                } else setTimeout(loop.bind(this), 200);\n            }).call(this);\n        });\n    }\n    commit(callback) {\n        if (typeof callback !== 'function') throw new Error('\"commit.callback\" needs to be a function');\n        const callbackString = callback.toString();\n        const bodyString = callbackString.substring(callbackString.indexOf('{') + 1, callbackString.lastIndexOf('}'));\n        return this.postMessage({\n            type: 'commit',\n            data: bodyString\n        });\n    }\n    message(callback) {\n        if (typeof callback !== 'function') throw new Error('\"message.callback\" needs to be a function');\n        this.messageCallback = callback;\n    }\n    destroy() {\n        this.destroyed = true;\n        window.removeEventListener('message', this.onMessage);\n    }\n}\nexports.default = ArtplayerPluginIframe;\nif (typeof window !== 'undefined') window['ArtplayerPluginIframe'] = ArtplayerPluginIframe;\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"5lQoW\":[function(require,module,exports,__globalThis) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, '__esModule', {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}]},[\"cTaWs\"], \"cTaWs\", \"parcelRequire4dc0\", {})\nlet {default: _default, } = parcelRequire4dc0(\"cTaWs\");\nexport {_default as default, };\n\n//# sourceMappingURL=index.js.map\n","export default class ArtplayerPluginIframe {\n    static get iframe() {\n        return window.top !== window;\n    }\n\n    static postMessage({ type, data, id = 0 }) {\n        if (!ArtplayerPluginIframe.iframe) {\n            throw new Error('The \"ArtplayerPluginIframe.postMessage\" method can only be used in iframe');\n        }\n\n        window.parent.postMessage(\n            {\n                type: type,\n                data: data,\n                id: id,\n            },\n            '*',\n        );\n    }\n\n    static async onMessage(event) {\n        if (!ArtplayerPluginIframe.iframe) {\n            throw new Error('The \"ArtplayerPluginIframe.onMessage\" method can only be used in iframe');\n        }\n\n        const { type, data, id } = event.data;\n        switch (type) {\n            case 'commit':\n                try {\n                    if (data.match(/\\bresolve\\((.*?)\\)/)) {\n                        const string = `return new Promise(function(resolve){\\n${data}\\n})`;\n                        const result = await new Function(string)();\n                        ArtplayerPluginIframe.postMessage({ type: 'response', data: result, id });\n                    } else {\n                        const result = new Function(data)();\n                        ArtplayerPluginIframe.postMessage({ type: 'response', data: result, id });\n                    }\n                } catch (error) {\n                    ArtplayerPluginIframe.postMessage({ type: 'error', data: error.message, id });\n                    throw error;\n                }\n                break;\n            default:\n                break;\n        }\n    }\n\n    static inject() {\n        if (!ArtplayerPluginIframe.iframe) {\n            throw new Error('The \"ArtplayerPluginIframe.inject\" method can only be used in iframe');\n        }\n\n        ArtplayerPluginIframe.postMessage({ type: 'inject' });\n        window.addEventListener('message', ArtplayerPluginIframe.onMessage);\n    }\n\n    constructor({ iframe, url }) {\n        if (iframe instanceof HTMLIFrameElement === false) {\n            throw new Error('\"option.iframe\" needs to be a HTMLIFrameElement');\n        }\n\n        if (typeof url !== 'string') {\n            throw new Error('\"option.url\" needs to be a string');\n        }\n\n        this.url = url;\n        this.$iframe = iframe;\n        this.promises = {};\n        this.injected = false;\n        this.destroyed = false;\n        this.messageCallback = () => null;\n        this.onMessage = this.onMessage.bind(this);\n        window.addEventListener('message', this.onMessage);\n        this.$iframe.src = this.url;\n    }\n\n    onMessage(event) {\n        const { type, data, id } = event.data;\n\n        switch (type) {\n            case 'inject':\n                this.injected = true;\n                break;\n            default:\n                break;\n        }\n\n        if (this.promises[id]) {\n            if (type === 'error') {\n                this.promises[id].reject(new Error(data));\n            } else {\n                this.promises[id].resove(data);\n            }\n            delete this.promises[id];\n        }\n\n        if (this.messageCallback) {\n            this.messageCallback({ type, data });\n        }\n    }\n\n    postMessage({ type, data }) {\n        return new Promise((resove, reject) => {\n            (function loop() {\n                if (this.destroyed) {\n                    reject(new Error('The instance has been destroyed'));\n                } else {\n                    if (this.injected) {\n                        const id = Date.now();\n                        this.promises[id] = { resove, reject };\n                        this.$iframe.contentWindow.postMessage(\n                            {\n                                type: type,\n                                data: data,\n                                id: id,\n                            },\n                            '*',\n                        );\n                    } else {\n                        setTimeout(loop.bind(this), 200);\n                    }\n                }\n            }).call(this);\n        });\n    }\n\n    commit(callback) {\n        if (typeof callback !== 'function') {\n            throw new Error('\"commit.callback\" needs to be a function');\n        }\n        const callbackString = callback.toString();\n        const bodyString = callbackString.substring(callbackString.indexOf('{') + 1, callbackString.lastIndexOf('}'));\n        return this.postMessage({ type: 'commit', data: bodyString });\n    }\n\n    message(callback) {\n        if (typeof callback !== 'function') {\n            throw new Error('\"message.callback\" needs to be a function');\n        }\n        this.messageCallback = callback;\n    }\n\n    destroy() {\n        this.destroyed = true;\n        window.removeEventListener('message', this.onMessage);\n    }\n}\n\nif (typeof window !== 'undefined') {\n    window['ArtplayerPluginIframe'] = ArtplayerPluginIframe;\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n"],"names":["modules","entry","mainEntry","parcelRequireName","externals","distDir","publicUrl","devServer","globalObject","globalThis","self","window","global","previousRequire","importMap","i","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","length","mainExports","define","amd","__globalThis","parcelHelpers","defineInteropFlag","ArtplayerPluginIframe","iframe","top","postMessage","type","data","onMessage","event","match","string","result","Function","error","message","inject","addEventListener","constructor","url","HTMLIFrameElement","$iframe","promises","injected","destroyed","messageCallback","src","reject","resove","Promise","loop","Date","now","contentWindow","setTimeout","commit","callback","callbackString","toString","bodyString","substring","indexOf","lastIndexOf","destroy","removeEventListener","default","interopDefault","a","__esModule","value","exportAll","source","dest","keys","forEach","key","prototype","hasOwnProperty","enumerable","export","destName","_default","parcelRequire4dc0"],"version":3,"file":"index.js.map"}