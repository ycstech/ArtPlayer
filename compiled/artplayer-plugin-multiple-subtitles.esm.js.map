{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,C,E,C,E,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,G,C,C,E,C,O,C,C,E,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,O,C,K,E,E,S,C,K,E,E,S,C,K,E,E,C,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,A,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,Q,C,S,C,C,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GC8CwB,EAAA,MAAA,CAAA,EAAA,UAAA,IAAA,GA9CxB,IAAA,EAAA,EAAA,YAEA,eAAe,EAAQ,CAAM,CAAE,CAAE,OAAA,CAAM,CAAE,SAAA,CAAQ,CAAE,SAAA,CAAQ,CAAE,EACzD,IAAM,EAAW,MAAM,MAAM,EAAO,GAAG,EACjC,EAAS,MAAM,EAAS,WAAW,GAEnC,EAAO,AADG,IAAI,YAAY,EAAO,QAAQ,EAAI,SAC9B,MAAM,CAAC,GAC5B,OAAQ,EAAO,IAAI,EAAI,EAAO,EAAO,GAAG,GACpC,IAAK,MACD,OAAO,EAAS,EAEpB,KAAK,MACD,OAAO,EAAS,EAEpB,KAAK,MACD,OAAO,CAEX,SACI,MAAO,EACf,CACJ,CA0Be,SAAS,EAAiC,CAAE,UAAA,EAAY,EAAE,CAAE,EACvE,OAAO,MAAO,IACV,GAAM,CAAE,SAAA,CAAQ,CAAE,OAAA,CAAM,CAAE,SAAA,CAAQ,CAAE,SAAA,CAAQ,CAAE,CAAG,EAAI,WAAW,CAAC,KAAK,CAEhE,EAAS,GAAI,CAAA,EAAA,EAAA,YAAY,AAAZ,EACb,EAAO,GAAI,CAAA,EAAA,EAAA,gBAAgB,AAAhB,EAQX,EAAQ,AAND,CAAA,MAAM,QAAQ,GAAG,CAC1B,EAAU,GAAG,CAAC,AAAC,GACJ,EAAQ,EAAQ,CAAE,OAAA,EAAQ,SAAA,EAAU,SAAA,CAAS,IACxD,EAGe,GAAG,CAAC,CAAC,EAAK,KACzB,IAAM,EAAO,EAAO,KAAK,CAAC,EAAK,YAG/B,OAFA,EAAK,GAAG,CAAG,CAAS,CAAC,EAAM,CAAC,GAAG,CAC/B,EAAK,IAAI,CAAG,CAAS,CAAC,EAAM,CAAC,IAAI,CAC1B,CACX,GAEI,EAAU,GACd,SAAS,EAAU,EAAQ,EAAE,EACzB,IAAM,EAAO,AA9CzB,SAAoB,CAAK,EAErB,IAAM,EAAS,AADA,GAAI,CAAA,EAAA,EAAA,YAAY,AAAZ,IACG,KAAK,CAAC,GAAI,YAEhC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAAK,CACnC,IAAM,EAAO,CAAK,CAAC,EAAE,CAErB,GAAI,CAAC,EAAK,OAAO,CAAE,CACf,EAAK,OAAO,CAAG,CAAA,EACf,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,IAAI,CAAC,MAAM,CAAE,IAAK,CACvC,IAAM,EAAM,EAAK,IAAI,CAAC,EAAE,CACxB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,IAAK,CAC/C,IAAM,EAAW,EAAI,IAAI,CAAC,QAAQ,CAAC,EAAE,AACrC,CAAA,EAAS,KAAK,CAAG,CAAC,yBAAyB,EAAE,EAAK,IAAI,CAAC,EAAE,EAAE,EAAS,KAAK,CAAC,MAAM,CAAC,AACrF,CACJ,CACJ,CAEA,EAAO,IAAI,CAAC,IAAI,IAAI,EAAK,IAAI,CACjC,CAEA,OAAO,CACX,EAwBoC,GAClB,EAAM,EAAK,SAAS,CAAC,EAAK,IAAI,EACpC,IAAI,eAAe,CAAC,GACpB,IAAM,EAAM,IAAI,eAAe,CAAC,IAAI,KAAK,CAAC,EAAI,CAAE,CAAE,KAAM,UAAW,IACnE,EAAU,EACV,EAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAG,CAAA,EAC7B,EAAI,QAAQ,CAAC,IAAI,CAAC,CACd,GAAG,EAAI,MAAM,CAAC,QAAQ,CACtB,IAAA,EACA,KAAM,MACN,UAAW,CACf,EACJ,CAIA,OAFA,EAAU,GAEH,CACH,KAAM,oBACN,OAAA,CAAO,EAAQ,EAAE,GACN,EAAU,EAAM,GAAG,CAAC,AAAC,GAAS,EAAM,IAAI,CAAC,AAAC,GAAS,EAAK,IAAI,GAAK,KAE5E,MAAA,IACW,EAAU,EAEzB,CACJ,CACJ,CAEI,AAAkB,aAAlB,OAAO,QACP,CAAA,OAAO,gCAAmC,CAAG,CADjD,C,E,C,W,Q,iD,O,E,C,Q,C,S,C,C,C,C,C,C,C,GC1FC,AAAA,WACG,IAAI,EAAqB,CACrB,UAAW,aACX,YAAa,CAAA,EACb,aAAc,OACd,UAAW,QACX,aAAc,OACd,cAAe,OACf,KAAM,IACN,UAAW,QACf,EAEI,EAAe,SAAU,CAAQ,EAC7B,AAAC,GACD,CAAA,EAAW,CACP,OAAQ,IACR,MAAO,IACP,MAAO,IACP,OAAQ,IACR,OAAQ,IACR,QAAS,GACb,CAAA,EAEJ,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,KAAK,CAAG,SAAU,CAAK,CAAE,CAAI,EAE9B,EAAQ,EAAM,OAAO,CAAC,MAAO,KAC7B,IACI,EAAY,KAAK,GAAG,GACpB,EAAU,EACV,EAAQ,EAAM,KAAK,CAHT,cAIV,EAAmB,CAAA,EACnB,EAAS,EAAE,CACX,EAAO,EAAE,CACT,EAAS,EAAE,CACf,SAAS,EAAI,CAAO,CAAE,CAAG,EACrB,EAAO,IAAI,CAAC,CAAE,QAAS,EAAS,KAAM,EAAU,EAAG,IAAK,CAAI,EAChE,CAEA,IAAI,EAAO,CAAK,CAAC,EAAQ,CACrB,EAAa,EAAK,MAAM,CACxB,EAAY,SACZ,EAAM,EACN,EAAmB,EAAU,MAAM,CAmBvC,IAhBgB,WAAZ,CAAI,CAAC,EAAE,GACP,EAAM,EACN,GAAoB,GAIpB,CAAA,EAAa,GACb,EAAK,OAAO,CAAC,KAAe,EAAI,GAC/B,EAAa,GAAoB,AAA2B,MAA3B,CAAI,CAAC,EAAiB,EAAY,AAA2B,MAA3B,CAAI,CAAC,EAAiB,AAAK,GAE/F,EAAI,4DAGR,IAGO,AAAkB,IAAlB,CAAK,CAAC,EAAQ,EAAU,AAAkB,KAAA,GAAlB,CAAK,CAAC,EAAQ,EAAe,CAExD,GADA,EAAI,sCACA,AAAiC,IAAjC,CAAK,CAAC,EAAQ,CAAC,OAAO,CAAC,UAAc,CACrC,EAAmB,CAAA,EACnB,KACJ,CACA,GACJ,CAGA,KAAO,AAAkB,KAAA,GAAlB,CAAK,CAAC,EAAQ,EAAe,CAEhC,KAAO,CAAC,GAAoB,AAAkB,IAAlB,CAAK,CAAC,EAAQ,EACtC,IAEJ,GAAI,CAAC,GAAoB,AAAkB,KAAA,GAAlB,CAAK,CAAC,EAAQ,CAAe,MAoBtD,IAxBI,EAOE,OAAO,MAAM,CAAC,CAAC,EAAG,EAAoB,CACxC,GAAI,GACJ,UAAW,EACX,QAAS,EACT,YAAa,CAAA,EACb,UAAW,aACX,YAAa,CAAA,EACb,aAAc,OACd,UAAW,QACX,aAAc,OACd,cAAe,OACf,KAAM,IACN,UAAW,SACX,KAAM,GACN,KAAM,IACV,GAEI,EAAe,CAAA,EAEnB,GAAI,AAAiC,IAAjC,CAAK,CAAC,EAAQ,CAAC,OAAO,CAAC,UAAc,CAOrC,GANA,EAAI,EAAE,CAAG,CAAK,CAAC,EAAQ,CAMnB,iBAAiB,IAAI,CAAC,EAAI,EAAE,EAAG,CAG/B,IADA,IACO,AAAkB,IAAlB,CAAK,CAAC,EAAQ,EAAU,AAAkB,KAAA,GAAlB,CAAK,CAAC,EAAQ,EACrC,AAAiC,IAAjC,CAAK,CAAC,EAAQ,CAAC,OAAO,CAAC,WAAc,EAAI,uCAC7C,IAEJ,QACJ,CAGA,GAAI,kBAAkB,IAAI,CAAC,EAAI,EAAE,EAAG,CAChC,IAAI,EAAQ,EAAE,CACV,EAAU,CAAA,EAEd,IADA,IACO,AAAkB,IAAlB,CAAK,CAAC,EAAQ,EAAU,AAAkB,KAAA,GAAlB,CAAK,CAAC,EAAQ,EACJ,IAAjC,CAAK,CAAC,EAAQ,CAAC,OAAO,CAAC,YACvB,EAAI,2CACJ,EAAU,CAAA,GAEd,EAAM,IAAI,CAAC,CAAK,CAAC,EAAQ,EACzB,IAEJ,GAAI,EAAK,MAAM,CAAE,CACb,EAAI,mDACJ,QACJ,CACI,AAAC,GACD,EAAO,IAAI,CAAC,EAAM,IAAI,CAAC,OAE3B,QACJ,CAIA,GAAI,AAAkB,IAAlB,CAAK,GAAC,EAAQ,EAAU,AAAkB,KAAA,GAAlB,CAAK,CAAC,EAAQ,CAAe,CACrD,EAAI,wCACJ,QACJ,CAEA,GAAI,AAAiC,IAAjC,CAAK,CAAC,EAAQ,CAAC,OAAO,CAAC,UAAc,CACrC,EAAe,CAAA,EACf,EAAI,qDACJ,QACJ,CACJ,CAGA,EAAmB,CAAA,EACnB,IAAI,EAAU,IAAI,EAAkC,CAAK,CAAC,EAAQ,CAAE,GAChE,EAAmB,EAIvB,GAHI,EAAK,MAAM,CAAG,GACd,CAAA,EAAmB,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,CAAC,SAAS,AAAT,EAEzC,GAAgB,CAAC,EAAQ,KAAK,CAAC,EAAK,GAAmB,CAOvD,IAJA,EAAM,KACN,IAGO,AAAkB,IAAlB,CAAK,CAAC,EAAQ,EAAU,AAAkB,KAAA,GAAlB,CAAK,CAAC,EAAQ,EAAe,CACxD,GAAI,AAAiC,IAAjC,CAAK,CAAC,EAAQ,CAAC,OAAO,CAAC,UAAc,CACrC,EAAmB,CAAA,EACnB,KACJ,CACA,GACJ,CACA,QACJ,CAIA,IAHA,IAGO,AAAkB,IAAlB,CAAK,CAAC,EAAQ,EAAU,AAAkB,KAAA,GAAlB,CAAK,CAAC,EAAQ,EAAe,CACxD,GAAI,AAAiC,IAAjC,CAAK,CAAC,EAAQ,CAAC,OAAO,CAAC,UAAc,CACrC,EAAI,kCACJ,EAAmB,CAAA,EACnB,KACJ,CACI,AAAY,IAAZ,EAAI,IAAI,EAAQ,CAAA,EAAI,IAAI,EAAI,IAAhC,EACA,EAAI,IAAI,EAAI,CAAK,CAAC,EAAQ,CAC1B,GACJ,CAGA,IAAI,EAAgB,IAAI,EAAoB,EAAI,IAAI,CAAE,EAAK,EAAM,EACjE,CAAA,EAAI,IAAI,CAAG,EAAc,KAAK,CAAC,EAAI,SAAS,CAAE,EAAI,OAAO,EACzD,EAAK,IAAI,CAAC,EACd,CASA,OARA,EAAK,IAAI,CAAC,SAAU,CAAC,CAAE,CAAC,SACpB,AAAI,EAAE,SAAS,CAAG,EAAE,SAAS,CAAS,GAClC,EAAE,SAAS,CAAG,EAAE,SAAS,CAAS,EAClC,EAAE,OAAO,CAAG,EAAE,OAAO,CAAS,IAC9B,CAAA,EAAE,OAAO,CAAG,EAAE,OAAO,AAAP,CAEtB,GAEO,CAAE,KAAM,EAAM,OAAQ,EAAQ,KAAM,KAAK,GAAG,GAAK,EAAW,OAAQ,CAAO,CACtF,CACJ,EAEI,EAAoC,SAAU,CAAI,CAAE,CAAY,EAChE,IAAI,EAAQ,eACR,EAAU,gBACV,EAAO,EACP,EAAM,EACN,EAAM,SAAU,CAAO,EACnB,EAAa,EAAS,EAAM,EAChC,EAEJ,SAAS,EAAK,CAAO,EACjB,KAAO,AAAa,KAAA,GAAb,CAAI,CAAC,EAAI,EAAiB,EAAQ,IAAI,CAAC,CAAI,CAAC,EAAI,GACnD,GAER,CACA,SAAS,EAAQ,CAAO,EAEpB,IADA,IAAI,EAAM,GACH,AAAa,KAAA,GAAb,CAAI,CAAC,EAAI,EAAiB,EAAQ,IAAI,CAAC,CAAI,CAAC,EAAI,GACnD,GAAO,CAAI,CAAC,EAAI,CAChB,IAEJ,OAAO,CACX,CAEA,SAAS,IACL,IACI,EACA,EACA,EACA,EAJA,EAAQ,UAMZ,GAAI,AAAa,KAAA,GAAb,CAAI,CAAC,EAAI,CAAe,YACxB,EAAI,uBAIR,GAAI,CAAC,KAAK,IAAI,CAAC,CAAI,CAAC,EAAI,EAAG,YACvB,EAAI,2DASR,GAJI,CAAA,AADJ,CAAA,EAAO,EAAQ,KAAf,EACS,MAAM,CAAG,GAAK,SAAS,EAAM,IAAM,EAAA,GACxC,CAAA,EAAQ,OADZ,EAII,AAAa,KAAb,CAAI,CAAC,EAAI,CAAS,YAClB,EAAI,iCAMR,GAHA,IAGI,AAAe,GAAf,AADJ,CAAA,EAAO,EAAQ,KAAf,EACS,MAAM,CAAO,YAClB,EAAI,+BAIR,GAAI,AAAS,SAAT,GAAoB,AAAa,KAAb,CAAI,CAAC,EAAI,CAAS,CACtC,GAAI,AAAa,KAAb,CAAI,CAAC,EAAI,CAAS,YAClB,EAAI,mDAKR,GAFA,IAEI,AAAe,GAAf,AADJ,CAAA,EAAO,EAAQ,KAAf,EACS,MAAM,CAAO,YAClB,EAAI,8BAGZ,KAAO,CACH,GAAI,AAAe,GAAf,EAAK,MAAM,CAAO,YAClB,EAAI,+BAGR,EAAO,EACP,EAAO,EACP,EAAO,GACX,OAEA,AAAI,AAAa,KAAb,CAAI,CAAC,EAAI,MACT,EAAI,sCAGR,IAGI,AAAe,GAAf,AADJ,CAAA,EAAO,EAAQ,KAAf,EACS,MAAM,OACX,EAAI,+CAIJ,SAAS,EAAM,IAAM,QACrB,EAAI,yCAGJ,SAAS,EAAM,IAAM,QACrB,EAAI,yCAIJ,AAAA,KAAA,SAAS,EAAM,IAAgB,AAAqB,GAArB,SAAS,EAAM,IAAW,SAAS,EAAM,IAAM,SAAS,EAAM,IAAM,GAE3G,CAgJA,IAAI,CAAC,KAAK,CAAG,SAAU,CAAG,CAAE,CAAgB,QAGxC,CAFA,EAAK,GACL,EAAI,SAAS,CAAG,IACZ,AAAiB,KAAA,GAAjB,EAAI,SAAS,EACb,KAAA,GAEA,EAAI,SAAS,CAAG,GAChB,EAAI,oFAEJ,EAAQ,IAAI,CAAC,CAAI,CAAC,EAAI,GACtB,EAAI,wDAER,EAAK,GAEY,KAAb,CAAI,CAAC,EAAI,EAKT,AAAa,KAAb,CAAI,GAAC,EAAI,EAKT,AAAa,KAAb,CAAI,GAAC,EAAI,OATT,EAAI,wCAaR,IACI,EAAQ,IAAI,CAAC,CAAI,CAAC,EAAI,GACtB,EAAI,wDAER,EAAK,GACL,EAAI,OAAO,CAAG,IACV,AAAe,KAAA,GAAf,EAAI,OAAO,GAGX,EAAI,OAAO,EAAI,EAAI,SAAS,EAC5B,EAAI,sDAGJ,EAAQ,IAAI,CAAC,CAAI,CAAC,EAAI,EAG1B,EAAK,IACL,AA1LJ,SAAuB,CAAK,CAAE,CAAG,EAG7B,IAAK,IAFD,EAAW,EAAM,KAAK,CAAC,GACvB,EAAO,EAAE,CACJ,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IACjC,GAAI,AAAe,IAAf,CAAQ,CAAC,EAAE,EAEf,IAAI,EAAQ,CAAQ,CAAC,EAAE,CAAC,OAAO,CAAC,KAC5B,EAAU,CAAQ,CAAC,EAAE,CAAC,KAAK,CAAC,EAAG,GAC/B,EAAQ,CAAQ,CAAC,EAAE,CAAC,KAAK,CAAC,EAAQ,GAOtC,GALI,AAAyB,IAAzB,EAAK,OAAO,CAAC,IACb,EAAI,sBAER,EAAK,IAAI,CAAC,GAEN,AAAS,IAAT,EAAa,YACb,EAAI,iCAIR,GAAI,AAAW,YAAX,EAAuB,CAEvB,GAAI,AAAS,MAAT,GAAiB,AAAS,MAAT,EAAe,CAChC,EAAI,sDACJ,QACJ,CACA,EAAI,SAAS,CAAG,CACpB,MAAO,GAAI,AAAW,QAAX,EAAmB,CAE1B,GAAI,IAAI,IAAI,CAAC,GAAQ,CACjB,IAAI,EAAO,EAAM,KAAK,CAAC,KACvB,EAAQ,CAAI,CAAC,EAAE,CACf,IAAI,EAAY,CAAI,CAAC,EAAE,AAC3B,CACA,GAAI,CAAC,yBAAyB,IAAI,CAAC,GAAQ,CACvC,EAAI,+CACJ,QACJ,CACA,GAAI,AAAyB,IAAzB,EAAM,OAAO,CAAC,IAAK,GAAU,CAC7B,EAAI,iDACJ,QACJ,CACA,GAAI,AAAsB,IAAtB,EAAM,OAAO,CAAC,MAAc,EAAM,OAAO,CAAC,MAAQ,EAAM,MAAM,CAAG,EAAG,CACpE,EAAI,+CACJ,QACJ,CACA,GAAI,AAAY,KAAZ,CAAK,CAAC,EAAE,EAAW,AAA2B,KAA3B,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,CAAS,CACnD,EAAI,kDACJ,QACJ,CACA,IAAI,EAAS,EACT,EAAY,CAAA,EAChB,GAAI,AAA2B,KAA3B,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,GACvB,EAAY,CAAA,EACZ,EAAS,EAAM,KAAK,CAAC,EAAG,EAAM,MAAM,CAAG,GACnC,SAAS,EAAO,IAAM,KAAK,CAC3B,EAAI,kCACJ,QACJ,CAEJ,GAAI,AAAW,KAAX,GAAiB,MAAM,IAAW,CAAC,SAAS,GAAS,CACrD,EAAI,sCACJ,QACJ,CACA,GAAI,AAAc,KAAA,IAAd,EAAyB,CACzB,GAAI,CAAC,CAAC,QAAS,SAAU,MAAM,CAAC,QAAQ,CAAC,GAAY,CACjD,EAAI,0DACJ,QACJ,CACA,EAAI,SAAS,CAAG,CACpB,CACA,EAAI,WAAW,CAAG,CAAC,EACnB,EAAI,YAAY,CAAG,WAAW,GAC1B,WAAW,GAAQ,QAAQ,KAAO,GAClC,CAAA,EAAI,eAAe,CAAG,CAAA,CAD1B,CAGJ,MAAO,GAAI,AAAW,YAAX,EAAuB,CAE9B,GAAI,IAAI,IAAI,CAAC,GAAQ,CACjB,IAAI,EAAO,EAAM,KAAK,CAAC,KACvB,EAAQ,CAAI,CAAC,EAAE,CACf,IAAI,EAAgB,CAAI,CAAC,EAAE,AAC/B,CACA,GAAI,AAA2B,KAA3B,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,CAAS,CAChC,EAAI,uCACJ,QACJ,CACA,GAAI,SAAS,EAAO,IAAM,KAAO,AAAsB,EAAtB,SAAS,EAAO,IAAS,CACtD,EAAI,iDACJ,QACJ,CAEA,GAAI,AAAW,KADf,CAAA,EAAS,EAAM,KAAK,CAAC,EAAG,EAAM,MAAM,CAAG,EAAvC,GACqB,MAAM,IAAW,CAAC,SAAS,GAAS,CACrD,EAAI,sCACJ,QACJ,CACA,GAAI,AAAkB,KAAA,IAAlB,EAA6B,CAC7B,GAAI,CAAC,CAAC,YAAa,SAAU,aAAa,CAAC,QAAQ,CAAC,GAAgB,CAChE,EAAI,yEACJ,QACJ,CACA,EAAI,aAAa,CAAG,CACxB,CACA,EAAI,YAAY,CAAG,WAAW,EAClC,MAAO,GAAI,AAAW,QAAX,EAAmB,CAE1B,GAAI,AAA2B,KAA3B,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,CAAS,CAChC,EAAI,8BACJ,QACJ,CACA,GAAI,SAAS,EAAO,IAAM,IAAK,CAC3B,EAAI,yBACJ,QACJ,CACA,IAAI,EAAO,EAAM,KAAK,CAAC,EAAG,EAAM,MAAM,CAAG,GACzC,GAAI,AAAS,KAAA,IAAT,GAAsB,AAAS,KAAT,GAAe,MAAM,GAAO,CAClD,EAAI,6BACJ,EAAO,IACP,QACJ,CAEI,GAAI,AADJ,CAAA,EAAO,WAAW,EAAlB,EACW,GAAK,EAAO,IAAK,CACxB,EAAI,wCACJ,QACJ,CAEJ,EAAI,IAAI,CAAG,CACf,MAAO,GAAI,AAAW,SAAX,EAAoB,CAE3B,IAAI,EAAc,CAAC,QAAS,SAAU,MAAO,OAAQ,QAAQ,CAC7D,GAAI,AAA8B,IAA9B,EAAY,OAAO,CAAC,GAAc,CAClC,EAAI,uCAAyC,EAAY,IAAI,CAAC,MAAQ,KACtE,QACJ,CACA,EAAI,SAAS,CAAG,CACpB,MACI,EAAI,oBAGhB,EA+CkB,EAAK,SAAS,CAAC,GAAM,GAC5B,CAAA,SACX,EACA,IAAI,CAAC,cAAc,CAAG,WAClB,IAAI,EAAK,WACT,AAAI,AAAa,KAAA,GAAb,CAAI,CAAC,EAAI,MACT,EAAI,gDAGD,CACX,CACJ,EAEI,EAAsB,SAAU,CAAI,CAAE,CAAY,CAAE,CAAI,CAAE,CAAQ,EAClE,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,EAAO,IAAI,CACX,EAAO,EACP,EAAM,EACN,EAAM,SAAU,CAAO,EACP,YAAR,GACJ,EAAa,EAAS,EAAM,EAChC,CAEJ,CAAA,IAAI,CAAC,KAAK,CAAG,SAAU,CAAQ,CAAE,CAAM,EAYnC,IAAI,EAAS,CAAE,SAAU,EAAE,AAAC,EACxB,EAAU,EACV,EAAa,EAAE,CAEnB,SAAS,EAAO,CAAK,EACjB,EAAQ,QAAQ,CAAC,IAAI,CAAC,CAClB,KAAM,SACN,KAAM,CAAK,CAAC,EAAE,CACd,QAAS,CAAK,CAAC,EAAE,CACjB,SAAU,EAAE,CACZ,OAAQ,CACZ,GACA,EAAU,EAAQ,QAAQ,CAAC,EAAQ,QAAQ,CAAC,MAAM,CAAG,EAAE,AAC3D,CAUA,KAAO,AAAa,KAAA,GAAb,CAAI,CAAC,EAAI,EAAe,CAC3B,IAAI,EAAQ,AA+DpB,WAKI,IAJA,IAAI,EAAQ,OACR,EAAS,GACT,EAAS,GACT,EAAU,EAAE,CACT,AAAiB,KAAA,GAAjB,CAAI,CAAC,EAAM,EAAE,EAAiB,AAAO,GAAP,GAAU,CAC3C,IAAI,EAAI,CAAI,CAAC,EAAI,CACjB,GAAI,AAAS,QAAT,EACA,GAAI,AAAK,KAAL,EACA,EAAS,EACT,EAAQ,cACL,GAAI,AAAK,KAAL,GAAY,AAAU,IAAV,EACnB,EAAQ,WACL,GAAI,AAAK,KAAL,GAAY,AAAK,KAAA,GAAL,EACnB,MAAO,CAAC,OAAQ,EAAO,CAEvB,GAAU,OAEX,GAAI,AAAS,UAAT,EACP,GAAI,AAAK,KAAL,GAAY,AAAK,KAAA,GAAL,EAAgB,KAExB,EAUJ,OAXA,EAAI,qBAEC,CAAA,EAAI,EAAO,KAAK,CAAC,eAAA,EAClB,GAAU,OAAO,YAAY,CAAC,CAAC,CAAC,EAAE,EAE9B,EAAK,QAAQ,CAAC,EAAO,CACrB,GAAU,EAAK,QAAQ,CAAC,EAAO,CAE/B,GAAU,EAGX,CAAC,OAAQ,EAAO,AAC3B,MAAO,GAAI,AAAK,KAAL,EACP,EAAI,qBACJ,GAAU,EACV,EAAS,OACN,GAAI,aAAa,IAAI,CAAC,GACzB,GAAU,OACP,GAAI,AAAK,KAAL,EAAU,CACjB,IAAI,EACC,CAAA,EAAI,EAAO,KAAK,CAAC,iBAAA,EAElB,GAAU,OAAO,YAAY,CAAC,IAAM,CAAC,CAAC,EAAE,EACjC,EAAK,QAAQ,CAAC,EAAS,EAAE,CAChC,GAAU,EAAK,QAAQ,CAAC,EAAS,EAAE,CAC3B,CAAA,EAAI,OAAO,IAAI,CAAC,GAAU,IAAI,CAAC,AAAC,GAAM,EAAO,UAAU,CAAC,GAAA,EAEhE,GAAU,EAAK,QAAQ,CAAC,EAAE,CAAG,EAAO,KAAK,CAAC,EAAE,MAAM,EAAI,GAEtD,EAAI,qBACJ,GAAU,EAAS,KAEvB,EAAQ,MACZ,MACI,EAAI,qBACJ,GAAU,EAAS,EACnB,EAAQ,YAET,GAAI,AAAS,OAAT,EACP,GAAI,AAAK,KAAL,GAAa,AAAK,MAAL,GAAa,AAAK,MAAL,GAAa,AAAK,KAAL,EACvC,EAAQ,4BACL,GAAI,AAAK,KAAL,EACP,EAAQ,uBACL,GAAI,AAAK,KAAL,EACP,EAAQ,eACL,GAAI,KAAK,IAAI,CAAC,GACjB,EAAS,EACT,EAAQ,qBACL,GAAI,AAAK,KAAL,GAAY,AAAK,KAAA,GAAL,EAInB,MAHI,AAAK,KAAL,GACA,IAEG,CAAC,YAAa,GAAI,EAAE,CAAE,GAAG,CAEhC,EAAS,EACT,EAAQ,iBAET,GAAI,AAAS,aAAT,EACP,GAAI,AAAK,KAAL,GAAa,AAAK,MAAL,GAAa,AAAK,KAAL,EAC1B,EAAQ,4BACL,GAAI,AAAK,MAAL,EACP,EAAS,EACT,EAAQ,4BACL,GAAI,AAAK,KAAL,EACP,EAAQ,uBACL,GAAI,AAAK,KAAL,GAAY,AAAK,KAAA,GAAL,EAInB,MAHI,AAAK,KAAL,GACA,IAEG,CAAC,YAAa,EAAQ,EAAE,CAAE,GAAG,CAEpC,GAAU,OAEX,GAAI,AAAS,mBAAT,EACP,GAAI,AAAK,KAAL,GAAa,AAAK,MAAL,GAAa,AAAK,KAAL,EACtB,GACA,EAAQ,IAAI,CAAC,GAEjB,EAAS,GACT,EAAQ,4BACL,GAAI,AAAK,MAAL,EACH,GACA,EAAQ,IAAI,CAAC,GAEjB,EAAS,EACT,EAAQ,4BACL,GAAI,AAAK,KAAL,EACH,GACA,EAAQ,IAAI,CAAC,GAEjB,EAAS,QACN,GAAI,AAAK,KAAL,GAAY,AAAK,KAAA,GAAL,EAOnB,MANI,AAAK,KAAL,GACA,IAEA,GACA,EAAQ,IAAI,CAAC,GAEV,CAAC,YAAa,EAAQ,EAAS,GAAG,CAEzC,GAAU,OAEX,GAAI,AAAS,wBAAT,EACP,GAAI,AAAK,KAAL,GAAY,AAAK,KAAA,GAAL,EAUZ,MATI,AAAK,KAAL,GACA,IAQG,CAAC,YAAa,EAAQ,EAN7B,EAAS,EACJ,KAAK,CAAC,qBACN,MAAM,CAAC,SAAU,CAAI,EAClB,GAAI,EAAM,MAAO,CAAA,CACrB,GACC,IAAI,CAAC,KACmC,MAE7C,GAAU,OAEX,GAAI,AAAS,WAAT,EACP,GAAI,AAAK,KAAL,GAAY,AAAK,KAAA,GAAL,EAIZ,MAHI,AAAK,KAAL,GACA,IAEG,CAAC,UAAW,EAAO,MAE1B,GAAU,OAEX,GAAI,AAAS,iBAAT,EACP,GAAI,AAAK,KAAL,GAAY,AAAK,KAAA,GAAL,EAIZ,MAHI,AAAK,KAAL,GACA,IAEG,CAAC,YAAa,EAAO,MAE5B,GAAU,OAGd,EAAI,iBAGR,CAAA,GACJ,CACJ,IA/NQ,GAAI,AAAY,QAAZ,CAAK,CAAC,EAAE,CACR,EAAQ,QAAQ,CAAC,IAAI,CAAC,CAAE,KAAM,OAAQ,MAAO,CAAK,CAAC,EAAE,CAAE,OAAQ,CAAQ,QACpE,GAAI,AAAY,aAAZ,CAAK,CAAC,EAAE,CAAiB,CAC5B,AAAQ,YAAR,GAAoB,EAAI,iDAC5B,IAAI,EAAO,CAAK,CAAC,EAAE,AACf,AAAQ,CAAA,KAAR,GAAe,AAAQ,QAAR,GAAkB,AAAY,IAAZ,CAAK,CAAC,EAAE,EACzC,EAAI,+CAEI,KAAR,GAAe,AAAQ,KAAR,GAAe,AAAQ,KAAR,GAAe,AAAQ,KAAR,GAAe,AAAQ,QAAR,GAErD,AAAQ,MAAR,GAAgB,AAAgB,QAAhB,EAAQ,IAAI,CACnC,EAAO,GACA,AAAQ,KAAR,GACH,AAxBhB,SAAiB,CAAI,EAEjB,IADA,IAAI,EAAO,EACJ,GAAM,CACT,GAAI,AAqBY,KArBZ,EAAK,IAAI,CAAU,MAAO,CAAA,EAC9B,EAAO,EAAK,MAAM,AACtB,CAEJ,EAiBwB,IACR,EAAI,uCAER,EAAO,GACP,EAAQ,KAAK,CAAG,CAAK,CAAC,EAAE,CACpB,AAAC,CAAK,CAAC,EAAE,EACT,EAAI,gCAED,AAAQ,QAAR,GACP,EAAO,GACP,EAAQ,KAAK,CAAG,CAAK,CAAC,EAAE,EAExB,EAAI,uBAEZ,MAAO,GAAI,AAAY,WAAZ,CAAK,CAAC,EAAE,CACX,AAAQ,YAAR,GAAoB,EAAI,+CAExB,CAAK,CAAC,EAAE,EAAI,EAAQ,IAAI,CACxB,EAAU,EAAQ,MAAM,CACjB,AAAY,QAAZ,CAAK,CAAC,EAAE,EAAc,AAAgB,MAAhB,EAAQ,IAAI,CACzC,EAAU,EAAQ,MAAM,CAAC,MAAM,CAE/B,EAAI,2BAEL,GAAI,AAAY,aAAZ,CAAK,CAAC,EAAE,CAAiB,CAC5B,AAAQ,YAAR,GAAoB,EAAI,gDAC5B,IACI,EAAY,AADF,IAAI,EAAkC,CAAK,CAAC,EAAE,CAAE,GACtC,cAAc,EACrB,MAAA,GAAb,IACI,CAAA,GAAa,GAAY,GAAa,CAAA,GACtC,EAAI,gEAEJ,EAAW,MAAM,CAAG,GAAK,CAAU,CAAC,EAAW,MAAM,CAAG,EAAE,EAAI,GAC9D,EAAI,0DAER,EAAQ,QAAQ,CAAC,IAAI,CAAC,CAAE,KAAM,YAAa,MAAO,EAAW,OAAQ,CAAQ,GAC7E,EAAW,IAAI,CAAC,GAExB,CACJ,CACA,KAAO,EAAQ,MAAM,EACb,AAAgB,KAAhB,EAAQ,IAAI,EACZ,EAAI,6BAER,EAAU,EAAQ,MAAM,CAE5B,OAAO,AA/FP,SAAS,EAAa,CAAI,EACtB,IAAM,EAAgB,CAAE,GAAG,CAAI,AAAC,EAOhC,OANI,EAAK,QAAQ,EACb,CAAA,EAAc,QAAQ,CAAG,EAAK,QAAQ,CAAC,GAAG,CAAC,EAD/C,EAGI,EAAc,MAAM,EACpB,OAAO,EAAc,MAAM,CAExB,CACX,EAsFoB,EACxB,CAoKJ,EAEI,EAAmB,WACnB,SAAS,EAAmB,CAAO,EAC/B,IAAM,EAAK,AAAC,CAAA,KAAO,AAA6C,IAA7C,AAAC,CAAA,EAAU,KAAK,KAAK,CAAC,EAAA,EAAU,OAAO,CAAC,EAAK,EAAM,KAAK,CAAC,IACxE,EAAI,EACJ,EAAI,EACJ,EAAI,EAMR,OALI,GAAW,MACX,CAAA,EAAI,KAAK,KAAK,CAAC,EAAU,KAD7B,EAGA,EAAI,KAAK,KAAK,CAAE,AAAA,CAAA,EAAU,KAAO,CAAA,EAAK,IACtC,EAAI,KAAK,KAAK,CAAC,EAAU,KAAO,EAAI,GAAK,GAClC,AAAC,CAAA,EAAI,EAAI,IAAM,EAAA,EAAO,AAAA,CAAA,GAAK,CAAA,EAAG,QAAQ,CAAC,EAAG,KAAO,IAAM,AAAC,CAAA,GAAK,CAAA,EAAG,QAAQ,CAAC,EAAG,KAAO,IAAM,CACpG,CAyEA,IAAI,CAAC,SAAS,CAAG,SAAU,CAAI,CAAE,CAAM,EACnC,IAhBkB,EAgBd,EAAS,aACb,GAAI,EACA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,IAC/B,GAND,UAM0B,CAAM,CAAC,EAAE,CANf,OAS3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAC7B,GArBC,AAAA,CAAA,AAAW,KAAA,IAAX,CAFa,EAuBS,CAAI,CAAC,EAAE,EArBzB,EAAE,CAAiB,EAAI,EAAE,CAAG,KAAO,EAAA,EACxC,EAAmB,EAAI,SAAS,EAChC,WACA,EAAmB,EAAI,OAAO,EAC9B,AA/DR,SAA8B,CAAG,EAC7B,IAAI,EAAS,GACb,IAAM,EAAqB,OAAO,IAAI,CAAC,GAAoB,MAAM,CAAC,AAAC,GAAM,CAAG,CAAC,EAAE,GAAK,CAAkB,CAAC,EAAE,EA0BzG,OAzBI,EAAmB,QAAQ,CAAC,cAC5B,CAAA,GAAU,aAAe,EAAI,SAAS,AAAT,EAE7B,EAAmB,QAAQ,CAAC,cAC5B,CAAA,GAAU,UAAY,EAAI,SAAS,AAAT,EAE1B,EAAmB,QAAQ,CAAC,SAC5B,CAAA,GAAU,SAAW,EAAI,IAAI,CAAG,GADpC,EAGI,CAAA,EAAmB,QAAQ,CAAC,cAAgB,EAAmB,QAAQ,CAAC,eAAA,GACxE,CAAA,GACI,SACA,EAAI,YAAY,CACf,CAAA,EAAI,WAAW,CAAG,GAAK,GAAA,EACvB,CAAA,EAAI,SAAS,EAAI,EAAI,SAAS,EAAI,EAAmB,SAAS,CAAG,IAAM,EAAI,SAAS,CAAG,EAAA,CAAC,EAE7F,CAAA,EAAmB,QAAQ,CAAC,iBAAmB,EAAmB,QAAQ,CAAC,gBAAA,GAC3E,CAAA,GACI,aACA,EAAI,YAAY,CAChB,IACC,CAAA,EAAI,aAAa,EAAI,EAAI,aAAa,GAAK,EAAmB,aAAa,CACtE,IAAM,EAAI,aAAa,CACvB,EAAA,CAAC,EAER,CACX,EAkC6B,GACrB,KACA,AAnCR,SAAS,EAAc,CAAI,EAEvB,IAAK,IADD,EAAS,GACJ,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CAClC,IAAI,EAAO,CAAI,CAAC,EAAE,CAClB,GAAI,AAAa,QAAb,EAAK,IAAI,CACT,GAAU,EAAK,KAAK,CAAC,OAAO,CAAC,KAAM,SAAS,OAAO,CAAC,KAAM,QAAQ,OAAO,CAAC,KAAM,aAC7E,GAAI,AAAa,UAAb,EAAK,IAAI,CAAc,CAE9B,GADA,GAAU,IAAM,EAAK,IAAI,CACrB,EAAK,OAAO,CACZ,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,OAAO,CAAC,MAAM,CAAE,IACrC,GAAU,IAAM,EAAK,OAAO,CAAC,EAAE,AAGnC,CAAA,EAAK,KAAK,EACV,CAAA,GAAU,IAAM,EAAK,KAAK,AAAL,EAEzB,GAAU,IACN,EAAK,QAAQ,EAAE,CAAA,GAAU,EAAc,EAAK,QAAQ,CAAA,EACxD,GAAU,KAAO,EAAK,IAAI,CAAG,GACjC,KAAW,AAAa,aAAb,EAAK,IAAI,CAChB,GAAU,IAAM,EAAmB,EAAK,KAAK,EAAI,IAEjD,GAAU,IAAM,EAAK,KAAK,CAAG,GAErC,CACA,OAAO,CACX,EASsB,EAAI,IAAI,CAAC,QAAQ,EAC/B,OAgBJ,OAAO,CACX,CACJ,EAEA,SAAS,EAAU,CAAM,EACrB,EAAO,YAAY,CAAG,EACtB,EAAO,iCAAiC,CAAG,EAC3C,EAAO,mBAAmB,CAAG,EAC7B,EAAO,gBAAgB,CAAG,CAC9B,CACI,AAAkB,aAAlB,OAAO,QAAwB,EAAU,QACT,EAAU,EAClD,G,E,C,E,C,Q,C,S,C,C,C,C,C,C,C,ECh4BA,EAAQ,cAAc,CAAG,SAAU,CAAC,EAClC,OAAO,GAAK,EAAE,UAAU,CAAG,EAAI,CAAC,QAAS,CAAC,CAC5C,EAEA,EAAQ,iBAAiB,CAAG,SAAU,CAAC,EACrC,OAAO,cAAc,CAAC,EAAG,aAAc,CAAC,MAAO,CAAA,CAAI,EACrD,EAEA,EAAQ,SAAS,CAAG,SAAU,CAAM,CAAE,CAAI,EAkBxC,OAjBA,OAAO,IAAI,CAAC,GAAQ,OAAO,CAAC,SAAU,CAAG,EAE7B,YAAR,GACA,AAAQ,eAAR,GACA,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAM,IAK7C,OAAO,cAAc,CAAC,EAAM,EAAK,CAC/B,WAAY,CAAA,EACZ,IAAK,WACH,OAAO,CAAM,CAAC,EAAI,AACpB,CACF,EACF,GAEO,CACT,EAEA,EAAQ,MAAM,CAAG,SAAU,CAAI,CAAE,CAAQ,CAAE,CAAG,EAC5C,OAAO,cAAc,CAAC,EAAM,EAAU,CACpC,WAAY,CAAA,EACZ,IAAK,CACP,EACF,C,E,C,E,E,C,Q,C,Q,oB,C,G,G,C,Q,C,C,C,kB,gB,K,O","sources":["<anon>","packages/artplayer-plugin-multiple-subtitles/src/index.js","packages/artplayer-plugin-multiple-subtitles/src/parser.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (\n  modules,\n  entry,\n  mainEntry,\n  parcelRequireName,\n  externals,\n  distDir,\n  publicUrl,\n  devServer\n) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var importMap = previousRequire.i || {};\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        if (externals[name]) {\n          return externals[name];\n        }\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        globalObject\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.require = nodeRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.distDir = distDir;\n  newRequire.publicUrl = publicUrl;\n  newRequire.devServer = devServer;\n  newRequire.i = importMap;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  // Only insert newRequire.load when it is actually used.\n  // The code in this file is linted against ES5, so dynamic import is not allowed.\n  // INSERT_LOAD_HERE\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n    }\n  }\n})({\"3MgS1\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"default\", ()=>artplayerPluginMultipleSubtitles);\nvar _parser = require(\"./parser\");\nasync function loadVtt(option, { getExt, srtToVtt, assToVtt }) {\n    const response = await fetch(option.url);\n    const buffer = await response.arrayBuffer();\n    const decoder = new TextDecoder(option.encoding || 'utf-8');\n    const text = decoder.decode(buffer);\n    switch(option.type || getExt(option.url)){\n        case 'srt':\n            return srtToVtt(text);\n        case 'ass':\n            return assToVtt(text);\n        case 'vtt':\n            return text;\n        default:\n            return '';\n    }\n}\nfunction mergeTrees(trees) {\n    const parser = new (0, _parser.WebVTTParser)();\n    const result = parser.parse('', 'metadata');\n    for(let i = 0; i < trees.length; i++){\n        const tree = trees[i];\n        if (!tree.updated) {\n            tree.updated = true;\n            for(let j = 0; j < tree.cues.length; j++){\n                const cue = tree.cues[j];\n                for(let k = 0; k < cue.tree.children.length; k++){\n                    const children = cue.tree.children[k];\n                    children.value = `<div class=\"art-subtitle-${tree.name}\">${children.value}</div>`;\n                }\n            }\n        }\n        result.cues.push(...tree.cues);\n    }\n    return result;\n}\nfunction artplayerPluginMultipleSubtitles({ subtitles = [] }) {\n    return async (art)=>{\n        const { unescape, getExt, srtToVtt, assToVtt } = art.constructor.utils;\n        const parser = new (0, _parser.WebVTTParser)();\n        const seri = new (0, _parser.WebVTTSerializer)();\n        const vtts = await Promise.all(subtitles.map((option)=>{\n            return loadVtt(option, {\n                getExt,\n                srtToVtt,\n                assToVtt\n            });\n        }));\n        const trees = vtts.map((vtt, index)=>{\n            const tree = parser.parse(vtt, 'metadata');\n            tree.url = subtitles[index].url;\n            tree.name = subtitles[index].name;\n            return tree;\n        });\n        let lastUrl = '';\n        function setTracks(trees = []) {\n            const tree = mergeTrees(trees);\n            const vtt = seri.serialize(tree.cues);\n            URL.revokeObjectURL(lastUrl);\n            const url = URL.createObjectURL(new Blob([\n                vtt\n            ], {\n                type: 'text/vtt'\n            }));\n            lastUrl = url;\n            art.option.subtitle.escape = false;\n            art.subtitle.init({\n                ...art.option.subtitle,\n                url,\n                type: 'vtt',\n                onVttLoad: unescape\n            });\n        }\n        setTracks(trees);\n        return {\n            name: 'multipleSubtitles',\n            tracks (names = []) {\n                return setTracks(names.map((name)=>trees.find((tree)=>tree.name === name)));\n            },\n            reset () {\n                return setTracks(trees);\n            }\n        };\n    };\n}\nif (typeof window !== 'undefined') window['artplayerPluginMultipleSubtitles'] = artplayerPluginMultipleSubtitles;\n\n},{\"./parser\":\"01rPS\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5lQoW\"}],\"01rPS\":[function(require,module,exports,__globalThis) {\n// Any copyright is dedicated to the Public Domain.\n// http://creativecommons.org/publicdomain/zero/1.0/\n// Not intended to be fast, but if you can make it faster, please help out!\n/* eslint-disable */ (function() {\n    var defaultCueSettings = {\n        direction: 'horizontal',\n        snapToLines: true,\n        linePosition: 'auto',\n        lineAlign: 'start',\n        textPosition: 'auto',\n        positionAlign: 'auto',\n        size: 100,\n        alignment: 'center'\n    };\n    var WebVTTParser = function(entities) {\n        if (!entities) entities = {\n            '&amp': '&',\n            '&lt': '<',\n            '&gt': '>',\n            '&lrm': '\\u200e',\n            '&rlm': '\\u200f',\n            '&nbsp': '\\u00A0'\n        };\n        this.entities = entities;\n        this.parse = function(input, mode) {\n            // global search and replace for \\0\n            input = input.replace(/\\0/g, '\\uFFFD');\n            var NEWLINE = /\\r\\n|\\r|\\n/, startTime = Date.now(), linePos = 0, lines = input.split(NEWLINE), alreadyCollected = false, styles = [], cues = [], errors = [];\n            function err(message, col) {\n                errors.push({\n                    message: message,\n                    line: linePos + 1,\n                    col: col\n                });\n            }\n            var line = lines[linePos], lineLength = line.length, signature = 'WEBVTT', bom = 0, signature_length = signature.length;\n            /* Byte order mark */ if (line[0] === '\\ufeff') {\n                bom = 1;\n                signature_length += 1;\n            }\n            /* SIGNATURE */ if (lineLength < signature_length || line.indexOf(signature) !== 0 + bom || lineLength > signature_length && line[signature_length] !== ' ' && line[signature_length] !== '\\t') err('No valid signature. (File needs to start with \"WEBVTT\".)');\n            linePos++;\n            /* HEADER */ while(lines[linePos] != '' && lines[linePos] != undefined){\n                err('No blank line after the signature.');\n                if (lines[linePos].indexOf('-->') != -1) {\n                    alreadyCollected = true;\n                    break;\n                }\n                linePos++;\n            }\n            /* CUE LOOP */ while(lines[linePos] != undefined){\n                var cue;\n                while(!alreadyCollected && lines[linePos] == '')linePos++;\n                if (!alreadyCollected && lines[linePos] == undefined) break;\n                /* CUE CREATION */ cue = Object.assign({}, defaultCueSettings, {\n                    id: '',\n                    startTime: 0,\n                    endTime: 0,\n                    pauseOnExit: false,\n                    direction: 'horizontal',\n                    snapToLines: true,\n                    linePosition: 'auto',\n                    lineAlign: 'start',\n                    textPosition: 'auto',\n                    positionAlign: 'auto',\n                    size: 100,\n                    alignment: 'center',\n                    text: '',\n                    tree: null\n                });\n                var parseTimings = true;\n                if (lines[linePos].indexOf('-->') == -1) {\n                    cue.id = lines[linePos];\n                    /* COMMENTS\n             Not part of the specification's parser as these would just be ignored. However,\n             we want them to be conforming and not get \"Cue identifier cannot be standalone\".\n           */ if (/^NOTE($|[ \\t])/.test(cue.id)) {\n                        // .startsWith fails in Chrome\n                        linePos++;\n                        while(lines[linePos] != '' && lines[linePos] != undefined){\n                            if (lines[linePos].indexOf('-->') != -1) err('Cannot have timestamp in a comment.');\n                            linePos++;\n                        }\n                        continue;\n                    }\n                    /* STYLES */ if (/^STYLE($|[ \\t])/.test(cue.id)) {\n                        var style = [];\n                        var invalid = false;\n                        linePos++;\n                        while(lines[linePos] != '' && lines[linePos] != undefined){\n                            if (lines[linePos].indexOf('-->') != -1) {\n                                err('Cannot have timestamp in a style block.');\n                                invalid = true;\n                            }\n                            style.push(lines[linePos]);\n                            linePos++;\n                        }\n                        if (cues.length) {\n                            err('Style blocks cannot appear after the first cue.');\n                            continue;\n                        }\n                        if (!invalid) styles.push(style.join('\\n'));\n                        continue;\n                    }\n                    linePos++;\n                    if (lines[linePos] == '' || lines[linePos] == undefined) {\n                        err('Cue identifier cannot be standalone.');\n                        continue;\n                    }\n                    if (lines[linePos].indexOf('-->') == -1) {\n                        parseTimings = false;\n                        err('Cue identifier needs to be followed by timestamp.');\n                        continue;\n                    }\n                }\n                /* TIMINGS */ alreadyCollected = false;\n                var timings = new WebVTTCueTimingsAndSettingsParser(lines[linePos], err);\n                var previousCueStart = 0;\n                if (cues.length > 0) previousCueStart = cues[cues.length - 1].startTime;\n                if (parseTimings && !timings.parse(cue, previousCueStart)) {\n                    /* BAD CUE */ cue = null;\n                    linePos++;\n                    /* BAD CUE LOOP */ while(lines[linePos] != '' && lines[linePos] != undefined){\n                        if (lines[linePos].indexOf('-->') != -1) {\n                            alreadyCollected = true;\n                            break;\n                        }\n                        linePos++;\n                    }\n                    continue;\n                }\n                linePos++;\n                /* CUE TEXT LOOP */ while(lines[linePos] != '' && lines[linePos] != undefined){\n                    if (lines[linePos].indexOf('-->') != -1) {\n                        err('Blank line missing before cue.');\n                        alreadyCollected = true;\n                        break;\n                    }\n                    if (cue.text != '') cue.text += '\\n';\n                    cue.text += lines[linePos];\n                    linePos++;\n                }\n                /* CUE TEXT PROCESSING */ var cuetextparser = new WebVTTCueTextParser(cue.text, err, mode, entities);\n                cue.tree = cuetextparser.parse(cue.startTime, cue.endTime);\n                cues.push(cue);\n            }\n            cues.sort(function(a, b) {\n                if (a.startTime < b.startTime) return -1;\n                if (a.startTime > b.startTime) return 1;\n                if (a.endTime > b.endTime) return -1;\n                if (a.endTime < b.endTime) return 1;\n                return 0;\n            });\n            /* END */ return {\n                cues: cues,\n                errors: errors,\n                time: Date.now() - startTime,\n                styles: styles\n            };\n        };\n    };\n    var WebVTTCueTimingsAndSettingsParser = function(line, errorHandler) {\n        var SPACE = /[\\u0020\\t\\f]/, NOSPACE = /[^\\u0020\\t\\f]/, line = line, pos = 0, err = function(message) {\n            errorHandler(message, pos + 1);\n        }, spaceBeforeSetting = true;\n        function skip(pattern) {\n            while(line[pos] != undefined && pattern.test(line[pos]))pos++;\n        }\n        function collect(pattern) {\n            var str = '';\n            while(line[pos] != undefined && pattern.test(line[pos])){\n                str += line[pos];\n                pos++;\n            }\n            return str;\n        }\n        /* http://dev.w3.org/html5/webvtt/#collect-a-webvtt-timestamp */ function timestamp() {\n            var units = 'minutes', val1, val2, val3, val4;\n            // 3\n            if (line[pos] == undefined) {\n                err('No timestamp found.');\n                return;\n            }\n            // 4\n            if (!/\\d/.test(line[pos])) {\n                err('Timestamp must start with a character in the range 0-9.');\n                return;\n            }\n            // 5-7\n            val1 = collect(/\\d/);\n            if (val1.length > 2 || parseInt(val1, 10) > 59) units = 'hours';\n            // 8\n            if (line[pos] != ':') {\n                err('No time unit separator found.');\n                return;\n            }\n            pos++;\n            // 9-11\n            val2 = collect(/\\d/);\n            if (val2.length != 2) {\n                err('Must be exactly two digits.');\n                return;\n            }\n            // 12\n            if (units == 'hours' || line[pos] == ':') {\n                if (line[pos] != ':') {\n                    err('No seconds found or minutes is greater than 59.');\n                    return;\n                }\n                pos++;\n                val3 = collect(/\\d/);\n                if (val3.length != 2) {\n                    err('Must be exactly two digits.');\n                    return;\n                }\n            } else {\n                if (val1.length != 2) {\n                    err('Must be exactly two digits.');\n                    return;\n                }\n                val3 = val2;\n                val2 = val1;\n                val1 = '0';\n            }\n            // 13\n            if (line[pos] != '.') {\n                err('No decimal separator (\".\") found.');\n                return;\n            }\n            pos++;\n            // 14-16\n            val4 = collect(/\\d/);\n            if (val4.length != 3) {\n                err('Milliseconds must be given in three digits.');\n                return;\n            }\n            // 17\n            if (parseInt(val2, 10) > 59) {\n                err('You cannot have more than 59 minutes.');\n                return;\n            }\n            if (parseInt(val3, 10) > 59) {\n                err('You cannot have more than 59 seconds.');\n                return;\n            }\n            return parseInt(val1, 10) * 3600 + parseInt(val2, 10) * 60 + parseInt(val3, 10) + parseInt(val4, 10) / 1000;\n        }\n        /* http://dev.w3.org/html5/webvtt/#parse-the-webvtt-settings */ function parseSettings(input, cue) {\n            var settings = input.split(SPACE), seen = [];\n            for(var i = 0; i < settings.length; i++){\n                if (settings[i] == '') continue;\n                var index = settings[i].indexOf(':'), setting = settings[i].slice(0, index), value = settings[i].slice(index + 1);\n                if (seen.indexOf(setting) != -1) err('Duplicate setting.');\n                seen.push(setting);\n                if (value == '') {\n                    err('No value for setting defined.');\n                    return;\n                }\n                if (setting == 'vertical') {\n                    // writing direction\n                    if (value != 'rl' && value != 'lr') {\n                        err(\"Writing direction can only be set to 'rl' or 'rl'.\");\n                        continue;\n                    }\n                    cue.direction = value;\n                } else if (setting == 'line') {\n                    // line position and optionally line alignment\n                    if (/,/.test(value)) {\n                        var comp = value.split(',');\n                        value = comp[0];\n                        var lineAlign = comp[1];\n                    }\n                    if (!/^[-\\d](\\d*)(\\.\\d+)?%?$/.test(value)) {\n                        err('Line position takes a number or percentage.');\n                        continue;\n                    }\n                    if (value.indexOf('-', 1) != -1) {\n                        err(\"Line position can only have '-' at the start.\");\n                        continue;\n                    }\n                    if (value.indexOf('%') != -1 && value.indexOf('%') != value.length - 1) {\n                        err(\"Line position can only have '%' at the end.\");\n                        continue;\n                    }\n                    if (value[0] == '-' && value[value.length - 1] == '%') {\n                        err('Line position cannot be a negative percentage.');\n                        continue;\n                    }\n                    var numVal = value;\n                    var isPercent = false;\n                    if (value[value.length - 1] == '%') {\n                        isPercent = true;\n                        numVal = value.slice(0, value.length - 1);\n                        if (parseInt(value, 10) > 100) {\n                            err('Line position cannot be >100%.');\n                            continue;\n                        }\n                    }\n                    if (numVal === '' || isNaN(numVal) || !isFinite(numVal)) {\n                        err('Line position needs to be a number');\n                        continue;\n                    }\n                    if (lineAlign !== undefined) {\n                        if (![\n                            'start',\n                            'center',\n                            'end'\n                        ].includes(lineAlign)) {\n                            err('Line alignment needs to be one of start, center or end');\n                            continue;\n                        }\n                        cue.lineAlign = lineAlign;\n                    }\n                    cue.snapToLines = !isPercent;\n                    cue.linePosition = parseFloat(numVal);\n                    if (parseFloat(numVal).toString() !== numVal) cue.nonSerializable = true;\n                } else if (setting == 'position') {\n                    // text position and optional positionAlign\n                    if (/,/.test(value)) {\n                        var comp = value.split(',');\n                        value = comp[0];\n                        var positionAlign = comp[1];\n                    }\n                    if (value[value.length - 1] != '%') {\n                        err('Text position must be a percentage.');\n                        continue;\n                    }\n                    if (parseInt(value, 10) > 100 || parseInt(value, 10) < 0) {\n                        err('Text position needs to be between 0 and 100%.');\n                        continue;\n                    }\n                    numVal = value.slice(0, value.length - 1);\n                    if (numVal === '' || isNaN(numVal) || !isFinite(numVal)) {\n                        err('Line position needs to be a number');\n                        continue;\n                    }\n                    if (positionAlign !== undefined) {\n                        if (![\n                            'line-left',\n                            'center',\n                            'line-right'\n                        ].includes(positionAlign)) {\n                            err('Position alignment needs to be one of line-left, center or line-right');\n                            continue;\n                        }\n                        cue.positionAlign = positionAlign;\n                    }\n                    cue.textPosition = parseFloat(numVal);\n                } else if (setting == 'size') {\n                    // size\n                    if (value[value.length - 1] != '%') {\n                        err('Size must be a percentage.');\n                        continue;\n                    }\n                    if (parseInt(value, 10) > 100) {\n                        err('Size cannot be >100%.');\n                        continue;\n                    }\n                    var size = value.slice(0, value.length - 1);\n                    if (size === undefined || size === '' || isNaN(size)) {\n                        err('Size needs to be a number');\n                        size = 100;\n                        continue;\n                    } else {\n                        size = parseFloat(size);\n                        if (size < 0 || size > 100) {\n                            err('Size needs to be between 0 and 100%.');\n                            continue;\n                        }\n                    }\n                    cue.size = size;\n                } else if (setting == 'align') {\n                    // alignment\n                    var alignValues = [\n                        'start',\n                        'center',\n                        'end',\n                        'left',\n                        'right'\n                    ];\n                    if (alignValues.indexOf(value) == -1) {\n                        err('Alignment can only be set to one of ' + alignValues.join(', ') + '.');\n                        continue;\n                    }\n                    cue.alignment = value;\n                } else err('Invalid setting.');\n            }\n        }\n        this.parse = function(cue, previousCueStart) {\n            skip(SPACE);\n            cue.startTime = timestamp();\n            if (cue.startTime == undefined) return;\n            if (cue.startTime < previousCueStart) err('Start timestamp is not greater than or equal to start timestamp of previous cue.');\n            if (NOSPACE.test(line[pos])) err(\"Timestamp not separated from '-->' by whitespace.\");\n            skip(SPACE);\n            // 6-8\n            if (line[pos] != '-') {\n                err('No valid timestamp separator found.');\n                return;\n            }\n            pos++;\n            if (line[pos] != '-') {\n                err('No valid timestamp separator found.');\n                return;\n            }\n            pos++;\n            if (line[pos] != '>') {\n                err('No valid timestamp separator found.');\n                return;\n            }\n            pos++;\n            if (NOSPACE.test(line[pos])) err(\"'-->' not separated from timestamp by whitespace.\");\n            skip(SPACE);\n            cue.endTime = timestamp();\n            if (cue.endTime == undefined) return;\n            if (cue.endTime <= cue.startTime) err('End timestamp is not greater than start timestamp.');\n            if (NOSPACE.test(line[pos])) spaceBeforeSetting = false;\n            skip(SPACE);\n            parseSettings(line.substring(pos), cue);\n            return true;\n        };\n        this.parseTimestamp = function() {\n            var ts = timestamp();\n            if (line[pos] != undefined) {\n                err('Timestamp must not have trailing characters.');\n                return;\n            }\n            return ts;\n        };\n    };\n    var WebVTTCueTextParser = function(line, errorHandler, mode, entities) {\n        this.entities = entities;\n        var self = this;\n        var line = line, pos = 0, err = function(message) {\n            if (mode == 'metadata') return;\n            errorHandler(message, pos + 1);\n        };\n        this.parse = function(cueStart, cueEnd) {\n            function removeCycles(tree) {\n                const cyclelessTree = {\n                    ...tree\n                };\n                if (tree.children) cyclelessTree.children = tree.children.map(removeCycles);\n                if (cyclelessTree.parent) delete cyclelessTree.parent;\n                return cyclelessTree;\n            }\n            var result = {\n                children: []\n            }, current = result, timestamps = [];\n            function attach(token) {\n                current.children.push({\n                    type: 'object',\n                    name: token[1],\n                    classes: token[2],\n                    children: [],\n                    parent: current\n                });\n                current = current.children[current.children.length - 1];\n            }\n            function inScope(name) {\n                var node = current;\n                while(node){\n                    if (node.name == name) return true;\n                    node = node.parent;\n                }\n                return;\n            }\n            while(line[pos] != undefined){\n                var token = nextToken();\n                if (token[0] == 'text') current.children.push({\n                    type: 'text',\n                    value: token[1],\n                    parent: current\n                });\n                else if (token[0] == 'start tag') {\n                    if (mode == 'chapters') err('Start tags not allowed in chapter title text.');\n                    var name = token[1];\n                    if (name != 'v' && name != 'lang' && token[3] != '') err('Only <v> and <lang> can have an annotation.');\n                    if (name == 'c' || name == 'i' || name == 'b' || name == 'u' || name == 'ruby') attach(token);\n                    else if (name == 'rt' && current.name == 'ruby') attach(token);\n                    else if (name == 'v') {\n                        if (inScope('v')) err('<v> cannot be nested inside itself.');\n                        attach(token);\n                        current.value = token[3]; // annotation\n                        if (!token[3]) err('<v> requires an annotation.');\n                    } else if (name == 'lang') {\n                        attach(token);\n                        current.value = token[3]; // language\n                    } else err('Incorrect start tag.');\n                } else if (token[0] == 'end tag') {\n                    if (mode == 'chapters') err('End tags not allowed in chapter title text.');\n                    // XXX check <ruby> content\n                    if (token[1] == current.name) current = current.parent;\n                    else if (token[1] == 'ruby' && current.name == 'rt') current = current.parent.parent;\n                    else err('Incorrect end tag.');\n                } else if (token[0] == 'timestamp') {\n                    if (mode == 'chapters') err('Timestamp not allowed in chapter title text.');\n                    var timings = new WebVTTCueTimingsAndSettingsParser(token[1], err), timestamp = timings.parseTimestamp();\n                    if (timestamp != undefined) {\n                        if (timestamp <= cueStart || timestamp >= cueEnd) err('Timestamp must be between start timestamp and end timestamp.');\n                        if (timestamps.length > 0 && timestamps[timestamps.length - 1] >= timestamp) err('Timestamp must be greater than any previous timestamp.');\n                        current.children.push({\n                            type: 'timestamp',\n                            value: timestamp,\n                            parent: current\n                        });\n                        timestamps.push(timestamp);\n                    }\n                }\n            }\n            while(current.parent){\n                if (current.name != 'v') err('Required end tag missing.');\n                current = current.parent;\n            }\n            return removeCycles(result);\n        };\n        function nextToken() {\n            var state = 'data', result = '', buffer = '', classes = [];\n            while(line[pos - 1] != undefined || pos == 0){\n                var c = line[pos];\n                if (state == 'data') {\n                    if (c == '&') {\n                        buffer = c;\n                        state = 'escape';\n                    } else if (c == '<' && result == '') state = 'tag';\n                    else if (c == '<' || c == undefined) return [\n                        'text',\n                        result\n                    ];\n                    else result += c;\n                } else if (state == 'escape') {\n                    if (c == '<' || c == undefined) {\n                        err('Incorrect escape.');\n                        let m;\n                        if (m = buffer.match(/^&#([0-9]+)$/)) result += String.fromCharCode(m[1]);\n                        else if (self.entities[buffer]) result += self.entities[buffer];\n                        else result += buffer;\n                        return [\n                            'text',\n                            result\n                        ];\n                    } else if (c == '&') {\n                        err('Incorrect escape.');\n                        result += buffer;\n                        buffer = c;\n                    } else if (/[a-z#0-9]/i.test(c)) buffer += c;\n                    else if (c == ';') {\n                        let m;\n                        if (m = buffer.match(/^&#(x?[0-9]+)$/)) // we prepend \"0\" so that x20 be interpreted as hexadecim (0x20)\n                        result += String.fromCharCode('0' + m[1]);\n                        else if (self.entities[buffer + c]) result += self.entities[buffer + c];\n                        else if (m = Object.keys(entities).find((n)=>buffer.startsWith(n))) // partial match\n                        result += self.entities[m] + buffer.slice(m.length) + c;\n                        else {\n                            err('Incorrect escape.');\n                            result += buffer + ';';\n                        }\n                        state = 'data';\n                    } else {\n                        err('Incorrect escape.');\n                        result += buffer + c;\n                        state = 'data';\n                    }\n                } else if (state == 'tag') {\n                    if (c == '\\t' || c == '\\n' || c == '\\f' || c == ' ') state = 'start tag annotation';\n                    else if (c == '.') state = 'start tag class';\n                    else if (c == '/') state = 'end tag';\n                    else if (/\\d/.test(c)) {\n                        result = c;\n                        state = 'timestamp tag';\n                    } else if (c == '>' || c == undefined) {\n                        if (c == '>') pos++;\n                        return [\n                            'start tag',\n                            '',\n                            [],\n                            ''\n                        ];\n                    } else {\n                        result = c;\n                        state = 'start tag';\n                    }\n                } else if (state == 'start tag') {\n                    if (c == '\\t' || c == '\\f' || c == ' ') state = 'start tag annotation';\n                    else if (c == '\\n') {\n                        buffer = c;\n                        state = 'start tag annotation';\n                    } else if (c == '.') state = 'start tag class';\n                    else if (c == '>' || c == undefined) {\n                        if (c == '>') pos++;\n                        return [\n                            'start tag',\n                            result,\n                            [],\n                            ''\n                        ];\n                    } else result += c;\n                } else if (state == 'start tag class') {\n                    if (c == '\\t' || c == '\\f' || c == ' ') {\n                        if (buffer) classes.push(buffer);\n                        buffer = '';\n                        state = 'start tag annotation';\n                    } else if (c == '\\n') {\n                        if (buffer) classes.push(buffer);\n                        buffer = c;\n                        state = 'start tag annotation';\n                    } else if (c == '.') {\n                        if (buffer) classes.push(buffer);\n                        buffer = '';\n                    } else if (c == '>' || c == undefined) {\n                        if (c == '>') pos++;\n                        if (buffer) classes.push(buffer);\n                        return [\n                            'start tag',\n                            result,\n                            classes,\n                            ''\n                        ];\n                    } else buffer += c;\n                } else if (state == 'start tag annotation') {\n                    if (c == '>' || c == undefined) {\n                        if (c == '>') pos++;\n                        buffer = buffer.split(/[\\u0020\\t\\f\\r\\n]+/).filter(function(item) {\n                            if (item) return true;\n                        }).join(' ');\n                        return [\n                            'start tag',\n                            result,\n                            classes,\n                            buffer\n                        ];\n                    } else buffer += c;\n                } else if (state == 'end tag') {\n                    if (c == '>' || c == undefined) {\n                        if (c == '>') pos++;\n                        return [\n                            'end tag',\n                            result\n                        ];\n                    } else result += c;\n                } else if (state == 'timestamp tag') {\n                    if (c == '>' || c == undefined) {\n                        if (c == '>') pos++;\n                        return [\n                            'timestamp',\n                            result\n                        ];\n                    } else result += c;\n                } else err('Never happens.'); // The joke is it might.\n                // 8\n                pos++;\n            }\n        }\n    };\n    var WebVTTSerializer = function() {\n        function serializeTimestamp(seconds) {\n            const ms = ('00' + (seconds - Math.floor(seconds)).toFixed(3) * 1000).slice(-3);\n            let h = 0, m = 0, s = 0;\n            if (seconds >= 3600) h = Math.floor(seconds / 3600);\n            m = Math.floor((seconds - 3600 * h) / 60);\n            s = Math.floor(seconds - 3600 * h - 60 * m);\n            return (h ? h + ':' : '') + ('' + m).padStart(2, '0') + ':' + ('' + s).padStart(2, '0') + '.' + ms;\n        }\n        function serializeCueSettings(cue) {\n            var result = '';\n            const nonDefaultSettings = Object.keys(defaultCueSettings).filter((s)=>cue[s] !== defaultCueSettings[s]);\n            if (nonDefaultSettings.includes('direction')) result += ' vertical:' + cue.direction;\n            if (nonDefaultSettings.includes('alignment')) result += ' align:' + cue.alignment;\n            if (nonDefaultSettings.includes('size')) result += ' size:' + cue.size + '%';\n            if (nonDefaultSettings.includes('lineAlign') || nonDefaultSettings.includes('linePosition')) result += ' line:' + cue.linePosition + (cue.snapToLines ? '' : '%') + (cue.lineAlign && cue.lineAlign != defaultCueSettings.lineAlign ? ',' + cue.lineAlign : '');\n            if (nonDefaultSettings.includes('textPosition') || nonDefaultSettings.includes('positionAlign')) result += ' position:' + cue.textPosition + '%' + (cue.positionAlign && cue.positionAlign !== defaultCueSettings.positionAlign ? ',' + cue.positionAlign : '');\n            return result;\n        }\n        function serializeTree(tree) {\n            var result = '';\n            for(var i = 0; i < tree.length; i++){\n                var node = tree[i];\n                if (node.type == 'text') result += node.value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n                else if (node.type == 'object') {\n                    result += '<' + node.name;\n                    if (node.classes) for(var y = 0; y < node.classes.length; y++)result += '.' + node.classes[y];\n                    if (node.value) result += ' ' + node.value;\n                    result += '>';\n                    if (node.children) result += serializeTree(node.children);\n                    result += '</' + node.name + '>';\n                } else if (node.type == 'timestamp') result += '<' + serializeTimestamp(node.value) + '>';\n                else result += '<' + node.value + '>';\n            }\n            return result;\n        }\n        function serializeCue(cue) {\n            return (cue.id !== undefined ? cue.id + '\\n' : '') + serializeTimestamp(cue.startTime) + ' --> ' + serializeTimestamp(cue.endTime) + serializeCueSettings(cue) + '\\n' + serializeTree(cue.tree.children) + '\\n\\n';\n        }\n        function serializeStyle(style) {\n            return 'STYLE\\n' + style + '\\n\\n';\n        }\n        this.serialize = function(cues, styles) {\n            var result = 'WEBVTT\\n\\n';\n            if (styles) for(var i = 0; i < styles.length; i++)result += serializeStyle(styles[i]);\n            for(var i = 0; i < cues.length; i++)result += serializeCue(cues[i]);\n            return result;\n        };\n    };\n    function exportify(object) {\n        object.WebVTTParser = WebVTTParser;\n        object.WebVTTCueTimingsAndSettingsParser = WebVTTCueTimingsAndSettingsParser;\n        object.WebVTTCueTextParser = WebVTTCueTextParser;\n        object.WebVTTSerializer = WebVTTSerializer;\n    }\n    if (typeof window !== 'undefined') exportify(window);\n    exportify(exports);\n})();\n\n},{}],\"5lQoW\":[function(require,module,exports,__globalThis) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, '__esModule', {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}]},[\"3MgS1\"], \"3MgS1\", \"parcelRequire4dc0\", {})\nlet {default: _default, } = parcelRequire4dc0(\"3MgS1\");\nexport {_default as default, };\n\n//# sourceMappingURL=index.js.map\n","import { WebVTTParser, WebVTTSerializer } from './parser';\n\nasync function loadVtt(option, { getExt, srtToVtt, assToVtt }) {\n    const response = await fetch(option.url);\n    const buffer = await response.arrayBuffer();\n    const decoder = new TextDecoder(option.encoding || 'utf-8');\n    const text = decoder.decode(buffer);\n    switch (option.type || getExt(option.url)) {\n        case 'srt': {\n            return srtToVtt(text);\n        }\n        case 'ass': {\n            return assToVtt(text);\n        }\n        case 'vtt': {\n            return text;\n        }\n        default:\n            return '';\n    }\n}\n\nfunction mergeTrees(trees) {\n    const parser = new WebVTTParser();\n    const result = parser.parse('', 'metadata');\n\n    for (let i = 0; i < trees.length; i++) {\n        const tree = trees[i];\n\n        if (!tree.updated) {\n            tree.updated = true;\n            for (let j = 0; j < tree.cues.length; j++) {\n                const cue = tree.cues[j];\n                for (let k = 0; k < cue.tree.children.length; k++) {\n                    const children = cue.tree.children[k];\n                    children.value = `<div class=\"art-subtitle-${tree.name}\">${children.value}</div>`;\n                }\n            }\n        }\n\n        result.cues.push(...tree.cues);\n    }\n\n    return result;\n}\n\nexport default function artplayerPluginMultipleSubtitles({ subtitles = [] }) {\n    return async (art) => {\n        const { unescape, getExt, srtToVtt, assToVtt } = art.constructor.utils;\n\n        const parser = new WebVTTParser();\n        const seri = new WebVTTSerializer();\n\n        const vtts = await Promise.all(\n            subtitles.map((option) => {\n                return loadVtt(option, { getExt, srtToVtt, assToVtt });\n            }),\n        );\n\n        const trees = vtts.map((vtt, index) => {\n            const tree = parser.parse(vtt, 'metadata');\n            tree.url = subtitles[index].url;\n            tree.name = subtitles[index].name;\n            return tree;\n        });\n\n        let lastUrl = '';\n        function setTracks(trees = []) {\n            const tree = mergeTrees(trees);\n            const vtt = seri.serialize(tree.cues);\n            URL.revokeObjectURL(lastUrl);\n            const url = URL.createObjectURL(new Blob([vtt], { type: 'text/vtt' }));\n            lastUrl = url;\n            art.option.subtitle.escape = false;\n            art.subtitle.init({\n                ...art.option.subtitle,\n                url,\n                type: 'vtt',\n                onVttLoad: unescape,\n            });\n        }\n\n        setTracks(trees);\n\n        return {\n            name: 'multipleSubtitles',\n            tracks(names = []) {\n                return setTracks(names.map((name) => trees.find((tree) => tree.name === name)));\n            },\n            reset() {\n                return setTracks(trees);\n            },\n        };\n    };\n}\n\nif (typeof window !== 'undefined') {\n    window['artplayerPluginMultipleSubtitles'] = artplayerPluginMultipleSubtitles;\n}\n","// Any copyright is dedicated to the Public Domain.\n// http://creativecommons.org/publicdomain/zero/1.0/\n\n// Not intended to be fast, but if you can make it faster, please help out!\n\n/* eslint-disable */\n(function () {\n    var defaultCueSettings = {\n        direction: 'horizontal',\n        snapToLines: true,\n        linePosition: 'auto',\n        lineAlign: 'start',\n        textPosition: 'auto',\n        positionAlign: 'auto',\n        size: 100,\n        alignment: 'center',\n    };\n\n    var WebVTTParser = function (entities) {\n        if (!entities) {\n            entities = {\n                '&amp': '&',\n                '&lt': '<',\n                '&gt': '>',\n                '&lrm': '\\u200e',\n                '&rlm': '\\u200f',\n                '&nbsp': '\\u00A0',\n            };\n        }\n        this.entities = entities;\n        this.parse = function (input, mode) {\n            // global search and replace for \\0\n            input = input.replace(/\\0/g, '\\uFFFD');\n            var NEWLINE = /\\r\\n|\\r|\\n/,\n                startTime = Date.now(),\n                linePos = 0,\n                lines = input.split(NEWLINE),\n                alreadyCollected = false,\n                styles = [],\n                cues = [],\n                errors = [];\n            function err(message, col) {\n                errors.push({ message: message, line: linePos + 1, col: col });\n            }\n\n            var line = lines[linePos],\n                lineLength = line.length,\n                signature = 'WEBVTT',\n                bom = 0,\n                signature_length = signature.length;\n\n            /* Byte order mark */\n            if (line[0] === '\\ufeff') {\n                bom = 1;\n                signature_length += 1;\n            }\n            /* SIGNATURE */\n            if (\n                lineLength < signature_length ||\n                line.indexOf(signature) !== 0 + bom ||\n                (lineLength > signature_length && line[signature_length] !== ' ' && line[signature_length] !== '\\t')\n            ) {\n                err('No valid signature. (File needs to start with \"WEBVTT\".)');\n            }\n\n            linePos++;\n\n            /* HEADER */\n            while (lines[linePos] != '' && lines[linePos] != undefined) {\n                err('No blank line after the signature.');\n                if (lines[linePos].indexOf('-->') != -1) {\n                    alreadyCollected = true;\n                    break;\n                }\n                linePos++;\n            }\n\n            /* CUE LOOP */\n            while (lines[linePos] != undefined) {\n                var cue;\n                while (!alreadyCollected && lines[linePos] == '') {\n                    linePos++;\n                }\n                if (!alreadyCollected && lines[linePos] == undefined) break;\n\n                /* CUE CREATION */\n                cue = Object.assign({}, defaultCueSettings, {\n                    id: '',\n                    startTime: 0,\n                    endTime: 0,\n                    pauseOnExit: false,\n                    direction: 'horizontal',\n                    snapToLines: true,\n                    linePosition: 'auto',\n                    lineAlign: 'start',\n                    textPosition: 'auto',\n                    positionAlign: 'auto',\n                    size: 100,\n                    alignment: 'center',\n                    text: '',\n                    tree: null,\n                });\n\n                var parseTimings = true;\n\n                if (lines[linePos].indexOf('-->') == -1) {\n                    cue.id = lines[linePos];\n\n                    /* COMMENTS\n             Not part of the specification's parser as these would just be ignored. However,\n             we want them to be conforming and not get \"Cue identifier cannot be standalone\".\n           */\n                    if (/^NOTE($|[ \\t])/.test(cue.id)) {\n                        // .startsWith fails in Chrome\n                        linePos++;\n                        while (lines[linePos] != '' && lines[linePos] != undefined) {\n                            if (lines[linePos].indexOf('-->') != -1) err('Cannot have timestamp in a comment.');\n                            linePos++;\n                        }\n                        continue;\n                    }\n\n                    /* STYLES */\n                    if (/^STYLE($|[ \\t])/.test(cue.id)) {\n                        var style = [];\n                        var invalid = false;\n                        linePos++;\n                        while (lines[linePos] != '' && lines[linePos] != undefined) {\n                            if (lines[linePos].indexOf('-->') != -1) {\n                                err('Cannot have timestamp in a style block.');\n                                invalid = true;\n                            }\n                            style.push(lines[linePos]);\n                            linePos++;\n                        }\n                        if (cues.length) {\n                            err('Style blocks cannot appear after the first cue.');\n                            continue;\n                        }\n                        if (!invalid) {\n                            styles.push(style.join('\\n'));\n                        }\n                        continue;\n                    }\n\n                    linePos++;\n\n                    if (lines[linePos] == '' || lines[linePos] == undefined) {\n                        err('Cue identifier cannot be standalone.');\n                        continue;\n                    }\n\n                    if (lines[linePos].indexOf('-->') == -1) {\n                        parseTimings = false;\n                        err('Cue identifier needs to be followed by timestamp.');\n                        continue;\n                    }\n                }\n\n                /* TIMINGS */\n                alreadyCollected = false;\n                var timings = new WebVTTCueTimingsAndSettingsParser(lines[linePos], err);\n                var previousCueStart = 0;\n                if (cues.length > 0) {\n                    previousCueStart = cues[cues.length - 1].startTime;\n                }\n                if (parseTimings && !timings.parse(cue, previousCueStart)) {\n                    /* BAD CUE */\n\n                    cue = null;\n                    linePos++;\n\n                    /* BAD CUE LOOP */\n                    while (lines[linePos] != '' && lines[linePos] != undefined) {\n                        if (lines[linePos].indexOf('-->') != -1) {\n                            alreadyCollected = true;\n                            break;\n                        }\n                        linePos++;\n                    }\n                    continue;\n                }\n                linePos++;\n\n                /* CUE TEXT LOOP */\n                while (lines[linePos] != '' && lines[linePos] != undefined) {\n                    if (lines[linePos].indexOf('-->') != -1) {\n                        err('Blank line missing before cue.');\n                        alreadyCollected = true;\n                        break;\n                    }\n                    if (cue.text != '') cue.text += '\\n';\n                    cue.text += lines[linePos];\n                    linePos++;\n                }\n\n                /* CUE TEXT PROCESSING */\n                var cuetextparser = new WebVTTCueTextParser(cue.text, err, mode, entities);\n                cue.tree = cuetextparser.parse(cue.startTime, cue.endTime);\n                cues.push(cue);\n            }\n            cues.sort(function (a, b) {\n                if (a.startTime < b.startTime) return -1;\n                if (a.startTime > b.startTime) return 1;\n                if (a.endTime > b.endTime) return -1;\n                if (a.endTime < b.endTime) return 1;\n                return 0;\n            });\n            /* END */\n            return { cues: cues, errors: errors, time: Date.now() - startTime, styles: styles };\n        };\n    };\n\n    var WebVTTCueTimingsAndSettingsParser = function (line, errorHandler) {\n        var SPACE = /[\\u0020\\t\\f]/,\n            NOSPACE = /[^\\u0020\\t\\f]/,\n            line = line,\n            pos = 0,\n            err = function (message) {\n                errorHandler(message, pos + 1);\n            },\n            spaceBeforeSetting = true;\n        function skip(pattern) {\n            while (line[pos] != undefined && pattern.test(line[pos])) {\n                pos++;\n            }\n        }\n        function collect(pattern) {\n            var str = '';\n            while (line[pos] != undefined && pattern.test(line[pos])) {\n                str += line[pos];\n                pos++;\n            }\n            return str;\n        }\n        /* http://dev.w3.org/html5/webvtt/#collect-a-webvtt-timestamp */\n        function timestamp() {\n            var units = 'minutes',\n                val1,\n                val2,\n                val3,\n                val4;\n            // 3\n            if (line[pos] == undefined) {\n                err('No timestamp found.');\n                return;\n            }\n            // 4\n            if (!/\\d/.test(line[pos])) {\n                err('Timestamp must start with a character in the range 0-9.');\n                return;\n            }\n            // 5-7\n            val1 = collect(/\\d/);\n            if (val1.length > 2 || parseInt(val1, 10) > 59) {\n                units = 'hours';\n            }\n            // 8\n            if (line[pos] != ':') {\n                err('No time unit separator found.');\n                return;\n            }\n            pos++;\n            // 9-11\n            val2 = collect(/\\d/);\n            if (val2.length != 2) {\n                err('Must be exactly two digits.');\n                return;\n            }\n            // 12\n            if (units == 'hours' || line[pos] == ':') {\n                if (line[pos] != ':') {\n                    err('No seconds found or minutes is greater than 59.');\n                    return;\n                }\n                pos++;\n                val3 = collect(/\\d/);\n                if (val3.length != 2) {\n                    err('Must be exactly two digits.');\n                    return;\n                }\n            } else {\n                if (val1.length != 2) {\n                    err('Must be exactly two digits.');\n                    return;\n                }\n                val3 = val2;\n                val2 = val1;\n                val1 = '0';\n            }\n            // 13\n            if (line[pos] != '.') {\n                err('No decimal separator (\".\") found.');\n                return;\n            }\n            pos++;\n            // 14-16\n            val4 = collect(/\\d/);\n            if (val4.length != 3) {\n                err('Milliseconds must be given in three digits.');\n                return;\n            }\n            // 17\n            if (parseInt(val2, 10) > 59) {\n                err('You cannot have more than 59 minutes.');\n                return;\n            }\n            if (parseInt(val3, 10) > 59) {\n                err('You cannot have more than 59 seconds.');\n                return;\n            }\n            return (\n                parseInt(val1, 10) * 60 * 60 + parseInt(val2, 10) * 60 + parseInt(val3, 10) + parseInt(val4, 10) / 1000\n            );\n        }\n\n        /* http://dev.w3.org/html5/webvtt/#parse-the-webvtt-settings */\n        function parseSettings(input, cue) {\n            var settings = input.split(SPACE),\n                seen = [];\n            for (var i = 0; i < settings.length; i++) {\n                if (settings[i] == '') continue;\n\n                var index = settings[i].indexOf(':'),\n                    setting = settings[i].slice(0, index),\n                    value = settings[i].slice(index + 1);\n\n                if (seen.indexOf(setting) != -1) {\n                    err('Duplicate setting.');\n                }\n                seen.push(setting);\n\n                if (value == '') {\n                    err('No value for setting defined.');\n                    return;\n                }\n\n                if (setting == 'vertical') {\n                    // writing direction\n                    if (value != 'rl' && value != 'lr') {\n                        err(\"Writing direction can only be set to 'rl' or 'rl'.\");\n                        continue;\n                    }\n                    cue.direction = value;\n                } else if (setting == 'line') {\n                    // line position and optionally line alignment\n                    if (/,/.test(value)) {\n                        var comp = value.split(',');\n                        value = comp[0];\n                        var lineAlign = comp[1];\n                    }\n                    if (!/^[-\\d](\\d*)(\\.\\d+)?%?$/.test(value)) {\n                        err('Line position takes a number or percentage.');\n                        continue;\n                    }\n                    if (value.indexOf('-', 1) != -1) {\n                        err(\"Line position can only have '-' at the start.\");\n                        continue;\n                    }\n                    if (value.indexOf('%') != -1 && value.indexOf('%') != value.length - 1) {\n                        err(\"Line position can only have '%' at the end.\");\n                        continue;\n                    }\n                    if (value[0] == '-' && value[value.length - 1] == '%') {\n                        err('Line position cannot be a negative percentage.');\n                        continue;\n                    }\n                    var numVal = value;\n                    var isPercent = false;\n                    if (value[value.length - 1] == '%') {\n                        isPercent = true;\n                        numVal = value.slice(0, value.length - 1);\n                        if (parseInt(value, 10) > 100) {\n                            err('Line position cannot be >100%.');\n                            continue;\n                        }\n                    }\n                    if (numVal === '' || isNaN(numVal) || !isFinite(numVal)) {\n                        err('Line position needs to be a number');\n                        continue;\n                    }\n                    if (lineAlign !== undefined) {\n                        if (!['start', 'center', 'end'].includes(lineAlign)) {\n                            err('Line alignment needs to be one of start, center or end');\n                            continue;\n                        }\n                        cue.lineAlign = lineAlign;\n                    }\n                    cue.snapToLines = !isPercent;\n                    cue.linePosition = parseFloat(numVal);\n                    if (parseFloat(numVal).toString() !== numVal) {\n                        cue.nonSerializable = true;\n                    }\n                } else if (setting == 'position') {\n                    // text position and optional positionAlign\n                    if (/,/.test(value)) {\n                        var comp = value.split(',');\n                        value = comp[0];\n                        var positionAlign = comp[1];\n                    }\n                    if (value[value.length - 1] != '%') {\n                        err('Text position must be a percentage.');\n                        continue;\n                    }\n                    if (parseInt(value, 10) > 100 || parseInt(value, 10) < 0) {\n                        err('Text position needs to be between 0 and 100%.');\n                        continue;\n                    }\n                    numVal = value.slice(0, value.length - 1);\n                    if (numVal === '' || isNaN(numVal) || !isFinite(numVal)) {\n                        err('Line position needs to be a number');\n                        continue;\n                    }\n                    if (positionAlign !== undefined) {\n                        if (!['line-left', 'center', 'line-right'].includes(positionAlign)) {\n                            err('Position alignment needs to be one of line-left, center or line-right');\n                            continue;\n                        }\n                        cue.positionAlign = positionAlign;\n                    }\n                    cue.textPosition = parseFloat(numVal);\n                } else if (setting == 'size') {\n                    // size\n                    if (value[value.length - 1] != '%') {\n                        err('Size must be a percentage.');\n                        continue;\n                    }\n                    if (parseInt(value, 10) > 100) {\n                        err('Size cannot be >100%.');\n                        continue;\n                    }\n                    var size = value.slice(0, value.length - 1);\n                    if (size === undefined || size === '' || isNaN(size)) {\n                        err('Size needs to be a number');\n                        size = 100;\n                        continue;\n                    } else {\n                        size = parseFloat(size);\n                        if (size < 0 || size > 100) {\n                            err('Size needs to be between 0 and 100%.');\n                            continue;\n                        }\n                    }\n                    cue.size = size;\n                } else if (setting == 'align') {\n                    // alignment\n                    var alignValues = ['start', 'center', 'end', 'left', 'right'];\n                    if (alignValues.indexOf(value) == -1) {\n                        err('Alignment can only be set to one of ' + alignValues.join(', ') + '.');\n                        continue;\n                    }\n                    cue.alignment = value;\n                } else {\n                    err('Invalid setting.');\n                }\n            }\n        }\n\n        this.parse = function (cue, previousCueStart) {\n            skip(SPACE);\n            cue.startTime = timestamp();\n            if (cue.startTime == undefined) {\n                return;\n            }\n            if (cue.startTime < previousCueStart) {\n                err('Start timestamp is not greater than or equal to start timestamp of previous cue.');\n            }\n            if (NOSPACE.test(line[pos])) {\n                err(\"Timestamp not separated from '-->' by whitespace.\");\n            }\n            skip(SPACE);\n            // 6-8\n            if (line[pos] != '-') {\n                err('No valid timestamp separator found.');\n                return;\n            }\n            pos++;\n            if (line[pos] != '-') {\n                err('No valid timestamp separator found.');\n                return;\n            }\n            pos++;\n            if (line[pos] != '>') {\n                err('No valid timestamp separator found.');\n                return;\n            }\n            pos++;\n            if (NOSPACE.test(line[pos])) {\n                err(\"'-->' not separated from timestamp by whitespace.\");\n            }\n            skip(SPACE);\n            cue.endTime = timestamp();\n            if (cue.endTime == undefined) {\n                return;\n            }\n            if (cue.endTime <= cue.startTime) {\n                err('End timestamp is not greater than start timestamp.');\n            }\n\n            if (NOSPACE.test(line[pos])) {\n                spaceBeforeSetting = false;\n            }\n            skip(SPACE);\n            parseSettings(line.substring(pos), cue);\n            return true;\n        };\n        this.parseTimestamp = function () {\n            var ts = timestamp();\n            if (line[pos] != undefined) {\n                err('Timestamp must not have trailing characters.');\n                return;\n            }\n            return ts;\n        };\n    };\n\n    var WebVTTCueTextParser = function (line, errorHandler, mode, entities) {\n        this.entities = entities;\n        var self = this;\n        var line = line,\n            pos = 0,\n            err = function (message) {\n                if (mode == 'metadata') return;\n                errorHandler(message, pos + 1);\n            };\n\n        this.parse = function (cueStart, cueEnd) {\n            function removeCycles(tree) {\n                const cyclelessTree = { ...tree };\n                if (tree.children) {\n                    cyclelessTree.children = tree.children.map(removeCycles);\n                }\n                if (cyclelessTree.parent) {\n                    delete cyclelessTree.parent;\n                }\n                return cyclelessTree;\n            }\n\n            var result = { children: [] },\n                current = result,\n                timestamps = [];\n\n            function attach(token) {\n                current.children.push({\n                    type: 'object',\n                    name: token[1],\n                    classes: token[2],\n                    children: [],\n                    parent: current,\n                });\n                current = current.children[current.children.length - 1];\n            }\n            function inScope(name) {\n                var node = current;\n                while (node) {\n                    if (node.name == name) return true;\n                    node = node.parent;\n                }\n                return;\n            }\n\n            while (line[pos] != undefined) {\n                var token = nextToken();\n                if (token[0] == 'text') {\n                    current.children.push({ type: 'text', value: token[1], parent: current });\n                } else if (token[0] == 'start tag') {\n                    if (mode == 'chapters') err('Start tags not allowed in chapter title text.');\n                    var name = token[1];\n                    if (name != 'v' && name != 'lang' && token[3] != '') {\n                        err('Only <v> and <lang> can have an annotation.');\n                    }\n                    if (name == 'c' || name == 'i' || name == 'b' || name == 'u' || name == 'ruby') {\n                        attach(token);\n                    } else if (name == 'rt' && current.name == 'ruby') {\n                        attach(token);\n                    } else if (name == 'v') {\n                        if (inScope('v')) {\n                            err('<v> cannot be nested inside itself.');\n                        }\n                        attach(token);\n                        current.value = token[3]; // annotation\n                        if (!token[3]) {\n                            err('<v> requires an annotation.');\n                        }\n                    } else if (name == 'lang') {\n                        attach(token);\n                        current.value = token[3]; // language\n                    } else {\n                        err('Incorrect start tag.');\n                    }\n                } else if (token[0] == 'end tag') {\n                    if (mode == 'chapters') err('End tags not allowed in chapter title text.');\n                    // XXX check <ruby> content\n                    if (token[1] == current.name) {\n                        current = current.parent;\n                    } else if (token[1] == 'ruby' && current.name == 'rt') {\n                        current = current.parent.parent;\n                    } else {\n                        err('Incorrect end tag.');\n                    }\n                } else if (token[0] == 'timestamp') {\n                    if (mode == 'chapters') err('Timestamp not allowed in chapter title text.');\n                    var timings = new WebVTTCueTimingsAndSettingsParser(token[1], err),\n                        timestamp = timings.parseTimestamp();\n                    if (timestamp != undefined) {\n                        if (timestamp <= cueStart || timestamp >= cueEnd) {\n                            err('Timestamp must be between start timestamp and end timestamp.');\n                        }\n                        if (timestamps.length > 0 && timestamps[timestamps.length - 1] >= timestamp) {\n                            err('Timestamp must be greater than any previous timestamp.');\n                        }\n                        current.children.push({ type: 'timestamp', value: timestamp, parent: current });\n                        timestamps.push(timestamp);\n                    }\n                }\n            }\n            while (current.parent) {\n                if (current.name != 'v') {\n                    err('Required end tag missing.');\n                }\n                current = current.parent;\n            }\n            return removeCycles(result);\n        };\n\n        function nextToken() {\n            var state = 'data',\n                result = '',\n                buffer = '',\n                classes = [];\n            while (line[pos - 1] != undefined || pos == 0) {\n                var c = line[pos];\n                if (state == 'data') {\n                    if (c == '&') {\n                        buffer = c;\n                        state = 'escape';\n                    } else if (c == '<' && result == '') {\n                        state = 'tag';\n                    } else if (c == '<' || c == undefined) {\n                        return ['text', result];\n                    } else {\n                        result += c;\n                    }\n                } else if (state == 'escape') {\n                    if (c == '<' || c == undefined) {\n                        err('Incorrect escape.');\n                        let m;\n                        if ((m = buffer.match(/^&#([0-9]+)$/))) {\n                            result += String.fromCharCode(m[1]);\n                        } else {\n                            if (self.entities[buffer]) {\n                                result += self.entities[buffer];\n                            } else {\n                                result += buffer;\n                            }\n                        }\n                        return ['text', result];\n                    } else if (c == '&') {\n                        err('Incorrect escape.');\n                        result += buffer;\n                        buffer = c;\n                    } else if (/[a-z#0-9]/i.test(c)) {\n                        buffer += c;\n                    } else if (c == ';') {\n                        let m;\n                        if ((m = buffer.match(/^&#(x?[0-9]+)$/))) {\n                            // we prepend \"0\" so that x20 be interpreted as hexadecim (0x20)\n                            result += String.fromCharCode('0' + m[1]);\n                        } else if (self.entities[buffer + c]) {\n                            result += self.entities[buffer + c];\n                        } else if ((m = Object.keys(entities).find((n) => buffer.startsWith(n)))) {\n                            // partial match\n                            result += self.entities[m] + buffer.slice(m.length) + c;\n                        } else {\n                            err('Incorrect escape.');\n                            result += buffer + ';';\n                        }\n                        state = 'data';\n                    } else {\n                        err('Incorrect escape.');\n                        result += buffer + c;\n                        state = 'data';\n                    }\n                } else if (state == 'tag') {\n                    if (c == '\\t' || c == '\\n' || c == '\\f' || c == ' ') {\n                        state = 'start tag annotation';\n                    } else if (c == '.') {\n                        state = 'start tag class';\n                    } else if (c == '/') {\n                        state = 'end tag';\n                    } else if (/\\d/.test(c)) {\n                        result = c;\n                        state = 'timestamp tag';\n                    } else if (c == '>' || c == undefined) {\n                        if (c == '>') {\n                            pos++;\n                        }\n                        return ['start tag', '', [], ''];\n                    } else {\n                        result = c;\n                        state = 'start tag';\n                    }\n                } else if (state == 'start tag') {\n                    if (c == '\\t' || c == '\\f' || c == ' ') {\n                        state = 'start tag annotation';\n                    } else if (c == '\\n') {\n                        buffer = c;\n                        state = 'start tag annotation';\n                    } else if (c == '.') {\n                        state = 'start tag class';\n                    } else if (c == '>' || c == undefined) {\n                        if (c == '>') {\n                            pos++;\n                        }\n                        return ['start tag', result, [], ''];\n                    } else {\n                        result += c;\n                    }\n                } else if (state == 'start tag class') {\n                    if (c == '\\t' || c == '\\f' || c == ' ') {\n                        if (buffer) {\n                            classes.push(buffer);\n                        }\n                        buffer = '';\n                        state = 'start tag annotation';\n                    } else if (c == '\\n') {\n                        if (buffer) {\n                            classes.push(buffer);\n                        }\n                        buffer = c;\n                        state = 'start tag annotation';\n                    } else if (c == '.') {\n                        if (buffer) {\n                            classes.push(buffer);\n                        }\n                        buffer = '';\n                    } else if (c == '>' || c == undefined) {\n                        if (c == '>') {\n                            pos++;\n                        }\n                        if (buffer) {\n                            classes.push(buffer);\n                        }\n                        return ['start tag', result, classes, ''];\n                    } else {\n                        buffer += c;\n                    }\n                } else if (state == 'start tag annotation') {\n                    if (c == '>' || c == undefined) {\n                        if (c == '>') {\n                            pos++;\n                        }\n                        buffer = buffer\n                            .split(/[\\u0020\\t\\f\\r\\n]+/)\n                            .filter(function (item) {\n                                if (item) return true;\n                            })\n                            .join(' ');\n                        return ['start tag', result, classes, buffer];\n                    } else {\n                        buffer += c;\n                    }\n                } else if (state == 'end tag') {\n                    if (c == '>' || c == undefined) {\n                        if (c == '>') {\n                            pos++;\n                        }\n                        return ['end tag', result];\n                    } else {\n                        result += c;\n                    }\n                } else if (state == 'timestamp tag') {\n                    if (c == '>' || c == undefined) {\n                        if (c == '>') {\n                            pos++;\n                        }\n                        return ['timestamp', result];\n                    } else {\n                        result += c;\n                    }\n                } else {\n                    err('Never happens.'); // The joke is it might.\n                }\n                // 8\n                pos++;\n            }\n        }\n    };\n\n    var WebVTTSerializer = function () {\n        function serializeTimestamp(seconds) {\n            const ms = ('00' + (seconds - Math.floor(seconds)).toFixed(3) * 1000).slice(-3);\n            let h = 0,\n                m = 0,\n                s = 0;\n            if (seconds >= 3600) {\n                h = Math.floor(seconds / 3600);\n            }\n            m = Math.floor((seconds - 3600 * h) / 60);\n            s = Math.floor(seconds - 3600 * h - 60 * m);\n            return (h ? h + ':' : '') + ('' + m).padStart(2, '0') + ':' + ('' + s).padStart(2, '0') + '.' + ms;\n        }\n        function serializeCueSettings(cue) {\n            var result = '';\n            const nonDefaultSettings = Object.keys(defaultCueSettings).filter((s) => cue[s] !== defaultCueSettings[s]);\n            if (nonDefaultSettings.includes('direction')) {\n                result += ' vertical:' + cue.direction;\n            }\n            if (nonDefaultSettings.includes('alignment')) {\n                result += ' align:' + cue.alignment;\n            }\n            if (nonDefaultSettings.includes('size')) {\n                result += ' size:' + cue.size + '%';\n            }\n            if (nonDefaultSettings.includes('lineAlign') || nonDefaultSettings.includes('linePosition')) {\n                result +=\n                    ' line:' +\n                    cue.linePosition +\n                    (cue.snapToLines ? '' : '%') +\n                    (cue.lineAlign && cue.lineAlign != defaultCueSettings.lineAlign ? ',' + cue.lineAlign : '');\n            }\n            if (nonDefaultSettings.includes('textPosition') || nonDefaultSettings.includes('positionAlign')) {\n                result +=\n                    ' position:' +\n                    cue.textPosition +\n                    '%' +\n                    (cue.positionAlign && cue.positionAlign !== defaultCueSettings.positionAlign\n                        ? ',' + cue.positionAlign\n                        : '');\n            }\n            return result;\n        }\n        function serializeTree(tree) {\n            var result = '';\n            for (var i = 0; i < tree.length; i++) {\n                var node = tree[i];\n                if (node.type == 'text') {\n                    result += node.value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n                } else if (node.type == 'object') {\n                    result += '<' + node.name;\n                    if (node.classes) {\n                        for (var y = 0; y < node.classes.length; y++) {\n                            result += '.' + node.classes[y];\n                        }\n                    }\n                    if (node.value) {\n                        result += ' ' + node.value;\n                    }\n                    result += '>';\n                    if (node.children) result += serializeTree(node.children);\n                    result += '</' + node.name + '>';\n                } else if (node.type == 'timestamp') {\n                    result += '<' + serializeTimestamp(node.value) + '>';\n                } else {\n                    result += '<' + node.value + '>';\n                }\n            }\n            return result;\n        }\n        function serializeCue(cue) {\n            return (\n                (cue.id !== undefined ? cue.id + '\\n' : '') +\n                serializeTimestamp(cue.startTime) +\n                ' --> ' +\n                serializeTimestamp(cue.endTime) +\n                serializeCueSettings(cue) +\n                '\\n' +\n                serializeTree(cue.tree.children) +\n                '\\n\\n'\n            );\n        }\n        function serializeStyle(style) {\n            return 'STYLE\\n' + style + '\\n\\n';\n        }\n        this.serialize = function (cues, styles) {\n            var result = 'WEBVTT\\n\\n';\n            if (styles) {\n                for (var i = 0; i < styles.length; i++) {\n                    result += serializeStyle(styles[i]);\n                }\n            }\n            for (var i = 0; i < cues.length; i++) {\n                result += serializeCue(cues[i]);\n            }\n            return result;\n        };\n    };\n\n    function exportify(object) {\n        object.WebVTTParser = WebVTTParser;\n        object.WebVTTCueTimingsAndSettingsParser = WebVTTCueTimingsAndSettingsParser;\n        object.WebVTTCueTextParser = WebVTTCueTextParser;\n        object.WebVTTSerializer = WebVTTSerializer;\n    }\n    if (typeof window !== 'undefined') exportify(window);\n    if (typeof exports !== 'undefined') exportify(exports);\n})();\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n"],"names":["modules","entry","mainEntry","parcelRequireName","externals","distDir","publicUrl","devServer","globalObject","globalThis","self","window","global","previousRequire","importMap","i","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","length","mainExports","define","amd","__globalThis","parcelHelpers","defineInteropFlag","export","artplayerPluginMultipleSubtitles","_parser","loadVtt","option","getExt","srtToVtt","assToVtt","response","fetch","url","buffer","arrayBuffer","text","decoder","TextDecoder","encoding","decode","type","subtitles","art","unescape","constructor","utils","parser","WebVTTParser","seri","WebVTTSerializer","trees","vtts","Promise","all","map","vtt","index","tree","parse","lastUrl","setTracks","mergeTrees","result","updated","j","cues","cue","k","children","value","push","serialize","URL","revokeObjectURL","createObjectURL","Blob","subtitle","escape","init","onVttLoad","tracks","names","find","reset","defaultCueSettings","direction","snapToLines","linePosition","lineAlign","textPosition","positionAlign","size","alignment","entities","input","mode","replace","startTime","Date","now","linePos","lines","split","alreadyCollected","styles","errors","message","col","line","lineLength","signature","bom","signature_length","indexOf","undefined","assign","endTime","pauseOnExit","parseTimings","test","style","invalid","join","timings","WebVTTCueTimingsAndSettingsParser","previousCueStart","cuetextparser","WebVTTCueTextParser","sort","a","b","time","errorHandler","SPACE","NOSPACE","pos","skip","pattern","collect","str","timestamp","val1","val2","val3","val4","units","parseInt","parseSettings","settings","seen","setting","slice","comp","numVal","isPercent","isNaN","isFinite","includes","parseFloat","toString","nonSerializable","alignValues","substring","parseTimestamp","ts","cueStart","cueEnd","current","timestamps","attach","token","classes","nextToken","state","c","m","match","String","fromCharCode","keys","n","startsWith","filter","item","inScope","node","removeCycles","cyclelessTree","serializeTimestamp","seconds","ms","Math","floor","toFixed","h","s","padStart","serializeCueSettings","nonDefaultSettings","serializeTree","y","exportify","object","interopDefault","__esModule","default","exportAll","source","dest","forEach","key","prototype","hasOwnProperty","enumerable","destName","_default","parcelRequire4dc0"],"version":3,"file":"index.js.map"}